<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"s1mplecc.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="春光恰与少年同，十里清风慕天青">
<meta property="og:type" content="website">
<meta property="og:title" content="芥子屋">
<meta property="og:url" content="https://s1mplecc.github.io/index.html">
<meta property="og:site_name" content="芥子屋">
<meta property="og:description" content="春光恰与少年同，十里清风慕天青">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="s1mple">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://s1mplecc.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>芥子屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">芥子屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/s1mplecc" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/12/17/%E7%BD%91%E7%AB%99%E5%A4%96%E9%93%BE%E7%88%AC%E8%99%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/17/%E7%BD%91%E7%AB%99%E5%A4%96%E9%93%BE%E7%88%AC%E8%99%AB/" class="post-title-link" itemprop="url">网站外链爬虫</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-17 09:45:31 / 修改时间：13:47:55" itemprop="dateCreated datePublished" datetime="2021-12-17T09:45:31+08:00">2021-12-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Projects/" itemprop="url" rel="index"><span itemprop="name">Projects</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>网站外链爬虫，使用轻量级 Web 应用框架 Flask，以 Restful 接口提供服务，支持容器化部署。项目地址：<a target="_blank" rel="noopener" href="https://github.com/s1mplecc/external-link-crawer">https://github.com/s1mplecc/external-link-crawer</a> ，需要 Python 版本 3.x。</p>
<p>对于传入的网站 URL，获取其 HTML 网页，提取外部链接的域名。包含如下几类外链：</p>
<ul>
<li>超链接，标签 <code>a</code> 下的 <code>href</code> 属性；</li>
<li>图片，标签 <code>img</code> 下的 <code>src</code> 属性；</li>
<li>外部样式文件，标签 <code>link</code> 下  <code>href</code> 属性；</li>
<li>外部 JavaScript 脚本文件，标签 <code>script</code> 下  <code>src</code> 属性。</li>
</ul>
<h2 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h2><p>Step 1：克隆项目。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/s1mplecc/external-link-crawer.git</span></span><br></pre></td></tr></table></figure>

<p>Step 2：安装依赖，包括 Flask 和 BeautifulSoup4。建议使用 Virtualenv 局部安装依赖。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip3 install -r requirements.txt</span> </span><br></pre></td></tr></table></figure>

<p>Step 3：在 IDE 中运行或通过 Flask 命令行工具启动应用，端口号默认为 5000。生产环境可使用 Gunicorn 部署。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FLASK_ENV=<span class="string">&quot;development&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> flask run</span></span><br><span class="line"> * Environment: development</span><br><span class="line"> * Debug mode: on</span><br><span class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>

<h2 id="容器化部署"><a href="#容器化部署" class="headerlink" title="容器化部署"></a>容器化部署</h2><p>除本地运行之外，也支持在生产环境中使用容器化方式部署，镜像入口脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">gunicorn --worker-class=gevent --worker-connections=1000 -w 4 -b 0.0.0.0:8000 app:app</span><br></pre></td></tr></table></figure>

<p>使用 Gunicorn 启动 Flask 应用。由于爬虫运行效率主要受网络延迟影响，因此为提高并发吞吐量，使用多进程 + 协程方式部署。协程由 Gevent 库支持。参数 <code>-w</code> 指定进程数，每个进程默认最大并发连接数 1000。Gunicorn 应用端口号默认为 8000。</p>
<p>Step 1：拉取镜像。镜像已提交至 Docker Hub 仓库。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull s1mplecc/external-link-crawer</span></span><br></pre></td></tr></table></figure>

<p>也可以在本地手动构建镜像。克隆下项目后，在 Dockerfile 所在目录执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t s1mplecc/external-link-crawer .</span></span><br></pre></td></tr></table></figure>

<p>Step 2：启动容器，映射端口。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 5000:8000 --name external-link-crawer s1mplecc/external-link-crawer</span></span><br></pre></td></tr></table></figure>

<h2 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h2><ul>
<li>请求类型 GET；</li>
<li>请求前缀 <code>/external-link-domains</code> ；</li>
<li>参数 <code>url</code>，需传入合法 URL，否则返回参数异常状态码。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -XGET <span class="string">&quot;http://127.0.0.1:5000/external-link-domains?url=https://www.zhihu.com/&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="响应格式"><a href="#响应格式" class="headerlink" title="响应格式"></a>响应格式</h2><p>响应体为 JSON 格式，包含如下字段：</p>
<ul>
<li><code>data</code> 字段，数据本体；</li>
<li><code>code</code> 字段，状态码。成功 - 200，参数异常 - 400，服务器内部错误 - 500；</li>
<li><code>messages</code> 字段，附加消息。出错时提示异常信息。</li>
</ul>
<p>响应样例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;css_scripts_domains&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;hm.baidu.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;static.zhihu.com&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;css_scripts_domains_size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;href_domains&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;app.mokahr.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;beian.miit.gov.cn&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tsm.miit.gov.cn&quot;</span>,</span><br><span class="line">            <span class="string">&quot;www.12377.cn&quot;</span>,</span><br><span class="line">            <span class="string">&quot;www.beian.gov.cn&quot;</span>,</span><br><span class="line">            <span class="string">&quot;www.zhihu.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;zhstatic.zhihu.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;zhuanlan.zhihu.com&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;href_domains_size&quot;</span>: <span class="number">8</span>,</span><br><span class="line">        <span class="attr">&quot;img_domains&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;pic2.zhimg.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pic3.zhimg.com&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;img_domains_size&quot;</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;messages&quot;</span>: <span class="string">&quot;[SUCCESS] ok&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数异常响应样例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;messages&quot;</span>: <span class="string">&quot;[BAD_REQUEST] invalid param url value: xyz&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="镜像构建过程"><a href="#镜像构建过程" class="headerlink" title="镜像构建过程"></a>镜像构建过程</h2><p>Step 1：编写 Dockerfile。镜像基于 Python 官方镜像 3.8-slim 精简版本。将整个项目文件拷贝到镜像的工作目录内，在 <code>.dockerignore</code> 中指定忽略拷贝文件。入口文件为 Gunicorn 启动脚本。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> FLASK_WORK_DIR=<span class="string">&quot;/root/flask&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$FLASK_WORK_DIR</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install -r requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install gunicorn gevent</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x gunicorn_starter.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;./gunicorn_starter.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>Step 2：构建镜像。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t s1mplecc/external-link-crawer .</span></span><br></pre></td></tr></table></figure>

<p>Step 3：推送到远端仓库。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker tag s1mplecc/external-link-crawer docker.io/s1mplecc/external-link-crawer</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker push docker.io/s1mplecc/external-link-crawer</span> </span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/12/14/%E5%9F%BA%E4%BA%8E-Elasticsearch-%E4%B8%8E-Kibana-%E6%90%AD%E5%BB%BA%E6%B5%81%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/14/%E5%9F%BA%E4%BA%8E-Elasticsearch-%E4%B8%8E-Kibana-%E6%90%AD%E5%BB%BA%E6%B5%81%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/" class="post-title-link" itemprop="url">基于 Elasticsearch 与 Kibana 搭建流量可视化平台</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-14 17:40:39" itemprop="dateCreated datePublished" datetime="2021-12-14T17:40:39+08:00">2021-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ops/" itemprop="url" rel="index"><span itemprop="name">Ops</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>前期工作</strong>：基于 Bind9 搭建内网 DNS 服务器，使得在 <code>/etc/resolv.conf</code> 中配置了该服务器 IP 的节点或终端的 DNS 流量都会流经该服务器，为集群 DNS 流量采集提供了先决基础。同时，初步使用日志记录 DNS 查询请求（配置在 <code>/etc/named.conf</code> 中），后续可采用 Packetbeat/TShark 等工具主动捕获。DNS 查询日志内容格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30-Nov-2021 08:57:25.192 client @0x7f74f800b650 192.168.101.145#61323 (apisix.apache.org): query: apisix.apache.org IN A + (168.168.168.47)</span><br><span class="line">30-Nov-2021 08:57:25.192 client @0x7f7514148d20 192.168.101.145#61325 (github.com): query: github.com IN A + (168.168.168.47)</span><br></pre></td></tr></table></figure>

<p>为了推进后续的 DNS 流量分类研究工作，本文介绍了如何基于现有的 DNS 流量日志，使用 Elasticsearch 和 Kibana 搭建流量监测可视化平台。本文包含以下内容：</p>
<ul>
<li>使用 <strong>Filebeat</strong> 将流量日志实时同步到 Elasticsearch；</li>
<li>使用 <strong>Grok</strong> 正则过滤器对采集到的日志消息二次处理；</li>
<li>使用网络数据包分析工具 <strong>Packetbeat</strong>。</li>
</ul>
<p>将日志文件转储到 Elasticsearch，一是作为历史归档考量，Bind9 日志存在存储时限，如果文件大小达到设置的上限，旧的日志文件会被循环覆盖。二是 JSON 格式易于拓展，支持嵌套和数组，且易于特征提取阶段 Python 进行处理。三是可视化支持好，在 Elasticsearch 数据集上，使用 Kibana 可以快速建立指标分析、图表分析以及时间序列分析等可视化。下图是基于 DNS 查询日志配置的 Kibana Dashboard 可视化界面。</p>
<p><img data-src="1.png" alt="93787acedd01f3ccf8ad7f2e4c62627d.png"></p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>操作系统 CentOS 7.9；</li>
<li>Docker，版本 19.03.13；</li>
<li>Elastic Stack 工具集，版本 7.15.2。包括 Elasticsearch、Kibana、Filebeat 和 Packetbeat。</li>
</ul>
<h2 id="部署-Elasticsearch-Kibana"><a href="#部署-Elasticsearch-Kibana" class="headerlink" title="部署 Elasticsearch + Kibana"></a>部署 Elasticsearch + Kibana</h2><p>使用 Docker 快速部署 Elasticsearch 与 Kibana 环境。首先，拉取 Docker 镜像：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull docker.elastic.co/elasticsearch/elasticsearch:7.15.2</span><br><span class="line">$ docker pull docker.elastic.co/kibana/kibana:7.15.2</span><br></pre></td></tr></table></figure>

<p>需先以单点模式运行 Elasticsearch 容器，然后再启动 Kibana 容器。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name es01-test --net elastic -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> docker.elastic.co/elasticsearch/elasticsearch:7.15.2</span><br><span class="line">$ docker run -d --name kib01-test --net elastic -p 5601:5601 -e <span class="string">&quot;ELASTICSEARCH_HOSTS=http://es01-test:9200&quot;</span> docker.elastic.co/kibana/kibana:7.15.2</span><br></pre></td></tr></table></figure>

<p>成功启动容器后，可在 5601 端口访问 Kibana 首页。</p>
<p><img data-src="2.png" alt="d15ed7bec92f990449315ed49fa7bfeb.png"></p>
<h2 id="使用-Filebeat-监听日志文件变更"><a href="#使用-Filebeat-监听日志文件变更" class="headerlink" title="使用 Filebeat 监听日志文件变更"></a>使用 Filebeat 监听日志文件变更</h2><p>Filebeat 是 <a target="_blank" rel="noopener" href="https://www.elastic.co/cn/beats/">Elastic/Beats</a> 数据采集器工具集中的一员，负责日志采集，相比于运行在 JVM 上的 Logstash，它更加轻量级。Filebeat 能够实时捕获文件的新增内容（类似 <code>tail -f</code> 命令），按行将新增内容转发到 Elasticsearch 或 Logstash 中存储，并记录文件当前偏移量，以便中断后下次启动从中断点继续开始。</p>
<p>下载、解压 Filebeat 安装包并重命名。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.15.2-linux-x86_64.tar.gz</span><br><span class="line">$ tar -xzvf filebeat-7.15.2-linux-x86_64.tar.gz </span><br><span class="line">$ mv filebeat-7.15.2-linux-x86_64 filebeat</span><br></pre></td></tr></table></figure>

<p>Filebeat 安装目录中，包含启动脚本以及默认配置文件 filebeat.yml。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> filebeat</span><br><span class="line">$ ./filebeat version</span><br><span class="line">filebeat version 7.15.2 (amd64), libbeat 7.15.2 [fd322dad6ceafec40c84df4d2a0694ea357d16cc built 2021-11-04 14:22:49 +0000 UTC]</span><br></pre></td></tr></table></figure>

<p>按照 filebeat.yml 文件格式，编写<strong>自定义配置文件</strong> named.yml。在配置文件中，设置日志输入源为 Bind9 生成的 query.log；去除了 Filebeat 生成的冗余字段（可选）；设置了写入的 Elasticsearch 的 URL 以及索引分片数。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/log/named/query.log</span></span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">drop_fields:</span></span><br><span class="line">      <span class="attr">fields:</span> [<span class="string">&quot;host&quot;</span>,<span class="string">&quot;agent&quot;</span>,<span class="string">&quot;ecs&quot;</span>,<span class="string">&quot;input&quot;</span>]</span><br><span class="line">      <span class="attr">ignore_missing:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;http://localhost:9200&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>默认情况下，Filebeat 写入 Elasticsearch 的索引名形如 <code>filebeat-%&#123;[beat.version]&#125;-%&#123;+yyyy.MM.dd&#125;</code>。此项配置在 <code>output.elasticsearch.index</code> 中，Filebeat 会自动创建索引别名，如 filebeat-7.15.2。</p>
<p>运行 Filebeat，参数 <code>-c</code> 指定配置文件 named.yml，<code>-e</code> 将错误日志输出到控制台。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./filebeat -e -c named.yml</span><br></pre></td></tr></table></figure>

<p>注：使用 <code>nohup</code> 和 <code>&amp;</code> 命令可以后台运行，并且输入 <code>exit</code> 退出命令行终端后依然不会停止（直接关闭命令行终端会停止）。</p>
<p>从 Filebeat 发往 Elasticsearch 的日志消息，包装在 message 字段中，除此之外，还有一些 Filebeat 生成的记录字段。一条日志信息转化后的格式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;filebeat-7.15.2-2021.11.26-000001&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;5qjyan0BAsnp-ar_z6EP&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@timestamp&quot;</span>: <span class="string">&quot;2021-11-29T09:07:16.390Z&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;log&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;offset&quot;</span>: <span class="number">2892475</span>,</span><br><span class="line">      <span class="attr">&quot;file&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/var/log/named/query.log&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;29-Nov-2021 17:07:13.335 client @0x7fd6a0010f10 192.168.101.60#58832 (shcn2-06b.iplc188.com): query: shcn2-06b.iplc188.com IN A + (168.168.168.47)&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于原始的 message 字段，能够提供的信息有限，因此需要对消息字段加以处理。Logstash 的插件 Grok 正则过滤器提供对字符串的解析功能。如今，Elastic 提供了 Ingest Node 功能，允许在文档写入 Elasticsearch 索引之前经过<strong>预处理</strong>，并提供了对 Grok 的集成。</p>
<h2 id="使用-Grok-正则处理日志消息"><a href="#使用-Grok-正则处理日志消息" class="headerlink" title="使用 Grok 正则处理日志消息"></a>使用 Grok 正则处理日志消息</h2><p>在 Kibana 的 “Stack Management | Ingest Node Pipelines” 界面，可以指定一系列的处理器 （Processors）对消息进行流水线处理，包括定义异常处理分支。</p>
<p><img data-src="3.png" alt="dc741da57eca3e2b9bdc4bf70357cc3c.png"></p>
<p>对于 query.log 文件中的日志记录，由于日志格式固定，因此可以使用 Grok 对一条记录进行匹配。正则表达式格式如 <code>%&#123;IP:source.ip&#125;</code>，冒号左侧为 <a target="_blank" rel="noopener" href="https://github.com/logstash-plugins/logstash-patterns-core/blob/main/patterns/legacy/grok-patterns">Grok 默认 Pattern</a>，冒号右侧为存储的 JSON 字段名，支持嵌套结构。解析日志的 Grok 正则表达式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">23-Nov-2021 13:58:03.222 client @0x7f7034054680 168.168.168.47#56504 (baidu.com): query: baidu.com IN A + (168.168.168.47)</span><br><span class="line"></span><br><span class="line">%&#123;GREEDYDATA:timestamp&#125; %&#123;WORD&#125; %&#123;DATA:source.client&#125; %&#123;IP:source.ip&#125;#%&#123;NUMBER:source.port&#125; \(%&#123;HOSTNAME:domain.fullname&#125;\): query: %&#123;HOSTNAME&#125; %&#123;WORD:class&#125; %&#123;WORD:type&#125; </span><br></pre></td></tr></table></figure>

<p>此外，还可以<strong>自定义 Grok Pattern</strong>。例如，对于域名字段来说，其“二级域名 + 顶级域名”构成的域名后缀（即用户可以在域名注册网站购买的域名）可能具有重要分析意义。为此，定义了名为 SLD 的  Grok Pattern，将其解析成 <code>domain.eTLDplusOne</code> 字段（有效顶级域名 + 1，名称借鉴自 Packetbeat）。</p>
<p><img data-src="4-1.png" alt="fb23cc0fd30fb9e1e9c8d89ee52a22a6.png"></p>
<p>注：正则表达式中的反义字符由于要表示在 JSON 文档中，所以需要额外一个下划线，如 <code>\\.</code>。</p>
<p>可以在 “Stack Management | Ingest Node Pipelines” 界面添加测试文档测试流水线是否正常工作，这对于验证正则表达式正确性有巨大帮助。此外，还能够在 Dev Tools 的 Grok Debugger 控制台中调试正则表达式。</p>
<p>实际上，在 Kibana 界面添加 Pipeline 相当于在 Elasticsearch 的 <code>/_ingest/pipeline</code> 索引中添加了如下的一条文档：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dns_query_log_pipeline&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;description&quot;</span> : <span class="string">&quot;Extract fields from message.&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;processors&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;grok&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;message&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;patterns&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="string">&quot;%&#123;GREEDYDATA:timestamp&#125; %&#123;WORD&#125; %&#123;DATA:source.client&#125; %&#123;IP:source.ip&#125;#%&#123;NUMBER:source.port&#125; \(%&#123;HOSTNAME:domain.fullname&#125;\): query: %&#123;HOSTNAME&#125; %&#123;WORD:class&#125; %&#123;WORD:type&#125; &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;date&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;timestamp&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;formats&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;dd-MMM-yyyy HH:mm:ss.SSS&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">&quot;target_field&quot;</span> : <span class="string">&quot;timestamp&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;grok&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;domain.fullname&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;patterns&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="string">&quot;(%&#123;GREEDYDATA:domain.prefix&#125;\.)*(%&#123;SLD:domain.eTLDplusOne&#125;)&#123;1&#125;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">&quot;pattern_definitions&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;SLD&quot;</span> : <span class="string">&quot;&quot;</span><span class="string">&quot;((xn--)?[a-z0-9-]+\.[a-z|\-]&#123;2,63&#125;)&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;on_failure&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;set&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;domain.hostname&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;copy_from&quot;</span> : <span class="string">&quot;domain.fullname&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使该 Pipeline 生效，还需要在 Filebeat 的配置文件中添加此项配置，并重启 Filebeat 程序。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;http://localhost:9200&quot;</span>]</span><br><span class="line">  <span class="attr">pipeline:</span> <span class="string">&quot;dns_query_log_pipeline&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Kibana-可视化"><a href="#Kibana-可视化" class="headerlink" title="Kibana 可视化"></a>Kibana 可视化</h2><p>要在 Kibana 查看 Elasticsearch 中存储的数据，首先需要在 “Stack Management | Index patterns” 中配置索引模式（Index pattern）。</p>
<p><img data-src="4-2.png" alt="c1ddec742b59b52562067be4e9ed6231.png"></p>
<p>创建完成后，可以在 “Discover” 界面查看索引中存放的数据。</p>
<p><img data-src="5.png" alt="6625242b24495aaf1c3a084b4c17bb71.png"></p>
<p>还可以在 “Dashboard” 界面自定义可视化看板，效果图如前言中所示。</p>
<h2 id="使用-Packetbeat-监听数据包"><a href="#使用-Packetbeat-监听数据包" class="headerlink" title="使用 Packetbeat 监听数据包"></a>使用 Packetbeat 监听数据包</h2><p>除了使用 Filebeat + Grok 手动解析日志文件之外，Beats 工具集还提供了专用于<strong>网络数据包分析</strong>的轻量型工具 Packetbeat，它能够捕获由 ping 工具发起的 ICMP 报文（网络层），或者通过端口捕获应用层报文，如 HTTP 80 端口、MySQL 3306 端口等。捕获的报文可被解析成 JSON 格式存储到 Elasticsearch。</p>
<p>下载、解压 Packetbeat 安装包，并重命名。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L -O https://artifacts.elastic.co/downloads/beats/packetbeat/packetbeat-7.15.2-linux-x86_64.tar.gz</span><br><span class="line">$ tar xzvf packetbeat-7.15.2-linux-x86_64.tar.gz</span><br><span class="line">$ mv packetbeat-7.15.2-linux-x86_64 packetbeat</span><br></pre></td></tr></table></figure>

<p>Packetbeat 的配置文件模版位于 packetbeat.yml 中，我们需要自定义 DNS 配置文件 dns.yml。除了以 <code>packetbeat.</code> 开头的特定配置外，其他配置与 Filebeat 共用一套模版。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">packetbeat.interfaces.device:</span> <span class="string">eth0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">packetbeat.protocols:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">dns</span></span><br><span class="line">  <span class="attr">ports:</span> [<span class="number">53</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">drop_fields:</span></span><br><span class="line">      <span class="attr">fields:</span> [<span class="string">&quot;host&quot;</span>,<span class="string">&quot;agent&quot;</span>,<span class="string">&quot;ecs&quot;</span>]</span><br><span class="line">      <span class="attr">ignore_missing:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;http://localhost:9200&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>运行 Packetbeat，参数 <code>-c</code> 指定配置文件 named.yml，<code>-e</code> 将错误日志输出到控制台。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./packetbeat -e -c dns.yml</span><br></pre></td></tr></table></figure>

<p>启动 Packetbeat 后，捕获的数据被发送至 Elasticsearch，在 “Stack Management | Index patterns” 中配置索引模式后，就可以访问以 packetbeat-7.15.2 别名命名的索引中的数据。</p>
<p>此外，Packetbeat 还提供了一些可视化的 Kibana Dashboard 模版，通过如下命令初始化：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./packetbeat setup --dashboards</span><br></pre></td></tr></table></figure>

<p>Dashboard 效果图如下。</p>
<p><img data-src="6.png" alt="7a2a13ab1327c49fa654607b52f662e5.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>值得注意的是，Packetbeat 监听的是目的端口为 53 的数据包。不管是下面哪种 DNS 报文，Packetbeat 都能进行捕获。</p>
<ul>
<li>内网中访问内网 DNS 服务器的其他终端，如 192.168.101.215 -&gt; 168.168.168.47（内网 DNS 服务器）；</li>
<li>内网 DNS 服务器转发的 DNS 查询，如 168.168.168.47 -&gt; 8.8.8.8（谷歌 DNS 服务器，可在 Bind9 配置文件中定义转发规则）；</li>
<li>甚至是手动指定 DNS 服务器的查询报文，如 <code>dig @114.114.114.114 baidu.com</code>。</li>
</ul>
<p><img data-src="7.png" alt="08d3eb68410326d6b2798b8aa397eacc.png"></p>
<p>相比之下，使用日志记录 DNS 查询请求的方式就显得十分局限了。即使内网中的用户在 <code>/etc/resolv.conf</code> 中配置了内网 DNS 服务器，也不能保证恶意软件乖乖的使用该 DNS 服务器。因此理论上，只有在内网所有终端上部署类似 Packetbeat 的数据包探测器（类似的还有 Wireshark 的底层库工具 tshark），才能真正全量的监听 DNS 流量。此外，Packetbeat 解析出的 JSON 结构的数据所包含的信息要远大于通过正则分析的日志信息。</p>
<p>因此对于端口固定的数据包探测，Packetbeat 的实用性要优于 Filebeat + Grok 的方案。但 Filebeat 适用范围更广，任何有生成日志的程序，甚至是批/流处理产生的中间数据文件，理论上都能通过 Filebeat 采集特征存入 Elasticsearch 进行后续分析。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/filebeat/current/configuring-ingest-node.html#configuring-ingest-node">Filebeat Reference | Parse data by using ingest node</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/logstash-plugins/logstash-patterns-core/blob/main/patterns/legacy/grok-patterns">logstash-plugins/grok-patterns</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/beats/packetbeat/current/packetbeat-overview.html">Packetbeat Reference | Packetbeat overview</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/10/22/%E7%BB%93%E5%90%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MapReduce-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/22/%E7%BB%93%E5%90%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MapReduce-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">结合源码深入理解 MapReduce 工作原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-22 15:36:44" itemprop="dateCreated datePublished" datetime="2021-10-22T15:36:44+08:00">2021-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Concepts/" itemprop="url" rel="index"><span itemprop="name">Concepts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MapReduce-架构"><a href="#MapReduce-架构" class="headerlink" title="MapReduce 架构"></a>MapReduce 架构</h2><blockquote>
<p>本文讨论的 MapReduce 架构是 Hadoop 1.0 版本时的架构，从 Hadoop 2.0 开始，Hadoop 推出了资源管理框架 YARN。在 YARN 中，使用 ResourceManager 来负责容器的调度（任务运行在容器中），以及作业的管理。使用 NodeManager 来向 ResourceManager 汇报节点资源以及容器运行状态，NodeManager 负责创建并管理执行任务的容器。从职责方面，ResourceManager 等同于 JobTracker，NodeManager 等同于 TaskTracker。大多数的分布式框架都符合这种主从设计，如 HDFS 的 NameNode 和 DataNode、Spark 的 Driver 和 Executor 等。</p>
</blockquote>
<p>以下是 MapReduce 架构和工作流程中的常用术语：</p>
<ul>
<li>Job（作业）：是客户端需要执行的一个工作单元，包括输入数据、MapReduce 程序和配置信息；</li>
<li>Task（任务）：Hadoop 将作业分成若干个任务来执行，任务分为两类，即 Map 任务和 Reduce 任务；</li>
<li>Map/Reduce：从执行阶段来看，Map 和 Reduce 代表两个大类阶段。从计算模型角度看，它们代表两个计算步骤。从代码层面看，它们是定义在 Mapper 和 Reducer 类中的函数；</li>
<li>Mapper/Reducer：从执行阶段的详细划分来看，Mapper 和 Reducer 代表执行 map 与 reduce 函数的步骤。从代码层面看，这是定义在代码中的两个 Java 类。某些语境下，Mapper 可以指代 Map 任务，Reducer 同理。</li>
</ul>
<p>与多数的大数据分布式框架相同，MapReduce 的架构也遵循主从结构：</p>
<ul>
<li>运行在 HDFS NameNode 主节点上的 <strong>JobTracker</strong> 程序，负责接收从客户端提交的 Job，将其划分成 Map 任务和 Reduce 任务，分发给从节点 TaskTracker 执行。JobTracker 负责任务之间的协作，并通过 TaskTracker 发送来的心跳包维护集群的运行状态，以及作业进度信息。</li>
<li>多个运行在 HDFS DataNode 节点上的 <strong>TaskTracker</strong> 程序，负责执行 Map 任务和 Reduce 任务，直接与 HDFS 交互。每隔一段时间，TaskTracker 向 JobTracker 发送心跳包，汇报节点运行状态，以及任务完成进度。</li>
</ul>
<p><img data-src="1.png" alt="66b01a299a89595ca02de7b5b9f02b85.png"></p>
<p>为了减少网络传输带来的性能影响，JobTracker 在分发 Map 任务时基于<strong>数据本地化优化</strong>（Data locality optimization）策略，将 Map 任务分发给包含此 Map 处理数据的从节点，并将程序 Jar 包发送给该 TaskTracker，遵循“运算移动，数据不移动”的原则。</p>
<h2 id="新旧版本-API-说明"><a href="#新旧版本-API-说明" class="headerlink" title="新旧版本 API 说明"></a>新旧版本 API 说明</h2><p>本文中的源码是 Hadoop 3.2.0 版本的源码，使用的是 Hadoop 新版 API。新版 API 位于 <code>org.apache.hadoop.mapreduce</code> 包下，旧版 API 位于 <code>org.apache.hadoop.mapred</code> 包下，两版 API 并不兼容，你可以在 <a target="_blank" rel="noopener" href="https://www.slideshare.net/sh1mmer/upgrading-to-the-new-map-reduce-api">这里</a> 查看两者的区别。为保证向后兼容，Hadoop 并没有移除旧版 API，因此依赖库中两个版本并存，使用时要注意。</p>
<p>设计新版 API 的主要目的是给用户提供更加简洁优雅的接口，框架的核心代码并没有调整包，比如执行 Map 与 Reduce 任务的 MapTask 和 ReduceTask 类仍位于 <code>org.apache.hadoop.mapred</code> 包下。但由于使用了两套 API，在该类中你会经常看到以 Old/New 命名的类或方法，如 <code>runNewMapper()</code> 和 <code>runOldMapper()</code>。</p>
<p>在旧版本中，Mapper 与 Reducer 被定义为接口，而在新版本中被定义为具体类，并提供默认的 map 和 reduce 实现：仅是通过 <code>context.write()</code> 重新写回数据。旧版本的 Mapper 接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span>&lt;<span class="title">K1</span>, <span class="title">V1</span>, <span class="title">K2</span>, <span class="title">V2</span>&gt; <span class="keyword">extends</span> <span class="title">JobConfigurable</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">map</span><span class="params">(K1 key, V1 value, OutputCollector&lt;K2, V2&gt; output, Reporter reporter)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版本中广泛使用上下文 Context 对象，整合了 OutputCollector、Reporter  和部分 JobConf 的功能，来实现与 MapReduce 系统的通信，如使用 <code>context.write()</code> 代替旧版的 <code>output.collect()</code> 功能。</p>
<p>新版本使用 Job 类替换旧版的 JobClient 类，实现作业控制，并使用统一的配置类 Configuration 来替换旧版的 JobConf 类，用于作业配置。因此，现在的一个 MapReduce 程序的入口函数可能如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    Job job = Job.getInstance(conf, <span class="string">&quot;word count&quot;</span>);</span><br><span class="line">    job.setJarByClass(WordCount.class);</span><br><span class="line">    </span><br><span class="line">    FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">    FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">    job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">    job.setReducerClass(IntSumReducer.class);</span><br><span class="line">    </span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(IntWritable.class);</span><br><span class="line">    </span><br><span class="line">    System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MapReduce-中的数据格式"><a href="#MapReduce-中的数据格式" class="headerlink" title="MapReduce 中的数据格式"></a>MapReduce 中的数据格式</h2><p>MapReduce 工作过程中每个阶段的输入和输出数据都是以<strong>键值对</strong>的形式出现，如下表所示，表中的 k 与 v 代表了数据类型，不同下标代表不同的数据类型。</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">输入</th>
<th align="center">输出</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>map()</code></td>
<td align="center">&lt;$k_1$, $v_1$&gt;</td>
<td align="center">[&lt;$k_2$, $v_2$&gt;, …]</td>
<td align="center">一个输入分片被 Map 处理成一系列的键值对</td>
</tr>
<tr>
<td align="center"><code>reduce()</code></td>
<td align="center">&lt;$k_2$, [$v_2$, …]&gt;</td>
<td align="center">&lt;$k_3$, $v_3$&gt;</td>
<td align="center">Reduce 的输入键类型为 Map 后的输出键类型，输入值是键对应的值的集合</td>
</tr>
</tbody></table>
<p>下面以统计词频程序 WordCount 为例，来说明 MapReduce 过程中的数据类型转换。</p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><p>在 Mapper 工作之前，框架从文件系统中读取文件并切分为分片，将数据转换为 <code>&lt;KEYIN, VALUEIN&gt;</code> 格式的键值对传给 map 函数。在 WordCount 程序中可以理解为形如 <code>&lt;行号, &quot;a b c&quot;&gt;</code> 的输入数据。实际上，输入键“行号”在实际代码中可能如下的 LongWritable 类型，一个可序列化的长整型偏移量（offset）。这是由 Hadoop 框架定义的数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        String line = value.toString();</span><br><span class="line">        String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            Text outputKey = <span class="keyword">new</span> Text(word.toUpperCase().trim());</span><br><span class="line">            IntWritable outputValue = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">            context.write(outputKey, outputValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：Hadoop 提供了一套可优化网络序列化传输的基本类型，而不直接使用 Java 内置类型，这些类型位于 <code>org.apache.hadoop.io</code> 包中。上述代码中的 LongWritable 相当于 Java 的 Long 类型，Text 相当于 String 类型，IntWritable 相当于 Integer 类型。</p>
<p>map 函数将输入的文本串切分为一个个单词，输入的键值对被转换为 <code>&lt;KEYOUT, VALUEOUT&gt;</code> 格式的<strong>中间键值对</strong>输出。此时的输出键为单词，输出值为单词计数，默认为 1。即经由 Mapper 处理后，原本的“一行”数据被转换为了形如 <code>[&lt;&quot;a&quot;, 1&gt;, &lt;&quot;b&quot;, 1&gt;, &lt;&quot;c&quot;, 1&gt;]</code> 的中间数据。</p>
<p>中间数据是暂时数据，不会存入 HDFS，但是会存入运行 Map 任务节点的本地磁盘，经过数据混洗后被 Reducer 端消费。</p>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>由于 Reduce 任务与 Map 任务与不一定处于同一节点上，Reduce 任务会通过网络通信拉取多个 Map 任务产生的中间数据。数据从 Map 任务端传输给 Reduce 任务端的过程被称为<strong>数据混洗</strong>。</p>
<p>混洗之后传入给 Reducer 的输入键值对的值，是该键对应的值的集合（可迭代对象），如 <code>&lt;&quot;a&quot;, [1, 2, 1]&gt;</code>。值可能为 2 是因为，为了减少磁盘写入和网络传输的数据量，Map 任务可能会在本地节点上预先聚合，这也就是 Combiner 所做的工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text word, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            sum += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(word, <span class="keyword">new</span> IntWritable(sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过 reduce 函数处理后，单词的所有计数值被累加，输出形如 <code>&lt;&quot;a&quot;, 4&gt;</code> 的键值对。</p>
<h2 id="MapReduce-工作流程详解"><a href="#MapReduce-工作流程详解" class="headerlink" title="MapReduce 工作流程详解"></a>MapReduce 工作流程详解</h2><p>MapReduce 将处理过程分成两个大类阶段：Map 阶段和 Reduce 阶段。在 Map 阶段，由于任务分发基于数据本地化原则，Map 任务运行在包含有该任务处理数据的节点上，数据存储在当前节点的 HDFS DataNode 中。因此，Map 阶段处理的都是本地数据，不需要进行网络传输。Map 阶段产生的中间数据将会暂存在当前节点上，Reduce 阶段需要从相关节点上拉取数据进行聚合运算，再将结果写入 HDFS。因此，Reduce 阶段既需要磁盘读写，也需要网络传输。</p>
<p>当然，MapReduce 在工作时还要细分为许多小阶段，下面这张图很好的展示了 MapReduce 的整个工作流程，具体包括：数据读入阶段、Mapper 处理阶段、优化性阶段 Combiner、中间数据分区 Partitioner 阶段、被称为 MapReduce “心脏”的数据混洗 Shuffle 阶段、Reducer 处理阶段以及数据写入阶段。</p>
<p><img data-src="2.jpg" alt="9b17e681d1c5745840c517209dd2808f.jpeg"></p>
<p>从大类阶段上划分，数据混洗之前的阶段都可以划分到 Map 阶段，因为这些步骤都是在本地节点上完成的，不涉及网络传输。而在数据混洗阶段，程序从本地或是集群上的其他节点拉取并拷贝 Mapper 产生的中间数据，提供给 Reducer 作为输入。因此，可以将包括数据混洗及其之后的步骤划分为 Reduce 阶段。事实上，数据混洗的相关类也被定义在 <code>org.apache.hadoop.mapreduce.task.reduce</code> 包下。</p>
<p>下面将结合源码详细介绍各个阶段的工作。</p>
<h3 id="数据读入阶段"><a href="#数据读入阶段" class="headerlink" title="数据读入阶段"></a>数据读入阶段</h3><p>数据被 Mapper 处理前，需要先转换为 Mapper 支持的键值对类型，这个过程由 InputFormat 和 RecordReader 类完成。首先，由 InputFormat 类从 HDFS 读入文件并创建<strong>输入分片</strong>（Input Split），分片为等长的逻辑数据块，比如可能是形如 <code>(input-file-path, start, offset)</code> 的元组。</p>
<p>一个合理的分片大小应该与 HDFS 块大小保持一致，默认为 128 MB。<strong>Hadoop 会在分片数据所在的物理节点寻找一个空闲的 Map 槽，运行 Map 任务</strong>，由该任务运行用户自定义的 map 函数从而处理分片中的每条记录。此时，符合之前所说的数据本地化原则。一旦一个分片跨越两个物理块，由于 HDFS 的分布式存储特性，这两个块极可能位于不同的 DataNode 上，此时分片中的部分数据就需要通过网络传输到 Map 任务运行的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputFormat</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;InputSplit&gt; <span class="title">getSplits</span><span class="params">(JobContext context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> RecordReader&lt;K, V&gt; <span class="title">createRecordReader</span><span class="params">(InputSplit split, TaskAttemptContext context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InputFormat 会为一个分片创建一个 RecordReader 对象，负责将输入分片转换为 Mapper 可处理的键值对。从数据视图角度看，输入数据字节流被转换为了面向记录的视图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordReader</span>&lt;<span class="title">KEYIN</span>, <span class="title">VALUEIN</span>&gt; <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">nextKeyValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KEYIN <span class="title">getCurrentKey</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> VALUEIN <span class="title">getCurrentValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mapper-阶段"><a href="#Mapper-阶段" class="headerlink" title="Mapper 阶段"></a>Mapper 阶段</h3><p>在这个阶段，Mapper 会执行用户定义的 map 函数，并将输入的键值对转换为中间键值对序列。在 MapTask 类中，使用新版本的 Mapper 会直接调用 <code>mapper.run()</code> 方法运行，旧版本还需要由包装有 Mapper 的 MapRunner 来运行。新版的 API 中，允许用户覆盖 <code>run()</code> 方法，以及 Context 对象的生命周期方法，来做到对 Mapper 执行的完全控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mapper</span>&lt;<span class="title">KEYIN</span>, <span class="title">VALUEIN</span>, <span class="title">KEYOUT</span>, <span class="title">VALUEOUT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(KEYIN key, VALUEIN value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        context.write((KEYOUT) key, (VALUEOUT) value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        setup(context);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (context.nextKeyValue()) &#123;</span><br><span class="line">                map(context.getCurrentKey(), context.getCurrentValue(), context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cleanup(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：Map 阶段的整个工作流程，可以在 MapTask 类的 <code>run()</code> 和 <code>runNewMapper()</code> 或 <code>runOldMapper()</code> 方法中清晰的一览。</p>
<h3 id="Partitioner-阶段"><a href="#Partitioner-阶段" class="headerlink" title="Partitioner 阶段"></a>Partitioner 阶段</h3><p>与 Map 任务不同，Reduce 任务并不具备数据本地化的优势，单个 Reduce 任务的输入通常来自于所有 Mapper 的输出。因此，即使 Reduce 任务与某些个 Map 任务处于同一节点上，也不可避免的需要通过网络传输从其他节点上获取 Mapper 输出。</p>
<p>当只有一个 Reduce 任务时，这个 Reduce 任务会读取所有 Mapper 输出，此时对中间数据分区意义不大，因为所有 Mapper 输出都被写入同一文件。但当有多个 Reduce 任务时，为提高数据吞吐量，<strong>每个 Map 任务会针对输出进行分区（Partition），即为每个 Reduce 任务创建一个分区</strong>。同一个键对应的键值对记录都被划分在同一分区中，每个分区中可以包含许多键（及其对应的值）。并且，一个分区中的记录是<strong>按键排序</strong>的，这样，磁盘读取一个键的所有记录时能保证读取连续数据，而不是从零散的文件中再过滤数据。</p>
<h4 id="数据溢写"><a href="#数据溢写" class="headerlink" title="数据溢写"></a>数据溢写</h4><p><img data-src="3.png" alt="20cbf28f315007e05a1c762915a25ca2.png"></p>
<p>每个 Map 任务有一个环形内存缓冲区，缓冲区大小由 <code>io.sort.mb</code> 指定，默认 100MB。Mapper 产生的中间键值对记录将被先写入缓冲区，当达到缓冲区设定阈值时（<code>io.sort.spill.percent</code>，默认 80%），会开启一个线程将内容<strong>溢写</strong>（spill）到磁盘，由 <code>mapred.local.dir</code> 属性指定的目录。线程工作的同时，Mapper 的输出继续被写到缓冲区，如果在此期间缓冲区被写满，Mapper 将会阻塞直到溢写过程结束。</p>
<p><strong>每次缓冲区达到溢出阈值，就会新建一个溢出文件，键值对会在内存中先按键排序然后写入文件</strong>。在任务完成前，溢出文件会不断合并并保证文件中数据是有序的。</p>
<p>数据溢写会写入运行 Map 任务节点的本地磁盘，并不会写入 HDFS（但 Reducer 的输出并不是这样）。这是因为，Map 任务运行的输入分片来自本地节点，输出也应写入本地节点，这样保证了整个 Map 任务的数据本地化。而写入 HDFS 则会为数据创建分布式副本，带来额外网络开销。更何况，Map 任务产生的输出只是暂时数据，任务执行完毕后会被删除。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>下面我们通过阅读 <code>org.apache.hadoop.mapred.MapTask</code> 类的相关源码，来加深对 Map 任务将中间键值对分区、排序存入磁盘过程的理解。Hadoop 使用 OutputCollector 将 Mapper 数据写入磁盘，由于继承/实现的类不同，MapTask 类中存在 Old/NewOutputCollector 两套新旧收集器。以新版 NewOutputCollector 为例，它的实现逻辑如下：</p>
<ul>
<li>首先，创建一个排序收集器 collector，具体的排序逻辑在 MapOutputBuffer 类中，其实现了 IndexedSortable 接口的 <code>compare()</code> 方法，按键进行排序；</li>
<li>从作业上下文（配置）中获取 Reduce 任务总数；</li>
<li>当 Reduce 任务数大于一时，通过反射创建 Partitioner 类的实例，这个类可以是用户自定义的类，并在配置阶段注入；</li>
<li>如果 Reduce 任务数等于零（纯 Map 作业）或等于一，创建匿名内部类，返回的分区号为固定值，所有输出写到同一分区；</li>
<li>写入阶段通过收集器的 <code>collect()</code> 方法，将键值对按照分区号写入对应分区。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NewOutputCollector</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">RecordWriter</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MapOutputCollector&lt;K,V&gt; collector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Partitioner&lt;K,V&gt; partitioner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partitions;</span><br><span class="line"></span><br><span class="line">    NewOutputCollector(JobContext jobContext, JobConf job, TaskUmbilicalProtocol umbilical, TaskReporter reporter) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        collector = createSortingCollector(job, reporter);</span><br><span class="line">        partitions = jobContext.getNumReduceTasks();</span><br><span class="line">        <span class="keyword">if</span> (partitions &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            partitioner = (Partitioner&lt;K,V&gt;) ReflectionUtils.newInstance(jobContext.getPartitionerClass(), job);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            partitioner = <span class="keyword">new</span> Partitioner&lt;K,V&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(K key, V value, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> partitions - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(K key, V value)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        collector.collect(key, value, partitioner.getPartition(key, value, partitions));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Partitioner 类位于 <code>org.apache.hadoop.mapreduce</code> 包下，其作用是返回一个整型分区号，Map 任务将这个分区号作为写入哪个分区的标识。用户可以自定义分区函数，需要继承 Partitioner 类。通常，默认的分区函数 HashPartitioner 足够用了，它使用哈希函数，将键进行哈希后取非负（前置位补零）然后对 Reduce 任务总数取模。这样，能保证键相同的记录被分配至同一分区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashPartitioner</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/** Use &#123;<span class="doctag">@link</span> Object#hashCode()&#125; to partition. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(K key, V value, <span class="keyword">int</span> numReduceTasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashPartitioner 足够高效，但如果你执行的 MapReduce 作业发生数据倾斜的问题（如存在大部分相同键），可以考虑自定义分区函数，比如加入随机值。</p>
<h4 id="Reduce-任务数设置"><a href="#Reduce-任务数设置" class="headerlink" title="Reduce 任务数设置"></a>Reduce 任务数设置</h4><p>Hadoop MapReduce 的<strong>并行度</strong>取决于 Map 任务数量和 Reduce 任务数量。Map 任务数量不需要手动设置，原因是该数量等于输入文件被划分成的分片数，框架会为一个输入分片分配一个 Map 任务。Map 任务数据取决于输入文件的大小以及 HDFS 文件块的大小。默认情况下，输入分片大小与块大小保持一致，均为 128 MB。</p>
<p>Reduce 任务数量可以在作业配置时通过 <code>job.setNumReduceTasks()</code> 手动设置。默认情况下，只有一个 Reduce 任务，这对于本地小规模数据已经足够了。但在真实应用中，几乎所有作业都将它设置为一个较大的数字，否则，所有的中间数据都被传输给一个 Reduce 任务，作业处理极其低效。</p>
<p>为一个作业设置多少个 Reduce 任务数，与其说是一门技术，不如说更多是一门艺术。由于并行化程度提高，增加 Reducer 能缩短 Reduce 阶段整体耗时。并且，增加的 Reducer 对于解决数据倾斜问题通常能有很好的帮助。然而，如果配置了过多 Reducer，文件将被切分为更多小文件，磁盘 I/O 次数将显著增加，这又不够优化。相对于大批量的小文件，Hadoop 更适合处理少量的大文件。一条经验法则是，目标 Reducer 保持在每个运行 5 分钟左右，且产生至少一个 HDFS 块的输出比较合适。</p>
<h3 id="Combiner-阶段"><a href="#Combiner-阶段" class="headerlink" title="Combiner 阶段"></a>Combiner 阶段</h3><p>为了减少 Map 和 Reduce 任务之间的数据传输量，Hadoop 允许用户针对 Map 任务指定一个 Combiner 类。以统计词频程序为例，Mapper 输出的键值对 <code>&lt;单词，计数值&gt;</code> 的计数值初始均为一，此时可通过 Combiner 将相同键的值进行聚合，即计数值累加。这样，同一个 Mapper （来自同一输入分片）的处理数据将被提前聚合，既减少了磁盘写入数据量，也减少了需要通过网络传输给 Reducer 的数据量。因此 Combiner 也被称为 “Mini-reducer” 或 “Local-reducer”，意指在本地节点完成的。</p>
<p><img data-src="4.png" alt="e58767ee9dfc6d8bf818f639a0508b7f.png"></p>
<p>Combiner 工作在文件溢写的前后，具体是在 MapTask 的内部类的 <code>sortAndSpill() </code> 和 <code>mergeParts()</code> 方法中，由 <code>combinerRunner.combine()</code> 运行。在 Mapper 输出的键值对被溢写到磁盘之前，会在内存中按键排序，如果定义了 Combiner，它将在排序后的输出上运行，经过 Combiner 紧凑后的数据再写入磁盘。在溢出文件合并阶段，如果至少存在 3 个溢出文件（由 <code>mapreduce.map.combine.minspills</code> 属性指定），那么 Combiner 将会在文件合并时再次运行。因此，Combiner 可能会在 Mapper 输出上反复运行。如果只有 1 或 2 个溢出文件，此时说明 Mapper 输出吞吐量降低，因而不值得调用 Combiner 带来额外开销。</p>
<p>由于 Combiner 与 Reducer 聚合逻辑相同，Hadoop 没有提供额外的 Combiner 类，而是通过 Reducer 类复用。新版的 CombinerRunner 代码如下，它通过反射获取了一个 Reducer 实例，直接运行 Reducer 的 <code>run()</code> 方法进行数据聚合，聚合结果由上下文对象传入 OutputCollector 中，最后写入磁盘。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NewCombinerRunner</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">CombinerRunner</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(RawKeyValueIterator iterator, OutputCollector&lt;K, V&gt; collector)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// make a reducer</span></span><br><span class="line">        Reducer&lt;K, V, K, V&gt; reducer = (Reducer&lt;K, V, K, V&gt;) ReflectionUtils.newInstance(reducerClass, job);</span><br><span class="line">        Context reducerContext = createReduceContext(reducer, job, taskId,</span><br><span class="line">                iterator, <span class="keyword">null</span>, inputCounter,</span><br><span class="line">                <span class="keyword">new</span> OutputConverter(collector),</span><br><span class="line">                committer,</span><br><span class="line">                reporter, comparator, keyClass,</span><br><span class="line">                valueClass);</span><br><span class="line">        reducer.run(reducerContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户在声明作业配置时可以直接复用定义好的 Reducer 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">job.setReducerClass(IntSumReducer.class);</span><br></pre></td></tr></table></figure>

<h3 id="Shuffler-阶段"><a href="#Shuffler-阶段" class="headerlink" title="Shuffler 阶段"></a>Shuffler 阶段</h3><p>数据混洗（Shuffle）被称为是 MapReduce 的“心脏”，是奇迹发生的地方。从宏观上，它体现为从 Map 任务端到 Reduce 任务端的数据流处理过程，具体说即是 <strong>Mapper 产生的中间键值对被重新组织（排序、分区），写入到本地磁盘中（溢写），Reducer 从多个 Mapper 工作节点上拷贝、合并数据</strong>的过程。最终目的是将数据从 Mapper 端发送到 Reducer 端，中间过程则是 MapReduce 框架基于性能考量的优化过程。从下图你可以清晰的体会到为什么这个过程被称为“数据混洗”。</p>
<p><img data-src="5.png" alt="2abd2dc93aa589f4b1d42b451b2b873c.png"></p>
<p>在微观上，Shuffle 被划分为了 Reduce 任务阶段的工作，定义在 <code>org.apache.hadoop.mapreduce.task.reduce</code> 包内。它是一个具体类，是框架定义的 <code>ShuffleConsumerPlugin&lt;K, V&gt;</code> 接口的内置实现类。从接口命名上可以体现出它作为 Mapper 端输出数据“消费者”的身份，“插件”则体现了它的可插拔特性，框架允许用户使用除了内置实现以外的三方插件。</p>
<p>在 ReduceTask 类的 <code>run()</code> 方法中通过反射获取了一个 Shuffle 类实例。<code>job.getClass()</code> 的第一个参数是三方插件的配置地址，第二个值 <code>Shuffle.class</code> 即为默认的内置实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReduceTask</span> <span class="keyword">extends</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(JobConf job, <span class="keyword">final</span> TaskUmbilicalProtocol umbilical)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ShuffleConsumerPlugin shuffleConsumerPlugin = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;? extends ShuffleConsumerPlugin&gt; clazz = job.getClass(MRConfig.SHUFFLE_CONSUMER_PLUGIN, Shuffle.class, ShuffleConsumerPlugin.class);</span><br><span class="line">        shuffleConsumerPlugin = ReflectionUtils.newInstance(clazz, job);</span><br><span class="line"></span><br><span class="line">        shuffleConsumerPlugin.init(shuffleContext);</span><br><span class="line">        rIter = shuffleConsumerPlugin.run();</span><br><span class="line">        <span class="keyword">if</span> (useNewApi) &#123;</span><br><span class="line">            runNewReducer(job, umbilical, reporter, rIter, comparator, keyClass, valueClass);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            runOldReducer(job, umbilical, reporter, rIter, comparator, keyClass, valueClass);</span><br><span class="line">        &#125;</span><br><span class="line">        shuffleConsumerPlugin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shuffle 类的 <code>run()</code> 方法，是数据混洗步骤真正的具体实现。</p>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p>在一个 Map 任务完成后，会通过心跳包通知 JobTracker，这样，JobTracker 就能获取 Map 输出与主机位置之间的映射关系，Reduce 任务中的一个线程定期询问 JobTracker 以获取 Map 输出位置，直到获取所有输出位置。当一个 Map 任务完成后，Reduce 任务就可以开始复制了，这就是 <strong>Reduce 任务的复制（copy）阶段</strong>。此过程由并发线程完成，默认是 5 个线程，由 <code>mapreduce.reduce.shuffle.parallelcopies</code> 属性指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shuffle</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ShuffleConsumerPlugin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">ExceptionReporter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RawKeyValueIterator <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// Start the map-completion events fetcher thread</span></span><br><span class="line">        <span class="keyword">final</span> EventFetcher&lt;K, V&gt; eventFetcher = <span class="keyword">new</span> EventFetcher&lt;K, V&gt;(reduceId, umbilical, scheduler, <span class="keyword">this</span>, maxEventsToFetch);</span><br><span class="line">        eventFetcher.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the map-output fetcher threads</span></span><br><span class="line">        <span class="keyword">boolean</span> isLocal = localMapFiles != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numFetchers = isLocal ? <span class="number">1</span> : jobConf.getInt(MRJobConfig.SHUFFLE_PARALLEL_COPIES, <span class="number">5</span>);</span><br><span class="line">        Fetcher&lt;K, V&gt;[] fetchers = <span class="keyword">new</span> Fetcher[numFetchers];</span><br><span class="line">        <span class="keyword">if</span> (isLocal) &#123;</span><br><span class="line">            fetchers[<span class="number">0</span>] = <span class="keyword">new</span> LocalFetcher&lt;K, V&gt;(jobConf, reduceId, scheduler, merger, reporter, metrics, <span class="keyword">this</span>, reduceTask.getShuffleSecret(), localMapFiles);</span><br><span class="line">            fetchers[<span class="number">0</span>].start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numFetchers; ++i) &#123;</span><br><span class="line">                fetchers[i] = <span class="keyword">new</span> Fetcher&lt;K, V&gt;(jobConf, reduceId, scheduler, merger, reporter, metrics, <span class="keyword">this</span>, reduceTask.getShuffleSecret());</span><br><span class="line">                fetchers[i].start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shuffle 使用名为 Fetcher 的线程类进行数据复制，如果 Reduce 任务恰好就处于运行 Map 任务的节点上，此时不需要网络通信，直接通过 LocalFetcher 获取本地数据。否则，使用 Fetcher 通过 HTTP 通信拉取相关节点上的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If merge is on, block</span></span><br><span class="line">        merger.waitForResource();</span><br><span class="line">        <span class="comment">// Get a host to shuffle from</span></span><br><span class="line">        host = scheduler.getHost();</span><br><span class="line">        metrics.threadBusy();</span><br><span class="line">        <span class="comment">// Shuffle</span></span><br><span class="line">        copyFromHost(host);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：拉取后的数据是写入内存还是写入磁盘，是由 MapOutput 类的 <code>shuffle()</code> 方法完成的，该类拥有两个具体子类：InMemoryMapOutput 和 OnDiskMapOutput。</p>
<p>如果 Map 任务输出相当小，会被复制到 Reduce 任务的 JVM 内存缓冲区中，一旦内存缓冲区达到阈值，Map 输出会被复制到磁盘。随着磁盘上副本增多，后台线程会将它们合并为更大的、按键排好序的文件，这就是 Reduce 任务的<strong>合并阶段</strong>（merge）。这个阶段将合并 Map 输出，并维持其按键排序。合并的数据可能来自于内存缓冲区和磁盘文件。</p>
<p>合并阶段按照预先设定的合并因子（默认为 10），每趟合并 10 个文件，所以合并过程是循环进行的。为减少磁盘读写次数，最后一轮的文件合并（包含所有数据）不再写入磁盘，而是直接传送给 Reducer 处理。</p>
<h3 id="Reducer-阶段"><a href="#Reducer-阶段" class="headerlink" title="Reducer 阶段"></a>Reducer 阶段</h3><p>在 Reducer 阶段，对已排序的输出中的每个键调用 reduce 函数。此阶段的输出直接写到输出文件系统，一般为 HDFS，还可以是数据库。如果采用 HDFS，由于 Reduce 任务运行所在的节点也运行 DataNode，所以第一个块副本将被写到本地磁盘中。</p>
<p>用户需要继承 Reducer 并重写 reduce 函数，函数的输入值入参是值的可迭代对象，框架会从文件系统中读取输入键对应的值集合，传入给 reduce 函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reducer</span>&lt;<span class="title">KEYIN</span>, <span class="title">VALUEIN</span>, <span class="title">KEYOUT</span>, <span class="title">VALUEOUT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(KEYIN key, Iterable&lt;VALUEIN&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (VALUEIN value : values) &#123;</span><br><span class="line">            context.write((KEYOUT) key, (VALUEOUT) value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 Mapper 类似，框架也允许用户覆盖 <code>run()</code> 方法，以及 Context 对象的生命周期方法。</p>
<h3 id="数据写入阶段"><a href="#数据写入阶段" class="headerlink" title="数据写入阶段"></a>数据写入阶段</h3><p>数据写入阶段，由 OutputFormat 负责检验作业的输出规范，如输出目录是否已存在。如果写入到文件系统，则由实现子类 FileOutputformat 的 <code>setOutputPath()</code> 方法负责从作业配置中读取输出目录。由 OutputFormat 创建的 RecordWriter 对象负责将 Reducer 产生的键值对数据写到输出文件，每个 Reducer 对应一个文件。此过程无需创建分片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputFormat</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> RecordWriter&lt;K, V&gt; <span class="title">getRecordWriter</span><span class="params">(TaskAttemptContext context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">checkOutputSpecs</span><span class="params">(JobContext context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> OutputCommitter <span class="title">getOutputCommitter</span><span class="params">(TaskAttemptContext context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MapReduce-的局限"><a href="#MapReduce-的局限" class="headerlink" title="MapReduce 的局限"></a>MapReduce 的局限</h2><p>在 MapReduce 的工作过程中，框架需要频繁地读写文件系统，MapReduce 作业往往又都是数据密集型的，因此大量的中间数据会被往复地写入、读取、合并排序后又写入磁盘。大量的磁盘 I/O 导致 MapReduce 的耗时往往是分钟级、甚至是小时级的。受到 MapReduce 诞生年代的约束，昂贵的内存迫使用户将 Hadoop 集群部署在廉价的商用机器集群上，使用磁盘来进行数据的缓存。大规模的分布式部署使得 MapReduce 程序具有高容错性和良好的横向扩展性优势。</p>
<p>时至今日，用户对数据处理延迟的忍耐性越来越低，在大规模数据批处理之上又诞生了实时性要求极高的流处理系统。不管是 Spark Streaming 还是 Flink 都能做到秒级甚至是毫秒级的响应，MapReduce 因为其性能局限已经跟不上时代的需求。</p>
<p>MapReduce 的函数本身是无状态的，这意味着并不是所有工作 MapReduce 都能胜任，比如需要状态共享和参数依赖的机器学习模型训练算法。尽管 MapReduce 可以通过文件存储状态，但这样带来的性能开销是巨大的。相反，Spark 作为一个基于内存迭代式的大数据计算引擎很适合这样的场景，其提供了有状态的流来应对需要状态共享的作业，通过 <code>updateStateByKey()</code> 和 <code>mapWithState()</code> 状态管理函数共享状态。状态被保存在内存中，后续访问直接从内存中读取。据 Spark 官方统计的 Spark 运行逻辑回归机器学习算法的运行时间要优于 hadoop 一百倍。这也让 Spark 提供机器学习库 Spark MLlib 成为可能。</p>
<p>MapReduce 框架要求用户编写底层的 map 和 reduce 函数，这对于数据分析师是一个考验，Spark SQL 允许数据分析师使用 SQL 语言处理数据，由框架负责将其翻译成底层执行步骤。而且，编写底层函数这样的控制粒度不够灵活，对于一个复杂的作业来说，可能要由多个 MapReduce 作业组合而成，这样又会引入额外的中间数据读写开销。相比之下，Spark 编程模型更灵活，提供了丰富的 Transformation 和 Action 算子。性能方面，Spark 会为作业构建逻辑执行计划图（DAG），并针对其步骤进行优化，减少数据混洗阶段的 I/O 次数。</p>
<p>不管怎么说，MapReduce 作为第一代分布式计算引擎，其后诞生的分布式框架都是在其基础上的演进，因此有必要对 MapReduce 工作原理做个详细了解。Spark 由批处理起家，延续了 MapReduce 编程模型的设计思路。下一节我们将介绍 Spark 的运行原理。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Hadoop 权威指南（第四版）</li>
<li><a target="_blank" rel="noopener" href="https://hadoop.apache.org/docs/stable/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html#Mapper">Apache Hadoop 官方文档：MapReduce Tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://techvidvan.com/tutorials/how-mapreduce-works/">Phases of MapReduce – How Hadoop MapReduce Works</a></li>
<li><a target="_blank" rel="noopener" href="http://hadoopbeforestarting.blogspot.com/2012/12/difference-between-hadoop-old-api-and.html">Difference  between Hadoop OLD API and NEW API</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/10/12/%E4%BD%BF%E7%94%A8-Docker-%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2-Spark-Hadoop-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/12/%E4%BD%BF%E7%94%A8-Docker-%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2-Spark-Hadoop-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4/" class="post-title-link" itemprop="url">使用 Docker 快速部署 Spark + Hadoop 大数据集群</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-12 21:47:58" itemprop="dateCreated datePublished" datetime="2021-10-12T21:47:58+08:00">2021-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ops/" itemprop="url" rel="index"><span itemprop="name">Ops</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了免去繁杂的环境配置工作，提供开箱即用的 Spark + Hadoop 快捷部署方案。本教程基于 BitNami 项目的成熟镜像方案，搭建 Spark Docker 集群，并在原有镜像基础上，构建了安装有对应版本 Hadoop 的镜像。</p>
<p>镜像已提交至 Docker Hub 官方仓库中，可通过如下命令拉取：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull s1mplecc/spark-hadoop:3</span><br></pre></td></tr></table></figure>

<p>构建镜像的所需文件也已提交至 GitHub：<a target="_blank" rel="noopener" href="https://github.com/s1mplecc/spark-hadoop-docker">s1mplecc/spark-hadoop-docker</a>。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>操作系统 MacOS Mojave，命令行工具：Terminal + Zsh</li>
<li>Docker Desktop for Mac，内置 Docker CLI client 与 Docker Compose</li>
<li>Spark Docker 镜像：<a target="_blank" rel="noopener" href="https://github.com/bitnami/bitnami-docker-spark">bitnami-docker-spark</a>，Spark 版本：3.1.2</li>
<li>Hadoop 版本：<a target="_blank" rel="noopener" href="https://hadoop.apache.org/release/3.2.0.html">hadoop-3.2.0</a></li>
</ul>
<h2 id="部署-Spark-集群"><a href="#部署-Spark-集群" class="headerlink" title="部署 Spark 集群"></a>部署 Spark 集群</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p><a target="_blank" rel="noopener" href="https://github.com/bitnami">BitNami</a> 是一个开源项目，现已被 VMware 公司收购，其宗旨是简化在个人终端、Kubernetes 和云服务器等环境上的开源软件的部署。其已为 Docker Hub 社区提供了数百个容器镜像方案，其中的 Redis、MongoDB 等热门镜像更是超过了十亿次下载。</p>
<p>bitnami/spark 镜像也已超过百万次下载，这是一个成熟的 Spark Docker 方案。此外选择它的重要原因是它的文档齐全，且更新频率快，目前的最新版本基于 Spark 官方发行的最新版本 Spark 3.1.2。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ docker pull bitnami/spark:3</span><br><span class="line">➜ docker images       </span><br><span class="line">REPOSITORY               TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">bitnami/spark            3         67ed3ae333e0   4 days ago      1.29GB</span><br></pre></td></tr></table></figure>

<p>注：此镜像基于 bitnami/minideb 基础镜像，这是 BitNami 构建的极简 Debian 系统镜像。Debian 由于系统稳定且内核占用资源小的优势，非常适合作为服务器操作系统。</p>
<h3 id="以集群方式运行"><a href="#以集群方式运行" class="headerlink" title="以集群方式运行"></a>以集群方式运行</h3><p>为了模拟 Spark 集群，采取一主二从的部署方式，使用 Docker Compose 对容器集群进行统一编排管理。</p>
<p>首先，在本地新建一个工作目录，我的路径为 <code>~/docker/spark</code>，在该目录下编写 docker-compose.yml 配置文件。基于 bitnami/spark 提供的配置文件，我做了一些修改，包括：</p>
<ul>
<li><code>hostname</code>：容器实例主机名；</li>
<li><code>volumes</code>：挂载本地目录 <code>~/docker/spark/share</code> 到容器目录 <code>/opt/share</code>；</li>
<li><code>ports</code>：开放 4040 和从节点 Spark Web UI 端口。</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">spark:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/bitnami/spark:3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MODE=master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_AUTHENTICATION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_LOCAL_STORAGE_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_SSL_ENABLED=no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker/spark/share:/opt/share</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8080:8080&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;4040:4040&#x27;</span></span><br><span class="line">  <span class="attr">spark-worker-1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/bitnami/spark:3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">worker1</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MODE=worker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MASTER_URL=spark://master:7077</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_MEMORY=1G</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_CORES=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_AUTHENTICATION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_LOCAL_STORAGE_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_SSL_ENABLED=no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker/spark/share:/opt/share</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8081:8081&#x27;</span></span><br><span class="line">  <span class="attr">spark-worker-2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/bitnami/spark:3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">worker2</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MODE=worker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MASTER_URL=spark://master:7077</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_MEMORY=1G</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_CORES=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_AUTHENTICATION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_LOCAL_STORAGE_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_SSL_ENABLED=no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker/spark/share:/opt/share</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8082:8081&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在可以启动 Spark Docker 集群了。在工作目录下，执行如下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ docker-compose up -d                        </span><br><span class="line">[+] Running 3/3</span><br><span class="line"> ⠿ Container spark-spark-1           Started                                         1.0s</span><br><span class="line"> ⠿ Container spark-spark-worker-2-1  Started                                         1.1s</span><br><span class="line"> ⠿ Container spark-spark-worker-1-1  Started                                         1.1s</span><br></pre></td></tr></table></figure>

<p>启动后的集群可以在 Docker Desktop 中进行查看：</p>
<p><img data-src="1.png" alt="7262ff48300734f66dd1a10cce5a064e.png"></p>
<p>可通过映射的端口访问 Spark Web UI。集群以默认的 Standalone 独立集群模式启动，通过 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> 查看集群运行状态：</p>
<p><img data-src="2.png" alt="556c8dffa7f55d32d78b52c11fe31701.png"></p>
<h4 id="集群网络"><a href="#集群网络" class="headerlink" title="集群网络"></a>集群网络</h4><p>默认情况下，通过 <code>docker-compose</code> 启动的容器集群，会创建并使用名为 <code>镜像名_default</code> 的桥接网络，如 <code>spark_default</code>。集群内的容器处于同一子网网段，因此可以相互通信。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ docker network ls         </span><br><span class="line">NETWORK ID     NAME            DRIVER    SCOPE</span><br><span class="line">331df1b4ff6d   bridge          bridge    local</span><br><span class="line">3a916c4f1299   host            host      local</span><br><span class="line">42b893852f97   none            null      local</span><br><span class="line">e425e615144b   spark_default   bridge    local</span><br></pre></td></tr></table></figure>

<p>通过 <code>inspect</code> 命令查看网络配置详情。以下是 <code>spark_default</code> 网络部分配置信息，其使用 <code>172.18.0.0/16</code> 子网网段，并为每个容器实例分配了 IPv4 地址。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">➜ docker network inspect e4</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;spark_default&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Id&quot;</span>: <span class="string">&quot;e425e615144b972265afa9c6e78d7bf22cab446bc5bdece3f188abf5879e8677&quot;</span>,   # NETWORK ID</span><br><span class="line">        <span class="attr">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;Subnet&quot;</span>: <span class="string">&quot;172.18.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;Gateway&quot;</span>: <span class="string">&quot;172.18.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;9b9d9c1bb6f873da6b3c72232afab3a451b12cdd4c19d51cc510de1854f95efd&quot;</span>: &#123;   # CONTAINER ID</span><br><span class="line">                <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;spark-spark-worker-1-1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.2/16&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;a162bd33dc1936c70259ed2146a1f4a30e52faf66a91624d794336b5357a5f7b&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;spark-spark-worker-2-1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.4/16&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;b6ad535e924221e30746722cd486dace692f0f42528eba57347ef4177b355855&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;spark-spark-1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.3/16&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>注：同 CONTAINER ID 一样，NETWORK ID 的前两位可以唯一标识一个网络，如 <code>e4</code>。</p>
<h3 id="使用-Spark-Shell-进行交互"><a href="#使用-Spark-Shell-进行交互" class="headerlink" title="使用 Spark Shell 进行交互"></a>使用 Spark Shell 进行交互</h3><p>查看正在运行的容器实例，找到 master 实例的容器 ID：a162bd33dc19。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker ps                </span><br><span class="line">CONTAINER ID   IMAGE                     COMMAND                  CREATED        STATUS             PORTS                                                                                                                                              NAMES</span><br><span class="line">a162bd33dc19   s1mplecc/spark-hadoop:3   <span class="string">&quot;/opt/bitnami/script…&quot;</span>   42 hours ago   Up About an hour   0.0.0.0:4040-&gt;4040/tcp, 0.0.0.0:8080-&gt;8080/tcp   spark-spark-1</span><br><span class="line">9b9d9c1bb6f8   s1mplecc/spark-hadoop:3   <span class="string">&quot;/opt/bitnami/script…&quot;</span>   42 hours ago   Up About an hour   0.0.0.0:8081-&gt;8081/tcp                                                                                                                             spark-spark-worker-1-1</span><br><span class="line">b6ad535e9242   s1mplecc/spark-hadoop:3   <span class="string">&quot;/opt/bitnami/script…&quot;</span>   42 hours ago   Up About an hour   0.0.0.0:8082-&gt;8081/tcp                                                                                                                             spark-spark-worker-2-1</span><br></pre></td></tr></table></figure>

<p>执行如下命令进入到 master 容器内部。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ docker <span class="built_in">exec</span> -it a1 bash</span><br><span class="line">I have no name!@master:/opt/bitnami/spark$ </span><br></pre></td></tr></table></figure>

<p>注：实际上 <code>-it</code> 参数的作用是分配一个交互式虚拟终端；容器 ID 的前两位可以唯一标识该容器，如 a1。</p>
<p>现在，可以通过 <code>pyspark</code> 或 <code>spark-shell</code> 命令启动 Spark 交互式命令行，下面以 <code>pyspark</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ pyspark </span><br><span class="line">Python 3.6.15 (default, Sep 24 2021, 11:37:20) </span><br><span class="line">[GCC 8.3.0] on linux</span><br><span class="line">Setting default log level to &quot;WARN&quot;.</span><br><span class="line">To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).</span><br><span class="line">Welcome to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  &#x27;_/</span><br><span class="line">   /__ / .__/\_,_/_/ /_/\_\   version 3.1.2</span><br><span class="line">      /_/</span><br><span class="line"></span><br><span class="line">Using Python version 3.6.15 (default, Sep 24 2021 11:37:20)</span><br><span class="line">Spark context Web UI available at http://master:4040</span><br><span class="line">Spark context available as &#x27;sc&#x27; (master = local[*], app id = local-1633913993830).</span><br><span class="line">SparkSession available as &#x27;spark&#x27;.</span><br></pre></td></tr></table></figure>

<p>在启动交互式 Shell 时，<strong>Spark 驱动器程序（Driver Program）会创建一个名为 sc 的 SparkContext 对象，我们可以通过该对象来创建 RDD</strong>。例如，通过 <code>sc.textFile()</code> 方法读取本地或 HDFS 文件，或者通过 <code>sc.parallelize()</code> 方法直接由 Python 集合创建 RDD。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = sc.textFile(<span class="string">&#x27;README.md&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines.count()</span><br><span class="line"><span class="number">108</span>                                   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines.<span class="built_in">filter</span>(<span class="keyword">lambda</span> line: <span class="built_in">len</span>(line) &gt; <span class="number">10</span>)</span><br><span class="line">PythonRDD[<span class="number">3</span>] at RDD at PythonRDD.scala:<span class="number">53</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines.<span class="built_in">filter</span>(<span class="keyword">lambda</span> line: <span class="built_in">len</span>(line) &gt; <span class="number">10</span>).count()</span><br><span class="line"><span class="number">67</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strs = sc.parallelize([<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;i am spark&#x27;</span>, <span class="string">&#x27;hadoop&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strs.flatMap(<span class="keyword">lambda</span> s: s.split(<span class="string">&#x27; &#x27;</span>)).collect()</span><br><span class="line">[<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;am&#x27;</span>, <span class="string">&#x27;spark&#x27;</span>, <span class="string">&#x27;hadoop&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strs.flatMap(<span class="keyword">lambda</span> s: s.split(<span class="string">&#x27; &#x27;</span>)).reduce(<span class="keyword">lambda</span> x, y: x + <span class="string">&#x27;-&#x27;</span> + y)</span><br><span class="line"><span class="string">&#x27;hello-world-i-am-spark-hadoop&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注：由于 Spark 的<strong>惰性求值</strong>特性，只有当执行 Action 操作时，如 count、collect、reduce，才会真正执行计算并返回结果。</p>
<p>Spark Shell 默认以本地模式运行，但也支持以集群模式运行。可以通过指定 <code>--master</code> 参数，如 <code>pyspark --master spark://master:7077</code>，以 Standalone 模式运行 PySpark Shell。</p>
<h3 id="使用-spark-submit-提交独立应用"><a href="#使用-spark-submit-提交独立应用" class="headerlink" title="使用 spark-submit 提交独立应用"></a>使用 spark-submit 提交独立应用</h3><p>Spark Shell 支持与存储在硬盘或内存上的分布式数据进行交互，如 HDFS。因此 Spark Shell 适用于即时数据分析，比如数据探索阶段。但我们的最终目的是创建一个独立的 Java、Scala 或 Python 应用，将其提交到 Spark 集群上运行。</p>
<p>Spark 为各种集群管理器提供了统一的工具来提交作业，这个工具就是 <code>spark-submit</code>。</p>
<h4 id="提交-Python-应用"><a href="#提交-Python-应用" class="headerlink" title="提交 Python 应用"></a>提交 Python 应用</h4><p>下面以 Python 应用为例，编写 Python 脚本 my_script.py。Python 的 Spark 依赖库就叫做 pyspark，已经包含在 Spark 安装包内，位于 <code>$SPARK_HOME/python</code> 目录下。在独立应用中，我们需要导入该依赖，并且手动创建一个 SparkContext 实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkConf, SparkContext</span><br><span class="line"></span><br><span class="line">conf = SparkConf().setAppName(<span class="string">&#x27;My App&#x27;</span>)</span><br><span class="line">sc = SparkContext(conf=conf)</span><br><span class="line"></span><br><span class="line">count = sc.<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">100</span>).<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">100</span>).count()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;count: &#x27;</span>, count)</span><br></pre></td></tr></table></figure>

<p>注：SparkConf 用于声明应用配置信息，可以编码在代码中，也可以在命令行以参数形式指定。SparkConf 读取优先级为：代码 &gt; <code>spark-submit</code> 命令行参数 &gt; 以 <code>--properties-file</code> 参数指定的配置文件 &gt; 系统默认配置。</p>
<p>使用 <code>spark-submit</code> 命令提交 Python 脚本，指定 <code>--master</code> 参数提交到集群上。如果未指定该参数，则默认以本地模式运行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ spark-submit --master spark://master:7077 /opt/share/my_script.py</span><br><span class="line">count:  99999899</span><br></pre></td></tr></table></figure>

<p>当指定为 <code>spark://host:port</code> 时，应用提交到 Spark 自带的独立集群管理器（Standalone）上运行，默认端口 7077；如果使用 Apache Mesos 集群管理器，需指定为 <code>mesos://host:port</code>，默认端口 5050；使用 Hadoop YARN 则需指定为 <code>yarn</code>。</p>
<p>应用运行时，SparkContext 实例会启动应用的 Web UI，默认端口 4040。你可以在此网址查看应用的作业（Job）、组成作业的所有步骤（Stage）、持久化的 RDD 以及执行器状态等信息，这对于应用性能评估有巨大帮助。运行结束后，SparkContext 实例消亡，同时会关闭此 Web UI。</p>
<p><img data-src="3.png" alt="2626b1a665dbf00b5641f10100befa4e.png"></p>
<h4 id="提交-Java-应用"><a href="#提交-Java-应用" class="headerlink" title="提交 Java 应用"></a>提交 Java 应用</h4><p>Spark 安装包内置了可以运行的示例 Jar 包，位于 <code>$SPARK_HOME/examples</code> 目录下。向 Spark 集群提交 Jar 包需额外指定程序入口类，即 main 函数所在类。可以通过 <code>jar tf</code> 命令查看 Jar 包所包含的类。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jar tf /opt/bitnami/spark/examples/jars/spark-examples_2.12-3.1.2.jar | grep WordCount</span><br><span class="line">org/apache/spark/examples/JavaWordCount.class</span><br><span class="line">org/apache/spark/examples/sql/streaming/StructuredKerberizedKafkaWordCount.class</span><br><span class="line">org/apache/spark/examples/sql/streaming/StructuredNetworkWordCountWindowed.class</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>找到统计词频的入口类 <code>org.apache.spark.examples.JavaWordCount</code>，以此为例，向 Spark 集群提交 Java 应用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ spark-submit --master spark://master:7077 \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--name &quot;JavaWordCount&quot; \</span><br><span class="line">--executor-memory 1g \</span><br><span class="line">--class org.apache.spark.examples.JavaWordCount \</span><br><span class="line">/opt/bitnami/spark/examples/jars/spark-examples_2.12-3.1.2.jar /opt/share/words.txt</span><br></pre></td></tr></table></figure>

<p>注：<code>--deploy-mode</code> 参数决定了驱动器程序的运行位置。默认情况下，即客户端模式（client）下，<code>spark-submit</code> 会在本地（运行该命令的机器上）启动驱动器程序。如果指定为集群模式（cluster），驱动器程序将会运行在随机选取的一个工作节点上，此时即使 ctrl-c 中断 <code>spark-submit</code> 命令，也不会影响应用继续运行。因此，集群模式适用于需要长时间作业的应用。此外，Spark Standalone 目前不支持以集群模式运行 Python 应用（可以使用 YARN 集群来解决）。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://spark.apache.org/docs/3.1.2/submitting-applications.html">Spark 3.1.2 官方文档</a>: Currently, the standalone mode does not support cluster mode for Python applications.</p>
</blockquote>
<p>当通过集群模式运行上述命令时，驱动器程序 Driver 并不是运行主节点上，而是运行在 IP 为 <code>172.18.0.2</code> 的工作节点上：</p>
<p><img data-src="4.png" alt="9dbf3ac21791155581e6c3e71924002c.png"></p>
<h2 id="安装-Hadoop"><a href="#安装-Hadoop" class="headerlink" title="安装 Hadoop"></a>安装 Hadoop</h2><p>Hadoop 由分布式文件系统 HDFS、分布式计算框架 MapReduce 和资源管理框架 YARN 组成。MapReduce 是面向磁盘的，运行效率受到磁盘读写性能的约束，Spark 延续了 MapReduce 编程模型的设计思路，提出了面向内存的分布式计算框架，性能较之 MapReduce 有了 10～100 倍的提升。与此同时，Spark 框架还对 HDFS 做了很好的支持，并支持运行在 YARN 集群上。</p>
<blockquote>
<p>Spark uses Hadoop’s client libraries for HDFS and YARN. Downloads are pre-packaged for a handful of popular Hadoop versions.</p>
</blockquote>
<p>由于 Spark 使用了 Hadoop 的客户端依赖库，所以 Spark 安装包会指定依赖的 Hadoop 特定版本，如 spark-3.1.2-bin-hadoop3.2.tgz。而 bitnami/spark 镜像中只包含 Hadoop 客户端，并不包含服务器端。因此，如果需要使用 HDFS 和 YARN 功能，还需要部署 Hadoop 集群。</p>
<p>将 Hadoop 部署在 Spark 集群上，可以避免不必要的网络通信，并且面向磁盘的 HDFS 与面向内存的 Spark 天生互补。因此，考虑在 bitnami/spark 镜像基础上构建安装有 Hadoop 的新镜像。</p>
<h3 id="确定-Hadoop-版本"><a href="#确定-Hadoop-版本" class="headerlink" title="确定 Hadoop 版本"></a>确定 Hadoop 版本</h3><p>首先，需要确定 bitnami/spark 镜像所依赖的 Hadoop 版本。启动 pyspark 进行查看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pyspark</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc._gateway.jvm.org.apache.hadoop.util.VersionInfo.getVersion()</span><br><span class="line"><span class="string">&#x27;3.2.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 Hadoop 官网找到 Hadoop 3.2.0 安装包的<a target="_blank" rel="noopener" href="https://hadoop.apache.org/release/3.2.0.html">下载地址</a>，稍后在构建镜像时通过 <code>curl -OL</code> 命令下载此安装包。</p>
<h3 id="准备配置文件及启动脚本"><a href="#准备配置文件及启动脚本" class="headerlink" title="准备配置文件及启动脚本"></a>准备配置文件及启动脚本</h3><p>在工作目录下创建 config 文件夹，编写需要覆盖的 Hadoop 配置文件。完整的配置文件已经上传至 GitHub：<a target="_blank" rel="noopener" href="https://github.com/s1mplecc/spark-hadoop-docker">s1mplecc/spark-hadoop-docker</a>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ tree ~/docker/spark/config</span><br><span class="line">config</span><br><span class="line">├── core-site.xml</span><br><span class="line">├── hadoop-env.sh</span><br><span class="line">├── hdfs-site.xml</span><br><span class="line">├── mapred-site.xml</span><br><span class="line">├── workers</span><br><span class="line">└── yarn-site.xml</span><br></pre></td></tr></table></figure>

<p>注：其他详细配置请参考 Apache Hadoop 官方文档：<a target="_blank" rel="noopener" href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/ClusterSetup.html">Hadoop Cluster Setup</a>。</p>
<p>除了配置文件外，还需要编写 Hadoop 启动脚本。由于设置了 ssh 免密通信，首先需要启动 ssh 服务，然后依次启动 HDFS 和 YARN 集群。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">service ssh start</span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/sbin/start-dfs.sh</span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/sbin/start-yarn.sh</span><br></pre></td></tr></table></figure>

<h3 id="基于-bitnami-spark-构建新镜像"><a href="#基于-bitnami-spark-构建新镜像" class="headerlink" title="基于 bitnami/spark 构建新镜像"></a>基于 bitnami/spark 构建新镜像</h3><p>在工作目录下，创建用于构建新镜像的 Dockerfile。新镜像基于 <code>docker.io/bitnami/spark:3</code>，依次执行如下指令：</p>
<ul>
<li>设置 Hadoop 环境变量；</li>
<li>配置集群间 ssh 免密通信。此处直接将 ssh-keygen 工具生成的公钥写入 authorized_keys 文件中，由于容器集群基于同一个镜像创建的，因此集群的公钥都相同且 authorized_keys 为自己本身；</li>
<li>下载 Hadoop 3.2.0 安装包并解压；</li>
<li>创建 HDFS NameNode 和 DataNode 工作目录；</li>
<li>覆盖 <code>$HADOOP_CONF_DIR</code> 目录下的 Hadoop 配置文件；</li>
<li>拷贝 Hadoop 启动脚本并设置为可执行文件；</li>
<li>格式化 HDFS 文件系统。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> docker.io/bitnami/spark:<span class="number">3</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">&quot;s1mplecc &lt;s1mple951205@gmail.com&gt;&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">&quot;Docker image with Spark (3.1.2) and Hadoop (3.2.0), based on bitnami/spark:3. \</span></span></span><br><span class="line"><span class="string"><span class="bash">For more information, please visit https://github.com/s1mplecc/spark-hadoop-docker.&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> HADOOP_HOME=<span class="string">&quot;/opt/hadoop&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> HADOOP_CONF_DIR=<span class="string">&quot;$HADOOP_HOME/etc/hadoop&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> HADOOP_LOG_DIR=<span class="string">&quot;/var/log/hadoop&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;$HADOOP_HOME/hadoop/sbin:$HADOOP_HOME/bin:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y openssh-server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ssh-keygen -t rsa -f /root/.ssh/id_rsa -P <span class="string">&#x27;&#x27;</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">    cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -OL https://archive.apache.org/dist/hadoop/common/hadoop-3.2.0/hadoop-3.2.0.tar.gz</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xzvf hadoop-3.2.0.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="bash">  mv hadoop-3.2.0 hadoop &amp;&amp; \</span></span><br><span class="line"><span class="bash">  rm -rf hadoop-3.2.0.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="bash">  mkdir /var/<span class="built_in">log</span>/hadoop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /root/hdfs/namenode &amp;&amp; \ </span></span><br><span class="line">    mkdir -p /root/hdfs/datanode </span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> config/* /tmp/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv /tmp/ssh_config /root/.ssh/config &amp;&amp; \</span></span><br><span class="line"><span class="bash">    mv /tmp/hadoop-env.sh <span class="variable">$HADOOP_CONF_DIR</span>/hadoop-env.sh &amp;&amp; \</span></span><br><span class="line"><span class="bash">    mv /tmp/hdfs-site.xml <span class="variable">$HADOOP_CONF_DIR</span>/hdfs-site.xml &amp;&amp; \ </span></span><br><span class="line">    mv /tmp/core-site.xml $HADOOP_CONF_DIR/core-site.xml &amp;&amp; \</span><br><span class="line">    mv /tmp/mapred-site.xml $HADOOP_CONF_DIR/mapred-site.xml &amp;&amp; \</span><br><span class="line">    mv /tmp/yarn-site.xml $HADOOP_CONF_DIR/yarn-site.xml &amp;&amp; \</span><br><span class="line">    mv /tmp/workers $HADOOP_CONF_DIR/workers</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> start-hadoop.sh /opt/start-hadoop.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /opt/start-hadoop.sh &amp;&amp; \</span></span><br><span class="line"><span class="bash">    chmod +x <span class="variable">$HADOOP_HOME</span>/sbin/start-dfs.sh &amp;&amp; \</span></span><br><span class="line"><span class="bash">    chmod +x <span class="variable">$HADOOP_HOME</span>/sbin/start-yarn.sh </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> hdfs namenode -format</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">&quot;/opt/bitnami/scripts/spark/entrypoint.sh&quot;</span> ]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;/opt/bitnami/scripts/spark/run.sh&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>在工作目录下，执行如下命令构建镜像：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ docker build -t s1mplecc/spark-hadoop:3 .</span><br></pre></td></tr></table></figure>

<p>构建过程将按照 Dockerfile 中的指令依次进行。</p>
<p><img data-src="5.png" alt="fcf37dc09ce643cfbdda2b473ac6a194.png"></p>
<h3 id="启动-spark-hadoop-集群"><a href="#启动-spark-hadoop-集群" class="headerlink" title="启动 spark-hadoop 集群"></a>启动 spark-hadoop 集群</h3><p>构建镜像完成后，还需要修改 <code>docker-compose.yml</code> 文件，使其从新的镜像 <code>s1mplecc/spark-hadoop:3</code> 中启动容器集群，同时映射 Hadoop Web UI 端口。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">spark:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">s1mplecc/spark-hadoop:3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MODE=master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_AUTHENTICATION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_LOCAL_STORAGE_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_SSL_ENABLED=no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker/spark/share:/opt/share</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8080:8080&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;4040:4040&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8088:8088&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8042:8042&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;9870:9870&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;19888:19888&#x27;</span></span><br><span class="line">  <span class="attr">spark-worker-1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">s1mplecc/spark-hadoop:3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">worker1</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MODE=worker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MASTER_URL=spark://master:7077</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_MEMORY=1G</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_CORES=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_AUTHENTICATION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_LOCAL_STORAGE_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_SSL_ENABLED=no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker/spark/share:/opt/share</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8081:8081&#x27;</span></span><br><span class="line">  <span class="attr">spark-worker-2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">s1mplecc/spark-hadoop:3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">worker2</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MODE=worker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MASTER_URL=spark://master:7077</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_MEMORY=1G</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_CORES=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_AUTHENTICATION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_LOCAL_STORAGE_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_SSL_ENABLED=no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker/spark/share:/opt/share</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8082:8081&#x27;</span></span><br></pre></td></tr></table></figure>

<p>运行 <code>docker-compose</code> 启动命令重建集群，不需要停止或删除旧集群。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ docker-compose up -d                     </span><br><span class="line">[+] Running 0/3</span><br><span class="line"> ⠼ Container spark-spark-1           Recreate                                        6.4s</span><br><span class="line"> ⠼ Container spark-spark-worker-2-1  Recreate                                        6.4s</span><br><span class="line"> ⠼ Container spark-spark-worker-1-1  Recreate                                        6.4s</span><br></pre></td></tr></table></figure>

<p>启动容器集群后，进入 master 容器执行启动脚本：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ docker <span class="built_in">exec</span> -it a1 bash</span><br><span class="line">$ ./start-hadoop.sh </span><br><span class="line">Starting OpenBSD Secure Shell server: sshd.</span><br><span class="line">Starting namenodes on [master]</span><br><span class="line">Starting secondary namenodes [master]</span><br><span class="line">Starting resourcemanager</span><br><span class="line">Starting nodemanagers</span><br></pre></td></tr></table></figure>

<h3 id="向-HDFS-写入文件"><a href="#向-HDFS-写入文件" class="headerlink" title="向 HDFS 写入文件"></a>向 HDFS 写入文件</h3><p>使用命令将共享文件中的 words.txt 写入 HDFS：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop fs -put /opt/share/words.txt /</span><br><span class="line">$ hdfs dfs -ls /</span><br><span class="line">Found 1 items</span><br><span class="line">-rw-r--r--   2 root supergroup        440 2021-10-12 07:07 /words.txt</span><br></pre></td></tr></table></figure>

<p>写入的文件可以在 HDFS Web UI 上进行浏览：</p>
<p><img data-src="6.png" alt="48ba5d8dbcb460ec421762e24565dd47.png"></p>
<h3 id="Spark-访问-HDFS"><a href="#Spark-访问-HDFS" class="headerlink" title="Spark 访问 HDFS"></a>Spark 访问 HDFS</h3><p>现在，可以通过 Spark 访问 HDFS 了，访问 URI 为 <code>hdfs://master:9000</code>，这是配置在 core-site.xml 文件中的默认文件系统 fs.defaultFS。下面通过 PySpark 演示如何读取和存储 HDFS 上的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ pyspark</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = sc.textFile(<span class="string">&#x27;hdfs://master:9000/words.txt&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines.collect()</span><br><span class="line">[<span class="string">&#x27;Apache Spark is a unified analytics engine for large-scale data processing. It provides high-level APIs in Java, Scala, Python and R, and an optimized engine that supports general execution graphs. It also supports a rich set of higher-level tools including Spark SQL for SQL and structured data processing, MLlib for machine learning, GraphX for graph processing, and Structured Streaming for incremental computation and stream processing.&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words = lines.flatMap(<span class="keyword">lambda</span> x: x.split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words.saveAsTextFile(<span class="string">&#x27;hdfs://master:9000/split-words.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>HDFS 上的文件被读取为 RDD，在内存上进行 Transformation 后写入 HDFS。写入的文件被存储到 HDFS 的 DataNode 块分区上。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ hdfs dfs -ls /</span><br><span class="line">Found 2 items</span><br><span class="line">drwxr-xr-x   - root supergroup          0 2021-10-12 13:28 /split-words.txt</span><br><span class="line">-rw-r--r--   2 root supergroup        440 2021-10-12 13:24 /words.txt</span><br><span class="line">$ hdfs dfs -ls /split-words.txt</span><br><span class="line">Found 3 items</span><br><span class="line">-rw-r--r--   2 root supergroup          0 2021-10-12 13:28 /split-words.txt/_SUCCESS</span><br><span class="line">-rw-r--r--   2 root supergroup        441 2021-10-12 13:28 /split-words.txt/part-00000</span><br><span class="line">-rw-r--r--   2 root supergroup          0 2021-10-12 13:28 /split-words.txt/part-00001</span><br><span class="line">$ hdfs dfs -cat /split-words.txt/part-00000</span><br><span class="line">Apache</span><br><span class="line">Spark</span><br><span class="line">is</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="将-Spark-应用提交到-YARN-集群"><a href="#将-Spark-应用提交到-YARN-集群" class="headerlink" title="将 Spark 应用提交到 YARN 集群"></a>将 Spark 应用提交到 YARN 集群</h3><p>在运行 Hadoop 启动脚本时同时启动了 HDFS 和 YARN，现在可以将 Spark 应用提交到 YARN 集群上。默认使用 HDFS 文件系统，如需读取本地文件，还需要指定 <code>file://</code> 前缀。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ spark-submit --master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--name <span class="string">&quot;Word Count&quot;</span> \</span><br><span class="line">--executor-memory 1g \</span><br><span class="line">--class org.apache.spark.examples.JavaWordCount \</span><br><span class="line">/opt/bitnami/spark/examples/jars/spark-examples_2.12-3.1.2.jar /words.txt</span><br></pre></td></tr></table></figure>

<p>提交到 YARN 上的应用通过 ResourceManager Web UI 进行查看，默认端口 8088。</p>
<p><img data-src="7.png" alt="21f342e77ffb7f24b02ffced7a931548.png"></p>
<h2 id="Web-UI-汇总"><a href="#Web-UI-汇总" class="headerlink" title="Web UI 汇总"></a>Web UI 汇总</h2><table>
<thead>
<tr>
<th align="center">Web UI</th>
<th align="center">默认网址</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">* <strong>Spark Application</strong></td>
<td align="center"><a target="_blank" rel="noopener" href="http://localhost:4040/">http://localhost:4040</a></td>
<td align="center">由 SparkContext 启动，显示以本地或 Standalone 模式运行的 Spark 应用</td>
</tr>
<tr>
<td align="center">Spark Standalone Master</td>
<td align="center"><a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a></td>
<td align="center">显示集群状态，以及以 Standalone 模式提交的 Spark 应用</td>
</tr>
<tr>
<td align="center">* <strong>HDFS NameNode</strong></td>
<td align="center"><a target="_blank" rel="noopener" href="http://localhost:9870/">http://localhost:9870</a></td>
<td align="center">可浏览 HDFS 文件系统</td>
</tr>
<tr>
<td align="center">* <strong>YARN ResourceManager</strong></td>
<td align="center"><a target="_blank" rel="noopener" href="http://localhost:8088/">http://localhost:8088</a></td>
<td align="center">显示提交到 YARN 上的 Spark 应用</td>
</tr>
<tr>
<td align="center">YARN NodeManager</td>
<td align="center"><a target="_blank" rel="noopener" href="http://localhost:8042/">http://localhost:8042</a></td>
<td align="center">显示工作节点配置信息和运行时日志</td>
</tr>
<tr>
<td align="center">MapReduce Job History</td>
<td align="center"><a target="_blank" rel="noopener" href="http://localhost:19888/">http://localhost:19888</a></td>
<td align="center">MapReduce 历史任务</td>
</tr>
</tbody></table>
<p>注：星号标注的为较常用的 Web UI。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://sparkbyexamples.com/spark/spark-web-ui-understanding/">Spark Web UI – Understanding Spark Execution</a></li>
<li><a target="_blank" rel="noopener" href="https://sparkbyexamples.com/spark/spark-deploy-modes-client-vs-cluster/">Spark Deploy Modes – Client vs Cluster Explained</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/networking/">Docker 官方文档：Networking in Compose</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">Docker 官方文档：Dockerfile reference</a></li>
<li><a target="_blank" rel="noopener" href="https://hadoop.apache.org/docs/r3.2.2/hadoop-project-dist/hadoop-common/ClusterSetup.html#Web_Interfaces">Apache Hadoop 官方文档：Hadoop Cluster Setup</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/05/12/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/12/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Python 面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-12 10:51:28" itemprop="dateCreated datePublished" datetime="2021-05-12T10:51:28+08:00">2021-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><strong>面向对象程序设计</strong>（Object-oriented programming，缩写 OOP）是指一种程序设计范型，它强调一切行为都是基于<strong>对象</strong>（object）完成的，而对象则指的是<strong>类</strong>（class）的实例。对象被作为程序的基本单元，数据和行为方法封装在其中，以提高软件的重用性、灵活性和扩展性，对象的行为方法可以访问和修改对象的数据。通过对象之间的相互协作，完成复杂的程序功能。面向对象编程语言具备封装、抽象、继承、多态等特性。</p>
<p>封装，又称<strong>信息隐藏</strong>，是指利用抽象数据类型（ADT）将数据和基于数据的操作封装在一起，尽可能地隐藏内部细节，只暴露一些公共接口与外部发生交互。面向对象编程语言使用类进行封装，数据和基于数据的操作对应于类的属性和方法。</p>
<p>具备封装性的面向对象程序设计隐藏了方法的具体执行步骤，取而代之的是对象之间的消息传递。举个例子，假设一个“歌唱家”想要“唱歌”，她当然知道自己该如何发声，但其他人没有必要了解她发声的细节，只管欣赏她美妙的歌喉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 一个面向过程的程序会这样写： */</span><br><span class="line">定义莱丝</span><br><span class="line">莱丝.设置音调(5)</span><br><span class="line">莱丝.吸气()</span><br><span class="line">莱丝.吐气()</span><br><span class="line"></span><br><span class="line">/* 当唱歌方法被封装到类中，任何歌唱家都可以简单地使用： */</span><br><span class="line">定义歌唱家类</span><br><span class="line">声明莱丝是一个歌唱家</span><br><span class="line">莱丝.唱歌()</span><br></pre></td></tr></table></figure>

<h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><p>使用封装能够对成员属性和方法进行精确的访问控制，通常来说，成员会依照它们的访问权限被分为3种：公有成员、私有成员以及保护成员，保护成员是指可以被子类访问的成员。有的语言更进一步：Java 专门提供了 public、private、protected 和缺省四个级别的访问权限控制关键字。Python 则更提倡开放，尽管没有强制要求，但也建议程序员使用带有下划线的命名风格来规范属性和方法的访问权限。</p>
<p>在 Python 中，非下划线开头的属性称为公有属性，单下划线或双下划线开头的属性称为私有属性，双下划线开头的私有属性不会被子类可见，Python 社区很少提及受保护的属性。PEP 8 提倡<strong>对于非公有方法和属性使用单个下划线开头</strong>，只有在避免子类命名冲突时才采用双下划线开头，这是因为解释器会改写双下划线开头的属性，改写为类名 + 变量名的格式。比如下面代码中的 <code>__v3</code> 就被改写为 <code>_C__v3</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    v1 = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    _v2 = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    __v3 = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[_ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">dir</span>(C) <span class="keyword">if</span> <span class="string">&#x27;v&#x27;</span> <span class="keyword">in</span> _]</span><br><span class="line">[<span class="string">&#x27;_C__v3&#x27;</span>, <span class="string">&#x27;_v2&#x27;</span>, <span class="string">&#x27;v1&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>即便如此，Python 也不能严格保证私有属性不能被外部访问。子类之所以不能访问父类的双下划线开头的属性，只是因为改写后的属性名称不相符而已。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">C</span>):</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B._v2</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B._C__v3</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>对于私有属性，《Effective Python》也建议尽量少用双下划线开头的属性，宁可让子类更多地访问父类的单下划线开头的私有属性，也不要使用双下划线命名限制子类访问，并在文档中把这些属性的合理用法告知子类的开发者。</p>
<p>为什么 Python 不从语法上严格保证私有属性的私密性呢？因为 Python 社区认为开放要比封闭好。而且，Python 提供了一些操作属性的特殊方法，如 <code>__getattr__</code>，使得无法隔绝私有属性的访问，既然如此，那么就默认开发者遵循 Python 编码风格和规范，能够按需操作类内部的属性。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽象是解决问题的法宝。良好的抽象策略可以简化问题的复杂度，并且提高系统的通用性和可扩展性。在面向对象程序设计出现直接，面向过程的程序设计多是针对的过程抽象。所谓过程抽象是将问题域中具有明确功能定义的操作抽取出来，将其定义为函数。而面向对象程序设计针对的是数据抽象，是较过程抽象更高级别的抽象方式，通过将描述客体的属性和行为绑定在一起，实现统一的抽象，从而达到对现实世界客体的真正模拟。</p>
<p>类是具有相同属性（数据元素）和行为（功能）的对象的抽象。因此，对象的抽象是类，类的具体化就是对象，也可以说<strong>类是抽象数据类型，对象是类的实例</strong>。类具有属性，它是对象的状态的抽象，用数据结构来存储类的属性。类具有操作，它是对象的行为的抽象，用操作名和实现该操作的方法来描述。类的每一个实例对象都具有这些数据和操作方法。</p>
<p>抽象可以具有层次性，由类的继承结构所体现。高层次的抽象封装行为，为低层次的抽象提供签名，可以不实现具体细节，比如抽象基类或接口。低层次的抽象实现具体细节，提供对象实例化功能。通过抽象的层次性和结构性，可以减小问题求解的复杂度。</p>
<p>从 C++ 2.0 起（1989 年发布），这门语言开始使用抽象类指定接口。Java 的设计者选择不支持类的多重继承，这排除了使用抽象类作为接口规范的可能性，因为一个类通常会实现多个接口。但是，Java 设计者提供了 interface 这个语言结构，以更明确的方式定义接口，并允许一个类实现多个接口 —— 这是一种多重继承。自 Java 8 起，接口可以提供方法实现，即默认方法，使得 Java 中的接口与 C++ 和 Python 中的抽象基类更像了。但它们之间有个关键的区别：Java 的接口没有状态。Java 之后使用最广泛的 JVM 语言要数 Scala 了，它就实现了性状（trait）。不管怎么说，让我们先从抽象基类开始，了解 Python 中的高层次抽象类型。</p>
<h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>在引入抽象基类（Abstract base classes，缩写 ABC）之前，Python 就已经很成功了。Python 倡导使用<strong>鸭子类型和协议</strong>，忽略对象的真正类型，转而关注对象有没有实现所需的方法、签名和语义。这使得 Python 编码更加宽松，不需要严格的类型限制。因此抽象基类并不是 Python 的第一选择，大概也因为此，直至 Python 语言诞生 15 年后，Python 2.6 中才引入抽象基类。</p>
<p>但这并不意味着抽象基类一无是处，相反，它被广泛应用于 Java、C# 等面向对象语言中。抽象基类的常见用途是实现接口时作为基类使用，它与普通基类的区别在于：</p>
<ul>
<li>抽象基类不能实例化；</li>
<li>具体子类必须实现抽象基类的抽象方法。</li>
</ul>
<p>正是由于抽象基类限定了子类必须实现特定的方法，它被经常用于构建框架。你可以在 Python 标准库的 <code>collections.abc</code> 和 <code>numbers</code> 模块中见到抽象基类的身影。</p>
<p>Python 中定义抽象基类需要用到标准库提供的 <code>abc</code> 模块，该模块由 <a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-3119/">PEP 3119 – Introducing Abstract Base Classes</a> 提案所引入。它支持两种方式定义抽象基类，一种是使用 <code>abc.ABCMeta</code> 作为元类。声明元类的 <code>metaclass</code> 关键字参数是 Python 3 引入的，在此之前 Python 2 还得使用 <code>__metaclass__</code> 类属性。另一种是直接继承 <code>abc.ABC</code> 类，需要注意 ABC 的类型仍然是 ABCMeta。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, ABCMeta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(ABC)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">abc</span>.<span class="title">ABCMeta</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">class</span> <span class="title">MyABC</span>(<span class="params">metaclass=ABCMeta</span>):</span> </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br></pre></td></tr></table></figure>

<p>一般通过继承 <code>ABC</code> 来简单地创建抽象基类，当遇到可能会导致元类冲突的多重继承时，也可以使用 <code>ABCMeta</code> 作为元类来定义抽象基类。</p>
<p><code>abc</code> 模块还提供了用于声明<strong>抽象方法</strong>的装饰器 <code>@abstractmethod</code>。抽象方法定义体中通常只有文档字符串。在导入时，Python 不会检查抽象方法是否被实现，而是在实例化时检查。如果没有实现，将抛出 <code>TypeError</code> 异常提示无法实例化抽象类。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">... </span>    @abstractmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_method</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="string">&quot;&quot;&quot;My abstract method&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">MyABC</span>):</span> </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Can<span class="string">&#x27;t instantiate abstract class C with abstract methods my_abstract_method</span></span><br></pre></td></tr></table></figure>

<p>抽象方法可以有实现代码，但即便实现了，子类也必须覆盖抽象方法。通常这样做的目的是在子类中使用 <code>super()</code> 复用基类的方法，为它添加功能而不是从头实现。其实在抽象基类出现之前，抽象方法会抛出 <code>NotImplementedError</code> 异常，提示子类必须实现该抽象方法。</p>
<p>除了 <code>@abstractmethod</code> 之外，<code>abc</code> 模块还定义了 <code>@abstractclassmethod</code>、<code>@abstractstaticmethod</code> 和 <code>@abstractproperty</code> 装饰器，可用于装饰类方法、静态方法和特性。但自 Python 3.3 起这三个装饰器就被废弃了，因为可以使用装饰器堆叠达到同样的效果。在堆叠时，要保证 <code>@abstractmethod</code> 是最内层的装饰器，即最靠近函数定义体。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_classmethod</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_staticmethod</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_property</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @my_abstract_property.setter</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_property</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：PEP 3119 提案同时也引入并定义了集合类型的抽象基类，包括容器和迭代器类型，可以参考提案的 <a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-3119/#abcs-for-containers-and-iterators">ABCs for Containers and Iterators</a> 一节。这些集合类型被统一定义在 <code>collections.abc</code> 模块中。为了减少加载时间，Python 3.4 在 <code>collections</code> 包之外实现了这个模块，即 <code>_collections_abc.py</code>，所以在导入时要使用 <code>collections.abc</code> 与 <code>collections</code> 分开导入。</p>
<h3 id="注册虚拟子类"><a href="#注册虚拟子类" class="headerlink" title="注册虚拟子类"></a>注册虚拟子类</h3><p>Python 中的抽象基类还有一个重要的实用优势：可以使用 register 将某个类声明为一个抽象基类的“虚拟”子类，这样就不用显式继承。这打破了继承的强耦合，与面向对象编程的惯有知识有很大出入，因此在使用继承时要多加小心。</p>
<p>虚拟子类不会从抽象基类中继承任何方法和属性，但类型检查函数 <code>issubclass()</code> 和 <code>isinstance()</code> 都会通过。Python 不会检查虚拟子类是否符合抽象基类的接口，即便实例化时也不会检查，但会在调用时抛出异常。因此，为了避免运行时错误，虚拟子类要实现抽象基类的所有抽象方法。</p>
<p>注册虚拟子类的 <code>register()</code> 方法可以作为普通函数调用，也可以作为装饰器使用。如下定义的抽象基类 Drawable 中定义了一个抽象方法 draw，可以随机抽取一个元素。我们实现了一个扑克类 Poker，使用装饰器形式将 Poker 类注册为 Drawable 的虚拟子类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawable</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Random draw an item.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Drawable.register</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poker</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.suits = (<span class="string">&#x27;Spade&#x27;</span>, <span class="string">&#x27;Heart&#x27;</span>, <span class="string">&#x27;Diamond&#x27;</span>, <span class="string">&#x27;Club&#x27;</span>)</span><br><span class="line">        self.numbers = (*<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>), <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">52</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        suit = self.suits[random.randint(<span class="number">0</span>, <span class="number">3</span>)]</span><br><span class="line">        number = self.numbers[random.randint(<span class="number">0</span>, <span class="number">12</span>)]</span><br><span class="line">        <span class="keyword">return</span> suit, number</span><br></pre></td></tr></table></figure>

<p>使用 <code>@Drawable.register</code> 与直接调用方法的 <code>Drawable.register(Poker)</code> 效果相同，这样即使不用显式继承，Poker 类也会被解释器视为 Drawable 抽象基类的子类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>poker = Poker()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>poker.draw()</span><br><span class="line">(<span class="string">&#x27;Diamond&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(Poker, Drawable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(poker, Drawable)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>注册虚拟子类被广泛应用于 <code>collections.abc</code> 模块中，比如将内置类型 tuple、str、range 和 memoryview 注册为序列类型 Sequence 的虚拟子类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">tuple</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">str</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">range</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">memoryview</span>)</span><br></pre></td></tr></table></figure>

<h4 id="subclasshook-钩子方法"><a href="#subclasshook-钩子方法" class="headerlink" title="__subclasshook__ 钩子方法"></a><code>__subclasshook__</code> 钩子方法</h4><p>有时甚至不需要手动注册，抽象基类也能将一个类绑定为虚拟子类。比如 Poker 类会被绑定为 <code>collections.abc.Sized</code> 的虚拟子类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Sized</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(Poker, Sized)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这是由于 Sized 抽象基类内部实现了一个名为 <code>__subclasshook__</code> 的钩子方法。这个方法会去检查类中是否包含 <code>__len__</code> 方法，如果包含，那么类型检查 <code>issubclass()</code> 和 <code>isinstance()</code> 会返回 True。</p>
<p>同理，我们可以为 Drawable 类实现此钩子方法，方法的两个参数指代的均是类对象 <code>__class__</code>。这样即使不手动注册，实现了 draw 方法的扭蛋机类 Capsule 也会被判定为 Drawable 的子类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawable</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Random draw an item.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span>(<span class="params">cls, C</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Drawable:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;draw&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(C)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Capsule</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line"><span class="comment"># &gt;&gt;&gt; issubclass(Capsule, Drawable)</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>实际上，很少需要为自己编写的抽象基类实现 <code>__subclasshook__</code> 方法，虽然这符合 Python 对于“鸭子类型”的定义，但这样做可靠性很低。好比说，不能指望任何实现了 draw 方法的类都是 Drawable 类型（可随机抽取元素），因为 draw 可能还指代其他语义，比如画图。</p>
<p>类型检查函数 <code>issubclass()</code> 和 <code>isinstance()</code> 之所以会返回 True，是由于定义在 ABCMeta 类中的 <code>__subclasscheck__</code>  和 <code>__instancecheck__</code> 特殊方法会覆盖其行为。在 ABCMeta 的构造方法中定义了一些 WeakSet 类型的类属性：<code>_abc_registry</code>、<code>_abc_cache</code> 和 <code>_abc_negative_cache</code>，它们会动态的存放抽象基类的虚拟子类（类型检查时会动态添加）。可以通过调试接口 <code>_dump_registry()</code> 查看一个抽象基类的虚拟子类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Drawable._dump_registry()</span><br><span class="line">Class: __main__.Drawable</span><br><span class="line">Inv. counter: <span class="number">45</span></span><br><span class="line">_abc_registry: <span class="built_in">set</span>()</span><br><span class="line">_abc_cache: &#123;&lt;weakref at <span class="number">0x10b0e5220</span>; to <span class="string">&#x27;type&#x27;</span> at <span class="number">0x7f9c88f3e380</span> (Poker)&gt;, &lt;weakref at <span class="number">0x10b0fe9a0</span>; to <span class="string">&#x27;type&#x27;</span> at <span class="number">0x7f9c88cb0dc0</span> (Capsule)&gt;&#125;</span><br><span class="line">_abc_negative_cache: <span class="built_in">set</span>()</span><br><span class="line">_abc_negative_cache_version: <span class="number">45</span></span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：ABCMeta 类的 Python 源码可以在 <code>_py_abc</code> 模块中查看。CPython 提供了一套基于 C 语言的更高效实现，仅在其导入失败时，才导入 <code>_py_abc</code> 模块中的 ABCMeta。</p>
<h4 id="白鹅类型"><a href="#白鹅类型" class="headerlink" title="白鹅类型"></a>白鹅类型</h4><p>最早提出“鸭子类型”的 Alex Martelli 建议在鸭子类型的基础上添加“白鹅类型”。白鹅类型是指，只要 cls 是抽象基类，即 cls 的元类是 <code>abc.ABCMeta</code>，就可以使用 <code>isinstance(obj, cls)</code>。事实上，虚拟子类就是一种白鹅类型，当我们向抽象基类注册一个虚拟子类时，ABCMeta 会将该类保存在抽象基类的类属性中，以供类型检查使用。</p>
<p>虚拟子类是抽象基类动态性的体现，也是符合 Python 风格的方式。它允许我们动态地改变类的属别关系。抽象基类定义了一系列方法，并给出了方法应当实现的功能，在这一层次上，“白鹅类型”能够对类型进行甄别。当一个类继承自抽象基类时，语言本身限制了该类必须完成抽象基类定义的语义；当一个类注册为虚拟子类时，限制则来自于编写者自身（成年人）。两种类都能通过“白鹅类型”的校验，不过虚拟子类提供了更好的灵活性与扩展性。例如，一个框架允许第三方插件时，采用虚拟子类即可以明晰接口，又不会影响内部的实现。</p>
<h3 id="自定义的抽象基类"><a href="#自定义的抽象基类" class="headerlink" title="自定义的抽象基类"></a>自定义的抽象基类</h3><p>在各类编程语言中，基础的数据结构都必不可少，比如链表、堆栈、集合等，对于这些数据结构，语言会对它们进行抽象，定义接口并设计一套继承体系。Java 将这些数据结构统称为容器（意指用于容纳数据），从最底层的 List、Set、Map 等接口，到 AbstractList、AbstractSet、AbstractMap 等抽象类，再到最上层的 ArrayList、HashSet、HashMap 等具体实现类，越靠近上层的类方法越丰富，但底层的接口和抽象类是框架的骨架，构成了整个容器框架。同时，接口和抽象类也是体现 Java 语言多态性（向上转型）的重要设计。</p>
<p>Python 的容器抽象基类定义在 <code>collections.abc</code> 模块中，其 UML 类图如下所示：</p>
<p><img data-src="uml.png" alt="162525d70561a8d42f3e5007ef176c0c.png"></p>
<p>下面我们尝试使用 Python 中的抽象基类实现一个自定义的容器类型。为了简化，这个容器类型仅支持新增 <code>push()</code> 和删除 <code>pop()</code> 两个操作。由于不同子类的具体实现不同，比如栈是先进后出，队列是先进先出，所以这两个方法被定义为抽象方法。此外还提供了检视容器元素的 <code>inspect()</code> 方法，由于实现逻辑相同，因此 <code>inspect()</code> 可以是具体方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, iterable=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> iterable:</span><br><span class="line">            self._items = <span class="built_in">list</span>(iterable)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._items = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Remove and return item. Raises IndexError if container is empty.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Add item.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._items</span><br></pre></td></tr></table></figure>

<p>可以看到，抽象基类既可以拥有抽象方法，也可以拥有具体方法。代码中的初始化方法 <code>__init__</code> 和 <code>inspect()</code> 方法都是具体方法，但子类依然可以覆盖具体方法，或者使用 <code>super()</code> 调用它们进行功能增强。</p>
<h3 id="自定义的抽象基类的子类"><a href="#自定义的抽象基类的子类" class="headerlink" title="自定义的抽象基类的子类"></a>自定义的抽象基类的子类</h3><p>接下来我们实现 Container 抽象基类的两个具体子类：栈和队列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params">Container</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(self._items):</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;Stack is empty.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._items.pop()  <span class="comment"># remove last item</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self._items.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params">Container</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(self._items):</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;Queue is empty.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._items.pop(<span class="number">0</span>)  <span class="comment"># remove first item</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self._items.append(item)</span><br></pre></td></tr></table></figure>

<p>由于具体子类继承自抽象基类 Container，所以在类声明时必须明确指定类扩展自 Container 类。并且覆盖抽象基类中的两个抽象方法。栈和队列的 <code>pop()</code> 行为不同，栈满足先进后出，而队列满足先进先出，并在容器为空时均抛出 IndexError 异常。接下来验证栈和队列的特性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack = Stack([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.push(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.inspect()</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue = Queue([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.push(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.pop()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.inspect()</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="何时使用抽象基类"><a href="#何时使用抽象基类" class="headerlink" title="何时使用抽象基类"></a>何时使用抽象基类</h3><p>对于简单的个人应用，优先使用现有的抽象基类，而不是自己编写抽象基类，因为这很容易造成过度设计。毕竟对于 Python 来说，“简单”永远是这门语言的核心，滥用抽象基类会造成灾难性后果，太注重语言的表面形式对于以实用和务实著称的 Python 可不是好事。</p>
<p>抽象基类可以约束各个子类实现相同的一套 API。除此之外，抽象基类的一个用途是运行时的类型检查，可以使用 <code>isinstance()</code> 检查某个对象是否是抽象基类的子类型，即是否实现了特定的接口。这便于我们对于不同的情形进行分支处理或异常捕获。</p>
<p>尽管抽象基类使得类型检查变得更容易了，但也不该过度使用它。Python 的核心在于它是一门动态语言，如果处处都强制实现类型约束，那么会使代码变得复杂且丑陋。我们应该拥抱 Python 的灵活性。</p>
<p>因此对于抽象基类的使用，要着重声明：除非构建的是允许用户扩展的框架，否则不要轻易定义抽象基类。日常使用中，我们与抽象基类的联系应该是创建现有抽象基类的子类。当你拥有像创建新的抽象基类的想法时，首先尝试使用常规的鸭子类型来解决问题。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象编程语言的一个重要功能就是“继承”，它可以使得在现有类的基础上，无需编写重复代码就可以实现功能的扩展。继承体现了从一般到特殊的过程。</p>
<p>通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。在某些面向对象语言中，一个子类可以继承自多个父类，这称为多重继承。Python 是一门支持多重继承的语言。</p>
<p>Python 的继承句法是，在类声明的括号中添加父类名，如 <code>class C(Base):</code> 声明了类 C 继承自基类 Base。当声明多重继承时，使用逗号隔开，如 <code>class C(BaseA，BaseB):</code>。</p>
<p>子类会继承父类的非私有属性和方法，包括类属性。这里的私有属性是指以双下划线开头且不以双下划线结尾命名的属性，由于 Python 的名称改写机制，这类私有属性将会被改写为“类名 + 属性名”的格式，所以不能被子类通过原有名称访问。</p>
<p>如下，B 类派生自 A 类，继承了 A 类的所有非私有属性和方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">... </span>    attr1 = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.attr2 = <span class="number">2</span> </span><br><span class="line"><span class="meta">... </span>        self._attr3 = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>        self.__attr4 = <span class="number">4</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span> </span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;class A method&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = B()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.attr1</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.attr2</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b._attr3</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__attr4</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;B&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__attr4&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.method()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">method</span></span></span><br></pre></td></tr></table></figure>

<p>子类可以覆盖父类的属性和方法，或者使用 <code>super()</code> 调用父类方法，在原有方法基础上添加新功能。<code>super()</code> 的一个重要用途是用于初始化方法 <code>__init__</code> 中。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line"><span class="meta">... </span>    attr1 = <span class="string">&#x27;b1&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">super</span>().__init__()</span><br><span class="line"><span class="meta">... </span>        self.attr5 = <span class="number">5</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">super</span>().method()</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;class B method&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = B()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.attr1</span><br><span class="line"><span class="string">&#x27;b1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;attr2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;_attr3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;_A__attr4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;attr5&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.method()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">method</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span> <span class="title">method</span></span></span><br></pre></td></tr></table></figure>

<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>Python 支持多重继承。人们对于多重继承褒贬不一，C++ 中对于多重继承的滥用一直饱受诟病，借鉴自 C++ 的 Java 选择直接移除了多重继承特性，采用接口（Interface）作为代替，并取得了巨大的成功。事实证明，接口是一种更加优雅的多重继承解决方案。</p>
<p>多重继承首先要解决的问题就是潜在的<strong>命名冲突</strong>，如果一个类继承自两个不相关的类，这两个类拥有实现不同的同名方法，那么该调用哪一个？这种冲突被称为“菱形问题”。为了解决这个问题，Python 会按照特定的顺序遍历继承图。这个顺序称为<strong>方法解析顺序</strong>（Method Resolution Order，缩写 MRO）。<strong>类有一个名为 <code>__mro__</code> 的类属性，它的值是一个元组，按照方法解析顺序存放各个超类的名称</strong>。</p>
<h4 id="mro-方法解析顺序"><a href="#mro-方法解析顺序" class="headerlink" title="__mro__ 方法解析顺序"></a><code>__mro__</code> 方法解析顺序</h4><p>我们定义一个继承结构，类 D 继承自类 B 和 C，而类 B 和 C 又都继承自类 A。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class A:&#x27;</span>, self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class B:&#x27;</span>, self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class C:&#x27;</span>, self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B, C</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>从继承结构上来看，这是一个菱形结构，会存在调用同名方法的二义性。那么，调用 D 实例的 <code>speak()</code> 方法会去调用哪个父类呢？</p>
<p>答案是会调用 B 的 <code>speak()</code> 方法。D 类的 <code>__mro__</code> 属性如下，访问 D 的方法，会按照 <code>D -&gt; B -&gt; C -&gt; A</code> 的顺序进行解析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = D()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.speak()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> &lt;multiple_inheritance.D <span class="built_in">object</span> at <span class="number">0x1086a6580</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D.__mro__</span><br><span class="line">(&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">multiple_inheritance</span>.<span class="title">D</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">multiple_inheritance</span>.<span class="title">B</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">multiple_inheritance</span>.<span class="title">C</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">multiple_inheritance</span>.<span class="title">A</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：方法解析顺序不会列出虚拟子类的被注册超类。因此虚拟子类也不会从被注册超类中继承任何方法。</p>
<h4 id="super-调用链"><a href="#super-调用链" class="headerlink" title="super() 调用链"></a><code>super()</code> 调用链</h4><p>在使用 <code>super()</code> 调用父类方法时，也遵循方法解析顺序。如果父类中的方法也包含 <code>super()</code> 语句，则按照方法解析顺序调用下一个父类的方法（下一个父类可能不是当前父类的直接父类）。比如如下添加了 <code>super()</code> 语句的 <code>speak()</code> 方法打印如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class A:&#x27;</span>, self)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().speak()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class B:&#x27;</span>, self)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().speak()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class C:&#x27;</span>, self)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B, C</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().speak()</span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D().speak()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> &lt;__main__.D <span class="built_in">object</span> at <span class="number">0x10edc8b80</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> &lt;__main__.D <span class="built_in">object</span> at <span class="number">0x10edc8b80</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> &lt;__main__.D <span class="built_in">object</span> at <span class="number">0x10edc8b80</span>&gt;</span><br></pre></td></tr></table></figure>

<p>按照 <code>D -&gt; B -&gt; C -&gt; A</code> 的方法解析顺序，D 中的 <code>super()</code> 方法跳转到 B，B 中的 <code>super()</code> 方法跳转到 C（而不是 B 的直接父类 A），C 中的 <code>super()</code> 方法再跳转到 A。由于 <code>super()</code> 语句在 print 语句之前，最终呈现出的打印顺序是方法解析顺序的出栈顺序。</p>
<h4 id="方法解析顺序的单调性"><a href="#方法解析顺序的单调性" class="headerlink" title="方法解析顺序的单调性"></a>方法解析顺序的单调性</h4><p>方法解析顺序不仅考虑继承图，还考虑子类声明中所列的超类顺序。如果 D 类声明为 <code>class D(B, C):</code>，那么 D 类一定会先于 B、C 类被搜索，且 B 类一定先于 C 类被搜索。我们将这种 <code>D -&gt; B -&gt; C</code> 的顺序称为<strong>方法解析顺序的单调性</strong>。 用户在定义继承关系时必须要遵循单调性原则。</p>
<p>Python 方法解析顺序采用的 C3 算法会检查方法解析顺序的单调性。简单地说，C3 算法的基本逻辑是，每定义好一个继承关系顺序，算法会将所有顺序按照满足单调性的方式整合起来，如果整合过程出现冲突，算法会抛出错误。</p>
<p>如下所示，由于定义 B 类时声明为 <code>class B(A):</code>，所以 B 的解析顺序要先于 A，然而在使用 <code>class C(A, B):</code> 声明 C 类时，A 的解析顺序又先于 B，因此发生冲突，抛出异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Cannot create a consistent method resolution</span><br><span class="line">order (MRO) <span class="keyword">for</span> bases A, B</span><br></pre></td></tr></table></figure>

<p>在 Python 标准库中，最常使用多重继承的是 <code>collections.abc</code> 模块，其中的类都定义为抽象基类。抽象基类类似于 Java 中的接口声明，只不过它可以提供具体方法。因此在 <code>collections.abc</code> 模块中频繁使用多重继承并没有问题，它为 Python 的集合类型构建了一个继承体系。然而，滥用多重继承容易得到令人费解和脆弱的设计。《Effective Python》中也提到：只在使用混入时才使用多重继承。为此，有必要先介绍一下混入类。</p>
<h3 id="混入类"><a href="#混入类" class="headerlink" title="混入类"></a>混入类</h3><p>除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，那就是<strong>混入</strong>（mixin），这在 Scala 和 JavaScript 使用颇多。如果一个类的作用是为多个不相关的子类提供方法实现，从而实现重用，但不体现 “is-a” 语义，应该把这个类明确定义为混入类。从概念上讲，混入不定义新类型，只是打包方法，便于重用。因此，<strong>混入类绝对不能实例化，而且具体类不能只继承混入类</strong>。</p>
<p>Python 没有提供定义混入类的专有关键字，而是推荐在名称末尾加上 “Mixin” 后缀。而在 Scala 中，使用 trait（特性）关键字来声明混入类，TypeScript 中则使用 implements 关键字来继承混入类。</p>
<p>抽象基类可以实现具体方法，因此也可以作为混入使用。<code>collections.abc</code> 模块中的抽象基类在一定程度上可以被视为混入类，它们都声明了 <code>__slots__ = ()</code> 语句，表明了混入类不能具有实例属性，即混入类不能被实例化。但是，抽象基类可以定义某个抽象类型，而混入做不到，因此，抽象基类可以作为其他类的唯一基类，而混入绝不能作为唯一超类。但是，抽象基类有个局限是混入类没有的，即：抽象基类中提供具体实现的抽象方法只能与抽象基类及其超类中的方法协作。</p>
<p>一些三方库和框架中也有用到混入，比如 Django 框架，我截取了 <a target="_blank" rel="noopener" href="https://github.com/django/django/blob/main/django/views/generic/base.py">Django 视图模块</a>的一小部分源码，以便更好的理解混入类与多重继承的关系。</p>
<h4 id="Django-源码"><a href="#Django-源码" class="headerlink" title="Django 源码"></a>Django 源码</h4><p>在 Django 中，视图是可调用对象，它的参数是表示 HTTP 请求的对象，返回值是一个表示 HTTP 响应的对象。我们要关注的是这些响应对象。响应可以是简单的重定向，没有主体内容，为我们导向另一个 url，也可以是复杂的网页内容，需要使用 HTML 模版渲染，最终呈现在浏览器终端上。为此，Django 框架提供了重定向视图 RedirectView，以及模版视图 TemplateView。</p>
<p>我们将注意力放在 TemplateView 类上，它继承自三个类，从左到右分别是模版响应混入类 TemplateResponseMixin、上下文混入类 ContextMixin，以及视图基类 View。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateView</span>(<span class="params">TemplateResponseMixin, ContextMixin, View</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Render a template. Pass keyword arguments from the URLconf to the context.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span> </span><br><span class="line">        context = self.get_context_data(**kwargs)</span><br><span class="line">        <span class="keyword">return</span> self.render_to_response(context)</span><br></pre></td></tr></table></figure>

<p>从类型上来说，TemplateView 依然是一个视图类型。View 是所有视图的基类，提供核心功能，如 dispatch 方法。RedirectView 由于不需要渲染，所以只继承了 View 类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Intentionally simple parent class for all views. Only implements</span></span><br><span class="line"><span class="string">    dispatch-by-method and simple sanity checking.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    http_method_names = [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>, <span class="string">&#x27;trace&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, **kwargs</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">as_view</span>(<span class="params">cls, **initkwargs</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self, request, *args, **kwargs</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">http_method_not_allowed</span>(<span class="params">self, request, *args, **kwargs</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">options</span>(<span class="params">self, request, *args, **kwargs</span>):</span> ...</span><br></pre></td></tr></table></figure>

<p>两个混入类 TemplateResponseMixin 和 ContextMixin 并不代表某一特定类型，而是打包了若干属性和方法，此类方法又不是 RedirectView 所需要的，因此不能定义在 View 基类中。TemplateResponseMixin 提供的功能只针对需要使用模版的视图，除了 TemplateView 还提供给其他视图，例如用于渲染列表的 ListView 视图以及默认视图 DetailView 等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateResponseMixin</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A mixin that can be used to render a template.&quot;&quot;&quot;</span></span><br><span class="line">    template_name = <span class="literal">None</span></span><br><span class="line">    template_engine = <span class="literal">None</span></span><br><span class="line">    response_class = TemplateResponse</span><br><span class="line">    content_type = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render_to_response</span>(<span class="params">self, context, **response_kwargs</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_template_names</span>(<span class="params">self</span>):</span> ...</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextMixin</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A default context mixin that passes the keyword arguments received by</span></span><br><span class="line"><span class="string">    get_context_data() as the template context.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    extra_context = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context_data</span>(<span class="params">self, **kwargs</span>):</span> ...</span><br></pre></td></tr></table></figure>

<p>Django 基于类的视图 API 是多重继承的一个优雅示例，尤其是 Django 的混入类易于理解：各个混入类的目的明确，且都以 “Mixin” 作为后缀。</p>
<h3 id="继承的最佳实践"><a href="#继承的最佳实践" class="headerlink" title="继承的最佳实践"></a>继承的最佳实践</h3><p><strong>明确使用继承的目的</strong>：在决定使用继承之前，首先明确这么做的目的。如果是为了继承重用代码，那么组合和委托也可以达到相同效果。《设计模式：可复用面向对象软件的基础》一书中明确指出：“<strong>优先使用对象组合，而不是类继承</strong>”。组合体现的是 “has-a” 语义，与继承相比，组合的耦合性更低，可扩展性更高。继承并不是银弹，继承意味着父类与子类的强耦合性，一旦父类接口发生变化，所有子类都会受到影响。如果继承用错了场合，那么后期的维护可能是灾难性的。但如果目的是继承接口，创建子类型，实现 “is-a” 关系，那么使用继承是合适的。<strong>接口继承是框架的支柱</strong>，如果类的作用是定义接口，就应该明确定义为抽象基类，就像 <code>collections.abc</code> 模块所做的那样。</p>
<p><strong>不要继承多个具体类</strong>：最多只有一个具体父类，也可以没有。也就是说，除了这一个具体父类之外，其余都是抽象基类或混入。并且，如果抽象基类或混入的组合被经常使用，那么就可以考虑定义一个聚合类，使用易于理解的方式将他们结合起来，就如同 <code>collections.abc</code> 模块中定义的 Collection 类：<code>class Collection(Sized, Iterable, Container):</code>。</p>
<p><strong>只在使用混入时才使用多重继承</strong>：这比上一条要更加严苛，尽管抽象基类有时可被视为混入类。不管怎么说，如果不是开发框架，尽量避免使用多重继承，如果不得不用多重继承，请使用混入类。混入类不会破坏现有的继承结构树，它就像小型的可插拔的扩展接口坞，目的不是声明 “is-a” 关系，而是为子类扩展特定功能。所以有时也将混入类称为混入组件。</p>
<p><strong>在声明多重继承自混入类和基类时，先声明混入类，最后声明基类</strong>：这是由于，在定义混入类时使用 <code>super()</code> 是普遍的。为了保证继承自混入类和基类的子类，在调用方法时会执行基类的同名方法，需要先声明混入类再声明基类。这样，按照方法解析顺序的单调性，混入类中的 <code>super()</code> 方法会调用到基类中的方法。</p>
<p>如下定义了一个属性只能赋值一次的字典，为其属性赋值时，按照方法解析顺序，会先调用混入类的 <code>__setitem__</code> 方法，执行到 <code>super()</code> 语句，调用基类 UserDict 的 <code>__setitem__</code> 方法进行设值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> UserDict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetOnceMappingMixin</span>:</span></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="built_in">str</span>(key) + <span class="string">&#x27; already set&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__setitem__(key, value)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetOnceDefaultDict</span>(<span class="params">SetOnceMappingMixin, UserDict</span>):</span> ...</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>collections</code> 模块子类化内置类型</strong>：内置类型的原生方法使用 C 语言实现，不会调用子类中覆盖的方法。比如，如下 DoubleDict 中定义的 <code>__setitem__</code> 方法并不会覆盖初始化方法 <code>__init__</code> 中的设值方法。因此，需要定制 list、dict 或 str 类型时，应该使用 <code>collections</code> 模块中的 UserList、UserDict 或 UserString 等。这些类是对内置类型的包装，会把操作委托给内置类型 —— 这是标准库中优先选择组合而不是继承的又一例证。如果所需的行为与内置类型区别很大，那么子类化 <code>collections.abc</code> 中的抽象基类自己实现或许更加容易。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DoubleDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">super</span>().__setitem__(key, value * <span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = DoubleDict(a=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> UserDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DoppelDict</span>(<span class="params">UserDict</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">super</span>().__setitem__(key, value * <span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = DoppelDict(a=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/04/26/Python-%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/Python-%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6/" class="post-title-link" itemprop="url">Python 属性、特性和描述符</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-26 11:18:39" itemprop="dateCreated datePublished" datetime="2021-04-26T11:18:39+08:00">2021-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><p>在 Python 中，数据属性和处理数据的方法统称为属性（attribute），方法也可称为方法属性，本质上是可调用的（callable）属性。Python 提供了丰富的 API 用于控制访问属性，以及实现动态属性。即使访问不存在的属性，也可以通过特殊方法实现“虚拟属性”，从而即时计算属性的值。</p>
<h3 id="处理属性的特殊属性"><a href="#处理属性的特殊属性" class="headerlink" title="处理属性的特殊属性"></a>处理属性的特殊属性</h3><p>为了方便处理属性，Python 定义了一些特殊属性，包括：</p>
<ul>
<li><code>__class__</code>：对象所属类的引用。<code>obj.__class__</code> 与 <code>type(obj)</code> 效果一致。类和类的实例都具有属性，有些属性只能在类中查询，比如特殊方法；</li>
<li><code>__dict__</code>：存储类或实例的可写属性的字典。如果设置了 <code>__slots__</code> 属性，实例可能没有 <code>__dict__</code> 属性；</li>
<li><code>__slots__</code>：类可以定义这个属性，限制实例能拥有哪些属性。该属性的值可以是个可迭代对象，但通常会使用元组。如果类设置了 <code>__slots__</code> 属性且 <code>__slots__</code> 中不包含 <code>&#39;__dict__&#39;</code>，那么该类的实例没有 <code>__dict__</code> 属性。</li>
</ul>
<h4 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a><code>__dict__</code></h4><p>默认情况下，Python 会使用名为 <code>__dict__</code> 的字典存储类和实例中的可写属性。其中，<strong>类属性字典</strong>由名为 <code>mappingproxy</code> 的代理对象包装，<code>mappingproxy</code> 定义在 <code>collections.abc</code> 模块中，特别指代类属性字典的类型：<code>mappingproxy = type(type.__dict__)</code>。类属性字典包含显式定义在类中的字段和方法，以及一些可写的特殊属性，包括模块、字典、弱引用和文档字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.b = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, </span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function Foo.__init__ at <span class="number">0x1051fe8b0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;Foo&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;Foo&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>类属性不仅限于类字典中所展示的，还包含一些不可变的类属性，比如所属类的引用 <code>__class__</code>，直接父类组成的元组 <code>__bases__</code> 等。</p>
<p><strong>实例属性字典</strong>则是普通的字典类型，为实例属性赋值，会动态的修改实例字典。如果属性不存在，则将其添加到字典中，包括在初始化方法 <code>__init__</code> 中赋值的实例属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.c = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h4><p>Python 解释器会默认在类的构造方法 <code>__new__</code> 中创建 <code>__dict__</code> 存放实例属性，在访问时通过访问实例字典读取属性值。由于字典底层使用了散列表结构，对属性的存取会相当迅速。但同时，为了减少散列冲突，散列表的大小通常要远大于键的数量，这种基于空间换时间的考量会导致字典会消耗大量内存。为此，Python 提供了 <code>__slots__</code> 属性，该属性会覆盖 <code>__dict__</code> 属性，<strong>使用类似元组的结构存储实例变量</strong>，从而达到节省内存的目的。</p>
<p>我沿用之前定义的 Person 类做了测试，它包含 name 和 age 两个实例属性。使用列表推导生成一百万个 Person 对象，分别对默认使用 <code>__dict__</code> 和添加了 <code>__slots__</code> 属性的内存占用情况进行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ time python3 slots.py --use-dict </span><br><span class="line">Initial RAM Usage:    5,472,256</span><br><span class="line">  Final RAM Usage:  186,380,288</span><br><span class="line">python3 slots.py --use-dict  1.11s user 0.07s system 99% cpu 1.187 total</span><br><span class="line">➜ time python3 slots.py --use-slots</span><br><span class="line">Initial RAM Usage:    5,476,352</span><br><span class="line">  Final RAM Usage:   76,369,920</span><br><span class="line">python3 slots.py --use-slots  0.74s user 0.04s system 99% cpu 0.788 total</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>__slots__</code> 后内存占用得到显著优化，只占了使用 <code>__dict__</code> 的一半不到，运行速度也更快。</p>
<p><strong>定义 <code>__slots__</code> 的方式</strong>是，创建一个名为 <code>__slots__</code> 的类属性，把它的值设为一个字符串构成的可迭代对象（通常使用元组），其中的元素名称代表实例属性，比如<code>__slots__ = (&#39;name&#39;, &#39;age&#39;)</code>。定义 <code>__slots__</code> 属性相当于告诉解释器：这个类的所有实例属性都在这儿了。<strong>实例不能再有 <code>__slots__</code> 所列之外的其他属性</strong>。但应该明白，<code>__slots__</code> 并不是用来禁止类的用户新增实例属性的手段，而只是一种内存优化方案。</p>
<p>如果你阅读 <code>collections.abc</code> 模块的源码，会发现其中的类都存在一行 <code>__slots__ = ()</code> 代码。即使这些类没有实例属性，使用空元组定义的 <code>__slots__</code> 属性可以避免类的构造方法创建 <code>__dict__</code> 空字典，空字典也会在堆上分配内存空间。对于集合这种基本数据类型，有必要为其声明空元组形式的 <code>__slots__</code> 属性。此外，对于模式固定的数据库记录，以及特大型数据集，也有必要声明 <code>__slots__</code> 属性。</p>
<p>上面介绍的这些特殊属性，在一些访问和处理属性的内置函数和特殊方法中会被使用。下面列出这些函数和方法。</p>
<h3 id="处理属性的内置函数"><a href="#处理属性的内置函数" class="headerlink" title="处理属性的内置函数"></a>处理属性的内置函数</h3><p><code>dir([object])</code>：列出对象的大多数属性。object 参数是可选的，缺省时会列出当前模块的属性。dir 函数能够审查对象有没有 <code>__dict__</code> 和 <code>__slots__</code> 属性，并列出其中的键。</p>
<p><code>getattr(object, name[, default])</code>：从对象中读取属性值。获取的属性可能来自对象所属的类或超类。如果没有找到指定属性，则抛出 AttributeError 异常，或返回预设默认值。</p>
<p><code>hasattr(object, name)</code>：会调用 getattr 函数查看能否获取指定的属性，当抛出 AttributeError 异常时返回 False。</p>
<p><code>setattr(object, name, value)</code>：为对象指定的属性设值。这个函数可能会创建一个新属性，或者覆盖现有的属性。前提是对象能够接受这个值，比如设定了 <code>__slots__</code> 的对象不能添加新属性。</p>
<p><code>vars([object])</code>：返回对象的 <code>__dict__</code> 属性，参数缺省时返回当前模块的 <code>__dict__</code> 属性。vars 函数不能处理设定了 <code>__slots__</code> 属性的对象。</p>
<h3 id="处理属性的特殊方法"><a href="#处理属性的特殊方法" class="headerlink" title="处理属性的特殊方法"></a>处理属性的特殊方法</h3><p><code>__getattribute__(self, name)</code>：除了访问特殊属性和特殊方法，尝试获取指定的属性时总会调用这个方法。dot 运算符、<code>getattr</code> 和 <code>hasattr</code> 会调用这个方法。该方法内部定义了属性访问规则，当未找到指定属性时抛出 AttributeError 异常，<code>__getattr__</code> 方法会被调用。</p>
<p><code>__getattr__(self, name)</code>：仅当获取指定属性失败时，即处理不存在的属性时被调用。用户自定义的类可以实现 <code>__getattr__</code> 方法从而动态计算属性的值。</p>
<p><code>__setattr__(self, name, value)</code>：尝试为指定属性设值时总会调用该方法。dot 运算符和 <code>setattr</code> 会调用这个方法。该方法内部定义了属性设值规则。</p>
<p><code>__delattr__(self, name)</code>：使用 del 关键字删除属性时会调用这个方法。</p>
<p><code>__dir__(self)</code>：内置函数 <code>dir()</code> 会调用这个方法。</p>
<h3 id="属性访问规则"><a href="#属性访问规则" class="headerlink" title="属性访问规则"></a>属性访问规则</h3><p>Python 解释器在访问属性时会按照一定的规则，从入口方法 <code>__getattribute__</code> 开始，按照顺序依次查找，如果找到则返回，未找到则抛出异常，调用 <code>__getattr__</code> 动态计算虚拟属性。属性访问规则如下：</p>
<ol>
<li><code>__getattribute__</code> 方法</li>
<li>数据描述符</li>
<li>实例对象的字典</li>
<li>类的字典</li>
<li>非数据描述符</li>
<li>父类的字典</li>
<li><code>__getattr__</code> 方法</li>
</ol>
<p>注：其中，数据描述符是实现了 <code>__get__</code> 和 <code>__set__</code> 描述符协议的类。描述符的内容，会在后面做详细介绍。</p>
<p>查询属性的入口方法 <code>__getattribute__</code> 实现逻辑的伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">name</span>)：</span></span><br><span class="line"><span class="function">    # 先在类(<span class="params">包括父类、祖先类</span>)字典中查找数据描述符</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">find</span> <span class="title">data</span> <span class="title">descriptor</span> <span class="title">in</span> <span class="title">class</span> <span class="title">and</span> <span class="title">base</span> <span class="title">class</span> <span class="title">__dict__</span>:</span></span><br><span class="line">        <span class="comment"># 如果是数据描述符，则调用该数据描述符的 __get__ 方法并将结果返回</span></span><br><span class="line">        <span class="keyword">return</span> descriptor.__get__(instance, instance.__class__)</span><br><span class="line">    <span class="comment"># 如果不是数据描述符，继续查询实例字典</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> instance.__dict__:</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[name]</span><br><span class="line">    <span class="comment"># 实例字典中没有，则继续查询类字典</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> instance.__class__.__dict__:</span><br><span class="line">        <span class="keyword">return</span> instance.__class__.__dict__[name]</span><br><span class="line">    <span class="comment"># 在类和父类字典中查询非数据描述符</span></span><br><span class="line">    <span class="keyword">if</span> find non-data descriptor <span class="keyword">in</span> <span class="class"><span class="keyword">class</span> <span class="title">and</span> <span class="title">base</span> <span class="title">class</span> <span class="title">__dict__</span>:</span></span><br><span class="line">        <span class="comment"># 如果找到，返回描述符实例</span></span><br><span class="line">        <span class="keyword">return</span> descriptor.instance</span><br><span class="line">    <span class="comment"># 如果不是描述符，继续在父类字典中查找</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> baseclass __dict__:</span><br><span class="line">        <span class="keyword">return</span> baseclass.__dict__[name]</span><br><span class="line">    <span class="comment"># 如果依然没有找到，抛出异常，__getattr__ 函数会被调用</span></span><br><span class="line">    <span class="keyword">raise</span> AttributeError</span><br></pre></td></tr></table></figure>

<p>为实例属性赋值则没有这么麻烦，<code>__setattr__</code> 作为入口方法，只需要判断属性是否是数据描述符，如果是则调用其 <code>__set__</code> 方法，如果不是则为实例字典添加新的属性。<code>__setattr__</code> 实现逻辑的伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__setattr__(name, value):</span><br><span class="line">    <span class="comment"># 先在类(包括父类、祖先类)字典中查找描述符</span></span><br><span class="line">    <span class="keyword">if</span> find data descriptor <span class="keyword">in</span> <span class="class"><span class="keyword">class</span> <span class="title">and</span> <span class="title">base</span> <span class="title">class</span> <span class="title">__dict__</span>:</span></span><br><span class="line">        <span class="comment"># 如果是数据描述符，则调用描述符的 __set__ 方法进行设值</span></span><br><span class="line">        descriptor.__set__(instance, value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 否则，为实例属性字典添加新值</span></span><br><span class="line">        instance.__dict__[name] = value</span><br></pre></td></tr></table></figure>

<p>由此也可以发现，Python 存取属性的方式特别不对等。通过实例访问属性时，如果实例中没有指定属性，那么会尝试获取类属性。而为实例中的属性赋值时，如果属性不存在会在实例中创建该属性，根本不影响类。</p>
<p>下面介绍如何使用 <code>__getattr__</code> 方法动态计算虚拟属性。</p>
<h3 id="自定义-getattr-即时计算属性"><a href="#自定义-getattr-即时计算属性" class="headerlink" title="自定义 __getattr__ 即时计算属性"></a>自定义 <code>__getattr__</code> 即时计算属性</h3><p>处理 JSON 是非常常见的需求，JavaScript 对 JSON 具有天生的支持，可以使用 dot 运算符链式获取属性的值，如 <code>res.cities[0].ext.province</code>。而 Python 原生的字典不支持使用 dot 运算符直接获取属性，只能使用 <code>res[&#39;cities&#39;][0][&#39;ext&#39;][&#39;province&#39;]</code> 的形式，会显得格外冗长。但可以通过实现一个近似字典的类，达到同样的效果。如下是 Python 中的效果演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> json_parser <span class="keyword">import</span> JsonParser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json = &#123;</span><br><span class="line"><span class="meta">... </span>  <span class="string">&quot;code&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line"><span class="meta">... </span>  <span class="string">&quot;cities&quot;</span>: [</span><br><span class="line"><span class="meta">... </span>    &#123;</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;lat&quot;</span>: <span class="string">&quot;41.2334465&quot;</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;lng&quot;</span>: <span class="string">&quot;116.9772857&quot;</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;citycode&quot;</span>: <span class="number">207</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;ext&quot;</span>: &#123;</span><br><span class="line"><span class="meta">... </span>        <span class="string">&quot;province&quot;</span>: <span class="string">&quot;河北省&quot;</span>,</span><br><span class="line"><span class="meta">... </span>        <span class="string">&quot;city&quot;</span>: <span class="string">&quot;承德市&quot;</span></span><br><span class="line"><span class="meta">... </span>      &#125;</span><br><span class="line"><span class="meta">... </span>    &#125; </span><br><span class="line"><span class="meta">... </span>  ]</span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = JsonParser(json)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.code</span><br><span class="line"><span class="string">&#x27;200&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.cities[<span class="number">0</span>].citycode</span><br><span class="line"><span class="number">207</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.cities[<span class="number">0</span>].ext.province</span><br><span class="line"><span class="string">&#x27;河北省&#x27;</span></span><br></pre></td></tr></table></figure>

<p>能够使用 dot 运算符链式获取属性的关键在于定义在 JsonParser 中的 <code>__getattr__</code> 方法。前面已经说过，Python 解释器在查询对象属性失败时会调用 <code>__getattr__</code> 方法动态计算属性。下面代码定义了动态计算的逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonParser</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, arg</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(arg, Mapping):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(arg, MutableSequence):</span><br><span class="line">            <span class="keyword">return</span> [cls(i) <span class="keyword">for</span> i <span class="keyword">in</span> arg]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self._data = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> JsonParser(self._data[name])</span><br></pre></td></tr></table></figure>

<p>通过 <code>__getattr__</code> 方法递归地创建 JsonParser 类，并将下级的 JSON 结构  <code>_data[name]</code> 作为构造参数传入。构造方法 <code>__new__</code> 会判断传入参数的类型，如果是映射类型直接创建 JsonParser 对象，如果是可变序列，则通过列表推导式返回 JsonParser 列表。之所以要这么处理是因为 JSON 结构可能是数组，除了映射结构还需要对数组类型进行解析，以支持 <code>cities[0]</code> 式的访问。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>在 Java 中，为了控制属性的访问权限，一般会将属性设置为私有属性，并为可以公开的属性设置公有的 getter 和 setter 方法。这样做还有一个好处，可以在方法内添加对属性的验证，比如保证商品的数量不会是负数。如果想更进一步，可以按照领域驱动设计的理念，可以将属性设置为实体类 Entity，在类中对属性进行校验。这两种思想在 Python 中也都有对应的实现，前一种对应于特性，后一种对应于描述符。</p>
<p>特性经常用于把公开的属性变成使用读值方法和设置方法管理的属性，且在不影响客户端代码的前提下实施业务规则。使用 <code>get/set + 属性名</code> 的命名方式不符合 Python 一贯的简约作风，为此 Python 提供了特性，即 property。property 是一个类形式的函数装饰器，本质上它是一个<strong>描述符类</strong>（实现了描述符协议）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">property</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        fget: <span class="type">Optional</span>[<span class="type">Callable</span>[[<span class="type">Any</span>], <span class="type">Any</span>]] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">        fset: <span class="type">Optional</span>[<span class="type">Callable</span>[[<span class="type">Any</span>, <span class="type">Any</span>], <span class="literal">None</span>]] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">        fdel: <span class="type">Optional</span>[<span class="type">Callable</span>[[<span class="type">Any</span>], <span class="literal">None</span>]] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">        doc: <span class="type">Optional</span>[<span class="built_in">str</span>] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span>(<span class="params">self, fget: <span class="type">Callable</span>[[<span class="type">Any</span>], <span class="type">Any</span>]</span>) -&gt; <span class="built_in">property</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span>(<span class="params">self, fset: <span class="type">Callable</span>[[<span class="type">Any</span>, <span class="type">Any</span>], <span class="literal">None</span>]</span>) -&gt; <span class="built_in">property</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleter</span>(<span class="params">self, fdel: <span class="type">Callable</span>[[<span class="type">Any</span>], <span class="literal">None</span>]</span>) -&gt; <span class="built_in">property</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj: <span class="type">Any</span>, <span class="built_in">type</span>: <span class="type">Optional</span>[<span class="built_in">type</span>] = ...</span>) -&gt; <span class="type">Any</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, obj: <span class="type">Any</span>, value: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, obj: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fget</span>(<span class="params">self</span>) -&gt; <span class="type">Any</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fset</span>(<span class="params">self, value: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fdel</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br></pre></td></tr></table></figure>

<p>使用函数形式的装饰器会返回一个嵌套的高阶函数，类形式的装饰器也类似，使用 <code>@property</code> 装饰的方法会被包装成特性类。特性类具有 getter、setter 和 deleter 方法属性，这三个属性也都返回 property 对象。</p>
<p>因此，用 <code>@property</code> 装饰的读值方法，如下的 <code>amount(self)</code> 方法，相当于返回一个 <code>property(amount)</code> 特性对象，将读值方法作为初始化参数 fget 传入。而后可以使用 <code>@amount.setter</code> 装饰设值方法，此时设值方法 amount 返回的是特性对象，setter 是它的方法属性。相当于 <code>property(amount).setter(amount)</code>，第二个 amount 是设值方法，将设值方法作为 fset 参数传入 setter 方法。也因此，<code>@amount.setter</code> 必须要定义在被 <code>@property</code> 装饰的设置方法之后。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, price, amount</span>):</span></span><br><span class="line">        self.price = price</span><br><span class="line">        self.amount = amount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.amount</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">amount</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._amount</span><br><span class="line"></span><br><span class="line"><span class="meta">    @amount.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">amount</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> value &gt;= <span class="number">0</span>:</span><br><span class="line">            self._amount = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;item amount must &gt;= 0&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>读值方法可以不与实例属性名一致，但要保证，读值方法名称、设值方法名称和 <code>@amount.setter</code> 装饰器中的名称三者保持一致，即都为 amount。这样，在访问属性时可以通过 <code>item.amount</code> 的形式对真正的实例属性 <code>self._amount</code> 进行读值和赋值。其实，初始化函数中的 <code>self.amount = amount</code> 语句就已经在使用特性的设置方法了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;_amount&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.total_price()</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.total_price()</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount = -<span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: item amount must &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到，真正被操作的实例属性 <code>_amount</code> 被保存在实例字典中。</p>
<p>任何对 <code>item.amount</code> 的读值和设值操作，都会经过由特性包装的读值和设值方法进行处理。由于在设值方法中对属性值做了非负验证，所以将其设置为负值会抛出 ValueError 异常。</p>
<p>需要注意的是，特性是类属性，被保存于类的 <code>__dict__</code> 字典中。在使用 <code>obj.attr</code> 这样的表达式时，不会从 obj 开始查询 attr 属性，而是从实例所属的类，即 <code>obj.__class__</code> 开始，仅当类中没有名为 attr 的特性时，才会去查询实例字典。也就是说，<strong>特性的读值和设值方法要优先于实例字典</strong>，只有直接存取 <code>__dict__</code> 属性才能跳过特性的处理逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;attribute&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function LineItem.__init__ at <span class="number">0x105459a60</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;total_price&#x27;</span>: &lt;function LineItem.total_price at <span class="number">0x105459af0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;amount&#x27;</span>: &lt;<span class="built_in">property</span> <span class="built_in">object</span> at <span class="number">0x105487680</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;_amount&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__[<span class="string">&#x27;_amount&#x27;</span>] = -<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这条规则不仅适用于特性，还适用于数据描述符，其实，特性也是数据描述符。或者换句话说，正是由于数据描述符的访问优先级要高于实例字典，特性的读值和设值方法访问才优先于实例字典。下面我们介绍描述符。</p>
<h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><p>描述符是 Python 的独有特征，不仅在应用层，内置库和标准库中也有使用。除了特性之外，使用描述符的还有方法、classmethod 和 staticmethod 装饰器，以及 functools 模块中的诸多类。理解描述符是精通 Python 的关键，本章的话题就是描述符。</p>
<p><strong>描述符是实现了特定协议的类</strong>，这个协议包括 <code>__get__</code>、<code>__set__</code> 和 <code>__delete__</code> 方法。特性类 property 实现了完整的描述符协议。通常，可以只实现部分协议。其实，我们在真实代码中见到的大多数描述符只实现了 <code>__get__</code> 和 <code>__set__</code> 方法，还有很多只实现了其中的一个。</p>
<h3 id="定制描述符实现属性验证"><a href="#定制描述符实现属性验证" class="headerlink" title="定制描述符实现属性验证"></a>定制描述符实现属性验证</h3><p><strong>描述符是对多个属性运用相同存取逻辑的一种方式</strong>。假设我们想为之前定义的 LineItem 类中的 price 和 amount 属性都设置非负验证，一种方式是为它们都编写读值和设值方法，但这会造成代码重复。为了避免这个问题，Python 提出了一种面向对象的解决方式，那就是定制描述符类。</p>
<p>在下面的代码中，定义了一个名为 Quantity 的描述符类，用于管理 LineItem 的属性。我们将 LineItem 类称为托管类，被管理的属性称为托管属性。Quantity 类的实例属性 attribute 指代托管属性的名称，由初始化方法传入。通过在托管类中声明类属性的形式，如 <code>price = Quantity(&#39;price&#39;)</code> 将描述符实例绑定给 price 属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, attribute</span>):</span></span><br><span class="line">        self.attribute = attribute</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> value &gt;= <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.attribute] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;<span class="subst">&#123;self.attribute&#125;</span> must &gt;= 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    price = Quantity(<span class="string">&#x27;price&#x27;</span>)</span><br><span class="line">    amount = Quantity(<span class="string">&#x27;amount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, price, amount</span>):</span></span><br><span class="line">        self.price = price</span><br><span class="line">        self.amount = amount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.amount</span><br></pre></td></tr></table></figure>

<p>描述符类中定义了 <code>__set__</code> 方法，当尝试为托管属性赋值时，会调用这个方法并对值做验证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;amount&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount = -<span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: amount must &gt;= <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.price = -<span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: price must &gt;= <span class="number">0</span>                            </span><br></pre></td></tr></table></figure>

<p><strong><code>__set__</code> 方法的签名</strong>：<code>def __set__(self, instance, value) -&gt; None: ...</code>。第一个参数 self 是<strong>描述符实例</strong>，即 <code>LineItem.price</code> 或 <code>LineItem.amount</code>；第二个参数 instance 是<strong>托管类实例</strong>，即 LineItem 实例；第三个参数 value 是要设置的值。在为属性赋值时，必须直接操作托管实例的 <code>__dict__</code>，如果使用内置的 setattr 函数，将会重复调用 <code>__set__</code> 导致无限递归。</p>
<p>由于读值方法不需要特殊的逻辑，所以这个描述符类没有定义 <code>__get__</code> 方法。一般情况下，如果没有 <code>__get__</code> 方法，为了给用户提供内省和其他元编程技术支持，通过托管类访问属性会返回描述符实例。通过实例访问则会去实例字典中查询对应属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.attribute]</span><br></pre></td></tr></table></figure>

<p><strong><code>__get__</code> 方法的签名</strong>：<code>def __get__(self, instance, owner) -&gt; Any: ...</code>。与 <code>__set__</code> 方法相同，<code>__get__</code> 方法的第一个参数代表描述符实例，第二个参数代表托管类实例。而第三个参数 owner 是<strong>托管类的引用</strong>，当通过托管类访问属性时会被使用，返回类字典中的描述符实例，可以理解为 <code>instance.__class__</code>。</p>
<p>此时通过托管类访问属性会得到描述符实例，通过实例访问属性会得到托管属性的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.amount</span><br><span class="line">&lt;lineitem_with_descriptor.Quantity <span class="built_in">object</span> at <span class="number">0x108c52760</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;lineitem_with_descriptor&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;price&#x27;</span>: &lt;lineitem_with_descriptor.Quantity <span class="built_in">object</span> at <span class="number">0x10abd1910</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;amount&#x27;</span>: &lt;lineitem_with_descriptor.Quantity <span class="built_in">object</span> at <span class="number">0x10ac037f0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function LineItem.__init__ at <span class="number">0x10abd8af0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;total_price&#x27;</span>: &lt;function LineItem.total_price at <span class="number">0x10abd8b80</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>同一时刻，内存中可能存在许多 LineItem 实例，但只会存在两个描述符实例：<code>LineItem.price</code> 和 <code>LineItem.amount</code>。这是因为描述符实例被定义为 LineItem 的类属性，会出现在 LineItem 的类字典中，由全部实例共享。</p>
<h3 id="描述符分类"><a href="#描述符分类" class="headerlink" title="描述符分类"></a>描述符分类</h3><p>我们将同时实现了 <code>__get__</code> 和 <code>__set__</code> 方法的描述符类称为<strong>数据描述符</strong>，将只实现了 <code>__get__</code> 的描述符类称为<strong>非数据描述符</strong>。在 CPython 的描述符对象 <a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/master/Objects/descrobject.c">descrobject</a> 的源码中，会检查描述符是否有 <code>__set__</code> 方法来返回描述符是否是数据描述符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyDescr_IsData</span><span class="params">(PyObject *ob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Py_TYPE(ob)-&gt;tp_descr_set != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python 社区在讨论这些概念时会用不同的术语，数据描述符也被称为<strong>覆盖型描述符</strong>或强制描述符，非数据描述符也被称为<strong>非覆盖型描述符</strong>或遮盖型描述符。总之，这两者的区别在于是否实现了 <code>__set__</code> 方法。之所以这么分类，是由于 Python 中<strong>存取属性方式的不对等性</strong>，我们在属性访问规则一节中提到了这点。这种不对等的处理方式也对描述符产生影响。</p>
<p>描述符的覆盖体现在，如果实现了 <code>__set__</code> 方法，即使描述符是类属性，也会覆盖对实例属性的赋值操作。比如 <code>item.amount = -1</code> 不会直接修改实例字典，而是强制执行描述符的 <code>__set__</code> 方法对数值进行非负验证。</p>
<p>如果没有实现 <code>__set__</code> 方法，比如 Python 中的方法就是以非覆盖型描述符实现的，只定义了 <code>__get__</code> 方法。如果类中定义了名为 method 的方法，使用 <code>obj.method = 1</code> 会直接修改实例字典，即<strong>实例属性会遮盖同名描述符属性</strong>，但类中的描述符属性依然存在。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span>():</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.method = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;method&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.method</span><br><span class="line">&lt;function C.method at <span class="number">0x10f7ff940</span>&gt;</span><br></pre></td></tr></table></figure>

<p>综上所述，数据描述符的表现形式更像可以被随意赋值的数据，提供了完备的取值方法 <code>__get__</code> 和设值方法 <code>__set__</code>。而非数据描述符表现形式不像数据，比如 Python 中的方法，为非数据描述符赋值会遮盖掉实例的同名描述符属性。</p>
<p>以上讨论的都是是否存在 <code>__set__</code> 方法的情形，其实，也可以没有读值方法 <code>__get__</code>，比如我们定义的 Quantity 描述符。一般情况下，没有读值方法时访问属性会返回描述符对象本身。然而访问 LineItem 实例属性 <code>item.amount</code> 会得到对应数值。这是因为在它的初始化方法 <code>__init__</code> 中已经调用了描述符的 <code>__set__</code> 方法，该方法为实例字典 <code>__dict__</code> 创建了同名实例属性，由于实例属性会遮盖同名描述符属性，读取属性会返回实例字典中的值而不是描述符对象。这也是为什么将实现了 <code>__set__</code> 的描述符称为遮盖型描述符的原因。</p>
<p>总之，<strong>按照属性访问规则，数据描述符在实例字典之前被访问（调用 <code>__get__</code> 和<code>__set__</code> 方法），非数据描述符在实例字典之后被访问（可能会被遮盖）</strong>。</p>
<h3 id="方法是描述符"><a href="#方法是描述符" class="headerlink" title="方法是描述符"></a>方法是描述符</h3><p>定义在类中的方法会变成绑定方法（bound method），这是 Python 语言底层使用描述符的最好例证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span>():</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.method</span><br><span class="line">&lt;bound method C.method of &lt;__main__.C <span class="built_in">object</span> at <span class="number">0x10f837580</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.method</span><br><span class="line">&lt;function C.method at <span class="number">0x10fff6b80</span>&gt;</span><br></pre></td></tr></table></figure>

<p>通过类和实例访问函数返回的是不同的对象。CPython 中定义的函数对象 <a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/master/Objects/funcobject.c">funcobject</a> 实现了描述符协议的 <code>__get__</code> 方法，即如下的 <code>func_descr_get</code> 方法。与描述符一样，通过托管类访问函数时，传入的 obj 参数为空，函数的 <code>__get__</code> 方法会返回自身的引用。通过实例访问函数时，返回的是绑定方法对象，并把托管实例绑定给函数的第一个参数（即 self），这与 functool.partial 函数的行为一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bind a function to an object */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject *</span></span><br><span class="line"><span class="function"><span class="title">func_descr_get</span><span class="params">(PyObject *func, PyObject *obj, PyObject *type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == Py_None || obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(func);</span><br><span class="line">        <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyMethod_New(func, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Method objects are used for bound instance methods returned by instancename.methodname.</span></span><br><span class="line"><span class="comment">   ClassName.methodname returns an ordinary function. */</span></span><br><span class="line"><span class="function">PyObject * <span class="title">PyMethod_New</span><span class="params">(PyObject *func, PyObject *self)</span></span></span><br></pre></td></tr></table></figure>

<p>绑定方法对象还有个 <code>__call__</code> 方法，用于处理真正的调用过程。这个方法会调用 <code>__func__</code> 属性引用的原始函数，把函数的第一个参数设为绑定方法的 <code>__self__</code> 属性。这就是<strong>形参 self 的隐式绑定过程</strong>。</p>
<h3 id="使用描述符的最佳实践"><a href="#使用描述符的最佳实践" class="headerlink" title="使用描述符的最佳实践"></a>使用描述符的最佳实践</h3><p><strong>使用特性以保持简单</strong>：内置的 property 类创建的是数据描述符，<code>__get__</code> 和 <code>__set__</code> 方法都实现了。特性的 <code>__set__</code> 方法默认抛出 AttributeError: can’t set attribute，因此创建只读属性最简单的方式是使用特性。且由于特性存在 <code>__set__</code> 方法，不会被同名实例属性遮盖。</p>
<p><strong>只读描述符也要实现 <code>__set__</code> 方法</strong>：如果使用描述符类实现只读数据属性，要记住，<code>__get__</code> 和 <code>__set__</code> 方法必须都定义。否则，实例的同名属性会遮盖描述符。只读属性的 <code>__set__</code> 方法只需抛出 AttributeError 异常，并提供合适的错误消息。</p>
<p><strong>非特殊的方法可以被实例属性遮盖</strong>：Python 的方法只实现了 <code>__get__</code> 方法，所以对与方法名同名的属性将会遮盖描述符，也就是说 <code>obj.method = 1</code> 负值后通过实例访问 method 将会得到数字 1，但不影响类或其他实例。然而，特殊方法不受这个问题影响。因为解释器只会在类中查询特殊方法。也就是说 <code>repr(x)</code> 执行的其实是 <code>x.__class__.__repr__(x)</code>，因此 x 的 <code>__repr__</code> 属性对 <code>repr(x)</code> 方法调用没有影响。出于同样的原因，实例的 <code>__getattr__</code> 属性不会破坏常规的属性访问规则。</p>
<p><strong>用于验证的描述符可以只实现 <code>__set__</code> 方法</strong>：对仅用于验证的描述符来说，<code>__set__</code> 方法应该检查 value 参数是否有效，如果有效，使用与描述符实例同名的名称作为键，直接在实例字典中设值，如 Quantity 中的 <code>instance.__dict__[self.attribute] = value</code> 语句。这样，从实例字典中读取同名属性就不需要经过 <code>__get__</code> 方法处理。</p>
<p><strong>仅有 <code>__get__</code> 方法的描述符可以实现高效缓存</strong>：如果仅实现了 <code>__get__</code> 方法，那么创建的是非数据描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例字典中获取值，而不会再出发描述符的 <code>__get__</code> 方法。</p>
<h3 id="描述符应用场景"><a href="#描述符应用场景" class="headerlink" title="描述符应用场景"></a>描述符应用场景</h3><p>当将描述符逻辑抽象到单独的代码单元中，如 Quantity 类中，就可以在整个应用中进行重用。在一些框架中，会将描述符定义在单独的工具模块中，比如 Django 框架中与数据库交互的模型字段类，就是描述符类。你会发现下面这段 Django 的测试用例的代码与我们定义的 LineItem 非常类似。只不过我们的描述符类 Quantity 换成了他们的 models.CharFiled 等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    books = models.ManyToManyField(Book)</span><br><span class="line">    person = models.OneToOneField(<span class="string">&#x27;Person&#x27;</span>, models.CASCADE, null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>当然，目前定义的描述符类还有提升的空间，比如 <code>price = Quantity(&#39;price&#39;)</code> 使用字符串对属性名进行初始化可能并不那么可靠。又比如想为字段设置更多限定，比如 Django 中设置的字段 max_length 等。其实，Django 框架使用到了 Python 更高阶的类元编程的特性 —— 元类。除了开放框架，一般用不到这个特性。后面我们会对元类加以介绍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/04/12/Python-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/12/Python-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Python 函数详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-12 22:48:57" itemprop="dateCreated datePublished" datetime="2021-04-12T22:48:57+08:00">2021-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>除了用户定义的函数，调用运算符，即 “()” 括号对，还能应用到其他对象上。我们将能应用调用运算符的对象称为<strong>可调用对象</strong>，通过内置的 <code>callable()</code> 方法可以判断对象是否是可调用对象。在 Python 3 的<a target="_blank" rel="noopener" href="https://docs.python.org/3/reference/datamodel.html">数据模型文档</a>中，一共列出了 7 种可调用对象：</p>
<ul>
<li><strong>内置函数和内置方法</strong>：使用 C 语言（CPython）实现的函数和方法，如 <code>len()</code> 和 <code>alist.append()</code>；</li>
<li><strong>用户定义的函数</strong>：包括使用 def 创建的普通函数和 lambda 创建的匿名函数；</li>
<li><strong>实例方法与类方法</strong>：定义在类中的方法，实例方法是指第一个参数为 <code>self</code> 的方法，类方法是指第一个参数为 <code>cls</code> 的方法；</li>
<li><strong>类</strong>：对类使用调用运算符，如 <code>C()</code>，会执行类的 <code>__new__</code> 方法创建类的实例，然后执行 <code>__init__</code> 初始化；</li>
<li><strong>类的实例</strong>：如果类定义了 <code>__call__</code> 方法，那它的实例可以作为函数调用；</li>
<li><strong>生成器函数</strong>：内部使用了 yield 关键字的函数，调用生成器函数会返回生成器对象；</li>
<li><strong>协程函数和异步生成器函数</strong>：从 Python 3.5 开始支持使用 <code>async def</code> 关键字来定义协程函数，如果内部包含 yield 关键字则被称为异步生成器函数。该函数被调用时会返回一个异步迭代器对象。</li>
</ul>
<h3 id="自定义的可调用类型"><a href="#自定义的可调用类型" class="headerlink" title="自定义的可调用类型"></a>自定义的可调用类型</h3><p>在装饰器一节，我们已经认识到了，装饰器不仅可以是函数，也可以是类。任何类只要实现了 <code>__call__</code> 方法，那它就是可调用对象，就可以表现的如同函数。因此，我们可以编写用户自定义的可调用类型，将其用在任何期待函数的地方。下面我将通过 Java 和 Python 两种语言，展现它们在可调用类型上的异同。</p>
<p>假设现有一副扑克，要求按照 <code>A, 2 ~ 10, J, Q, K</code> 的顺序进行排序。在 Java 中，可以通过 <code>Collections.sort()</code> 集合类的接口对一个集合进行排序。Python 也提供了内置的 <code>sorted()</code> 方法，对可迭代对象进行排序。但两种语言都不支持直接对字符串和数字类型进行比较，所以还需要实现特定的排序逻辑。</p>
<p>Java 中要实现排序逻辑通常有两种方法。一种是让类实现 Comparable 接口，重写其中的 <code>compareTo()</code> 抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Poker</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Poker otherPoker)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重点想展示第二种方法：新建一个实现了 Comparator 接口的比较器类，重写其 <code>compare()</code> 抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PokerComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Poker</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Poker firstPoker, Poker secondPoker)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// return ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PokerComparator pokerComparator = <span class="keyword">new</span> PokerComparator();</span><br><span class="line">Collections.sort(pokers, pokerComparator);</span><br></pre></td></tr></table></figure>

<p>对于这种方法，需要将比较器对象作为第二个参数传入 <code>Collections.sort()</code> 接口中。由于 Java 对象不能将函数作为参数的限制，我们定义了一个辅助类，实际上这个类对我们而言只有一个方法有用，那就是 <code>compare()</code> 方法，<code>Collections.sort()</code> 接口会去调用该方法，所以它就是对应的排序逻辑，只不过是用类实现的。</p>
<p>Python 的函数可以直接作为参数传递，但我们接下来要讲的是如何定义一个类似 Comparator 的类，让它能实现排序逻辑。</p>
<p>Python 内置的排序方法 <code>sorted()</code>，<strong>允许接收一个关键字参数 key 作为排序的键</strong>，比如 <code>key=len</code> 时依照元素的长度进行排序。对于扑克牌 A ~ K，可以维护一个映射数字类型的字典，比如将 ‘K’ 映射到 13，排序时直接通过映射的数值大小排序。维护一个字典，函数当然可以做到，但将其作为类的属性更加合适。可以定义一个扑克序列类，在初始化这个类时就构建好字典。为了让类可被调用，还需要实现 <code>__call__</code> 方法，直接返回字典中扑克牌对应的数值作为排序的键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PokerOrder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._seq = &#123;<span class="built_in">str</span>(i): i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)&#125;</span><br><span class="line">        self._seq.setdefault(<span class="string">&#x27;J&#x27;</span>, <span class="number">11</span>)</span><br><span class="line">        self._seq.setdefault(<span class="string">&#x27;Q&#x27;</span>, <span class="number">12</span>)</span><br><span class="line">        self._seq.setdefault(<span class="string">&#x27;K&#x27;</span>, <span class="number">13</span>)</span><br><span class="line">        self._seq.setdefault(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._seq.get(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self._seq)</span><br></pre></td></tr></table></figure>

<p>由于 PokerOrder 类实现了 <code>__call__</code> 方法，它的实例会被 <code>callable()</code> 方法判定为可调用对象，可以直接应用调用运算符，传入扑克牌值返回对应数值。在排序时，将 PokerOrder 类的实例作为关键字传入，相当于将序列中的每项元素执行 <code>__call__</code> 方法返回的值作为键进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pokerorder = PokerOrder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pokerorder.show()</span><br><span class="line">&#123;<span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;10&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;J&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;Q&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;K&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(pokerorder)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pokerorder(<span class="string">&#x27;K&#x27;</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;2&#x27;</span>], key=pokerorder)</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;K&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>将类定义为可调用类型，不仅能维护内部属性，还能自定义方法，比如如上代码中的 <code>show()</code> 方法。除此之外，在实现更复杂的排序逻辑时，比如按照花色排序等，使用类要比使用函数更合适。甚至如果你觉的 PokerOrder 类应该被实现为单例模式，还可以添加 <code>__new__</code> 方法保证创建类中的字典只会被创建一次。</p>
<h2 id="函数对象与方法对象"><a href="#函数对象与方法对象" class="headerlink" title="函数对象与方法对象"></a>函数对象与方法对象</h2><p>Python 中一切皆对象，不管是函数还是类中定义的方法都是对象。对于类中的实例方法来说，通过类访问该实例方法，如 <code>C.foo</code>，会返回一个<strong>函数对象</strong>，即 <code>function</code> 类型；通过实例访问实例方法，如 <code>c.foo</code>，会返回一个<strong>绑定方法对象</strong>，即 <code>method</code> 类型，该方法对象绑定在实例上。对于类方法而言，无论是通过类还是实例访问，都返回绑定方法对象，该方法对象绑定在类上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self, x</span>):</span> <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span>    @<span class="built_in">classmethod</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">cls, x</span>):</span> <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.foo</span><br><span class="line">&lt;function C.foo at <span class="number">0x10d613f70</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(C.foo)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">function</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span> = <span class="title">C</span>()</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">C</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10b0a5820</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span>.<span class="title">foo</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">C</span>.<span class="title">foo</span> <span class="title">of</span> &lt;<span class="title">__main__</span>.<span class="title">C</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10b0a5820</span>&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">c.foo</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">method</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">C</span>.<span class="title">bar</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">C</span>.<span class="title">bar</span> <span class="title">of</span> &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">C</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span>.<span class="title">bar</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">C</span>.<span class="title">bar</span> <span class="title">of</span> &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">C</span>&#x27;&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法对象中包含一些特殊的只读属性：</p>
<ul>
<li><code>__self__</code> 为类实例对象本身；</li>
<li><code>__func__</code> 为函数对象；</li>
<li><code>__doc__</code> 为方法的文档，与 <code>__func__.__doc__</code> 作用相同；</li>
<li><code>__name__</code> 为方法名称，与 <code>__func__.__name__</code> 作用相同；</li>
<li><code>__module__</code> 为方法所属模块的名称，没有则为 None。</li>
</ul>
<p><strong>访问方法对象的 <code>__func__</code> 属性会获得函数对象</strong>。虽然两者都能通过调用运算符 “()” 调用，但函数对象还需要手动传入第一个位置的参数，即 <code>self</code> 和 <code>cls</code> 参数，方法对象则不需要。原因在于，<strong>调用方法对象会调用对应的下层函数对象 <code>__func__</code>，并将 <code>__self__</code> 参数插入到参数列表的开头</strong>，如果是实例方法则插入类实例，如果是类方法则插入类本身。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self, x</span>):</span> <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span>    @<span class="built_in">classmethod</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">cls, x</span>):</span> <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.foo(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.foo.__func__(c, <span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.bar(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.bar.__func__(C, <span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>就如同上述代码所展示的，对于实例方法 <code>foo()</code> 来说，调用 <code>c.foo(1)</code> 相当于调用 <code>c.foo.__func__(c, 1)</code>。对于类方法 <code>bar()</code> 来说，无论是调用 <code>c.bar(1)</code> 还是 <code>C.bar(1)</code> 都相当于调用 <code>C.bar.__func__(C, 1)</code>。</p>
<h3 id="函数内省"><a href="#函数内省" class="headerlink" title="函数内省"></a>函数内省</h3><p>将函数作为对象处理，可以用于运行时内省，类似于 Java 中的反射，可以在运行时获取函数的信息，比如注解、闭包、参数默认值等。下面列出了一些函数对象特有的属性和方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="built_in">set</span>(<span class="built_in">dir</span>(func)) - <span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="built_in">object</span>)))</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__call__&#x27;</span>, <span class="string">&#x27;__closure__&#x27;</span>, <span class="string">&#x27;__code__&#x27;</span>, <span class="string">&#x27;__defaults__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__get__&#x27;</span>, <span class="string">&#x27;__globals__&#x27;</span>, <span class="string">&#x27;__kwdefaults__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p><code>dir()</code> 函数可以查看一个模块或一个类中的所有属性，当然方法也算方法属性。上述代码将 func 函数对象与常规对象 object 的属性集合做了一个差集，只打印函数对象特有的属性。下表对这些特有属性做了简要说明。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>__annotations__</code></td>
<td>dict</td>
<td>参数和返回值的注解</td>
</tr>
<tr>
<td><code>__call__</code></td>
<td>method-wrapper</td>
<td>实现 () 运算符，即可调用对象协议</td>
</tr>
<tr>
<td><code>__closure__</code></td>
<td>tuple</td>
<td>函数闭包，即自由变量的绑定（没有则是None）</td>
</tr>
<tr>
<td><code>__code__</code></td>
<td>code</td>
<td>编译成字节码的函数元数据和函数定义体</td>
</tr>
<tr>
<td><code>__defaults__</code></td>
<td>tuple</td>
<td>形式参数的默认值</td>
</tr>
<tr>
<td><code>__get__</code></td>
<td>method-wrapper</td>
<td>实现只读描述符协议</td>
</tr>
<tr>
<td><code>__globals__</code></td>
<td>dict</td>
<td>函数所在模块中的全局变量</td>
</tr>
<tr>
<td><code>__kwdefaults__</code></td>
<td>dict</td>
<td>仅限关键字形式参数的默认值</td>
</tr>
<tr>
<td><code>__name__</code></td>
<td>str</td>
<td>函数名称</td>
</tr>
<tr>
<td><code>__qualname__</code></td>
<td>str</td>
<td>函数的限定名称，如 Random.choice</td>
</tr>
</tbody></table>
<p>函数内省经常被一些框架使用发挥出强大效果。比如 <code>__defaults__</code>、<code>__code__</code> 和 <code>__annotations__</code> 属性，经常被 IDE 用来提取关于函数签名的信息，我们之前也提到过 IDE 和 lint 工具使用函数注解做静态类型检查。还比如一些 Python Web 后端框架，可以自动解析 HTTP 请求中的参数将其注入到接口函数中执行，而不用程序员手动处理。</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>Python 最好的特性之一就是提供了极为灵活的参数处理机制。除了基础的定位参数（positional argument）之外，Python 还支持传入关键字参数（keyword argument），如我们之前所使用的内置方法 <code>sorted()</code>，就支持关键字参数 key 与 reverse。关键字参数允许提供默认值，如果无默认值一般为 None。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Return a new list containing all items from the iterable in ascending order.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">A custom key function can be supplied to customize the sort order, and the</span></span><br><span class="line"><span class="string">reverse flag can be set to request the result in descending order.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">sorted</span>(iterable, /, *, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>Java 5 中引入了不定长参数，允许在形参后添加 <code>...</code> 表示该形参可以接收多个参数值，多个参数将被当做数组传入，如 <code>void foo(String... args)</code>。Python 也支持<strong>不定长参数</strong>，它的形式是在参数名称前添加星号运算符，如 <code>*args</code>，不定长参数将被打包成<strong>元组</strong>传入。除此之外，Python 还支持传入<strong>非具名关键字参数</strong>，即没有明确指定名称的关键字参数，如 <code>**kwargs</code>，参数将会被打包成一个<strong>字典</strong>传入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;args: &#x27;</span>, args)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;kwargs: &#x27;</span>, kwargs)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="string">&#x27;b&#x27;</span>) </span><br><span class="line">args: (<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">kwargs: &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;b&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果同时使用 <code>*args</code> 和 <code>**kwargs</code>，<code>*args</code> 参数必须要在 <code>**kwargs</code> 之前。它们可以与其他类型的参数混合使用，但<strong>参数的顺序必须是：定位参数，默认参数，不定长参数，具名关键字参数和非具名关键字参数</strong>。即如下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">record</span>(<span class="params">name, age=<span class="number">18</span>, *phones, email=<span class="literal">None</span>, **other</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;name: &#x27;</span>, name)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;age: &#x27;</span>, age)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;phones: &#x27;</span>, phones)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;email: &#x27;</span>, email)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;other: &#x27;</span>, other)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="number">123456</span>, <span class="number">654321</span>, email=<span class="string">&#x27;abc@email.com&#x27;</span>, height=<span class="number">180</span>, weight=<span class="number">90</span>)</span><br><span class="line">name: Jack</span><br><span class="line">age: <span class="number">20</span></span><br><span class="line">phones: (<span class="number">123456</span>, <span class="number">654321</span>)</span><br><span class="line">email: abc@email.com</span><br><span class="line">other: &#123;<span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">90</span>&#125;</span><br></pre></td></tr></table></figure>

<p>其中，默认参数与具名关键字参数形式上一样，默认参数通常是用来简化函数调用者的传参的。这两者可以通过位置进行区分，在不定长参数之前的是默认参数，之后的是关键字参数。如果要传入不定长参数，默认参数就不能省略，此时默认参数被视为定位参数（默认值失去了意义），其后的非关键字参数会被不定长参数 <code>*phones</code> 捕获。如果省略了默认参数，那么不定长参数的第一个元素会被赋值给默认参数。具名关键字参数则没有这一限制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>record(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">123456</span>, <span class="number">654321</span>, height=<span class="number">180</span>)</span><br><span class="line">name:  Jack</span><br><span class="line">age:  <span class="number">123456</span></span><br><span class="line">phones:  (<span class="number">654321</span>,)</span><br><span class="line">email:  <span class="literal">None</span></span><br><span class="line">other:  &#123;<span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>仅限关键字参数</strong>（keyword-only argument）是 Python 3 新增的特性。如果定义函数时想指定仅限关键字参数，需要将它们放在带有 <code>*</code> 的不定长参数之后。如果不想支持不定长参数，可以在签名中放一个 <code>*</code>，标志着定位参数到此终结，之后的参数只能以关键字形式提供，即仅限关键字参数。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, *, b, c=<span class="number">3</span></span>):</span> </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a, b, c</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，仅限关键字参数不一定要有默认值，但如果没有默认值，调用函数时必须传入该参数。内置方法 <code>sorted()</code> 的参数就包含一个 <code>*</code>，其后的 key 和 reverse 参数就是带有默认值的仅限关键字参数。</p>
<h3 id="函数参数的最佳实践"><a href="#函数参数的最佳实践" class="headerlink" title="函数参数的最佳实践"></a>函数参数的最佳实践</h3><p>对于函数参数如何正确的使用，《Effective Python》给出了一些建议。我结合自己的一些看法，给出如下几点建议。</p>
<p>第一点，<strong>使用不定长参数减少视觉杂讯</strong>。这是一种比喻，目的是使函数签名内容不要过于过多，而应凸显重要部分。如果一个函数支持传入多个相同类型的对象，或对不同类型的对象做相同处理，可以考虑不定长参数（或者组合成一个可迭代对象传入）。拿 Python 的内置方法来举例，<code>map()</code> 的最后一个参数就是不定长参数 <code>*iterables</code>，支持传入多个可迭代对象；<code>print()</code> 方法的第一个参数 <code>*values</code> 也是不定长参数，对于传入多个参数，不管它们是什么类型都能将其打印。</p>
<p>第二点，<strong>使用关键字参数来表达可选的行为</strong>。关键字参数的名称可以辅助调用者明确参数的用途，比如 <code>sorted()</code> 方法中的 reverse 参数用来反向排序。关键字参数还能提供默认值，就如同一个开关，如果使用函数默认功能，就不需要操心这些参数，还可以避免传参时的重复代码。如果想开启附加功能，可以传入指定的关键字参数。带有默认值的关键字参数还能在不改变调用代码的基础上为函数添加新功能，保证了代码的兼容性。从另一种角度看，带有默认值的关键字参数提供了类似多态重载的动态语言特性，虽然 Python 并不支持函数重载。</p>
<p>第三点，<strong>使用仅限关键字参数来确保代码清晰</strong>。关键字参数可以提高可读性，但不能保证调用者一定使用关键字来明确指出参数的含义，关键字参数可以通过位置来赋值，比如定义的函数 <code>def func(a, b=1)</code> 可以通过 <code>func(1, 2)</code> 来为关键字参数 b 赋值。如果有必要，可以使用仅限关键字参数来强制调用者使用关键字。比如 <code>sorted()</code> 方法签名 <code>*</code> 后指定的仅限关键字参数 key 和 reverse。</p>
<p>第四点，<strong>使用 None 而不是可变序列为参数默认值赋空</strong>。绝对不要将参数默认值指定为空的可变序列 <code>[]</code> 和 <code>&#123;&#125;</code>。参数的默认值会在模块被加载时执行一次并绑定，如果默认值定义为了可变序列，那么以默认形式调用函数的代码都会共享同一份序列，从而导致难以预料的结果。比如如下解析 JSON 的函数，默认值为空字典，在解析出错时将其返回，导致两个对象共用一个字典。解决的方法是使用 None 作为参数默认值，在函数内重新赋值为空字典，并添加文档说明参数默认值的实际行为。如果参数默认值是动态变化的，如当前时间，也应如此做。总之，要避免参数默认值是可变的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">data, default=&#123;&#125;</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> json.loads(data)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ValueError:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> default</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = decode(<span class="string">&#x27;bad data&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar = decode(<span class="string">&#x27;also bad&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo <span class="keyword">is</span> bar</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>第五点，<strong>避免修改传入参数的值</strong>。函数式编程中非常强调的一点是，函数要无副作用。无副作用指的是函数内部不与外部互动（最典型的情况是，修改全局变量的值），产生除函数本身运算以外的其他效果。函数无副作用，意味着函数要保持独立，不依赖于上下文环境，不得修改外部变量包括传入参数的值。即使函数要在传入参数本身上做运算，也应该新建一个副本将其返回。就拿 <code>sorted()</code> 来说，即使排序前后元素位置没有变化，也返回一个全新的列表。除此之外，<code>map()</code>、<code>filter()</code> 等其他内置方法也都遵循这一点，不对参数本身做修改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(l)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(l) <span class="keyword">is</span> l</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义的-sorted-函数"><a href="#自定义的-sorted-函数" class="headerlink" title="自定义的 sorted() 函数"></a>自定义的 <code>sorted()</code> 函数</h3><p>在本章中我一直拿内置的 <code>sorted()</code> 函数来举例，不妨自己来实现一个。借此案例我想演示：如何使用仅限关键字参数，如何编写高阶函数，以及如何使用卫语句对异常参数进行处理。</p>
<p>这里的排序算法不是关键，使用的是最简单的冒泡排序算法。函数签名上尽可能与 <code>sorted()</code> 保持一致，为了保证函数无副作用，函数内部新建了一个列表副本保存传入可迭代序列的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">iterable, *, key=<span class="literal">None</span>, reverse=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">callable</span>(key):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">type</span>(key)&#125;</span> object is not callable&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    _l = <span class="built_in">list</span>(iterable)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(_l)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> _l[j] &gt; _l[i]:</span><br><span class="line">                    _l[j], _l[i] = _l[i], _l[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> key(_l[j]) &gt; key(_l[i]):</span><br><span class="line">                    _l[j], _l[i] = _l[i], _l[j]</span><br><span class="line">    <span class="keyword">if</span> reverse:</span><br><span class="line">        _l.reverse()</span><br><span class="line">    <span class="keyword">return</span> _l</span><br></pre></td></tr></table></figure>

<p>仅限关键字参数是指在 <code>*</code> 运算符之后定义的关键字参数，在调用时必须指定关键字名称，如上述函数中的 key 和 reverse 关键字。</p>
<p>在函数的开头，首先判断传入的 key 参数在非 None 情况下是否是可调用的，若不可调用则抛出 TypeError 异常。这种 if 条件分支语句叫做<strong>卫语句</strong>（guard clause），目的是将可能出错的每个分支做单独检查，要么抛出异常要么立即返回。通过在函数头部的集中处理及早抛出各种可能的异常（又称迅速失败），避免无效的运算。函数真正的实现代码放在卫语句之后，保证运行到此处时所有条件都已通过。</p>
<p>通过了卫语句检测的 key 参数是可调用的，在函数内部直接使用 <code>key()</code> 调用。对于接收函数作为参数的 <code>sort()</code> 函数，我们将其称之为<strong>高阶函数</strong>，这也是 Python 函数式编程特性之一。</p>
<p>下面是测试方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_should_sort_number_sequence</span>(<span class="params">self</span>):</span></span><br><span class="line">    _l = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>]</span><br><span class="line">    result = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">    <span class="keyword">assert</span> sort(_l) == result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_should_sort_sequence_with_key_function</span>(<span class="params">self</span>):</span></span><br><span class="line">    _l = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;aab&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;aabb&#x27;</span>]</span><br><span class="line">    result = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;aab&#x27;</span>, <span class="string">&#x27;aabb&#x27;</span>]</span><br><span class="line">    <span class="keyword">assert</span> sort(_l, key=<span class="built_in">len</span>) == result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_should_sort_sequence_with_key_function_and_reverse</span>(<span class="params">self</span>):</span></span><br><span class="line">    _l = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;aab&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;aabb&#x27;</span>]</span><br><span class="line">    result = [<span class="string">&#x27;aabb&#x27;</span>, <span class="string">&#x27;aab&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    <span class="keyword">assert</span> sort(_l, key=<span class="built_in">len</span>, reverse=<span class="literal">True</span>) == result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_should_raise_error_when_key_function_is_not_callable</span>(<span class="params">self</span>):</span></span><br><span class="line">    _l = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>]</span><br><span class="line">    <span class="keyword">with</span> pytest.raises(TypeError) <span class="keyword">as</span> e:</span><br><span class="line">        sort(_l, key=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>pytest 框架支持对抛出异常的测试，使用 with 语句加 <code>pytest.raises()</code> 方法可以断言定义体内调用的方法是否会抛出对应的异常。</p>
<h3 id="与-运算符"><a href="#与-运算符" class="headerlink" title="* 与 ** 运算符"></a><code>*</code> 与 <code>**</code> 运算符</h3><p>在 Python 中，<code>*</code> 与 <code>**</code> 运算符除了能用作数学运算符中的乘法和乘方之外，还有一些其他的巧妙用法。之前讨论的函数中的不定长参数 <code>*args</code> 和不具名关键字参数 <code>**kwargs</code> 是它们的经典用法之一。此外，这两个运算符还可以用来对参数列表进行<strong>拆包</strong>。</p>
<p>运用 <code>*</code> 运算符可以把一个可迭代对象拆开作为函数的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>, b=<span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a=<span class="number">1</span>, b=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(*t)</span><br><span class="line">a=<span class="number">1</span>, b=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>类似的，运用 <code>**</code> 运算符可以把一个字典拆开作为函数的参数，同名键会绑定到对应的具名参数上，如果函数还定义了非具名关键字参数 <code>**kwargs</code>，除了绑定的同名键外余下参数会被 <code>**kwargs</code> 捕获。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a=<span class="literal">None</span>, b=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>, b=<span class="subst">&#123;b&#125;</span>, kwargs=<span class="subst">&#123;kwargs&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(**d)</span><br><span class="line">a=<span class="number">1</span>, b=<span class="number">2</span>, kwargs=&#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>*</code> 运算符对于函数参数中的可迭代对象拆包概念，在 Python 3 被扩展到了<strong>平行赋值</strong>。在平行赋值中，<code>*</code> 前缀只能被用在一个变量名前，但这个变量可以出现在赋值表达式的任何位置，用来处理剩下的元素。拆包所赋值的元素是列表类型，即使其中只有一个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *rest, d, e = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, rest, d, e</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *rest, c, d, e = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, rest, c, d, e</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>Python 中的 lambda 关键字用于创建<strong>匿名函数</strong>。lambda 表达式的格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments : statement</span><br></pre></td></tr></table></figure>

<p>表达式以 lambda 关键字开头，冒号 “:” 左侧是函数的<strong>传入参数</strong>，当有多个入参时使用逗号划分开，冒号右侧是<strong>返回值</strong>的表达式语句，函数会根据表达式计算结果并将其返回。lambda 表达式会创建一个函数对象，可以对其赋值并如同普通函数一样使用。下面定义了一个求平方的 lambda 表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>square = <span class="keyword">lambda</span> x : x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x101631e50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(<span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>lambda 句法只是语法糖，上述定义的 lambda 表达式与如下使用 def 关键字定义的普通函数没有本质区别，甚至 lambda 表达式的功能要更加受限。由于 Python 简单的句法限制了 lambda 定义体只能使用纯表达式，不能进行赋值，也不能使用 while 和 try 等 Python 语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square</span><br><span class="line">&lt;function square at <span class="number">0x101631dc0</span>&gt;</span><br></pre></td></tr></table></figure>

<p>在 Python 中，<strong>lambda 表达式的通常作用是作为参数传入给高阶函数</strong>。比如在列表推导一节介绍的 map、filter 和 reduce 函数，这些函数接收一个函数作为参数，如果不想额外定义函数，那么使用 lambda 表达式创建匿名函数就是最佳的应用场景。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x : x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x : x &lt; <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>除了上述这种应用场景之外，Python 很少使用匿名函数。受到句法的限制，lambda 表达式无法实现复杂的函数功能。同时，在使用 lambda 表达式时要尽可能保证表达式的清晰简短，否则冗长的 lambda 表达式将会导致代码难以阅读。此时，应该使用 def 关键字创建普通函数，即《Effective Python》所提倡的：<strong>使用辅助函数来取代复杂的表达式</strong>，并赋予函数清晰的名称以提高代码可读性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/04/01/Python-%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%BF%AD%E4%BB%A3%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/Python-%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%BF%AD%E4%BB%A3%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">Python 中的可迭代类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-01 17:11:20" itemprop="dateCreated datePublished" datetime="2021-04-01T17:11:20+08:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>之前我们已经讨论过，Python 的“序列协议”是指：任何类，只要使用标准的签名和语义实现了 <code>__getitem__</code> 和 <code>__len__</code> 方法，就能用在任何期待序列的地方，解释器会为这些类做特殊的支持，比如支持迭代和 in 运算符。序列协议的接口定义可以查阅官方的 CPython API 接口文档：<a target="_blank" rel="noopener" href="https://docs.python.org/3.8/c-api/sequence.html">Python/C API Reference Manual – Sequence Protocol</a>，其中有这样一个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PySequence_Check</span><span class="params">(PyObject *o)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* Return 1 if the object provides sequence protocol, and 0 otherwise. Note that it returns 1 for Python classes with a __getitem__() method unless they are dict subclasses since in general case it is impossible to determine what the type of keys it supports. This function always succeeds. */</span></span></span><br></pre></td></tr></table></figure>

<p>这个函数的作用是检查并返回对象是否支持序列协议 —— 只在实现了 <code>__getitem__</code> 方法且不是字典子类时才返回 1。这也符合我们之前所说的，协议是非正式的，没有强制力，只要你知道类的具体使用场景，可以只实现协议的一部分。比如，仅为了支持迭代，甚至不需要提供 <code>__len__</code> 方法。</p>
<p>Python 常用的内置序列类型包括：字符串 str、列表 list、元组 tuple 和范围 range。尽管字典 dict 和集合 set 实现了序列协议中的 <code>__getitem__</code> 和 <code>__len__</code> 方法，但它们并不算序列类型，因为它们的特征与序列有本质差异，比如这两个类型不支持通过整数下标索引访问元素，不支持切片，并且字典和集合内的元素是无序的。</p>
<p>序列类 Sequence，定义在标准库 <code>collections.abc</code> 模块中，继承自 Reversible 和 Collection 类，而 Collection 又继承自 Sized、Iterable 和 Container，体现了序列类可反转、具有规模、可迭代和是一个容器的语义。</p>
<p>从 <code>collections.abc</code> 模块的源码中，我们还能了解到序列类包含哪些子类。除了显示继承了 Sequence 的子类，如 ByteString 和 MutableSequence，还有通过 register 关键字绑定为 Sequence 虚拟子类的一些内置类型，在绑定虚拟子类一节中也提到过这一点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> <span class="type">Sequence</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="built_in">issubclass</span>(i, <span class="type">Sequence</span>) <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="built_in">str</span>, <span class="built_in">list</span>, <span class="built_in">tuple</span>, <span class="built_in">range</span>, <span class="built_in">bytes</span>, <span class="built_in">bytearray</span>, <span class="built_in">memoryview</span>)])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>([<span class="built_in">issubclass</span>(i, <span class="type">Sequence</span>) <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="built_in">dict</span>, <span class="built_in">set</span>)])</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>上面列表推导表达式中的所有类型都是定义在 builtsin 模块中的内置类型，可以看到，除了 dict 和 set 之外，第二行的所有内置类型都是序列类型。除此之外，标准库中还定义了其他序列类型，比如 array 模块的 array 数组类型，collections 模块中的 deque 双端队列类型。</p>
<p>对于这些序列类型，按照序列内可容纳的类型，可以划分为以下两组：</p>
<ul>
<li><strong>容器序列</strong>：list、tuple 和 collections.deque 这些序列类能存放不同类型的数据；</li>
<li><strong>扁平序列</strong>：str、bytes、bytearray、memoryview、array.array 和 range 这类序列类只能容纳一种或某种特定类型的数据。</li>
</ul>
<p>容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列存放的是值而不是引用。扁平序列存储在一段连续的内存空间之上，只能存放诸如字符、字节和数值这种基础类型。</p>
<p>序列类型还能按照能否被修改来分类：</p>
<ul>
<li><strong>可变序列</strong>：list、bytearray、memoryview、array.array 和 collections.deque；</li>
<li><strong>不可变序列</strong>：tuple、str、bytes 和 range。</li>
</ul>
<p>可变序列 MutableSequence 也定义在 <code>collections.abc</code> 模块中，并在继承 Sequence 的基础上还添加了一些支持序列修改的默认方法，如 <code>append()</code>、<code>pop()</code> 方法等。除了 Sequence 基类中要实现的 <code>__getitem__</code> 和 <code>__len__</code> 方法外，可变序列还要求具体子类必须实现 <code>__setitem__</code>、<code>__delitem__</code> 和 <code>insert()</code> 方法。</p>
<p>序列不可变意味着序列一旦被声明赋值，序列的大小就固定下来，其内的元素也不能被修改。这里用来说明序列可变不可变的典型案例是列表和元组。在 Python 中，列表是可变的，元组是不可变的。列表可变体现在它支持对元素的增加删除和直接赋值，且列表支持<strong>就地运算</strong>，比如使用 “+=” 运算符可以直接将一个可迭代对象中的元素添加到当前列表的末尾。而元组是不可变的，元组一经定义大小就已固定，不能增加删除元素，也不对其内元素重新赋值。即使元组也支持就地运算符，但会生成一个新的元组对象重新绑定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>]  <span class="comment"># list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4411278528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4411278528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4410964416</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t += (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4411277824</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>此外，Python 中的可散列对象一定是不可变类型，散列方法 <code>__hash__</code> 通常和 <code>__eq__</code> 方法一起用来判断两个对象是否相等，如集合 set 和字典的键要求元素是可散列的，这被用来判断元素是否重复。所以，元组可以作为集合的元素和字典的键，而列表却不可以。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t1) == <span class="built_in">id</span>(t2)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(t1) == <span class="built_in">hash</span>(t2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>,)])</span><br><span class="line">&#123;(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>,)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(&#123;(<span class="number">1</span>, <span class="number">2</span>): <span class="number">1</span>&#125;)</span><br><span class="line">&#123;(<span class="number">1</span>, <span class="number">2</span>): <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注：在散列时，元组内的每一项元素会被散列然后进行 XOR 异或运算，因此只有当元组中的每个元素都是不可变类型时，该元组才能被散列。</p>
<h2 id="map、filter-与列表推导"><a href="#map、filter-与列表推导" class="headerlink" title="map、filter 与列表推导"></a>map、filter 与列表推导</h2><p>列表是 Python 中非常重要且常用的内置类型，列表被注册为可变序列的虚拟子类，<code>MutableSequence.register(list)</code>，所以列表的性质与可变序列性质相符，可以阅读 <code>collections.abc</code> 模块中 MutableSequence 类的源码进行了解。列表的性质不做过多介绍，这一节我想介绍一下列表推导。在上一节中就曾经使用 <code>all()</code>、<code>any()</code> 方法结合列表推导，巧妙地展示了哪些内置类型是序列类的子类。</p>
<p>在介绍列表推导之前，有必要先介绍以下几个函数：<code>map()</code>、<code>filter()</code> 和 <code>reduce()</code> 函数。这几个函数是函数式编程的范例函数。它们都是用于处理可迭代序列的基本函数，所以被视为可迭代数据集函数式编程的基石，包含了数据集的映射、过滤和规约三个思想。所有支持函数式编程的语言都提供了这些函数的接口。Java 8 新增的 Stream API 配合箭头函数可以写出很优雅的链式函数，同样，JavaScript 中也支持链式写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&gt; l.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x)</span><br><span class="line">[ <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> ]</span><br><span class="line">&gt; l.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x).filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">10</span>)</span><br><span class="line">[ <span class="number">16</span>, <span class="number">25</span> ]</span><br><span class="line">&gt; l.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x).filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">10</span>).reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)</span><br><span class="line"><span class="number">41</span></span><br></pre></td></tr></table></figure>

<p>相比之下，Python 中的写法就不那么优雅了，map、filter 和 reduce 函数作为内置库或者标准库中的函数提供，序列本身并没有实现这些方法，所以不能通过 dot 运算符直接调用，而需要将序列作为这些函数的参数传入。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a><code>map()</code></h3><blockquote>
<p><code>map(func, *iterables) --&gt; map object</code></p>
<p>Make an iterator that computes the function using arguments from each of the iterables.  Stops when the shortest iterable is exhausted.</p>
</blockquote>
<p>map 函数，又称映射函数，定义在内置模块 builtins 模块中。map 函数将可迭代对象的每个元素依次应用于 func 函数进行映射，返回的 map object 是一个可以依次产出映射后元素的生成器对象，可以使用 <code>list()</code> 包装一次性输出。传入的函数 func 可以是预先定义好的函数，也可以是 lambda 表达式定义的匿名函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(square, <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x106ebb910</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(square, <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>

<p>从函数签名来看，map 函数能够接受多个可迭代对象，映射时将依次从每个可迭代对象中各取出一个元素应用于 func 函数，因此 func 也须接受同样数量的参数。如果这些可迭代对象的元素个数不一致，以个数最少的为标杆，即个数最少的可迭代对象遍历完毕时终止迭代。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x * y, <span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x * y, <span class="built_in">range</span>(<span class="number">10</span>), <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a><code>filter()</code></h3><blockquote>
<p><code>filter(function or None, iterable) --&gt; filter object</code></p>
<p>Return an iterator yielding those items of iterable for which function(item) is true. If function is None, return the items that are true.</p>
</blockquote>
<p>filter 函数，又称过滤函数，定义在内置模块 builtins 模块中。过滤函数将可迭代对象中的每个元素应用于谓词函数 function 后为 True 的保留下来。返回的 filter object 也是一个生成器对象，可以依次产出过滤后为真的元素。如果 function 为 None，直接判断元素是否为真值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">5</span>, <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="literal">None</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="number">0.0</span>, -<span class="number">1</span>, [], (<span class="number">1</span>, <span class="number">2</span>)]))</span><br><span class="line">[<span class="number">1</span>, <span class="literal">True</span>, -<span class="number">1</span>, (<span class="number">1</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a><code>reduce()</code></h3><blockquote>
<p><code>reduce(function, sequence[, initial]) -&gt; value</code></p>
<p>Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. For example, reduce(lambda x, y: x + y, [1, 2, 3, 4, 5]) calculates ((((1 + 2) + 3) + 4) + 5).  If initial is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty.</p>
</blockquote>
<p>reduce 函数，又称规约函数，定义在 functools 模块中。规约函数的参数除了函数和序列之外，还接收一个可选的初始值。规约函数会将一个序列从左至右逐步规约为一个值。参数 function 接收两个参数，第一个参数代表每步规约后的累积值（首次规约为初始值），第二个参数代表每次迭代的序列中的元素，返回值为规约的结果，作为下一步规约的第一个参数传入。也就是说，function 函数的第一个参数、每步规约的返回值和 reduce 函数的返回值应为同一类型，function 的第二个参数为迭代序列的元素类型，两者可以是相同类型也可以是不同类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x + y, <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="number">45</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">concat_string</span>(<span class="params">s, ch</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> s + <span class="built_in">str</span>(ch)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(concat_string, [<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>], <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;0a1b&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h3><p>如果想像 JavaScript 代码演示的那样，依次对一个序列数据流进行映射、过滤和规约操作，Python 的写法会显得不那么优雅。由于序列必须作为参数传入，无法放在左侧使用 dot 运算符进行链式书写，我们不得不编写多层嵌套的表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &lt; <span class="number">50</span>, <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, <span class="built_in">range</span>(<span class="number">10</span>))))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(operator.add, (<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &lt; <span class="number">50</span>, <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, <span class="built_in">range</span>(<span class="number">10</span>)))))</span><br><span class="line"><span class="number">140</span></span><br></pre></td></tr></table></figure>

<p>且不说冗余的 lambda 关键字，即使预先定义了函数使用函数名代替，整个表达式从右至左的执行循序也会不利于理解。所幸的是，Python 提供了一种精炼的表达式，来代替多层嵌套下纠缠不清的 map 和 filter 方法，那就是<strong>列表推导</strong>（list comprehension）。</p>
<p>列表推导是一个语法糖，可以根据可迭代对象构建出一个新的列表。列表推导使用一对中括号 “[]”，内部至少包含一个 for 循环表达式，对应 map 方法；以及可选的 if 条件表达式，对应 filter 方法。列表推导返回的是列表类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x &lt; <span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[_ * _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> _ &lt; <span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>,)] <span class="keyword">for</span> x <span class="keyword">in</span> y]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>表达式内的变量是一个局部变量，作用域仅限于该列表推导表达式。但 Python2 中的列表推导存在变量泄漏问题，表达式内的变量会影响到上下文中的同名变量，在 Python 3 中这个缺陷已被修复。</p>
<p>列表推导也支持<strong>多重循环</strong>，即多个 for 循环表达式，这些 for 表达式会按照从左至右的顺序来嵌套。与多层嵌套的 for 循环函数一致，先定义（左侧）的 for 循环在外层，后定义（右侧）的 for 循环在内层。外层定义的变量可用作内层的 for 循环，如上述代码中的最后一个列表推导式。如果用函数形式书写，那么代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>,)] <span class="keyword">for</span> x <span class="keyword">in</span> y]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">flat</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>,)]:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> x <span class="keyword">in</span> y:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(flat())</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>字典和集合也有类似的推导机制，可以通过这些推导机制创建衍生的数据结构。字典推导可以从任何以键值对为元素的可迭代对象中构建出字典。集合推导可以从可迭代对象中去除重复元素，构建集合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;i: j <span class="keyword">for</span> j, i <span class="keyword">in</span> d.items()&#125;  <span class="comment"># 字典推导</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;i <span class="keyword">for</span> i <span class="keyword">in</span> d.keys()&#125;  <span class="comment"># 集合推导</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="列表推导的最佳实践"><a href="#列表推导的最佳实践" class="headerlink" title="列表推导的最佳实践"></a>列表推导的最佳实践</h4><p>使用列表推导的原则是：<strong>只用于创建新的列表，并且尽量保持简短，不建议使用含有两个以上表达式的列表推导</strong>。依照函数式编程中的纯函数定义，函数不应该对传入的参数进行修改，否则会产生副作用。所以列表推导不该对传入序列做修改，而应该只用于创建新的列表。尽量保持简短则是出于可读性的考量。如果包含两个较长的表达式，可以考虑拆分为两行。Python 会忽略 []、{} 和 () 中换行，所以可以省略不太好看的续行符 \。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>

<p>如果列表推导式过长，就要考虑是否需要使用函数形式改写，有时命名清晰且带有缩进的函数可读性要更高。</p>
<p>列表推导也不是银弹，相较于生成器表达式的惰性求值，它会<strong>及早求值</strong>（eager evaluation）。在声明了一个列表推导式时，序列中的所有数据都会被即时处理，并将处理后的完整列表存放在内存中。并且在推导过程中，对于输入序列的每个值都可能创建一个仅含一项元素的全新列表。所以当序列的数据量很大时，如读文件或读数据库，将会消耗大量内存并导致程序崩溃。所以，列表推导另一个最佳实践是：<strong>使用生成器表达式代替数据量较大的列表推导</strong>。生成式表达式将在后续章节进行介绍。</p>
<h2 id="可迭代对象、迭代器和生成器源码分析"><a href="#可迭代对象、迭代器和生成器源码分析" class="headerlink" title="可迭代对象、迭代器和生成器源码分析"></a>可迭代对象、迭代器和生成器源码分析</h2><p>迭代，或称循环，是数据处理的基石。Python 中的可迭代类型的抽象基类定义在 <code>collections.abc</code> 模块中，从抽象层次来说，可以分为以下三类：</p>
<ul>
<li><strong>可迭代对象</strong>，<code>class Iterable(metaclass=ABCMeta)</code>，抽象类；</li>
<li><strong>迭代器</strong>，<code>class Iterator(Iterable)</code>，继承自 Iterable 的抽象类；</li>
<li><strong>生成器</strong>，<code>class Generator(Iterator)</code>，继承自 Iterator 的抽象类。</li>
</ul>
<p>在这三个抽象基类的实现中，都有一个名为 <code>__subclasshook__</code> 的钩子方法，用于将实现了特定方法的类绑定为这些抽象基类的虚拟子类。如下是可迭代对象 Iterable 的部分代码，钩子方法检查了类中有无实现 <code>__iter__</code> 方法，对于实现了的类，会被绑定为 Iterable 的虚拟子类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterable</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span>(<span class="params">cls, C</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterable:</span><br><span class="line">            <span class="keyword">return</span> _check_methods(C, <span class="string">&quot;__iter__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br></pre></td></tr></table></figure>

<p>联系到鸭子类型一节中所说的“协议”的概念，可以得出结论：可迭代对象的协议需要实现 <code>__iter__</code> 方法；类似的，迭代器协议需要同时实现 <code>__iter__</code> 和 <code>__next__</code> 方法；生成器协议要更复杂一些，除了这两个方法外还需要实现  <code>send()</code>、<code>throw()</code> 和 <code>close()</code> 方法，这三个方法体现了生成器除了迭代之外的功能：可以用作<strong>协程</strong>。</p>
<p>除了钩子方法之外，<code>collections.abc</code> 模块中还使用 register 关键字手动绑定了 Iterator 和 Generator 的虚拟子类。这里截取了部分源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dict_keyiterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(&#123;&#125;.keys()))</span><br><span class="line">dict_valueiterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(&#123;&#125;.values()))</span><br><span class="line">dict_itemiterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(&#123;&#125;.items()))</span><br><span class="line">list_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>([]))</span><br><span class="line">range_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(<span class="built_in">range</span>(<span class="number">0</span>)))</span><br><span class="line">set_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(<span class="built_in">set</span>()))</span><br><span class="line">str_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">tuple_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(()))</span><br><span class="line"></span><br><span class="line">Iterator.register(dict_keyiterator)</span><br><span class="line">Iterator.register(dict_valueiterator)</span><br><span class="line">Iterator.register(dict_itemiterator)</span><br><span class="line">Iterator.register(list_iterator)</span><br><span class="line">Iterator.register(range_iterator)</span><br><span class="line">Iterator.register(set_iterator)</span><br><span class="line">Iterator.register(str_iterator)</span><br><span class="line">Iterator.register(tuple_iterator)</span><br><span class="line"></span><br><span class="line">generator = <span class="built_in">type</span>((<span class="keyword">lambda</span>: (<span class="keyword">yield</span>))())</span><br><span class="line">Generator.register(generator)</span><br></pre></td></tr></table></figure>

<p>上述代码出现的所有内置类型，包括 list、range、set、str 和 tuple，都实现了 <code>__iter__</code> 方法，所以都是可迭代对象。特殊一点的是字典的键、值和键值对，也都分别被定义为可迭代的视图类型 KeysView、ValuesView 和 ItemsView。这些类型都是 Python 的集合类型，集合由于继承了 Iterable 类，所以 <strong>Python 中的所有集合都是可迭代对象</strong>。此处说的集合不是内置类型 set 而是 Collection，定义在 <code>collections.abc</code> 模块中。也有人将 Collection 称之为“容器”的，这里将其称之为集合而不是容器是为了与 <code>collections.abc</code> 模块中的另一个类 Container 做区分。集合类的钩子方法会去检测是否实现了 <code>__len__</code>、<code>__iter__</code> 和 <code>__contains__</code> 这三个方法。</p>
<p>尽管上述所说的这些内置类型都是可迭代对象，但要注意它们并不是迭代器，被注册的是经过 <code>iter()</code> 方法包装后的类型。也就是说，访问这些内置类型的 <code>__iter__</code> 方法将会返回一个迭代器，即 <code>iter(iterable) -&gt; iterator</code>。迭代器除了能被 for 循环遍历外，还能使用 <code>next()</code> 方法产出下一个值。编码时如果要使用 <code>next()</code> 方法，首先要注意对象是不是一个迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(l, Iterator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">iter</span>(l)</span><br><span class="line">&lt;list_iterator <span class="built_in">object</span> at <span class="number">0x106e2f640</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(<span class="built_in">iter</span>(l))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>除了可迭代对象和迭代器之外，<code>collections.abc</code> 模块中还定义了生成器类 Generator，并将形如 <code>type((lambda: (yield))())</code> 的类型注册为了生成器的虚拟子类。其中，yield 是一个关键字，意为产出一个值。<strong>只要 Python 函数的定义中含有 yield 关键字，该函数就是生成器函数，调用生成器函数时会返回一个生成器对象</strong>。<code>lambda: (yield)</code> 语句其实是定义了一个返回生成器函数的匿名函数，再调用这个生成器函数得到生成器对象，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> (<span class="keyword">yield</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen()</span><br><span class="line">&lt;generator <span class="built_in">object</span> gen at <span class="number">0x104b36660</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(gen())</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">generator</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">(<span class="params"><span class="keyword">lambda</span>: (<span class="params"><span class="keyword">yield</span></span>)</span>)(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">generator</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>生成器尤为重要，有必要将其作为单独的一节进行介绍。下一节我们将介绍生成器函数的执行过程，以及如何使用生成器表达式返回一个生成器对象。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>所有生成器都是迭代器，因为生成器完全实现了迭代器接口。不过，根据《设计模式：可复用面向对象软件的基础》一书的定义，迭代器用于从集合中取出元素，而生成器用于“凭空”生成元素。通过斐波那契数列能很好地说明二者之间的区别：斐波纳契数列中的数有无穷多个，无法将它们都装在一个集合里，但是生成器可以在每次需要时生成一项元素。因此，尽管 Python 社区中经常将迭代器和生成器视为同一概念，你也要明白生成器所具有的特殊语义。</p>
<h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><p>前面我们说到，生成器函数是包含了 yield 关键字的函数，调用生成器函数时会返回一个生成器对象。也就是说，生成器函数是生成器的工厂函数。因此，生成器函数和普通的函数有着显著的行为差异：即使没有 return 语句，生成器函数依然会返回一个生成器对象。就算有，定义在 yield 语句后的 return 返回值也会被忽略。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen()</span><br><span class="line">&lt;generator <span class="built_in">object</span> gen at <span class="number">0x10ddd9820</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(gen())</span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>“yield” 这个单词，除了产出还有<strong>让步</strong>的含义，对于生成器函数中的 yield 来说，这两个含义都成立。让步体现在，生成器函数在执行到 yield 语句产出值后，会作出让步，暂停执行生成器，让调用方继续工作，直到需要下一个值时再调用 <code>next()</code>。下面使用 for 循环来更清楚地说明生成器函数定义体的执行过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;continue&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> gen_AB():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, c)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">start</span><br><span class="line">--&gt; A</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">--&gt; B</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>迭代时，for 机制的作用与 <code>g = iter(gen_AB())</code> 一样，生成器的 <code>__iter__</code> 方法会返回生成器对象本身，然后每次迭代时调用 <code>next(g)</code>。</p>
<ul>
<li>在 for 循环中第一次隐式调用 next 函数时，会打印 ‘start’，然后停留在第一个 yield 语句，产出值 ‘A’；</li>
<li>第二次隐式调用 next 函数时，会打印 ‘continue’，然后停留在第一个 yield 语句，产出值 ‘B’；</li>
<li>第三次隐式调用 next 函数时，打印 ‘end’，到达函数定义体的末尾，导致生成器对象抛出 StopIteration 异常。for 机制会捕获异常，因此循环终止时不会报错。</li>
</ul>
<p>如果显式调用 <code>next()</code> 方法，那么生成器函数定义体被执行的过程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = <span class="built_in">iter</span>(gen_AB())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line">start</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line">end</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>在这个例子中你可以看到，定义在生成器函数体内的 print 语句并没有在生成器函数被调用时就立即打印，而被延迟到调用 <code>next(g)</code> 时才打印。同样，如果在生成器函数中加入复杂的处理逻辑，该逻辑只在被 <code>next()</code> 调用时才进行处理，从而达到延迟处理的目的。我们将生成器的这一特性归纳为<strong>惰性求值</strong>（lazy evaluation），即尽可能地延后求值，只在需要时才进行求值。这样做的优点是可以节省内存，还可能避免无用的处理。</p>
<p>与惰性求值相对的是<strong>及早求值</strong>（eager evaluation），比如之前介绍的列表推导，列表这种数据结构一定要求内部的元素是已明确其值的，并且会将完整的列表保存在内存中。因此，《Effective Python》中提出这么一条：<strong>考虑用生成器来改写直接返回列表的函数</strong>。实际上，Python 3 已经对一些原本原本返回列表的函数使用生成器进行了改写。比如 Python 2 中返回完整列表的 <code>range()</code> 函数，现在也返回一个类似生成器的对象。如果一定要让 <code>range()</code> 函数返回列表，必须明确指明，如 <code>list(range(100))</code>。</p>
<p>定义生成器函数时，唯一需要留意的就是：<strong>函数返回的那个迭代器是有状态的</strong>，调用者不应该反复使用它。</p>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>除了定义包含 yield 关键字的生成器函数可以返回生成器外，生成器表达式也可以返回生成器对象。相比于列表推导的及早求值，生成器表达式能够进行惰性求值：不会迫切地构建列表，而是返回一个生成器，按需产出元素。也就是说，如果说列表推导时构建列表的工厂，那么生成器表达式就是构建生成器的工厂。</p>
<p>生成器表达式与列表推导的唯一区别是使用了一对圆括号 “()” 代替列表推导中的中括号 “[]”。我们使用之前定义的生成器函数 <code>gen_AB()</code> 来演示生成器表达式与列表推导之间的区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()]  <span class="comment"># list comprehension</span></span><br><span class="line">start</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> res1:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">--&gt; A</span><br><span class="line">--&gt; B</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB())  <span class="comment"># generator expression</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x10dea8f20</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> res2:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">start</span><br><span class="line">--&gt; A</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">--&gt; B</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>归因于列表的及早求值，在声明列表推导表达式时，<code>gen_AB()</code> 函数中的 print 语句被立即执行了，函数产出的两个值 ‘A’、’B’ 也被存放在构建出的列表中。而生成器表达式则将这个过程推迟到值真正需要之时，即 for 循环隐式调用 <code>next()</code> 之时。</p>
<p>前面提到，生成器对象是有状态的，这里体现在，一个生成器对象产出的值只能被消费一次，除非定义一个新的个生成器对象重新绑定。你可以想象成，生成器对象中存在不能回头的“指针”，每次调用 <code>next()</code> 方法时指向下一个元素，这个过程不可逆。所以对于同一个生成器对象重复调用时可能会产生意想不到的结果。比如下面代码中第二次调用 <code>list(res2)</code> 返回一个空列表，因为第一次调用时“指针”就已经到头了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(res2)</span><br><span class="line">start</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(res2)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(res2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>所以如果要对生成器对象进行多次迭代，一种方法是使用列表将生成器中的所有元素备份下来，另一种是定义一个新的生成器对象重新绑定。由此可见，尽管生成器对象相比列表能够通过惰性求值节省内存，但如果每次迭代时定义新的生成器对象，求值过程也会被重复多次。而列表推导只会在声明时进行一次求值，并将结果保存在列表中可供多次迭代调用，这其实是一种空间消耗和时间消耗的权衡。</p>
<h3 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h3><p>刚才所提到的生成器产出值被消费的概念，也侧面体现了生成器可以作为“协程”的语义。“协程”从字面意思理解就是协作的进程，协作的进程之间需要进行通信，就需要消费者和生产者之间建立通道。从 Python 3.3 开始引入了一个新的句法：<code>yield from</code>，类似于其他语言中的 await 关键字。它可以在两个生成器之间建立通道，将产出的值从一个生成器传输到另一个生成器。</p>
<p>如果生成器函数需要产出其他生成器的值，传统的做法是使用 for 循环遍历生成器的元素并产出。以下定义了一个能够产出多个生成器产出值的生成器函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">chain</span>(<span class="params">*iterables</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> i</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1 = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(chain(g1, g2))</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>引入的 <code>yield from</code> 句法可以直接将一个生成器的所有产出值产出，而不用遍历生成器对象。因此我们可以编写只有一层的 for 循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">chain</span>(<span class="params">*iterables</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> <span class="keyword">from</span> it</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1 = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain(g1, g2)</span><br><span class="line">&lt;generator <span class="built_in">object</span> chain at <span class="number">0x10dea8e40</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(chain(g1, g2))</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>chain 函数依然返回一个生成器对象，其中的 <code>yield from it</code> 语句对 it 对象所做的第一件事是调用 <code>iter(it)</code> 获得一个迭代器，所以 it 对象可以是任何可迭代对象。我们将 <code>yield from &lt;iterable&gt;</code> 表达式中用于获取值的 <code>&lt;iterable&gt;</code> 称为<strong>子生成器</strong>（subgenerator），即上面代码中的 g1、g2；将包含了 <code>yield from</code> 语句的生成器函数，即 chain 函数，称为委派生成器。<code>yield from</code> 的主要功能是打开双向通道，把最外层的调用层与最内层的子生成器连接起来，这样二者可以直接发送和产出值。</p>
<p>上述的例子只能勉强算一个协程的案例，其中的“协作”部分体现的不够明显，只是简单的将一个生成器的值传输给另一个生成器产出。真正的协作应该是通过生成器对象的 <code>send()</code> 方法将值从客户端传输给生成器。在后面章节我们会专门介绍协程，里面会提及生成器的 <code>send()</code>、<code>throw()</code> 和 <code>close()</code> 方法，以及 <code>yield from</code> 句法的其他作用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/03/18/Python-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/18/Python-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" class="post-title-link" itemprop="url">Python 运算符重载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-18 11:44:40" itemprop="dateCreated datePublished" datetime="2021-03-18T11:44:40+08:00">2021-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>运算符重载这个语言特性其实一直备受争议，鉴于太多 C++ 程序员滥用这个特性，Java 之父 James Gosling 很干脆的决定不为 Java 提供运算符重载功能。但另一方面，正确的使用运算符重载确实能提高代码的可读性和灵活性。为此，Python 施加了一些限制，在灵活性、可用性和安全性之间做到了平衡。主要包括：</p>
<ul>
<li>不能重载内置类型的运算符</li>
<li>不能新建运算符，只能重载现有的</li>
<li>is、and、or 和 not 运算符不能重载（但位运算符 &amp;、| 和 ~ 可以）</li>
</ul>
<p>Python 的运算符重载非常方便，只需要<strong>重写对应的特殊方法</strong>。在上面一节我们已经介绍了如何重载一个向量类的 “+” 和 “==” 运算符，实现还算简单，接下来我们考虑一个更复杂的情形：不只限于二维向量相加的 Vector 类，以引入 Python 运算符重载更全面的知识点。</p>
<h3 id="改进版的-Vector"><a href="#改进版的-Vector" class="headerlink" title="改进版的 Vector"></a>改进版的 Vector</h3><p>考虑到高维向量的应用场景，我们应当支持不同维度向量的相加操作，并且为低维向量的缺失值做默认添 0 处理，这也是一些统计分析应用的常用缺失值处理方式。基于此，首先要确定的便是，Vector 类的构造函数不再只接收固定数量和位置的参数，而应当接收可变参数。</p>
<p>通常情况下，Python 函数接收可变参数有两种处理方式。一种是接收不定长参数，即 <code>*args</code>，这样我们就可以用类似 <code>Vector(1, 2)</code> 或 <code>Vector(1, 2, 3)</code> 的方式来初始化不同维数的向量类。在这种情况下，函数会将不定长参数打包成名为 <code>args</code> 的元组进行处理，当然能满足迭代的需求。虽然这种方式看上去很直观，但考虑到向量类从功能上讲也是一个序列类，而 Python 中的内置序列类型的构造方法基本上都是接收<strong>可迭代对象</strong>（Iterable）作为参数，考虑到一致性我们也采取这种形式，并且通过重写 <code>__repr__</code> 输出更直观的向量类的数学表示形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, components: Iterable</span>):</span></span><br><span class="line">        self._components = array(<span class="string">&#x27;i&#x27;</span>, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self._components))</span><br></pre></td></tr></table></figure>

<p>为了方便之后对向量分量的处理，将其保存在一个数组中，第一个参数 ‘i’ 标明这是一个整型数组。这样做还有一个好处就是，保证了向量序列的不可变性，这一点同 Python 内置类型不可变列表 tuple 类似。如此定义后，我们可以这样实例化 Vector 类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector(<span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>由于 Vector 类接收 Iterable 对象作为构造参数，而任何实现了 <code>__iter__</code> 方法的类都会被绑定为 Iterable 的子类，所以可以传入 list、tuple 和 range 等可迭代对象。</p>
<p>接下来，重载 Vector 类的加号运算符，为了满足之前所说的低维向量默认添 0 处理，我们引入迭代工具包下的 <code>zip_longest</code> 方法，它可以接收多个可迭代对象，将其打包成一个个的元组，如 <code>zip_longest(p, q, ...) --&gt; (p[0], q[0]), (p[1], q[1]), ...</code>。同时关键字参数 fillvalue 可以指定填充的默认值。但在这之前，由于 <code>zip_longest</code> 参数必须是可迭代对象，我们还需要为 Vector 类实现 <code>__iter__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br></pre></td></tr></table></figure>

<p><code>__add__</code> 的实现逻辑很简单，按位相加返回一个新的 Vector 对象，在构造 Vector 对象时使用到了生成器表达式，而生成器 Generator 是 Iterable 的子类，所以也符合构造参数的要求。</p>
<p>为了验证效果，还需要重载 <code>==</code> 运算符，考虑到两个向量维度可能不同，首先要对维度，也就是向量分量的个数进行比较，为此需要重写 <code>__len__</code> 方法。其次是进行按位比较，内置的 zip 函数可以将两个迭代对象打包从而同时进行遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self) == <span class="built_in">len</span>(other) <span class="keyword">and</span> <span class="built_in">all</span>(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(self, other))</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践：用 zip 函数同时遍历两个迭代器</strong>。《Effective Python》的第 11 条提到了这一点。在 Python 中经常会遇到需要平行地迭代两个序列的情况。一般的做法是，写一个 for 循环对一个序列进行迭代，然后想办法获得其索引，通过索引访问第二个序列的对应元素。常见的做法是借助 enumerate 函数，通过 <code>for index, item in enumerate(items)</code> 的方式获取索引。现在有一种更优雅的写法，使用内置的 zip 函数，它可以将两个及以上的迭代器封装成生成器，这个生成器能在每次迭代时从每个迭代器中取出下一个值构成元组，再结合元组拆包就能达到平行取值的目的，如上述代码中的 <code>for a, b in zip(self, other)</code>。显然，这种方式可读性更高。但如果待遍历序列不等长，zip 函数会提前终止，这可能导致意外的结果。所以在<strong>不确定序列是否等长</strong>的条件下，可以考虑使用 itertools 模块中过的 <code>zip_longest</code> 函数。</p>
<p>至此，重载的 “+” 和 “==” 运算符初步完成了，可以编写测试用例进行验证了，作为本系列第一个比较全面的测试类，我将在文末贴出完整的测试代码，这里先在控制台演示重载之后的效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + Vector((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>由于 <code>__add__</code> 方法中的 other 只要求是可迭代对象而没有类型限制，所以重载的加号运算符不止可以对两个 Vector 实例进行相加，也支持 Vector 实例与一个可迭代对象相加，不管是 list、tuple 还是其他 Iterable 类型。但需要注意的是，可迭代对象必须作为第二个操作数，也就是 “+” 右侧的操作数。理解这一点并不难，因为我们只实现了 Vector 的 <code>__add__</code> 方法，而 Python 的内置类型类可不明白怎么对加上一个向量进行处理，比如下面报错提示的 tuple 类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">1</span>) + v1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate <span class="built_in">tuple</span> (<span class="keyword">not</span> <span class="string">&quot;Vector&quot;</span>) to <span class="built_in">tuple</span></span><br></pre></td></tr></table></figure>

<h4 id="反向运算符"><a href="#反向运算符" class="headerlink" title="反向运算符"></a>反向运算符</h4><p>那么有什么方法，不需要重写 tuple 类中的 <code>__add__</code> 方法（显然这种方式也不合理），也能使重载的加号运算符支持 <code>(1, 1) + v1</code> 呢？答案是有的，在此之前，不得不提到 Python 的<strong>运算符分派机制</strong>。</p>
<p>对于中缀运算符，Python 提供了特殊的分派机制。对于表达式 <code>a + b</code>，解释器会执行以下几步操作：</p>
<ol>
<li>如果 a 有 <code>__add__</code> 方法且不返回 NotImplemented，调用 <code>a.__add__(b)</code>；</li>
<li>如果 a 没有 <code>__add__</code> 方法或调用返回 NotImplemented，检查 b 有没有 <code>__radd__</code> 方法，如果有且不返回 NotImplemented，调用 <code>b.__radd__(a)</code>；</li>
<li>如果 b 没有 <code>__radd__</code> 方法或调用返回 NotImplemented，抛出 TypeError。</li>
</ol>
<p>注：NotImplemented 是 Python 内置的特殊单例值，如果运算符特殊方法不能处理给定的操作数，那么要把它返回给解释器。</p>
<p>如果将 <code>__add__</code> 称为正向方法，那么 <code>__radd__</code> 就可以称为 <code>__add__</code> 方法的<strong>反向方法</strong>，或者右向方法，这个方法的作用是支持操作数从右至左进行计算。因此，为了支持 <code>(1, 1) + v1</code>，我们需要定义 Vector 类的反向方法。而反向方法只需要委托给已经定义好的 <code>__add__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self + other</span><br></pre></td></tr></table></figure>

<p><code>__radd__</code> 通常就是这么简单，由于解释器调用的是 <code>b.__radd__(a)</code>，而这里的 b 即 v1 是一个 Vector 实例，能够与一个元组相加，所以这时 <code>(1, 1) + v1</code> 不会再报错。同时，还对 <code>__add__</code> 方法做了些修改：<strong>捕获 TypeError 异常并返回 NotImplemented</strong>。这也是一种重载中缀运算符时的最佳实践，抛出异常将导致算符分派机制终止，而抛出 NotImplemented 则会让解释器再尝试调用反向运算符方法。当运算符左右操作数是不同类型时，反向方法也许能够正常运算。</p>
<p>现在，验证重载的反向运算符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">1</span>) + v1</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] + v1</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>对于比较运算符，正向和反向调用使用的是同一系列方法，只不过对调了参数。注意是同一系列而不是同一方法。例如，对 “==” 来说，正向调用是 <code>a.__eq__(b)</code>，那么反向调用就是 <code>b.__eq__(a)</code>；而对 “&gt;” 来说，正向 <code>a.__gt__(b)</code> 的反向调用是 <code>b.__lt__(a)</code>。</p>
<p>如果正向调用左操作数的 <code>__eq__</code> 方法返回 NotImplemented，Python 解释器会去尝试反向调用右操作数的 <code>__eq__</code> 方法，若右操作数也返回 NotImplemented，解释器不会抛出 TypeError 异常，而是会比较对象的 ID 作最后一搏。</p>
<p>对元组和 Vector 实例比较的具体步骤如下：</p>
<ol>
<li>尝试调用 tuple 的 <code>__eq__</code> 方法，由于 tuple 不认识 Vector 类，返回 NotImplemented；</li>
<li>尝试调用 Vector 的 <code>__eq__</code> 方法，返回 True。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">2</span>) == Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>另外，对于 “!=” 运算符，Python 3 的最佳实践是只实现 <code>__eq__</code> 方法而不实现它，因为从 object 继承来的 <code>__ne__</code> 方法会对 <code>__eq__</code> 返回的结果取反。而 Python 2 则不同，重载 “==” 的同时也应重载 “!=” 运算符。Python 之父 Guido 曾提到这是 Python 2 的一个设计缺陷且已在 Python 3 中修复了。</p>
<h4 id="就地运算符"><a href="#就地运算符" class="headerlink" title="就地运算符"></a>就地运算符</h4><p>增量赋值运算符，也称就地运算符，如 “+=”，有两种运算方式。对于不可变类型来说，<code>a += b</code> 的作用与 <code>a = a + b</code> 完全一致，增量赋值不会修改不可变目标，而是<strong>新建实例</strong>，然后重新绑定，也就是说运算前后的 a 不是同一对象。对于不可变类型，这是预期的行为。</p>
<p>而对于实现了就地运算符方法，如 <code>__iadd__</code>，的可变类型来说，<code>a += b</code> 会调用该方法就地修改左操作数，而不是创建一个新的对象。这一点，Python 的内置类型，不可变的 tuple 和可变的 list 就可以很好的说明。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4359598592</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t += (<span class="number">3</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4359584960</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4360054336</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4360054336</span></span><br></pre></td></tr></table></figure>

<p>阅读源码你会发现，list 类 实现了 <code>__iadd__</code> 方法而 tuple 类没有实现。对 list 而言，”+=” 就地运算符的逻辑与其 <code>extend()</code> 方法相同，将一个可迭代对象的元素依次追加到当前列表的末尾。而对 tuple 而言，即使没有定义 <code>__iadd__</code> 方法，使用 “+=” 也会委托给 <code>__add__</code> 方法进行运算返回一个新的 tuple 对象。</p>
<p>从设计层面考虑，Vector 应当与元组一致，被设计成不可变类型，即每次对向量进行运算后生成一个新的向量。站在函数式编程的角度，这种设计无副作用（不在函数内部修改传入参数状态），从而避免一些难以预料的问题。因此<strong>对于不可变类型，一定不能实现就地特殊方法</strong>。对 Vector 使用 “+=” 运算符会调用现有的 <code>__add__</code> 方法生成一个新的 Vector 实例。<code>v1 += (1, 1)</code> 与 <code>v1 = v1 + (1, 1)</code> 行为一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(v1)</span><br><span class="line"><span class="number">4360163280</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 += (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(v1)</span><br><span class="line"><span class="number">4359691376</span></span><br></pre></td></tr></table></figure>

<h3 id="附录：代码"><a href="#附录：代码" class="headerlink" title="附录：代码"></a>附录：代码</h3><h4 id="vector-py"><a href="#vector-py" class="headerlink" title="vector.py"></a>vector.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, components: Iterable</span>):</span></span><br><span class="line">        self._components = array(<span class="string">&#x27;i&#x27;</span>, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self._components))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self) == <span class="built_in">len</span>(other) <span class="keyword">and</span> <span class="built_in">all</span>(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(self, other))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self + other</span><br></pre></td></tr></table></figure>

<h4 id="vector-test-py"><a href="#vector-test-py" class="headerlink" title="vector_test.py"></a>vector_test.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestVector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_compare_two_vectors_with_override_compare_operators</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        v2 = Vector((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        v3 = Vector([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">        v4 = Vector([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> v1 == v2</span><br><span class="line">        <span class="keyword">assert</span> v3 != v2</span><br><span class="line">        <span class="keyword">assert</span> v4 != v3</span><br><span class="line">        <span class="keyword">assert</span> (<span class="number">1</span>, <span class="number">2</span>) == v2</span><br><span class="line">        <span class="keyword">assert</span> v2 == [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_add_two_same_dimension_vectors_with_override_add_operator</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        v2 = Vector((<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        result = Vector([<span class="number">2</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> result == v1 + v2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_add_two_different_dimension_vectors_with_override_add_operator</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        v2 = Vector((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        result = Vector([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> result == v1 + v2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_add_vector_and_iterable_with_override_add_operator</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> v1 + (<span class="number">1</span>, <span class="number">1</span>) == (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">assert</span> v1 + [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] == (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_add_iterable_and_vector_with_override_radd_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> (<span class="number">1</span>, <span class="number">1</span>) + v1 == (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] + v1 == (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_create_new_vector_when_use_incremental_add_operator</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        id1 = <span class="built_in">id</span>(v1)</span><br><span class="line">        v1 += (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">id</span>(v1) != id1</span><br></pre></td></tr></table></figure>

<h3 id="附录：常见可重载运算符"><a href="#附录：常见可重载运算符" class="headerlink" title="附录：常见可重载运算符"></a>附录：常见可重载运算符</h3><h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">特殊方法</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center"><code>__neg__</code></td>
<td align="left">一元取负算术运算符</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center"><code>__pos__</code></td>
<td align="left">一元取正算术运算符</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center"><code>__invert__</code></td>
<td align="left">对整数按位取反，定义为 ~x == -(x+1)</td>
</tr>
</tbody></table>
<h4 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">正向方法</th>
<th align="center">反向方法</th>
<th align="center">就地方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center"><code>__add__</code></td>
<td align="center"><code>__radd__</code></td>
<td align="center"><code>__iadd__</code></td>
<td align="center">加法或拼接</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><code>__sub__</code></td>
<td align="center"><code>__rsub__</code></td>
<td align="center"><code>__isub__</code></td>
<td align="center">减法</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center"><code>__mul__</code></td>
<td align="center"><code>__rmul__</code></td>
<td align="center"><code>__imul__</code></td>
<td align="center">乘法或重复复制</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center"><code>__truediv__</code></td>
<td align="center"><code>__rtruediv__</code></td>
<td align="center"><code>__itruediv__</code></td>
<td align="center">除法</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center"><code>__floordiv__</code></td>
<td align="center"><code>__rfloordiv__</code></td>
<td align="center"><code>__ifloordiv__</code></td>
<td align="center">整除</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center"><code>__mod__</code></td>
<td align="center"><code>__rmod__</code></td>
<td align="center"><code>__imod__</code></td>
<td align="center">取模</td>
</tr>
<tr>
<td align="center"><code>divmod()</code></td>
<td align="center"><code>__divmod__</code></td>
<td align="center"><code>__rdivmod__</code></td>
<td align="center"><code>__idivmod__</code></td>
<td align="center">返回由整除的商和模数组成的元组</td>
</tr>
<tr>
<td align="center">**，<code>pow()</code></td>
<td align="center"><code>__pow__</code></td>
<td align="center"><code>__rpow__</code></td>
<td align="center"><code>__ipow__</code></td>
<td align="center">取幂</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center"><code>__matmul__</code></td>
<td align="center"><code>__rmatmul__</code></td>
<td align="center"><code>__imatmul__</code></td>
<td align="center">矩阵乘法</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center"><code>__and__</code></td>
<td align="center"><code>__rand__</code></td>
<td align="center"><code>__iand__</code></td>
<td align="center">按位与</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center"><code>__or__</code></td>
<td align="center"><code>__ror__</code></td>
<td align="center"><code>__ior__</code></td>
<td align="center">按位或</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center"><code>__xor__</code></td>
<td align="center"><code>__rxor__</code></td>
<td align="center"><code>__ixor__</code></td>
<td align="center">按位异或</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center"><code>__lshift__</code></td>
<td align="center"><code>__rlshift__</code></td>
<td align="center"><code>__ilshift__</code></td>
<td align="center">按位左移</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center"><code>__rshift__</code></td>
<td align="center"><code>__rrshift__</code></td>
<td align="center"><code>__irshift__</code></td>
<td align="center">按位右移</td>
</tr>
</tbody></table>
<h4 id="比较运算符-1"><a href="#比较运算符-1" class="headerlink" title="比较运算符"></a>比较运算符</h4><table>
<thead>
<tr>
<th align="center">分组</th>
<th align="center">中缀运算符</th>
<th align="center">正向方法调用</th>
<th align="center">反向方法调用</th>
<th align="center">后备机制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">相等性</td>
<td align="center">a == b</td>
<td align="center"><code>a.__eq__(b)</code></td>
<td align="center"><code>b.__eq__(a)</code></td>
<td align="center">返回 <code>id(a) == id(b)</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a != b</td>
<td align="center"><code>a.__ne__(b)</code></td>
<td align="center"><code>b.__ne__(a)</code></td>
<td align="center">返回 <code>not (a == b)</code></td>
</tr>
<tr>
<td align="center">排序</td>
<td align="center">a &gt; b</td>
<td align="center"><code>a.__gt__(b)</code></td>
<td align="center"><code>b.__lt__(a)</code></td>
<td align="center">抛出 TypeError</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a &lt; b</td>
<td align="center"><code>a.__lt__(b)</code></td>
<td align="center"><code>b.__gt__(a)</code></td>
<td align="center">抛出 TypeError</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a &gt;= b</td>
<td align="center"><code>a.__ge__(b)</code></td>
<td align="center"><code>b.__le__(a)</code></td>
<td align="center">抛出 TypeError</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a &lt;= b</td>
<td align="center"><code>a.__le__(b)</code></td>
<td align="center"><code>b.__ge__(a)</code></td>
<td align="center">抛出 TypeError</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/03/10/Python-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/10/Python-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Python 鸭子类型和特殊方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-10 22:19:15" itemprop="dateCreated datePublished" datetime="2021-03-10T22:19:15+08:00">2021-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Python-是动态强类型语言"><a href="#Python-是动态强类型语言" class="headerlink" title="Python 是动态强类型语言"></a>Python 是动态强类型语言</h2><blockquote>
<p><strong>Dynamic programming language</strong>: In computer science, a dynamic programming language is a class of high-level programming languages, which at runtime execute many common programming behaviours that <strong>static programming languages perform during compilation</strong>. These behaviors could include an extension of the program, by <strong>adding new code, by extending objects and definitions, or by modifying the type system</strong>.</p>
</blockquote>
<p>以上内容摘自维基百科对于动态编程语言（Dynamic programming language）的定义。动态语言是相对于静态语言而言的。相比之下，静态语言有更严格的语法限制，在编译阶段就能够确定数据类型，典型的静态语言包括 C、C++ 和 Java 等。这一类语言的优势在于代码结构规范，易于调试和重构。缺点则是语法冗杂，编码方式不灵活。</p>
<p>而动态语言最典型的特点在于不需要编码时指定数据类型，类型信息由运行时推断得出。常见的动态语言都是一些脚本语言，比如 JavaScript、Python、PHP 等。这类语言虽然调试和重构的支持不如静态语言，但由于没有类型约束编码更加灵活。</p>
<p>Python 就是一门动态编程语言，编码时不用指定类型，且运行时可以变更数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">a</span> = &#x27;1&#x27;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">a</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>尽管 “PEP 484 – Type Hints” 引入了类型提示，但它明确指出：Python 依旧是一门动态类型语言，作者从未打算强制要求使用类型提示，甚至不会把它变成约定。但是 API 作者能够添加可选的类型注解，执行某种静态类型检查。</p>
<p>另外值得注意的是，虽然 Python 支持运行时变更数据类型，但变量所指向的内存地址空间已经在变更时发生了变化。也就是说，数据类型变更后不再指向原先的内存地址空间。我们可以用查看对象内存地址的 <code>id()</code> 函数加以验证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">4316699376</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">123456</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">4316579216</span></span><br></pre></td></tr></table></figure>

<h3 id="强弱类型"><a href="#强弱类型" class="headerlink" title="强弱类型"></a>强弱类型</h3><p>确定了 Python 是动态语言后，接下来我们讨论<strong>强弱类型</strong>语言。首先，强弱类型与是否是动态语言没有必然联系，动态语言并不一定就是弱类型语言，Python 就是一门动态强类型语言。这里的“强弱”可以理解为用以<strong>描述编程语言对于混入不同类型的值进行运算时的处理方式</strong>。</p>
<p>比如在弱类型语言 JavaScript 中，我们可以直接对字符串和数值类型进行相加，虽然得出的结果并不一定是我们想要的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">&#x27;1&#x27;</span> + <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>

<p>出现这种现象的原因是 JavaScript 支持<strong>变量类型的隐式转换</strong>。上面的例子就是将数值类型隐式转换为了字符串类型再进行相加。也因此，JavaScript 中才会存在三个等号的判等运算符 <code>===</code>。与 <code>==</code> 不同，<code>===</code> 在判等时不会进行隐式转换，所以才会有下面这样的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span> == <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="number">1</span> === <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>而 Python 作为强类型语言，不支持类型的隐式转换，所以整型和字符型相加会直接报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> + <span class="string">&#x27;2&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">&#x27;int&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>

<p>所以，强弱类型语言的区别体现在：强类型语言在遇到函数声明类型和实际调用类型不符合的情况时会直接出错或者编译失败；而弱类型的语言可能会进行隐式转换，从而产生难以意料的结果。</p>
<h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><p>在面向对象的静态类型语言中，如果要实现一个带特定功能的序列类型，你可能会想到使用继承，以期能在添加特定功能的同时尽可能的重用代码。这符合面向对象的设计原则，但在 Python 中，继承却不是首选方案。</p>
<p>在 Python 这类动态类型语言中，有一种风格叫做<strong>鸭子类型</strong>（duck typing）。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口决定的，而是由”<strong>当前方法和属性的集合</strong>“决定。这个概念最早来源于 James Whitcomb Riley 提出的“鸭子测试”，“鸭子测试”可以这样表述：“如果一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么它就可以被称为鸭子。”</p>
<p>在 Python 中创建功能完善的序列类型无需使用继承，只需实现符合序列协议的方法。那么，协议又是什么呢？在面向对象编程中，协议是非正式的接口，只在文档中定义，不在代码中定义，可以看作是约定俗成的惯例。例如，Python 的迭代器协议就包含 <code>__iter__</code> 和 <code>__next__</code> 两个方法，任何实现了 <code>__iter__</code> 和 <code>__next__</code> 方法的类，Python 解释器会将其视为迭代器，所有迭代器支持的操作，该类也会支持，譬如 <code>next()</code> 方法和 <code>for</code> 循环。用鸭子类型来解释就是：这个类看起来像是迭代器，那它就是迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">IterDuck</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = IterDuck()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(IterDuck, Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(i, Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>由于实现了迭代器协议，上面代码中的 IterDuck 类甚至不需要显式的继承 Iterator 类，Python 解释器就已经将它绑定为 Iterator 类的子类。</p>
<p><strong>在鸭子类型中，关注点在于对象的行为，即提供的方法，而不在于对象所属的类型。</strong></p>
<h3 id="序列协议"><a href="#序列协议" class="headerlink" title="序列协议"></a>序列协议</h3><p>序列协议之所以要专门作为单独的一节，是因为序列在 Python 中尤为重要，Python 会特殊对待看起来像是序列的对象。序列协议包含 <code>__len__</code> 和 <code>__getitem__</code> 两个方法。任何类，只要实现了 <code>__len__</code> 和 <code>__getitem__</code> 方法，就可以被看作是一个序列，即使这一次 Python 解释器不再将其绑定为 Sequence 类的子类。</p>
<p>由于序列的特殊性，如果你知道类的具体应用场景，甚至只需要实现序列协议的一部分。下面的代码演示了一个只实现了 <code>__getitem__</code> 方法的类，对于序列操作的支持程度：尽管只实现了 <code>__getitem__</code> 方法，但 SeqDuck 实例却可以使用 <code>for</code> 循环迭代以及 <code>in</code> 运算符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">SeqDuck</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">range</span>(<span class="number">3</span>)[index]</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SeqDuck()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>]  <span class="comment"># __getitem__</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> s: <span class="built_in">print</span>(i)  <span class="comment"># __iter__</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> <span class="keyword">in</span> s  <span class="comment"># __contains__</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>即使没有 <code>__iter__</code> 方法，SeqDuck 实例依然是可迭代的对象，因为当 Python 解释器发现存在 <code>__getitem__</code> 方法时，会尝试调用它，传入从 0 开始的整数索引进行迭代（这是一种后备机制）。同样的，即使没有 <code>__contains__</code> 方法，但 Python 足够智能，能够迭代 SeqDuck 实例检查有没有指定元素。</p>
<p>综上，鉴于序列协议的重要性，如果没有 <code>__iter__</code> 和 <code>__contains__</code> 方法，Python 会尝试调用 <code>__getitem__</code> 方法设法让迭代和 <code>in</code> 运算符可用。</p>
<h3 id="绑定虚拟子类"><a href="#绑定虚拟子类" class="headerlink" title="绑定虚拟子类"></a>绑定虚拟子类</h3><p>你也许会有个疑问，为什么 IterDuck 和 SeqDuck 都没有显示继承父类，但 IterDuck 却是 Iterator 类的子类，而 SeqDuck 不是 Sequence 的子类呢？这要归因于 Python 的<strong>虚拟子类</strong>机制。一般情况下，使用 <code>register()</code> 方法可以将一个类注册为另一个类的虚拟子类，比如 <code>collections.abc</code> 模块中是这样将内置类型 tuple、str、range 和 memoryview 注册为序列类 Sequence 的虚拟子类的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">tuple</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">str</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">range</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">memoryview</span>)</span><br></pre></td></tr></table></figure>

<p>这也是为什么这些类的显示继承父类是 object，但同样能应用序列类的诸多方法。而对于用户自定义的类型来说，<strong>即使不注册，抽象基类也能把一个类识别为虚拟子类，这需要抽象基类实现一个名为 <code>__subclasshook__</code> 的特殊的钩子方法</strong>。如下是 <code>collections.abc</code> 模块中 Iterator 抽象基类的源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _collections_abc.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>(<span class="params">Iterable</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span>(<span class="params">cls, C</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterator:</span><br><span class="line">            <span class="keyword">return</span> _check_methods(C, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__next__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br></pre></td></tr></table></figure>

<p>对于实现了迭代器协议，即 <code>__iter__</code> 和 <code>__next__</code> 方法的类来说，它就会被钩子方法检测到并绑定为 Iterator 的虚拟子类，这解释了为什么 <code>issubclass(IterDuck, Iterator)</code> 会验证通过。类似的，可迭代对象 Iterable 协议要更加宽松，因为它只检查了 <code>__iter__</code> 方法。</p>
<p>那么为什么 SeqDuck 没有被绑定为 Sequence 的子类呢？因为 Sequence 类没有实现 <code>__subclasshook__</code> 钩子方法。Python 对序列的子类要求更加严格，即使实现了序列协议 <code>__len__</code> 和 <code>__getitem__</code> 方法的类可以被视为一个序列，但依然不能称之为序列的子类。最典型的例子就是内置类型字典。虽然字典实现了这两个方法，但它不能通过整数偏移值获取元素，且字典内的元素顺序是无序的，所以不能将其视为 Sequence 的子类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> <span class="type">Sequence</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;__getitem__&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">dict</span>) <span class="keyword">and</span> <span class="string">&#x27;__len__&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">dict</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">dict</span>, <span class="type">Sequence</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(d, <span class="type">Sequence</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">1</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>想要更深入地理解鸭子类型，必须要了解 Python 中的特殊方法。前面我们提到的以双下划线开头和结尾的方法，比如 <code>__iter__</code>，就称为<strong>特殊方法</strong>（special methods），或称为<strong>魔法方法</strong>（magic methods）。</p>
<p>Python 标准库和内置库包含了许多特殊方法，需要注意的是，永远不要自己命名一个新的特殊方法，因为你不知道下个 Python 版本会不会将其纳入到标准库中。我们需要做的，是重写现有的特殊方法，并且通常情况下，不需要显式的调用它们，应当使用更高层次的封装方法，比如使用 <code>str()</code> 代替 <code>__str__()</code>，对特殊方法的调用应交由 Python 解释器进行。</p>
<p>Python 对于一些内置方法及运算符的调用，本质上就是调用底层的特殊方法。比如在使用 <code>len(x)</code> 方法时，实际上会去查找并调用 x 对象的 <code>__len__</code> 方法；在使用 <code>for</code> 循环时，会去查找并调用对象的 <code>__iter__</code> 方法，如果没有找到这个方法，那会去查找对象的 <code>__getitem__</code> 方法，正如我们之前所说的这是一种后备方案。</p>
<p>可以说，特殊方法是 Python 语言灵活的精髓所在，下面我们结合鸭子类型一章中的 SeqDuck 类与特殊方法，尝试还原 Python 解释器运行的逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqDuck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, pos</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">range</span>(<span class="number">3</span>)[pos]</span><br></pre></td></tr></table></figure>

<ol>
<li>Python 解释器读入 SeqDuck 类，对所有双下划线开头结尾的特殊方法进行检索。</li>
<li>检索到 <code>__getitem__</code> 方法，方法签名符合序列协议。</li>
<li>当需要对 SeqDuck 实例进行循环迭代时，首先查找 <code>__iter__</code> 方法，未找到。</li>
<li>执行 <code>__getitem__</code> 方法，传入从 0 开始的整数索引进行迭代直至索引越界终止循环。</li>
</ol>
<p>该过程可以理解为 Python 解释器对 SeqDuck 类的功能进行了<strong>运行时扩充</strong>。显然这增强了 Python 语言的动态特性，但另一方面也解释了为什么 Python 运行效率较低。</p>
<p>下面我将对一些常用特殊方法进行介绍。</p>
<h3 id="new-amp-init"><a href="#new-amp-init" class="headerlink" title="__new__ &amp; __init__"></a><code>__new__</code> &amp; <code>__init__</code></h3><p>在 Java 和 C# 这些语言中，可以使用 <code>new</code> 关键字创建一个类的实例。Python 虽然没有 <code>new</code> 关键字，但提供了 <code>__new__</code> 特殊方法。在实例化一个 Python 类时，最先被调用的就是 <code>__new__</code> 方法。大多数情况下不需要我们重写 <code>__new__</code> 方法，Python 解释器也会执行 object 中的 <code>__new__</code> 方法创建类实例。但如果要使用单例模式，那么 <code>__new__</code> 方法就会派上用场。下面的代码展示了如何通过 <code>__new__</code> 控制只创建类的唯一实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line"><span class="meta">... </span>    _instance = <span class="literal">None</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>        cls._instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> cls._instance</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = Singleton()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Singleton()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 <span class="keyword">is</span> s2  <span class="comment">## id(s1) == id(s2)</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><code>__init__</code> 方法则类似于构造函数，如果需要对类中的属性赋初值，可以在 <code>__init__</code> 中进行。在一个类的实例被创建的过程中，<code>__new__</code> 要先于 <code>__init__</code> 被执行，因为要先创建好实例才能进行初始化。<code>__new__</code> 方法的第一个参数必须是 <code>cls</code> 类自身，<code>__init__</code> 方法的第一个参数必须是 <code>self</code> 实例自身。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;__new__ magic method is called&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span> (<span class="string">&quot;__init__ magic method is called&quot;</span>)</span><br><span class="line"><span class="meta">... </span>        self.name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Employee()</span><br><span class="line">__new__ magic method <span class="keyword">is</span> called</span><br><span class="line">__init__ magic method <span class="keyword">is</span> called</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.name</span><br><span class="line"><span class="string">&#x27;Jack&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于 Python 不支持方法重载，即同名方法只能存在一个，所以 Python 类只能有一个构造函数。如果需要定义和使用多个构造器，可以使用带默认参数的 <code>__init__</code> 方法，但这种方法实际使用还是有局限性。另一种方法则是使用带有 <code>@classmethod</code> 装饰器的类方法，可以像使用类的静态方法一样去调用它生成类的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, sex=<span class="string">&#x27;MAlE&#x27;</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">male</span>(<span class="params">cls, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">female</span>(<span class="params">cls, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls(name, <span class="string">&#x27;FEMALE&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">p1 = Person(<span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line">p2 = Person(<span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;FEMALE&#x27;</span>)</span><br><span class="line">p3 = Person.female(<span class="string">&#x27;Neo&#x27;</span>)</span><br><span class="line">p4 = Person.male(<span class="string">&#x27;Tony&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="str-amp-repr"><a href="#str-amp-repr" class="headerlink" title="__str__ &amp; __repr__"></a><code>__str__</code> &amp; <code>__repr__</code></h3><blockquote>
<p>str() is used for creating output for end user while repr() is mainly used for debugging and development. repr’s goal is to be <strong>unambiguous</strong> and str’s is to be <strong>readable</strong>.</p>
</blockquote>
<p><code>__str__</code> 和 <code>__repr__</code> 都可以用来输出一个对象的字符串表示。使用 <code>str()</code> 时会调用 <code>__str__</code> 方法，使用 <code>repr()</code> 时则会调用 <code>__repr__</code> 方法。<code>str()</code> 可以看作 string 的缩写，类似于 Java 中的 <code>toString()</code> 方法；<code>repr()</code> 则是 representation 的缩写。</p>
<p>这两个方法的区别主要在于受众。<code>str()</code> 通常是输出给终端用户查看的，可读性更高。而 <code>repr()</code> 一般用于调试和开发时输出信息，所以更加强调含义准确无异义。在 Python 控制台以及 Jupyter notebook 中输出对象信息会调用的 <code>__repr__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="literal">True</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x  <span class="comment"># list.__repr__</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="literal">True</span>]</span><br></pre></td></tr></table></figure>

<p>如果类没有定义 <code>__repr__</code> 方法，控制台会调用 object 类的 <code>__repr__</code> 方法输出对象信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a  <span class="comment"># object.__repr__</span></span><br><span class="line">&lt;__main__.A <span class="built_in">object</span> at <span class="number">0x104b69b50</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>__str__</code> 和 <code>__repr__</code> 也可以提供给 <code>print</code> 方法进行输出。如果只定义了一个方法则调用该方法，如果两个方法都定义了，会优先调用 <code>__str__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;repr: Foo&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;str: Foo&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line"><span class="built_in">repr</span>: Foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">str</span>: Foo</span><br></pre></td></tr></table></figure>

<h3 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h3><p>在 Python 中，函数是一等公民。这意味着 Python 中的函数可以作为参数和返回值，可以在任何想调用的时候被调用。为了扩充类的函数功能，Python 提供了 <code>__call__</code> 特殊方法，允许类的实例表现得与函数一致，可以对它们进行调用，以及作为参数传递。这在一些需要保存并经常更改状态的类中尤为有用。</p>
<p>下面的代码中，定义了一个从 0 开始的递增器类，它保存了计数器状态，并在每次调用时计数加一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Incrementor</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.counter = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.counter += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.counter</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inc = Incrementor()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inc()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inc()</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>允许将类的实例作为函数调用，如上面代码中的 <code>inc()</code>，本质上与 <code>inc.__call__()</code> 直接调用对象的方法并无区别，但它可以以一种更直观且优雅的方式来修改对象的状态。</p>
<p><code>__call__</code> 方法可以接收可变参数, 这意味着可以像定义任意函数一样定义类的 <code>__call__</code> 方法。当 <code>__call__</code> 方法接收一个函数作为参数时，那么这个类就可以作为一个函数装饰器。基于类的函数装饰器就是这么实现的。如下代码我在 func 函数上使用了类级别的函数装饰器 Deco，使得在执行函数前多打印了一行信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Deco</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.func = func</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;decorate...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@Deco</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;execute function&#x27;</span>, name)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">decorate...</span><br><span class="line">execute function foo</span><br></pre></td></tr></table></figure>

<p>实际上类级别的函数装饰器必须要实现 <code>__call__</code> 方法，因为本质上函数装饰器也是一个函数，只不过是一个接收被装饰函数作为参数的高阶函数。有关装饰器可以详见装饰器一章。</p>
<h3 id="add"><a href="#add" class="headerlink" title="__add__"></a><code>__add__</code></h3><p>Python 中的运算符重载也是通过重写特殊方法实现的。比如重载 “+” 加号运算符需要重写 <code>__add__</code>，重载比较运算符 “==” 需要重写 <code>__eq__</code> 方法。合理的重载运算符有助于提高代码的可读性。下面我将就一个代码示例进行演示。</p>
<p>考虑一个平面向量，由 x，y 两个坐标构成。为了实现向量的加法（按位相加），重写了加号运算符，为了比较两个向量是否相等重写了比较运算符，为了在控制台方便验证结果重写了 <code>__repr__</code> 方法。完整的向量类代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Vector(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x + other.x, self.y + other.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.x == other.x <span class="keyword">and</span> self.y == other.y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ne__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.__eq__(other)</span><br></pre></td></tr></table></figure>

<p>在控制台验证结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v2</span><br><span class="line">Vector(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == v2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v1 == Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>重载了 “+” 运算符后，可以直接使用 <code>v1 + v2</code> 对 Vector 类进行向量相加，而不必要编写专门的 <code>add()</code> 方法，并且重载了 <code>==</code> 运算符取代了 <code>v1.equals(v2)</code> 的繁冗写法。从代码可读性来讲直接使用运算符可读性更高，也更符合数学逻辑。</p>
<p>当然，运算符重载涉及的知识点不止于此，《流畅的 Python》将其作为单独的一章，可见其重要性。下一节我们将就运算符重载进行深入的讨论。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://foofish.net/dynamic_type_and_duck_type.html">Python：动态语言与鸭子类型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.tutorialsteacher.com/python/magic-methods-in-python">Python - Magic or Dunder Methods
</a></li>
<li><a target="_blank" rel="noopener" href="https://www.pythonlikeyoumeanit.com/Module4_OOP/Special_Methods.html">Python Like You Mean It - Special Methods</a></li>
<li><a target="_blank" rel="noopener" href="https://sikasjc.github.io/2018/09/02/magicmethods2/">全面学习Python魔法方法(magic methods)</a></li>
<li><a target="_blank" rel="noopener" href="https://hellowac.github.io/programing%20teach/2017/06/06/fluentpython13.html">流畅的python - 重载运算符</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="s1mple"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">s1mple</p>
  <div class="site-description" itemprop="description">春光恰与少年同，十里清风慕天青</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/s1mplecc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;s1mplecc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:s1mple951205@gmail.com" title="E-Mail → mailto:s1mple951205@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">s1mple</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 33231,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
