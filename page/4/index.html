<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"s1mplecc.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="春光恰与少年同，十里清风慕天青">
<meta property="og:type" content="website">
<meta property="og:title" content="芥子屋">
<meta property="og:url" content="https://s1mplecc.github.io/page/4/index.html">
<meta property="og:site_name" content="芥子屋">
<meta property="og:description" content="春光恰与少年同，十里清风慕天青">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="s1mple">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://s1mplecc.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>芥子屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">芥子屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/s1mplecc" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/10/11/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/11/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">LaTeX 数学公式语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-11 10:05:13" itemprop="dateCreated datePublished" datetime="2020-10-11T10:05:13+08:00">2020-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="特殊格式"><a href="#特殊格式" class="headerlink" title="特殊格式"></a>特殊格式</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$x^n$</td>
<td align="center"><code>x^n</code></td>
<td align="center">上标符号</td>
</tr>
<tr>
<td align="center">$x_1$</td>
<td align="center"><code>x_1</code></td>
<td align="center">下标符号</td>
</tr>
<tr>
<td align="center">$v_{\mbox{初始}}$</td>
<td align="center"><code>V_&#123;\mbox&#123;初始&#125;&#125;</code></td>
<td align="center">汉字形式</td>
</tr>
<tr>
<td align="center">$\displaystyle \frac{x+y}{y+z}$</td>
<td align="center"><code>\displaystyle \frac&#123;x+y&#125;&#123;y+z&#125;</code></td>
<td align="center">字体控制</td>
</tr>
<tr>
<td align="center">$\underline{x+y}$</td>
<td align="center"><code>\underline&#123;x+y&#125;</code></td>
<td align="center">下划线符号</td>
</tr>
<tr>
<td align="center">$\overbrace{a+b+c+d}^{2.0}$</td>
<td align="center"><code>\overbrace&#123;a+b+c+d&#125;^&#123;2.0&#125;</code></td>
<td align="center">上大括号</td>
</tr>
<tr>
<td align="center">$a+\underbrace{b+c}_{1.0}+d$</td>
<td align="center"><code>a+\underbrace&#123;b+c&#125;_&#123;1.0&#125;+d</code></td>
<td align="center">下大括号</td>
</tr>
<tr>
<td align="center">$x \stackrel{f} \rightarrow y$</td>
<td align="center"><code>x \stackrel&#123;f&#125; \rightarrow y</code></td>
<td align="center">上位符号</td>
</tr>
<tr>
<td align="center">${n+1 \choose k}={n \choose k}+{n \choose k-1}$</td>
<td align="center"><code>&#123;n+1 \choose k&#125;=&#123;n \choose k&#125;+&#123;n \choose k-1&#125;</code></td>
<td align="center">组合公式</td>
</tr>
</tbody></table>
<h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\pm$</td>
<td align="center"><code>\pm</code></td>
<td align="center">加减运算</td>
</tr>
<tr>
<td align="center">$\mp$</td>
<td align="center"><code>\mp</code></td>
<td align="center">减甲运算</td>
</tr>
<tr>
<td align="center">$\times$</td>
<td align="center"><code>\times</code></td>
<td align="center">乘法运算</td>
</tr>
<tr>
<td align="center">$\cdot$</td>
<td align="center"><code>\cdot</code></td>
<td align="center">点乘运算</td>
</tr>
<tr>
<td align="center">$\ast$</td>
<td align="center"><code>\ast</code></td>
<td align="center">星乘运算</td>
</tr>
<tr>
<td align="center">$\div$</td>
<td align="center"><code>\div</code></td>
<td align="center">除法运算</td>
</tr>
<tr>
<td align="center">$\frac{x+y}{y+z}$</td>
<td align="center"><code>\frac&#123;x+y&#125;&#123;y+z&#125;</code> 或 <code>&#123;x+y&#125; \over &#123;y+z&#125;</code></td>
<td align="center">分式运算</td>
</tr>
<tr>
<td align="center">$\overline{x}$</td>
<td align="center"><code>\overline&#123;x&#125;</code></td>
<td align="center">平均数运算</td>
</tr>
<tr>
<td align="center">$\sqrt x$</td>
<td align="center"><code>\sqrt x</code></td>
<td align="center">开根号运算</td>
</tr>
<tr>
<td align="center">$\sqrt[n]{x+y}$</td>
<td align="center"><code>\sqrt[n]&#123;x+y&#125;</code></td>
<td align="center">开方运算</td>
</tr>
<tr>
<td align="center">$\log_2 x$</td>
<td align="center"><code>\log_2 x</code></td>
<td align="center">对数运算</td>
</tr>
<tr>
<td align="center">$\lim \limits_{n \to \infty}x_n$</td>
<td align="center"><code>\lim \limits_&#123;n \to \infty&#125;x_n</code></td>
<td align="center">极限运算</td>
</tr>
<tr>
<td align="center">$\sum \limits_{i=1}^n{x_i}$</td>
<td align="center"><code>\sum \limits_&#123;i=1&#125;^n&#123;x_i&#125;</code></td>
<td align="center">求和运算</td>
</tr>
<tr>
<td align="center">$\prod \limits_{i=1}^n{x_i}$</td>
<td align="center"><code>\prod \limits_&#123;i=1&#125;^n&#123;x_i&#125;</code></td>
<td align="center">连乘运算</td>
</tr>
<tr>
<td align="center">$\int_{a}^{b} e^x, dx$</td>
<td align="center"><code>\int_&#123;a&#125;^&#123;b&#125; e^x\, dx</code></td>
<td align="center">积分运算</td>
</tr>
<tr>
<td align="center">$\iint \limits_D, dx,dy$</td>
<td align="center"><code>\iint \limits_D\, dx\,dy</code></td>
<td align="center">双重积分</td>
</tr>
<tr>
<td align="center">$\oint_{L} x+y, dx,dy$</td>
<td align="center"><code>\oint_&#123;L&#125; x+y\, dx\,dy</code></td>
<td align="center">闭合曲线积分</td>
</tr>
<tr>
<td align="center">$\partial x$</td>
<td align="center"><code>\partial x</code></td>
<td align="center">微分运算</td>
</tr>
</tbody></table>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\geq$</td>
<td align="center"><code>\geq</code></td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">$\leq$</td>
<td align="center"><code>\leq</code></td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">$\neq$</td>
<td align="center"><code>\neq</code></td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">$\ngeq$</td>
<td align="center"><code>\ngeq</code></td>
<td align="center">不大于等于</td>
</tr>
<tr>
<td align="center">$\not\geq$</td>
<td align="center"><code>\not\geq</code></td>
<td align="center">不大于等于</td>
</tr>
<tr>
<td align="center">$\nleq$</td>
<td align="center"><code>\nleq</code></td>
<td align="center">不小于等于</td>
</tr>
<tr>
<td align="center">$\not\leq$</td>
<td align="center"><code>\not\leq</code></td>
<td align="center">不小于等于</td>
</tr>
<tr>
<td align="center">$\approx$</td>
<td align="center"><code>\approx</code></td>
<td align="center">约等于</td>
</tr>
<tr>
<td align="center">$\equiv$</td>
<td align="center"><code>\equiv</code></td>
<td align="center">恒定等于</td>
</tr>
<tr>
<td align="center">$\bigodot$</td>
<td align="center"><code>\bigodot</code></td>
<td align="center">同或</td>
</tr>
<tr>
<td align="center">$\bigotimes$</td>
<td align="center"><code>\bigotimes</code></td>
<td align="center">同与</td>
</tr>
<tr>
<td align="center">$\bigoplus$</td>
<td align="center"><code>\bigoplus</code></td>
<td align="center">异或</td>
</tr>
</tbody></table>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\in$</td>
<td align="center"><code>\in</code></td>
<td align="center">属于</td>
</tr>
<tr>
<td align="center">$\notin$</td>
<td align="center"><code>\notin</code></td>
<td align="center">不属于</td>
</tr>
<tr>
<td align="center">$\subset$</td>
<td align="center"><code>\subset</code></td>
<td align="center">子集</td>
</tr>
<tr>
<td align="center">$\supset$</td>
<td align="center"><code>\supset</code></td>
<td align="center">子集</td>
</tr>
<tr>
<td align="center">$\subseteq$</td>
<td align="center"><code>\subseteq</code></td>
<td align="center">真子集</td>
</tr>
<tr>
<td align="center">$\subsetneq$</td>
<td align="center"><code>\subsetneq</code></td>
<td align="center">非真子集</td>
</tr>
<tr>
<td align="center">$\supseteq$</td>
<td align="center"><code>\supseteq</code></td>
<td align="center">真子集</td>
</tr>
<tr>
<td align="center">$\supsetneq$</td>
<td align="center"><code>\supsetneq</code></td>
<td align="center">非真子集</td>
</tr>
<tr>
<td align="center">$\not\subset$</td>
<td align="center"><code>\not\subset</code></td>
<td align="center">非子集</td>
</tr>
<tr>
<td align="center">$\not\supset$</td>
<td align="center"><code>\not\supset</code></td>
<td align="center">非子集</td>
</tr>
<tr>
<td align="center">$\cup$</td>
<td align="center"><code>\cup</code></td>
<td align="center">并集</td>
</tr>
<tr>
<td align="center">$\cap$</td>
<td align="center"><code>\cap</code></td>
<td align="center">交集</td>
</tr>
<tr>
<td align="center">$\setminus$</td>
<td align="center"><code>\setminus</code></td>
<td align="center">差集</td>
</tr>
<tr>
<td align="center">$\mathbb{R}$</td>
<td align="center"><code>\mathbb&#123;R&#125;</code></td>
<td align="center">实数集合</td>
</tr>
<tr>
<td align="center">$\mathbb{Z}$</td>
<td align="center"><code>\mathbb&#123;Z&#125;</code></td>
<td align="center">自然数集合</td>
</tr>
<tr>
<td align="center">$\emptyset$</td>
<td align="center"><code>\emptyset</code></td>
<td align="center">空集</td>
</tr>
</tbody></table>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\infty$</td>
<td align="center"><code>\infty</code></td>
<td align="center">无穷</td>
</tr>
<tr>
<td align="center">$\imath$</td>
<td align="center"><code>\imath</code></td>
<td align="center">虚数</td>
</tr>
<tr>
<td align="center">$\jmath$</td>
<td align="center"><code>\jmath</code></td>
<td align="center">虚数</td>
</tr>
<tr>
<td align="center">$\hat{a}$</td>
<td align="center"><code>\hat&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\check{a}$</td>
<td align="center"><code>\check&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\breve{a}$</td>
<td align="center"><code>\breve&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\tilde{a}$</td>
<td align="center"><code>\tilde&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\bar{a}$</td>
<td align="center"><code>\bar&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\vec{a}$</td>
<td align="center"><code>\vec&#123;a&#125;</code></td>
<td align="center">矢量符号</td>
</tr>
<tr>
<td align="center">$\acute{a}$</td>
<td align="center"><code>\acute&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\grave{a}$</td>
<td align="center"><code>\grave&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\mathring{a}$</td>
<td align="center"><code>\mathring&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\dot{a}$</td>
<td align="center"><code>\dot&#123;a&#125;</code></td>
<td align="center">一阶导数符号</td>
</tr>
<tr>
<td align="center">$\ddot{a}$</td>
<td align="center"><code>\ddot&#123;a&#125;</code></td>
<td align="center">二阶导数符号</td>
</tr>
<tr>
<td align="center">$\uparrow$</td>
<td align="center"><code>\uparrow</code></td>
<td align="center">上箭头</td>
</tr>
<tr>
<td align="center">$\Uparrow$</td>
<td align="center"><code>\Uparrow</code></td>
<td align="center">上箭头</td>
</tr>
<tr>
<td align="center">$\downarrow$</td>
<td align="center"><code>\downarrow</code></td>
<td align="center">下箭头</td>
</tr>
<tr>
<td align="center">$\Downarrow$</td>
<td align="center"><code>\Downarrow</code></td>
<td align="center">下箭头</td>
</tr>
<tr>
<td align="center">$\leftarrow$</td>
<td align="center"><code>\leftarrow</code></td>
<td align="center">左箭头</td>
</tr>
<tr>
<td align="center">$\Leftarrow$</td>
<td align="center"><code>\Leftarrow</code></td>
<td align="center">左箭头</td>
</tr>
<tr>
<td align="center">$\rightarrow$</td>
<td align="center"><code>\rightarrow</code></td>
<td align="center">右箭头</td>
</tr>
<tr>
<td align="center">$\Rightarrow$</td>
<td align="center"><code>\Rightarrow</code></td>
<td align="center">右箭头</td>
</tr>
<tr>
<td align="center">$\longrightarrow$</td>
<td align="center"><code>\longrightarrow</code></td>
<td align="center">向右长箭头</td>
</tr>
<tr>
<td align="center">$\Longrightarrow$</td>
<td align="center"><code>\Longrightarrow</code></td>
<td align="center">向右长箭头</td>
</tr>
<tr>
<td align="center">$A \xleftarrow{n=0} B \xrightarrow[T]{n&gt;0} C$</td>
<td align="center"><code>A \xleftarrow&#123;n=0&#125; B \xrightarrow[T]&#123;n&gt;0&#125; C</code></td>
<td align="center">上下方可输入公式的箭头</td>
</tr>
<tr>
<td align="center">$\triangleq$</td>
<td align="center"><code>\triangleq</code></td>
<td align="center">定义为</td>
</tr>
<tr>
<td align="center">$\because$</td>
<td align="center"><code>\because</code></td>
<td align="center">因为</td>
</tr>
<tr>
<td align="center">$\therefore$</td>
<td align="center"><code>\therefore</code></td>
<td align="center">所以</td>
</tr>
<tr>
<td align="center">$\forall$</td>
<td align="center"><code>\forall</code></td>
<td align="center">任意</td>
</tr>
<tr>
<td align="center">$\exists$</td>
<td align="center"><code>\exists</code></td>
<td align="center">存在</td>
</tr>
<tr>
<td align="center">$\ldots$</td>
<td align="center"><code>\ldots</code></td>
<td align="center">底端对齐的省略号</td>
</tr>
<tr>
<td align="center">$\cdots$</td>
<td align="center"><code>\cdots</code></td>
<td align="center">中线对齐的省略号</td>
</tr>
<tr>
<td align="center">$\vdots$</td>
<td align="center"><code>\vdots</code></td>
<td align="center">竖直对齐的省略号</td>
</tr>
<tr>
<td align="center">$\ddots$</td>
<td align="center"><code>\ddots</code></td>
<td align="center">斜对齐的省略号</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>矩阵表示</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\left[ \begin&#123;matrix&#125; 1 &amp;2 &amp;\cdots &amp;4\\5 &amp;6 &amp;\cdots &amp;8 \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ 13 &amp;14 &amp;\cdots &amp;16\end&#123;matrix&#125; \right]</span><br></pre></td></tr></table></figure>

<p>$$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8 \ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \ 13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]$$</p>
<p><strong>大括号公式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F(n)= \begin&#123;cases&#125; 1 &amp; \text&#123;n = 0 或 1&#125;\\ F(n-1)+F(n-2) &amp; \text&#123;n &gt; 1&#125; \end&#123;cases&#125;</span><br></pre></td></tr></table></figure>

<p>$$F(n)= \begin{cases} 1 &amp; \text{n = 0 或 1}\ F(n-1)+F(n-2) &amp; \text{n &gt; 1} \end{cases}$$</p>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table>
<thead>
<tr>
<th align="center">大写</th>
<th align="center">代码</th>
<th align="center">小写</th>
<th align="center">代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center"><code>A</code></td>
<td align="center">α</td>
<td align="center"><code>\alhpa</code></td>
</tr>
<tr>
<td align="center">B</td>
<td align="center"><code>B</code></td>
<td align="center">β</td>
<td align="center"><code>\beta</code></td>
</tr>
<tr>
<td align="center">Γ</td>
<td align="center"><code>\Gamma</code></td>
<td align="center">γ</td>
<td align="center"><code>\gamma</code></td>
</tr>
<tr>
<td align="center">Δ</td>
<td align="center"><code>\Delta</code></td>
<td align="center">δ</td>
<td align="center"><code>\delta</code></td>
</tr>
<tr>
<td align="center">E</td>
<td align="center"><code>E</code></td>
<td align="center">ϵ</td>
<td align="center"><code>\epsilon</code></td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center"><code>Z</code></td>
<td align="center">ζ</td>
<td align="center"><code>\zeta</code></td>
</tr>
<tr>
<td align="center">H</td>
<td align="center"><code>H</code></td>
<td align="center">η</td>
<td align="center"><code>\eta</code></td>
</tr>
<tr>
<td align="center">Θ</td>
<td align="center"><code>\Theta</code></td>
<td align="center">θ</td>
<td align="center"><code>\theta</code></td>
</tr>
<tr>
<td align="center">I</td>
<td align="center"><code>I</code></td>
<td align="center">ι</td>
<td align="center"><code>\iota</code></td>
</tr>
<tr>
<td align="center">K</td>
<td align="center"><code>K</code></td>
<td align="center">κ</td>
<td align="center"><code>\kappa</code></td>
</tr>
<tr>
<td align="center">Λ</td>
<td align="center"><code>\Lambda</code></td>
<td align="center">λ</td>
<td align="center"><code>\lambda</code></td>
</tr>
<tr>
<td align="center">M</td>
<td align="center"><code>M</code></td>
<td align="center">μ</td>
<td align="center"><code>\mu</code></td>
</tr>
<tr>
<td align="center">N</td>
<td align="center"><code>N</code></td>
<td align="center">ν</td>
<td align="center"><code>\nu</code></td>
</tr>
<tr>
<td align="center">Ξ</td>
<td align="center"><code>\Xi</code></td>
<td align="center">ξ</td>
<td align="center"><code>\xi</code></td>
</tr>
<tr>
<td align="center">O</td>
<td align="center"><code>O</code></td>
<td align="center">ο</td>
<td align="center"><code>\omicron</code></td>
</tr>
<tr>
<td align="center">Π</td>
<td align="center"><code>\Pi</code></td>
<td align="center">π</td>
<td align="center"><code>\pi</code></td>
</tr>
<tr>
<td align="center">P</td>
<td align="center"><code>P</code></td>
<td align="center">ρ</td>
<td align="center"><code>\rho</code></td>
</tr>
<tr>
<td align="center">Σ</td>
<td align="center"><code>\Sigma</code></td>
<td align="center">σ</td>
<td align="center"><code>\sigma</code></td>
</tr>
<tr>
<td align="center">T</td>
<td align="center"><code>T</code></td>
<td align="center">τ</td>
<td align="center"><code>\tau</code></td>
</tr>
<tr>
<td align="center">Υ</td>
<td align="center"><code>\Upsilon</code></td>
<td align="center">υ</td>
<td align="center"><code>\upsilon</code></td>
</tr>
<tr>
<td align="center">Φ</td>
<td align="center"><code>\Phi</code></td>
<td align="center">ϕ</td>
<td align="center"><code>\phi</code></td>
</tr>
<tr>
<td align="center">X</td>
<td align="center"><code>X</code></td>
<td align="center">χ</td>
<td align="center"><code>\chi</code></td>
</tr>
<tr>
<td align="center">Ψ</td>
<td align="center"><code>\Psi</code></td>
<td align="center">ψ</td>
<td align="center"><code>\psi</code></td>
</tr>
<tr>
<td align="center">Ω</td>
<td align="center"><code>\v</code></td>
<td align="center">ω</td>
<td align="center"><code>\omega</code></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/" class="post-title-link" itemprop="url">机器学习在网络安全中的应用 —— Chapter 1: Basics of Machine Learning in Cybersecurity</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-07 13:17:42" itemprop="dateCreated datePublished" datetime="2020-10-07T13:17:42+08:00">2020-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Translations/" itemprop="url" rel="index"><span itemprop="name">Translations</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文翻译并总结归纳自 <em><strong>Hands-On Machine Learning for Cybersecurity</strong></em> 书中的 Chapter 1: Basics of Machine Learning in Cybersecurity。该书主要着眼于机器学习在网络安全领域中的应用，介绍了多个方向的原理和解决方案，比如：包时间序列分析、垃圾邮件检测、使用 k-means 算法的网络异常检测等。总的来说，该书的动手操作很多，实战性很强。接下来我会用一个系列，整理归纳书中的各个章节。当然，除了第一章是介绍机器学习的概览之外，其他几个章节内容比较离散，所以顺序可能打乱。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自诞生以来，机器学习（Machine Learning）一直是一个非常热门的话题，它的出现实实在在地解决了很多问题，比如人脸识别、自动驾驶、购物推荐系统、聊天机器人等。</p>
<p>而在安全领域方面，老式的威胁检测系统通过使用启发式的和静态的签名（signature）来检测威胁和异常。例如：杀毒软件会根据病毒程序的特征，生成并维持一个病毒的签名库（保持持续更新），在查杀时通过与库中的签名比对来识别病毒程序。基于签名的威胁检测技术虽然容易理解，但并不健壮，它的最大的问题之一是：在数据规模、数据流速显著增大时，如何保证签名比对过程与数据流入速度匹配。每个包需要与数据库中的每个签名比对，如果不能保持同步，那意味着只能抛弃部分数据包，由此就会产生“漏网之鱼”。</p>
<p>如今，基于签名的系统逐渐被智能网络安全代理（Intelligent cybersecurity agent）所取代。机器学习在识别新型恶意软件、零日漏洞攻击（zero-day attack）、高级可持续威胁（advanced persistent threats，简称 APT）方面取得积极进展。</p>
<p>一般来说，由于攻击的复杂特性，要做到完全预防是很难的，机器学习能做到在攻击的初期识别攻击并防止其扩散到整个系统。许多网络安全公司使用诸如用户行为分析（user behavior analytics）和预测分析（predictive analytics）的高级分析方法，在威胁生命周期的早期阶段识别 APT 攻击，这种方式能够有效预防身份数据泄漏和内部威胁。规范分析（prescriptive analytics）则更具有响应性，能够在网络攻击发生以后分析该采取什么响应措施能将损失降到最小。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/1.png" alt="48e9cf0bd45e3630c4346d142839c8a1.png"></p>
<h2 id="机器学习中的数据"><a href="#机器学习中的数据" class="headerlink" title="机器学习中的数据"></a>机器学习中的数据</h2><p>数据是机器学习的核心。数据分为结构化数据和非结构化数据，<strong>结构化数据（structured data）</strong>可以被映射为二维表结构，包含表头（Header）和表内元素，传统的关系型数据库（RDBMS）如 MySQL、Oracle 等都是以这种方式存放结构化数据；而<strong>非结构化数据（unstructured data）</strong>数据结构不规则或不完整，没有预定义的数据模型，例如图片、音频/视频等；融合了结构化和非结构化的数据称为<strong>半结构化数据（semi-structured data）</strong>。</p>
<p>根据数据是否被打上标记，数据又被分为<strong>有标注数据（labelled data）</strong>和<strong>无标注数据（unlabelled data）</strong>。例如网络安全中的恶意流量检测，可以将样本中的善意流量（white）和恶意流量（black）手动打标（恶意流量可能是自己模拟生成的），构成训练集训练机器学习模型。</p>
<h3 id="机器学习阶段"><a href="#机器学习阶段" class="headerlink" title="机器学习阶段"></a>机器学习阶段</h3><p>机器学习分为以下四个阶段：</p>
<ul>
<li><strong>分析阶段（The analysis phase）</strong>：在这个阶段，采集到的数据需要被提取明确的<strong>特征（features）</strong>或者参数（parameters），来被用于训练模型。</li>
<li><strong>训练阶段（The training phase）</strong>： 前一阶段的数据将被用来在这个阶段训练机器学习模型（machine learning model），训练阶段是一个<strong>多次迭代</strong>的阶段，目的是为了训练一个更加可信的模型。</li>
<li><strong>测试阶段（The testing phase）</strong>： 在这一阶段，训练阶段产生的机器学习模型将结合更多的数据进行测试并<strong>评估模型</strong>的性能。测试的数据是前面阶段从未被使用的数据。模型的<strong>演化</strong>可能会需要参数训练（调参）。</li>
<li><strong>应用阶段（The application phase）</strong> ：模型被部署到<strong>生产环境</strong>，应用于真实数据。</li>
</ul>
<h3 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h3><p>在训练阶段，由于样本数据的不完备，训练出的机器学习模型可能并不理想（模型的泛化能力不佳），会产生两种现象：过拟合和欠拟合。</p>
<p><strong>过拟合（Overfitting）</strong>，是指系统太过适应于（fit）或者说太过依赖于训练集数据，导致新来的数据都视为不匹配，通常表现为：模型对于训练集表现很好，对于测试集表现很差（容纳度很低）。产生这种现象的常见原因之一是只使用了有标注的数据来训练模型。</p>
<blockquote>
<p>Overfitting: The production of an analysis that corresponds too closely or exactly to a particular set of data, and may therefore fail to fit additional data or predict future observations reliably. – Oxford Dictionary</p>
</blockquote>
<p><strong>欠拟合（Underfitting）</strong>，是模型表现差的另一种场景，通常是由于样本数量较少，模型训练依赖特征过少，学习能力低下造成的。</p>
<p>对于这两种情形，可以通过一些机器学习的常见步骤来消除，比如：数据的交叉验证（cross validation of the data），数据修剪（data pruning）和数据正则化（regularization of the data）。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/2.png" alt="0574cd5346226da66890df7956671e62.png"></p>
<p>由上图可以看到，当模型层级较低时（模型过于简单），表现为欠拟合，训练集和测试集效果都不好；当模型层级较高时（模型过于复杂），表现为过拟合，训练集效果很好，但由于学习能力过于强大，以至于把训练样本所包含的不太一般的特性都学到了，导致测试集中表现很差。所以我们需要摸索出合适的模型，既不能太简单也不能太复杂，使得在测试集上能有最优表现。</p>
<h2 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h2><p>传统上，基于所提供的学习类型，机器学习系统大体上可以分为两类：有监督学习和无监督学习。强化学习和深度学习是后面引入的新的研究分支。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/3.png" alt="49c0d215820883fdc0aa834405891742.png"></p>
<h3 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h3><p>有监督学习（Supervised learning）是指使用已标注的数据集推导出预测函数，对测试集进行分类和预测。有监督学习包含一些子分支，比如：</p>
<ul>
<li><strong>半监督学习（Semi-supervised learning）</strong>：训练阶段的数据集即含有有标注的，也含有未标注的。</li>
<li><strong>主动学习（Active learning）</strong>：主动学习是指，通过查询函数，从未标注数据集中查询出信息熵最大（可以简单理解为最复杂）的数据，交给督导者进行标注，循环迭代这个过程直至模型达到最佳。主动学习的“主动”，指的是<strong>主动提出标注请求</strong>，为此需要一个外在的能够对其请求进行标注的实体（通常是相关领域人员）。<br><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/4.png" alt="e834d2167c02ba1908f13760cec58005.png"></li>
</ul>
<p>有监督学习的常见应用包括：人脸识别，需要人为标注新面孔；垃圾邮件检测，需要对邮件内容文本进行分词处理，所以需要提前对一些敏感词汇做人为标注。</p>
<h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>无监督学习算法（Unsupervised learning）是指初始数据集是未标注的，数据视图是在处理过程中由系统自学习构建出来的，没有任何外部干涉。如果说有监督学习是：老师提供对错指示，要求学生能够“对于输入数据X能判断对错”，那么无监督学习就是：在没有老师的情况下，学生自学，要求学生能够“<strong>从数据X中归纳总结出知识点</strong>”。无监督学习算法的具体应用案例包括：用户行为分析（User behavior analysis）、购物篮分析（Market basket analysis）等。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/5.png" alt="942767e754efb165eb261f9f9692bbc4.png"></p>
<h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>强化学习（Reinforcement learning）是机器学习的又一分支，它强调如何基于<strong>环境</strong>而行动，以取得最大化的<strong>预期利益</strong>。</p>
<p>具有强化学习能力的程序或机器人被称为<strong>代理（Agent）</strong>。代理所解决的问题被抽象为<strong>环境（Environment）</strong>，比如迷宫或者棋盘。代理需要有一个基本的<strong>策略（Policy）</strong>，每次迭代根据这个策略选择一个<strong>动作（Action）</strong>作用于环境，环境接受该动作后<strong>状态（State）</strong>发生变化，同时产生一个<strong>信号（Reward）</strong>，正代表奖励，负代表惩罚。代理会根据这个信号评估之前的策略是否适合。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/6.png" alt="25df06c2835f3b3d1e7e198431865384.png"></p>
<p>强化学习有一些实际的用例，比如自动驾驶汽车，需要对周围复杂环境作出实施迅速的应对；又比如家喻户晓的 AlphaGo，只需要训练4个小时就可以击败世界知名的象棋AI Stockfish。</p>
<h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>深度学习（Deep learning）是机器学习领域的一个新的研究分支，是一种以人工神经网络为架构，对资料进行表征学习的算法。深度学习并不简单的囊括于传统的有监督/无监督分类中，它本身也会用到有监督和无监督的学习方法来训练深度神经网络。</p>
<p>深度学习的出现，引领了机器学习的又一波热潮，它摧枯拉朽地解决了之前未解决的诸多问题，使得似乎所有的机器辅助功能都变为可能。但它作为目前最热的机器学习方法之一，并不意味着是机器学习的终点，它也具有诸多问题，比如：深度学习需要巨大的数据集做支撑；复杂度较高；深度学习的构想来源于人脑的神经元结构，但人脑的复杂程度要远远超出它所能模拟的范畴。</p>
<h2 id="机器学习解决的问题"><a href="#机器学习解决的问题" class="headerlink" title="机器学习解决的问题"></a>机器学习解决的问题</h2><p>机器学习可以用于解决以下几类问题：分类问题，集群问题，回归问题，降维问题，密度估算问题等等。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/7.png" alt="53aaf02095bd399d6b16dec0b2332dd7.png"></p>
<h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><p>分类问题（Classification problems）是指基于特征将数据划分到多个类（class）中的问题。因为训练数据是有标注的，所以分类问题属于有监督学习。网络数据分类是一个经典的分类问题，互联网的内容可以根据它们的文本内容比如新闻、社交媒体、广告等划分到它们对应的类别。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/8.png" alt="d50de17881f0da10019d30b5e4266bef.png"></p>
<h3 id="聚类问题"><a href="#聚类问题" class="headerlink" title="聚类问题"></a>聚类问题</h3><p>聚类问题（Clustering problems）是指将数据分成若干组并将相似数据归为一组。聚类技术常用语信息检索、模式识别、人口统计分析领域。相比于分类问题，聚类问题并不关心某一类是什么，只需要将相似的数据归为一类。因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了，也就是说训练集无需作出预先标注。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/9.png" alt="c118f41b872bc162fd0f3858d25ec368.png"></p>
<h3 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h3><p>回归问题（Regression problems）指的是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。例如对于图中的二元组数据（x，y），我们可以求出能表示 x，y 关系的线性回归方程，再对接下来的测试数据集进行预测或分类。</p>
<p>回归包括多种类型，比如：线性回归（linear regression），逻辑回归（logistic regression），多项式回归（polynomial regression）等。回归可以用于欺诈检测系统，股票市场分析和预测。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/10.png" alt="985428a8e920d31726d314abe4af73d0.png"></p>
<h3 id="降维问题"><a href="#降维问题" class="headerlink" title="降维问题"></a>降维问题</h3><p>现实应用中属性维数经常成千上万，且许多学习方法都涉及距离计算，而高维空间会给距离计算带来很大的麻烦，当维数很高时甚至连计算内积都不再容易。事实上，在高维情形下出现的数据样本稀疏、距离计算困难等问题，是所有机器学习方法共同面临的严重障碍，被称为“维数灾难”（curse of dimensionality）。</p>
<p>缓解维数灾难的一个重要途径是<strong>降维（Dimension reduction）</strong>，亦称“维数约简”，即通过某种数学变换将原始高维属性空间转变为一个低维“子空间”（subspace），在这个子空间中样本密度大幅提高，距离计算也变得更为容易。降维将含有多个属性的高维数据，用它的主要属性去表示，并且不丢失重要特征。  降维技术经常用于<strong>特征提取</strong>，比如网络包流数据的处理，为了减少数据规模，通常只提取具有代表性的有用特征进行分析。</p>
<p>下图给出了一个直观的例子，将原始三维空间中的样本点，映射到二维嵌入子空间中。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/11.jpg" alt="d127776fa637378ffec32cc993ce3c49.png"></p>
<h3 id="密度估算问题"><a href="#密度估算问题" class="headerlink" title="密度估算问题"></a>密度估算问题</h3><p>密度估算问题（Density estimation problems）是用于对密集数据进行机器学习估算的统计学习方法。从技术上讲，它是一种<strong>计算概率密度函数</strong>的技术。在医学分析领域，通常使用这种技术来在庞大的人口中识别疾病相关症状。</p>
<h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><p>支持向量机（Support Vector Machines，SVM）属于有监督的算法，被用于解决线性或非线性的分类问题（linear/non linear classification）。由于优秀的性能，SVM 得到了广泛的应用。</p>
<p>若输入数据所在的特征空间存在作为决策边界（decision boundary）的超平面将样本按正类和负类分开，实际上构造了2个平行的超平面作为间隔边界以判别样本的分类，所有在上间隔边界上方的样本属于正类，在下间隔边界下方的样本属于负类。两个间隔边界的距离被定义为边距（margin），位于间隔边界上的正类和负类样本为支持向量（support vector）。SVM 旨在求解能够划分样本的<strong>最大边距超平面（maximum-margin hyperplane）</strong>。</p>
<p>对于二维平面，超平面可以理解为可以划分样本的一条「直线」，对于高维特征空间，SVM 可以通过<strong>核方法（kernel method）</strong>进行非线性分类。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/12.png" alt="e44a093db94c73420e3f30d4455b09f1.png"></p>
<h3 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a>贝叶斯网络</h3><p>贝叶斯网（Bayesian network，简称 BN）亦称“信念网”（belief network），它借助有向无环图（Direct Acyclic Graph，简称 DAG）来刻画属性之间的依赖关系，并使条件概率表（Conditional Probability Table，简称 CPT）来描述属性的联合概率分布。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/13.jpg" alt="fe9d8ceefb48edd4636364d7b7e00a2a.png"></p>
<p>上图给出了西瓜问题的一种贝叶斯网结构和属性“根蒂”的条件概率表。从图中网络结构可看出，“色泽”直接依赖于“好瓜”和“甜度”，而“根蒂”则直接依赖于“甜度”；进一步从条件概率表能得到“根蒂”对“甜度”量化依赖关系，如 $P(根蒂=硬挺|甜度=高)=0.1$ 等。</p>
<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>决策树（decision tree）是一类常见的机器学习方法。以二分类任务为例，我们希望从给定训练数据集学得一个模型用以对新示例进行分类，这个把样本分类的任务，可看作对“当前样本属于正类吗？“这个问题的“决策”或“判定”过程。</p>
<p>顾名思义，决策树是基于树结构来进行决策的，这恰是人类在面临决策问题时一种很自然的处理机制。树中非叶子节点表示需要作出分类判断的属性，每个分支代表可能的属性值。下图给出了西瓜问题的一颗决策树。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/14.jpg" alt="babb7185999143d2f546dc0d7fc76680.png"></p>
<h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>首先我们介绍一下 <strong>Bagging</strong>。给定包含 m 个样本的数据集，我们先随机取出一个样本放入采样集中，再把该样本放回初始数据集，使得下次采样时该样本仍有可能被选中，这样，经过m次随机采样操作，我们得到含 m 个样本的采样集，初始训练集中有的样本在采样集里多次出现，有的则从未出现。</p>
<p>照这样，我们可采样出 T 个含 m 个训练样本的采样集，然后基于每个采样集训练出一个基学习器，再将这些基学习器进行结合。这就是 Bagging 的基本流程。在对预测输出进行结合时，Bagging 通常对分类任务使用简单投票法，对回归任务使用简单平均法。若分类预测时出现两个类收到同样票数的情形，则最简单的做法是随机选择一个，也可进一步考察学习器投票的置信度来确定最终胜者。</p>
<p>随机森林（Random Forest，简称 RF）是 Bagging 的一个扩展变体。RF 在以决策树为基学习器构建 Bagging 集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。具体来说，传统决策树在选择划分属性时是在当前结点的属性集合（假定有 d 个属性）中选择一个最优属性；而在 RF 中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含 k 个属性的子集，然后再从这个子集中选择一个最优属性用于划分。这样使得随机森林中的决策树都能够彼此不同，提升系统的多样性，从而提升分类性能。</p>
<p>随机森林简单、容易实现、计算开销小，令人惊奇的是，它在很多现实任务中展现出强大的性能，被誉为“代表集成学习技术水平的方法”。</p>
<h3 id="kNN"><a href="#kNN" class="headerlink" title="kNN"></a>kNN</h3><p>k近邻（k-Nearest Neighbor，简称 kNN）学习是一种常用的监督学习方法，其工作机制非常简单：给定测试样本，基于某种距离度量找出训练集中与其最靠近的 k 个训练样本，然后基于这 k 个“邻居”的信息来进行预测。通常，在分类任务中可使用“投票法”，即选择这 k 个样本中出现最多的类别标记作为预测结果；在回归任务中可使用“平均法，即将这 k 个样本的实值输出标记的平均值作为预测结果；还可基于距离远近进行加权平均或加权投票，距离越近的样本权重越大。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/15.jpg" alt="a5e05733ac1f4912ecc1bd1828535f57.png"></p>
<p>上图是一个k近邻分类器示意图。虚线为等距线，测试样本在 k=1 或 k=5 时被判别为正例，k=3 时被判别为反例。显然，k 是一个重要参数，当 k 取不同值时，分类结果会有显著不同。</p>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。</p>
<p>神经网络中最基本的成分是神经元（neuron）模型，即上述定义中的“简单单元”。在生物神经网络中，每个神经元与其他神经元相连，当它“兴奋”时，就会向相连的神经元发送化学物质，从而改变这些神经元内的电位；如果某神经元的电位超过一个“阈值”（threshold），那么它就会被激活，即“兴奋”起来，向其他神经元发送化学物质。</p>
<p>1943年，McMulloch 和 Pitts 将上述情形抽象为下图所示的简单模型，这就是一直沿用至今的“<strong>M-P神经元模型</strong>”。把许多个这样的神经元按一定的层次结构连接起来，就得到了神经网络。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/16.jpg" alt="5ba11eb4ebb4f8dddb0b8806dace6347.png"></p>
<p>在这个模型中，神经元接收到来自 n 个其他神经元传递过来的输入信号，这些输入信号通过带权重的连接（connection）进行传递，神经元接收到总输入将与神经元的阈值进行比较，然后通过“激活函数”（activation function）处理以产生神经元的输出。</p>
<h2 id="机器学习架构"><a href="#机器学习架构" class="headerlink" title="机器学习架构"></a>机器学习架构</h2><p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/17.png" alt="8b49f81f455bb0bb519c3659accc8f7d.png"></p>
<p>注入机器学习系统的数据可能来自不同的源，可以是实时的流数据，也可以是批处理数据或者无交互的定时任务数据。常见的数据源有 Amazon Kinesis、Apache Flume、Apache Kafka 等。注入的数据经过清洗和预处理后被存入数据储存库中，例如 SQL/NoSQL 数据库、数据仓库（data warehouse）、HDFS 分布式系统等等。</p>
<h3 id="模型引擎"><a href="#模型引擎" class="headerlink" title="模型引擎"></a>模型引擎</h3><ul>
<li><strong>数据准备（Data preparation）</strong>：数据准备阶段需要进行数据清洗（data cleansing），检查数据一致性和完整性，对数据进行规范化，对拆分的或是聚合的数据进行转换和重组。</li>
<li><strong>特征生成（Feature generation）</strong>：找到待分析数据的关键特征。特征可以来自原始数据或者聚合后的数据，不同特征通常都是相互独立的。特征提取的首要目标是降低数据维度和提高模型性能。</li>
<li><strong>模型训练（Model training）</strong>：机器学习模型分析数据间的关联，将数据分类到不同的组。为了获得最佳性能，需要对数据特征进行合适的采样。通常 70～80% 的数据会被用于训练阶段。</li>
<li><strong>模型测试（Model testing）</strong>：在测试阶段我们验证模型，模型的性能能够被测试并做出调节。交叉验证能够确定模型的性能。通常 20% 的数据会被用于测试阶段。</li>
</ul>
<h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h3><p>性能调节（Performance tuning）和错误检测（error detection）是机器学习系统最重要的迭代过程，能够帮助提升系统的性能。如果系统的泛化功能能够以较高的概率给出较低的<strong>泛化误差（generalization error）</strong>，我们称这个系统拥有最优性能。事实上这属于 PAC 理论的范畴。</p>
<p>泛化误差与分类的准确度，回归模型预测的精确度直接相关。为了计算泛化误差，我们给出一些评估指标：</p>
<h4 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h4><p>假设现在有一条回归曲线，我们想测量每个点到回归线的距离，而均方误差（Mean squared error，MSE）就能够统计这些偏移量。$P_i$ 为预测值，$A_i$ 为真实值，MSE 对每个点偏移量的平方和求平均：</p>
<p>$$ MSE = \frac{1}{n}\sum_{i=1}^n{(P_i - A_i)^2} $$</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/18.png" alt="d8c5be836a6aff5b4e312f9b7a4a7a8a.png"></p>
<h4 id="平均绝对误差"><a href="#平均绝对误差" class="headerlink" title="平均绝对误差"></a>平均绝对误差</h4><p>平均绝对误差（Mean absolute error，MAE) 计算每个点绝对误差的均值。MAE 是时间序列分析中的预测误差的一个常见指标。相比于 MSE，由于 MSE 使用了平方会放大误差，所以 MSE 对于异常数据更加敏感，而 MAE 对异常点有更好的鲁棒性（抗干扰能力更强），更适合用来做预测分析。但对于学习效率来说，误差较大时 MSE 收敛更快精度更高。</p>
<p>$$ MAE = \frac{1}{n}\sum_{i=1}^n{|P_i - A_i|} $$</p>
<h4 id="精确率、召回率、准确率"><a href="#精确率、召回率、准确率" class="headerlink" title="精确率、召回率、准确率"></a>精确率、召回率、准确率</h4><p>精确率、召回率和准确率是机器学习分类问题（classification problem）模型评估中常见的性能度量指标：</p>
<ul>
<li><strong>精确率（Precision）</strong>，又叫查准率，定义为：$Precision \triangleq \frac{TP}{TP+FP}$</li>
<li><strong>召回率（Recall）</strong>，又叫查全率，定义为：$Recall \triangleq \frac{TP}{TP+FN}$</li>
<li><strong>准确率（Accuracy）</strong>，定义为：$Accuracy \triangleq \frac{TP+TN}{TP+TN+FP+FN}$</li>
</ul>
<p>上述定义式中 T 代表 True，F 代表 False，T/F 表示预测是否正确；P 代表 Positive，N 代表 Negative，P/N 代表本身是正例还是反例。例如：恶意流量检测系统中，P 代表是恶意流量，那么 TP 就代表正确检测出恶意流量，FN 代表本身不是恶意流量却被错误地识别为恶意流量。</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/19.png" alt="385e4f3b305ced036ed00c0098a74855.png"></p>
<p>Precision 从预测结果角度出发，描述了<strong>预测出来的正例结果中有多少是真实正例</strong>，关心的是查出来的准不准；Recall 从真实结果角度出发，描述了<strong>测试集中的真实正例有多少被检测出来</strong>，关心的是查的全不全。Accuracy 则代表所有预测中正确预测所占的比例。</p>
<p>当正负样本分布严重不均匀时，仅仅靠准确率 Accuracy 去评估模型性能是不合适的。就拿恶意流量检测来说，假设恶意流量占总流量的 0.1%，那么考虑一个全部流量都 pass 的检测系统，它的准确率依然能达到 99.9%，但是一条恶意流量都没有检测出来，这显然是不合要求的。所以通常需要结合这三个指标对模型进行整体评估。</p>
<h3 id="性能改善"><a href="#性能改善" class="headerlink" title="性能改善"></a>性能改善</h3><p>那么如何提高模型的性能呢？通常可以通过：</p>
<ul>
<li><strong>改善数据质量</strong>：数据需要清洗、重采样以及规范化，特征提取步骤也可能需要重新审视，缺乏独立性的特征也会导致性能不佳。</li>
<li><strong>更换算法</strong>：模型的性能不佳也可能是因为没有选对合适的算法，在这种情况下，不同算法的基准测试可以帮助我们做出合适的选择。基准测试包括但不限于：K倍交叉验证。</li>
<li>**使用集成学习（Ensemble Learning)**：同时使用多种学习算法来获得比单独使用任何学习算法具有更好的性能。一些最复杂的人工智能系统就是这类集成的副产物。</li>
</ul>
<h2 id="机器学习扩展库"><a href="#机器学习扩展库" class="headerlink" title="机器学习扩展库"></a>机器学习扩展库</h2><p>Python 作为机器学习最常用语言，虽然不是最快的，但因为它的灵活性而被数据科学家们广泛接受。Python 为机器学习专家提供了一系列的工具和扩展库，常用到的有：</p>
<ul>
<li><strong>NumPy</strong>：是统计分析和机器学习方面的重要扩展库，提供了支持线性代数、傅立叶变换和其他数值分析的复杂函数库。</li>
<li><strong>SciPy</strong>：基于 NumPy 的科学计算库，可以处理插值、积分、优化、图像处理、常微分方程数值解的求解、信号处理等问题。</li>
<li><strong>Scikit-learn</strong>：简单高效的机器学习库，提供了解决分类、集群、回归等问题的机器学习算法模型，Scikit-learn 依赖于 NumPy 和 SciPy。</li>
<li><strong>pandas</strong>：非常强力的数据统计分析工具。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。能够很好的读写和呈现表格数据。</li>
<li><strong>Matplotlib</strong>：绘图工具，常常与 NumPy、SciPy 配合使用。</li>
</ul>
<p>下图是 Scikit-learn 在解决不同规模，不同类型问题时推荐使用的算法模型：</p>
<p><img data-src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/20.png" alt="92b3401d754315d494e32f9bab97e755.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Halder, S. &amp; Ozdemir, S. <em>Hands-On Machine Learning for Cybersecurity: Safeguard your system by making your machines intelligent using the Python ecosystem[M].</em> Packt Publishing Ltd, 2018.</li>
<li>周志华. 机器学习[M]. 清华大学出版社, 2016.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/09/22/%E4%BB%80%E4%B9%88%E6%98%AFP-NP-NPC%E4%BB%A5%E5%8F%8ANP-Hard%E9%97%AE%E9%A2%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/%E4%BB%80%E4%B9%88%E6%98%AFP-NP-NPC%E4%BB%A5%E5%8F%8ANP-Hard%E9%97%AE%E9%A2%98%EF%BC%9F/" class="post-title-link" itemprop="url">什么是 P, NP, NPC 以及 NP-Hard 问题？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-22 21:17:07" itemprop="dateCreated datePublished" datetime="2020-09-22T21:17:07+08:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Concepts/" itemprop="url" rel="index"><span itemprop="name">Concepts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度并不是表示一个程序解决问题需要花多少时间，而是<strong>当问题规模扩大后，程序需要的时间长度增长得有多快</strong>。</p>
<p>不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序性能很好，具有$O(1)$的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是$O(n)$，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于$O(n^2)$的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是$O(a^n)$的指数级复杂度，甚至$O(n!)$的阶乘级复杂度。</p>
<p>我们将复杂度量级按照数量级递增进行排序得到下图，并将其分为两类：<strong>多项式量级</strong>和<strong>非多项式量级</strong>，后者的复杂度远远大于前者。</p>
<p><img data-src="/2020/09/22/%E4%BB%80%E4%B9%88%E6%98%AFP-NP-NPC%E4%BB%A5%E5%8F%8ANP-Hard%E9%97%AE%E9%A2%98%EF%BC%9F/0.jpg" alt="3723793cc5c810e9d5b06bc95325bf0a.jpeg"></p>
<p>多项式级的复杂度包括$O(1),O(log(n)),O(n^a)$等，它的规模n出现在底数的位置；非多项式级只包含$O(a^n),O(n!)$两种，其复杂度计算机往往不能承受。</p>
<p>自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。举个例子，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。</p>
<p>还有另外一个经典的问题：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE">Hamilton回路</a>。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后回到起点的路径（满足这个条件的路径叫做Hamilton回路）。这个问题目前还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。</p>
<p>由此，我们根据复杂度分级，将问题进行分类。最简单的一类问题被称为P问题，按复杂度依次递增，又有NP问题、NPC问题和NP-Hard问题。先来看看P问题的定义。</p>
<h2 id="P问题"><a href="#P问题" class="headerlink" title="P问题"></a>P问题</h2><blockquote>
<p>定义：在计算复杂度理论中，P（polynomial time class）是在复杂度类问题中可于确定型图灵机以多项式量级（或称多项式时间）求解的决定性问题。</p>
</blockquote>
<p>简单来说，就是<strong>一个P问题可以在多项式（$O(n^k)$）的时间复杂度内被解决</strong>。</p>
<p>P问题比较容易理解，它是复杂度最低的一类问题。事实上，计算机能解决的问题绝大部分都属于P问题，譬如排序、最小树、最短路、最大流、最小费用流、最大匹配等常见问题都是多项式时间可解的P类问题。</p>
<p>然而另一类问题如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TSP">旅行商问题(TSP)</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92">整数线性规划问题(ILP)</a>至今仍未找到多项式时间算法，又往往无法证明多项式算法的不存在性。在这类问题中，又存在一类特殊的问题，即：<strong>我无法在多项式时间内解决该问题，但我可以找到该问题的一个解，然后在多项式时间内验证该解是否正确</strong>。我们将这类问题归类为<strong>NP问题</strong>。举个例子，前面的Hamilton回路问题，虽然它不是P问题，但我可以找到一条路径，并在$O(n)$时间内验证这条路径是否经过每个顶点一次（每个顶点遍历一次）。</p>
<h2 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h2><blockquote>
<p>定义：非确定多项式类（non-deterministic polynomial，缩写：NP）是指在在非确定型图灵机上可以用多项式时间复杂度的算法解决的问题。</p>
</blockquote>
<p>简单来说，NP问题是指<strong>可以在多项式时间内猜出一个解或验证一个解的正确性的问题</strong>。</p>
<p>很显然，前面所说的Hamilton回路属于NP问题。但若是问题变成这样：试问一个图中是否不存在Hamilton回路？该问题就没法在多项式的时间里进行验证了，因为除非你验证过所有的路径，否则你不敢断定它“没有Hamilton回路”。</p>
<p>之所以要定义NP问题，是因为通常<strong>只有NP问题才有可能找到多项式的算法</strong>。若是一个问题连在多项式时间内验证一个解是否正确都做不到，那我们不指望能存在一个解决它的多项式级的算法。事实上信息学中的号称最困难的问题——“NP问题”，其实就是在探讨<strong>NP问题与P问题的关系</strong>。</p>
<p>很显然，所有的P问题都是NP问题，即$P \subset NP$。因为，如果能在多项式时间内解决一个问题，必然能在多项式时间内验证一个问题的解是否正确。那么问题就变成了：<strong>是否所有的NP问题都是P问题，即究竟是否有P=NP?</strong> </p>
<p>目前为止，这个问题还未被证明或推翻。但人们普遍认为，P≠NP，也就是说，多数人相信，<strong>存在至少一个不可能有多项式级复杂度的算法的NP问题</strong>。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，即所谓的NPC问题。正是NPC问题的存在，使人们相信P≠NP。下面我们介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p>
<h2 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h2><blockquote>
<p>定义：如果一个问题满足：</p>
<ol>
<li>它是一个NP问题。</li>
<li>其他属于NP的问题都可在多项式时间内归约成它。</li>
</ol>
<p>我们就将这类问题称为NP-完全问题（NP-Complete，缩写为NP-C或NPC）</p>
</blockquote>
<p>为了说明NPC问题，我们先引入一个概念——<strong>规约(Reducibility)<strong>。简单地说，一个问题A可以规约为问题B的含义是，可以用问题B的解法解决问题A。所以，B的时间复杂度是大于等于A的时间复杂度的。也就是说：</strong>A规约为B，B比A问题要更泛化、更难求解；但一旦B问题解决了，A问题也随之解决了</strong>。</p>
<p>《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以规约为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以找到一个“规则”：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以规约为TSP问题：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。</p>
<p>很显然，规约具有一项重要的性质：<strong>传递性</strong>。如果问题A可规约为问题B，问题B可规约为问题C，则问题A一定可规约为问题C。当然，我们所说的“可规约”是指的可“多项式地”规约(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。规约的过程只有用多项式的时间完成才有意义。</p>
<p>现在我们已经知道，一个问题规约为另一个问题，时间复杂度增加了，问题的应用范围也增大了。<strong>结合规约的传递性，通过对某类问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替原先复杂度较低但应用范围也更小的一类问题的算法</strong>。自然地，我们会想问，如果不断地规约上去，能否找到一个时间复杂度最高，并且能“通吃”所有的NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，<strong>存在这样一个NP问题，所有的NP问题都可以规约成它</strong>。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是所谓的NPC问题，也就是NP-完全问题。到这里你应该可以理解完全（Complete）的含义了。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，<strong>NPC问题是一类NP问题中最复杂的问题，也是在P≠NP假设下最不可能找到多项式时间（化简为P）的问题</strong>。</p>
<p>既然所有的NP问题都能规约为NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p>
<p>那么有没有比NPC问题更复杂的问题呢？答案是有的，就是我们接下来介绍的NP-Hard问题。</p>
<h2 id="NP-Hard问题"><a href="#NP-Hard问题" class="headerlink" title="NP-Hard问题"></a>NP-Hard问题</h2><blockquote>
<p>定义：如果所有NP问题都可以多项式时间归约到某个问题，则称该问题为NP-困难问题（NP-hardness, non-deterministic polynomial-time hardness，缩写为NP-Hard）。</p>
</blockquote>
<p>注意到，一个NP-Hard问题未必可以在多项式时间内验证一个解的正确性，即<strong>NP-Hard问题不一定是NP问题</strong>，也就是NP-Hard问题只满足NPC问题定义的第二个条件。因此我们可以<strong>将NPC问题理解为即是NP问题又是NP-Hard问题的一类问题</strong>。也就是说，NP-Hard问题要比NPC问题的范围更广。从时间复杂性上来考虑，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高更难以解决。换句话说，即使NPC问题有多项式时间的解（P=NP），NP-Hard问题依然可能没有多项式时间的解。</p>
<p>研究生数模竞赛中遇到的基本都是NP-Hard问题，在P≠NP的假设下，只能设计启发式算法或者近似算法，求得令人满意的可行解。<strong>启发式算法</strong>是一个基于直观或经验构造的算法，在可接受的花费(指计算时间和空间)下给出待解决优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。启发式算法以仿自然体算法为主，主要有遗传算法、蚁群算法、模拟退火法、神经网络等；<strong>近似算法</strong>则可以相当快速地找到合理的解决方案，需要证明解决方案的近似性，即所有实例中最坏情况下可以保证近似解的范围，并且运行时间合理。近似算法对于任何实例通常可得到一个有质量保证的解。近似性常用近似比、近似方案来度量。近似算法往往设计方法不难，比如贪心法、动态规划、基于线性规划的方法，但近似性的证明非常难。两者相辅相成。</p>
<h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p>基于P≠NP和P=NP两种猜想，我们得到描述P, NP, NPC，以及NP-Hard之间关系的欧拉图：</p>
<p><img data-src="/2020/09/22/%E4%BB%80%E4%B9%88%E6%98%AFP-NP-NPC%E4%BB%A5%E5%8F%8ANP-Hard%E9%97%AE%E9%A2%98%EF%BC%9F/1.png" alt="4dead7744239cc0042d7f029f3c3875a.png"></p>
<p>可以看到，在P≠NP假设下，P与NPC没有交集，亦即我们之前提到的，NPC问题最不可能化简为P问题。而在P=NP问题下，即使是最复杂的NPC问题也可以化简为P问题，因为从定义来说NPC也是一个NP问题。</p>
<h2 id="确定型与非确定型图灵机"><a href="#确定型与非确定型图灵机" class="headerlink" title="确定型与非确定型图灵机"></a>确定型与非确定型图灵机</h2><p>定义中提及了确定型/非确定型图灵机，虽然对于理解P和NP问题没有太大影响，但还是有必要在这里做一个简要的阐述。</p>
<p>图灵机（Turing machine），又称<strong>确定型图灵机</strong>，是英国数学家艾伦·图灵于1936年提出的一种将人的计算行为抽象化的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。图灵机有以下几个组成部分：</p>
<ol>
<li>一个不限长度的<strong>纸带</strong>。纸带被划分成一个个的小格子，格子中标有符号或者空白。</li>
<li>一个<strong>读写头</strong>。可在纸带上移动，能够读写格子中的符号。</li>
<li>一套<strong>控制规则</strong>。根据当前机器所处状态以及当前读写头所指的格子上的符号，来决定读写头下一步的动作，并改变状态寄存器的值。</li>
<li>一个<strong>状态寄存器</strong>。保存图灵机当前状态。</li>
</ol>
<p>不难看出图灵机本质上就是状态机，我们可以将机器从开始运行到停机的运作过程记录为一串序列：</p>
<p>$$q_0 \rightarrow_{\omega_0} q_1 \rightarrow_{\omega_1} q_2 \rightarrow … \rightarrow_{\omega_{n-1}} q_n$$</p>
<p>开始时，机器处于$q_0$状态，读写头指向0号格子；开始运行后，读入格子中的符号$\omega_0$，根据控制规则，机器进入下一状态$q_1$；重复此过程，直至到达终止状态，机器停机。</p>
<p>终止状态包括两种状态，$q_{accept}$称为接受状态，即机器根据控制规则成功运行至终态；$q_{reject}$称为拒绝状态，如果在运行中遇到下一个操作没有定义的情况，机器将立刻停机并拒绝输入的字符串。由于整个过程只要初始状态、输入、控制规则确定，机器运行的过程就确定，所以我们将其称之为<strong>确定型</strong>图灵机。</p>
<p>如果不加特殊说明，通常所说的图灵机都是确定型图灵机。<strong>非确定型图灵机</strong>和确定型图灵机的不同之处在于，在计算的每一时刻，根据当前状态和读写头所读的符号，<strong>机器存在多种状态转移方案，机器将任意地选择其中一种方案继续运作</strong>，直到最后停机为止。</p>
<p>图灵机是一个计算机的理论模型，我们通常说，现代计算机是基于冯诺依曼体系的，实际是冯诺依曼机就是基于图灵机模型的实现，包括高度复杂化的运算、控制、存储、输入、输出五个部分。比如纸带（用内存/磁盘模拟）、内部状态寄存器（现代计算机有大量的标志位和大量的寄存器甚至寄存器组）、在纸带上移动（各种跳转指令、各种复杂的寻址操作）、控制规则（CPU指令集）等。到目前为止，依然没有能够超越图灵机的模型。关于人工智能、量子计算机是否超越了图灵机也有非常有趣的讨论，感兴趣的读者可以自行查阅资料。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.matrix67.com/blog/archives/105">什么是P问题、NP问题和NPC问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27039635">怎么理解P问题和NP问题？- 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA">图灵机 - WiKi</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">基于 DPDK 的模拟 (D)Dos 攻击实验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 21:02:12" itemprop="dateCreated datePublished" datetime="2020-09-17T21:02:12+08:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Projects/" itemprop="url" rel="index"><span itemprop="name">Projects</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>该实验是我暑期前往导师实验室，与一群东南大学网安三年级的本科生所做。我的工作是帮他们搭建了实验所需运行的服务器环境，实验数据的采集、制图以及结果分析均是他们所做。由于该实验可能在我研究生阶段进行进一步的研究，所以将它摘至我的博客，文档亦摘录了本科生们所做的实验报告，特此申明。</p>
</blockquote>
<p>东大网安本科组员：翟思宇、肖遥、宋昌霖、胡钺琳、赵泽瑞、赵钧陶<br>指导老师：肖卿俊</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本实验搭载高速以太网卡，通过持续的高速数据传输，达到逼近目标服务器链路的传输速率极限，以模拟 (D)Dos 攻击的效果。攻击主机系统采用 Ubuntu Server 版本，受 Linux 系统 I/O 的内核机制的影响，发包速率受到限制。本实验创新性的利用 DPDK 软件平台绕过系统内核，实现高数据吞吐率的效果。</p>
<p><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/0.png" alt="81db04d3b1658e9c254bfbfce6dedde2.png"></p>
<p>如上图，Linux 内核协议栈的实现决定了它内核网络协议的性能不佳，Linux 在内核收包处理时，将网卡收到的报文通过 DMA 放到内存，网卡出发中断通知系统有报文到达，系统分配 sk_buff，将报文拷贝到 sk_buff 中，交由协议栈处理，之后将其送用户态应用程序处理。</p>
<p>这种情况下，报文数量的增多将急剧增加资源的消耗。这包含报文产生 CPU 中断的上下文切换、为报文申请分配 sk_buff 消耗的资源、用户态程序收发包时产生系统调用和上下文切换带来的系统资源消耗。Kernel Bypass（内核旁路）技术应运而生，DPDK 正是采用的上图图由这种类 DMA 机制，直接将数据包从硬件（网卡端口）传输至用户态应用程序，以此来实现低延迟、低消耗的高吞吐网络传输。</p>
<p>TRex 是思科研发的一款成熟的基于 DPDK 的网络测试工具。它运行在标准的 Intel 处理芯片上，同时支持 stateful 和 stateless 两种模式，stateful 可以描述 L4~L7 层的应用场景，而 stateless 主要用于进行定制包的发包。本实验主要利用 TRex 的 DPDK 高线速发包能力，模拟对目标服务器进行 (D)Dos 打击。</p>
<p><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/1.png" alt="7a135e990f639b406cd1cc244d4943f3.png"></p>
<h2 id="实验物理环境"><a href="#实验物理环境" class="headerlink" title="实验物理环境"></a>实验物理环境</h2><p><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/2.JPG" alt="2ffa174d247d24ce9f16ea7332178308.jpeg"></p>
<ol>
<li>DELL Xeon Server，OS: Ubuntu Server 18.04 LTS。原装的系统为 CentOS 6，实验过程中遇到内核版本过低不支持 TRex 发包的问题，所以重装了 Ubuntu 系统。此外服务器还安装了实验室购入的兼容 DPDK 的 INTEL X710 网卡。</li>
<li>NetFPGA-SUME Virtex-7 FPGA Development Board，四个 10Gbps 的端口，实验过程中使用两根光缆连接到服务器构成回环。</li>
<li>DELL 工作站，用于将编译好的 P4 程序烧入 NetFPGA 智能网卡。</li>
</ol>
<h2 id="服务器环境准备"><a href="#服务器环境准备" class="headerlink" title="服务器环境准备"></a>服务器环境准备</h2><h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><ol>
<li>服务器操作系统选择兼容性、稳定性较好的 Ubuntu 18.04.5 LTS 版本，官网下载需要翻墙，也可以选择清华或阿里的开源软件镜像网。<a target="_blank" rel="noopener" href="https://releases.ubuntu.com/bionic/">官网下载地址</a></li>
<li>制作启动 U 盘，使用 Rufus 镜像刻录工具将下载好的 iso 镜像刻录至 U 盘。<a target="_blank" rel="noopener" href="https://ubuntu.com/tutorials/create-a-usb-stick-on-windows#1-overview">官网教程 - Create a bootable USB stick on Windows</a>。</li>
<li>启动服务器，按住 F2 进入 DELL 的 BIOS 界面，将 U 盘调整为启动的第一选项。</li>
<li>重启服务器，按照引导程序安装系统。<a target="_blank" rel="noopener" href="https://ubuntu.com/tutorials/install-ubuntu-server#1-overview">官网教程 - Install Ubuntu Server</a></li>
</ol>
<h3 id="连接外网"><a href="#连接外网" class="headerlink" title="连接外网"></a>连接外网</h3><p><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/3.JPG" alt="8d45ed82634b33c68b4ddacfeef8a6a7.jpeg"></p>
<p>服务器共有四个网口 eno1～eno4，将网线插在左数第一个网口对应 eno1（图中①），并配置 interfaces 文件。图中②位置为 INTEL X710 网卡位置，从 NetFPGA 智能网卡的端口连接至服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vi etc/network/interfaces</span><br><span class="line"></span><br><span class="line">auto eno1</span><br><span class="line">iface eno1 inet dhcp</span><br></pre></td></tr></table></figure>

<p>在<code>/etc/resolv.conf</code>中加入 DNS 配置，此为阿里提供的公共 DNS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 223.6.6.6</span><br></pre></td></tr></table></figure>

<p>要先手动设置 IP 再使用 <code>dhclient</code> 命令启用 DHCP，<strong>每次重启服务器后如需连接外网，需输入这两行命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.102 netmask 255.255.255.0</span><br><span class="line">dhclient eno1</span><br></pre></td></tr></table></figure>

<p>执行完成就可以连通外网了</p>
<h3 id="设置网口"><a href="#设置网口" class="headerlink" title="设置网口"></a>设置网口</h3><p><code>ifconfig -a </code>查看网口信息，列出了 X710 网卡的两个网口信息，默认驱动是 Kernel Driver i40e，先设置 IP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig enp59s0f0 192.168.200.2</span><br><span class="line">sudo ifconfig enp59s0f1 192.168.201.2</span><br></pre></td></tr></table></figure>

<p>在工作站的主机上 ping 一下服务器保证双向联通</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>使用 <code>apt-get</code> 命令安装 DPDK 依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt install -y dpdk dpdk-dev dpdk-doc</span><br></pre></td></tr></table></figure>

<p>安装其他依赖，可以先在本地保存为 <code>install.sh</code>，然后使用 <code>scp</code> 命令传到服务器上 <code>sh install.sh</code>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y cmake gcc g++ git automake llvm llvm-dev llvm-runtime libtool bison flex build-essential vim</span><br><span class="line"></span><br><span class="line"># Install pkg-config here, as it is required for p4lang/PI</span><br><span class="line"># installation to succeed.</span><br><span class="line">sudo apt-get install -y pkg-config</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y wget curl zip unzip rar unrar unar</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y libgc-dev libfl-dev libgmp-dev libevent-dev libssl-dev libjudy-dev libpcap-dev tcpdump</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y libboost-dev libboost-iostreams-dev libboost-graph-dev libboost-test-dev libboost-program-options-dev libboost-system-dev libboost-filesystem-dev libboost-thread-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y libreadline6 libreadline6-dev</span><br><span class="line"># 这里如果提示废弃就执行下面的安装</span><br><span class="line">sudo apt-get install -y libreadline-dev </span><br><span class="line"></span><br><span class="line"># Deps needed to build PI:</span><br><span class="line">sudo apt-get install -y libjudy-dev libreadline-dev valgrind libtool-bin libboost-dev libboost-system-dev libboost-thread-dev</span><br><span class="line"></span><br><span class="line"># Things needed for `cd tutorials/exercises/basic ; make run` to work:</span><br><span class="line">sudo apt-get install -y libgflags-dev net-tools</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y doxygen graphviz texlive-full</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y bridge-utils tcpreplay</span><br><span class="line">sudo apt-get install -y zlib1g-dev pciutils kmod strace  ## needed by cisco trex</span><br></pre></td></tr></table></figure>

<h3 id="安装TRex"><a href="#安装TRex" class="headerlink" title="安装TRex"></a>安装TRex</h3><p>联网下载 TRex</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget --no-cache http://trex-tgn.cisco.com/trex/release/latest</span><br><span class="line">tar -zxvf latest</span><br></pre></td></tr></table></figure>

<p>我们下载的 TRex 最新版本为 v2.82，进入到该目录下并执行 DPDK 端口设置脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd v2.82</span><br><span class="line">./dpdk_setup_ports.py -i</span><br></pre></td></tr></table></figure>

<p>按照下图设置</p>
<p><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/4.jpeg" alt="0b9649d536fbab09908a9df0303c590a.jpeg"></p>
<p>此时可以注意到，X710 网卡的两个网口还是绑定的 i40e 内核驱动。但在运行 TRex 发包命令后会自动绑定到 DPDK 兼容驱动 igb_uio 上。</p>
<h2 id="发包测试"><a href="#发包测试" class="headerlink" title="发包测试"></a>发包测试</h2><p>实验环境准备就绪，进行发包测试。参考 TRex 官方手册 <a target="_blank" rel="noopener" href="https://trex-tgn.cisco.com/trex/doc/trex_manual.html#_running_examples">Running examples
</a>，在 stateful 模式下使用 <code>t-rex-64</code> 命令发送数据包。<code>-f</code> 指定配置 yaml，<code>-m</code> 指定重放次数，<code>-l</code> 指定网络延迟检测速率。更多参数详见官方手册。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./t-rex-64 -f avl/sfr_delay_10_1g.yaml -m 5 -l 1000</span><br></pre></td></tr></table></figure>

<p>测试效果如下：</p>
<p><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/5.jpeg" alt="7402f2999111d19e378f8883aaf3ba34.jpeg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-Per port stats table </span><br><span class="line"></span><br><span class="line">      ports |               0 |               1 </span><br><span class="line"> -----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   opackets |        27882688 |        35434728 </span><br><span class="line">     obytes |      8217921859 |     28586813888 </span><br><span class="line">   ipackets |         5007937 |             709 </span><br><span class="line">     ibytes |      4647534484 |           79608 </span><br><span class="line">    ierrors |               0 |               0 </span><br><span class="line">    oerrors |               0 |               0 </span><br><span class="line">      Tx Bw |       1.18 Gbps |       3.81 Gbps </span><br><span class="line"></span><br><span class="line">-Global stats enabled </span><br><span class="line"> Cpu Utilization : 31.6  %  31.6 Gb/core </span><br><span class="line"> Platform_factor : 1.0  </span><br><span class="line"> Total-Tx        :       5.00 Gbps  </span><br><span class="line"> Total-Rx        :       0.00  bps  </span><br><span class="line"> Total-PPS       :       1.07 Mpps  </span><br><span class="line"> Total-CPS       :      20.51 Kcps  </span><br><span class="line"></span><br><span class="line"> Expected-PPS    :       1.08 Mpps  </span><br><span class="line"> Expected-CPS    :      20.61 Kcps  </span><br><span class="line"> Expected-BPS    :       5.02 Gbps  </span><br><span class="line"></span><br><span class="line"> Active-flows    :    21328  Clients :      511   Socket-util : 0.0775 %    </span><br><span class="line"> Open-flows      :  1342791  Servers :     5621   Socket :    24927 Socket/Clients :  48.8 </span><br><span class="line"> drop-rate       :       5.00 Gbps   </span><br><span class="line"> current time    : 66.5 sec  </span><br><span class="line"> test duration   : 3533.5 sec  </span><br><span class="line"></span><br><span class="line">-Latency stats enabled </span><br><span class="line"> Cpu Utilization : 0.1 %  </span><br><span class="line"> if|   tx_ok , rx_ok  , rx check ,error,       latency (usec) ,    Jitter          max window </span><br><span class="line"></span><br><span class="line">   |         ,        ,          ,     ,   average   ,   max  ,    (usec)                     </span><br><span class="line"> ---------------------------------------------------------------------------------------------------------------- </span><br><span class="line"></span><br><span class="line"> 0 |    65254,   12858,         0,    0,          7  ,      23,       1      |  10  10  15  10  12  11  12  23  10  10  15  18  12 </span><br><span class="line"> 1 |    65254,     136,         0,    0,          3  ,       0,       0      |  0  0  0  0  0  0  0  0  0  0  0  0  0 </span><br><span class="line"></span><br><span class="line">## </span><br></pre></td></tr></table></figure>

<p>主要记录的数据包括：</p>
<ul>
<li><strong>Cpu Utilization</strong>，CPU利用率</li>
<li><strong>Total-Tx</strong>，总计发送速率（Transport）</li>
<li><strong>Total-Rx</strong>，总计接受速率（Receive）</li>
<li><strong>Total-PPS</strong>，总计每秒传输包数量（Packets per second）</li>
</ul>
<h2 id="发包实验"><a href="#发包实验" class="headerlink" title="发包实验"></a>发包实验</h2><p>接下来我们尝试在 stateful 模式下模拟 stateless 发包，使用的是 <code>cap2/</code> 目录下的 <code>imix.yaml</code> 配置文件，根据以太网协议，一个数据包的大小从最小 64Bytes 到最大 1518Bytes，imix 提供了 imix_64、imix_594 和 imix_1518 三类配置文件。</p>
<p><code>-c</code> 指定 CPU 核数，观察并绘制不同包大小、不同核数时 CPU 利用率以及吞吐率的 eps 矢量图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./t-rex-64 -f cap2/imix_1518.yaml -m 823451 -l 1000 -c 2</span><br></pre></td></tr></table></figure>

<p>实验结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">-Per port stats table </span><br><span class="line"></span><br><span class="line">      ports |               0 |               1 </span><br><span class="line"> -----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   opackets |        34232892 |           42080 </span><br><span class="line">     obytes |     51904428378 |         2777280 </span><br><span class="line">   ipackets |               0 |               0 </span><br><span class="line">     ibytes |               0 |               0 </span><br><span class="line">    ierrors |               0 |               0 </span><br><span class="line">    oerrors |               0 |               0 </span><br><span class="line">      Tx Bw |       9.89 Gbps |     527.55 Kbps </span><br><span class="line"></span><br><span class="line">-Global stats enabled </span><br><span class="line"> Cpu Utilization : 100.0  %  9.9 Gb/core </span><br><span class="line"> Platform_factor : 1.0  </span><br><span class="line"> Total-Tx        :       9.89 Gbps  </span><br><span class="line"> Total-Rx        :       0.00  bps  </span><br><span class="line"> Total-PPS       :     816.02 Kpps  </span><br><span class="line"> Total-CPS       :       0.00  cps  </span><br><span class="line"></span><br><span class="line"> Expected-PPS    :       6.59 Gpps  </span><br><span class="line"> Expected-CPS    :       6.59 Gcps  </span><br><span class="line"> Expected-BPS    :      80.00 Tbps  </span><br><span class="line"></span><br><span class="line"> Active-flows    :     1600  Clients :      254   Socket-util : 0.0100 %    </span><br><span class="line"> Open-flows      :     1600  Servers :    65534   Socket :     1600 Socket/Clients :  6.3 </span><br><span class="line"> Total_queue_full : 72264932         </span><br><span class="line"> drop-rate       :       9.89 Gbps   </span><br><span class="line"> current time    : 43.3 sec  </span><br><span class="line"> test duration   : 3556.7 sec  </span><br><span class="line"></span><br><span class="line">-Latency stats enabled </span><br><span class="line"> Cpu Utilization : 0.1 %  </span><br><span class="line"> if|   tx_ok , rx_ok  , rx check ,error,       latency (usec) ,    Jitter          max window </span><br><span class="line"></span><br><span class="line">   |         ,        ,          ,     ,   average   ,   max  ,    (usec)                     </span><br><span class="line"> ---------------------------------------------------------------------------------------------------------------- </span><br><span class="line"></span><br><span class="line"> 0 |    42080,       0,         0,    0,          0  ,       0,       0      |  0  0  0  0  0  0  0  0  0  0  0  0  0 </span><br><span class="line"> 1 |    42081,       0,         0,    0,          0  ,       0,       0      |  0  0  0  0  0  0  0  0  0  0  0  0  0 </span><br><span class="line"></span><br><span class="line">## </span><br></pre></td></tr></table></figure>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h3><p>一个以太网帧的结构包括：</p>
<table>
<thead>
<tr>
<th>PA</th>
<th>SFD</th>
<th>DA</th>
<th>SA</th>
<th>Type</th>
<th>Payload</th>
<th>FCS</th>
<th>IFG</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>1</td>
<td>6</td>
<td>6</td>
<td>2</td>
<td>46 ~ 1500</td>
<td>4</td>
<td>12</td>
</tr>
</tbody></table>
<p>最小帧长：7+1+(6+6+2+46+4)+12 = 84B（最小有效帧长 64B）<br>最大帧长：7+1+(6+6+2+1500+4)+12 = 1538B（最大有效帧长 1518B）</p>
<p>对于最小帧长，最大包传输率 M 和吞吐率 T 为：</p>
<p>$$M = Speed/Size = 100 * 10^9 / (84 * 8) = 148809523 pps$$<br>$$T = M * 64 * 8 = 76.19Gbps$$</p>
<p>对于最大帧长，最大包传输率 M 和吞吐率 T 为：</p>
<p>$$M = Speed/Size = 100 * 10^9 / (1538 * 8) = 8127438 pps$$<br>$$T = M * 1518 * 8 = 98.69Gbps$$</p>
<p>以此类推，我们对于不同的帧长做了理论分析，得到下图：</p>
<p><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/6.png" alt="38021550bd20f375c0c872a80cea41af.png"></p>
<h3 id="吞吐率测试结果"><a href="#吞吐率测试结果" class="headerlink" title="吞吐率测试结果"></a>吞吐率测试结果</h3><p>以下是吞吐率的测试结果：</p>
<p><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/7.png" alt="037b37c99b1bc4c938f887dc1b876ba1.png"><br><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/8.png" alt="ec784c4bc84e984d27170739145d5bfe.png"><br><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/9.png" alt="d9c6568a7c11555a9290d452fbacafe2.png"></p>
<h3 id="包传输率测试结果"><a href="#包传输率测试结果" class="headerlink" title="包传输率测试结果"></a>包传输率测试结果</h3><p>以下是包传输率的测试结果：</p>
<p><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/10.png" alt="0f5b53c8b5544ae9572cebc9168f12cb.png"><br><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/11.png" alt="83c9995318589576075bf3140b4f46fd.png"><br><img data-src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/12.png" alt="79d66dcca878a695f31c01cf8e08e2d8.png"></p>
<h3 id="与内核机制发包的对比"><a href="#与内核机制发包的对比" class="headerlink" title="与内核机制发包的对比"></a>与内核机制发包的对比</h3><table>
<thead>
<tr>
<th align="center">包大小(B)</th>
<th align="center">内核机制发包<br>CPU利用率</th>
<th align="center">内核机制发包<br/>PPS(Kpps)</th>
<th align="center">DPDK机制发包<br/>PPS(Mpps)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">64</td>
<td align="center">100%</td>
<td align="center">593.5</td>
<td align="center">14.85</td>
</tr>
<tr>
<td align="center">549</td>
<td align="center">100%</td>
<td align="center">585.29</td>
<td align="center">2.04</td>
</tr>
<tr>
<td align="center">1518</td>
<td align="center">97.70%</td>
<td align="center">537.27</td>
<td align="center">0.82</td>
</tr>
</tbody></table>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>由上述实验结果可知：</p>
<ol>
<li>10Gbps 线速的网络，用 DPDK 跑 4 个核，基本可以实现 64B 最小包较好的发送吞吐率，但是仍达不到 10Gbps 的线速，只有 7.6Gbps 左右。</li>
<li>DPDK 由于采用了绕过内核驱动的技术，使得网络数据包的发送速度大大增加。</li>
<li>此外，随着数据包长度增加，其他条件一定时，吞吐率也随之增加，这与我们的理论分析基本吻合。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><em>Surasak Sanguanpong, Experiences in Building a 100 Gbps (D)DoS Traffic Generator, DIY with a Single  Commodity-off-the-shelf (COTS) Server.</em></li>
<li><a target="_blank" rel="noopener" href="https://trex-tgn.cisco.com/trex/doc/trex_manual.html">TRex official manual</a></li>
<li><a target="_blank" rel="noopener" href="https://trex-tgn.cisco.com/trex/doc/trex_stateless.html#_stateful_vs_stateless">TRex Stateless Support</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/cisco-system-traffic-generator/trex-core">思科TRex Traffic Generator代码仓库</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/" class="post-title-link" itemprop="url">DataCon2020 加密恶意流量检测初赛 Writeup 及总结反思</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-09 23:20:52" itemprop="dateCreated datePublished" datetime="2020-08-09T23:20:52+08:00">2020-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Projects/" itemprop="url" rel="index"><span itemprop="name">Projects</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="初赛题目"><a href="#初赛题目" class="headerlink" title="初赛题目"></a>初赛题目</h2><p>主办方提供了 black/white/test 三个 pcap 文件夹，其中 black 和 white 分别是检测出有/无恶意软件感染的客户端 IP 组，要求选手对 test 数据集进行判定。</p>
<p><img data-src="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/0.png" alt="09bda35ff290f2e34d88d50e71d98f1a.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题的解题过程应分为以下三个大步骤：</p>
<ol>
<li><strong>特征选择（Feature Selection）</strong>，选取对于区分正常/恶意流量有明显作用的 Features。</li>
<li><strong>特征提取（Feature Extraction）</strong>，从 pcap 文件中提取上述 Features，并转换为模型训练所需要的格式。我们选择的特征提取工具为 <strong>Zeek</strong>。</li>
<li><strong>模型训练（Model Training）</strong>，选择合适的机器学习模型对三类 pcap 文件进行训练和预测。我们选择的 Python 机器学习库为 <strong>scikit-learn</strong>。</li>
</ol>
<h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><h3 id="合并pcap文件"><a href="#合并pcap文件" class="headerlink" title="合并pcap文件"></a>合并pcap文件</h3><p>主办方提供的 pcap 文件，其中 white/black 各有 1500 个 pcap，test 2000 个 pcap</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  tree eta_1 </span><br><span class="line">eta_1</span><br><span class="line">├── black</span><br><span class="line">│   ├── 192.168.10.91.pcap</span><br><span class="line">│   ├── 192.168.44.25.pcap</span><br><span class="line">│   ├── ...</span><br><span class="line">│   └── 192.168.80.115.pcap</span><br><span class="line">├── test</span><br><span class="line">│   ├── 192.168.150.71.pcap</span><br><span class="line">│   ├── 192.168.150.99.pcap</span><br><span class="line">│   ├── ...</span><br><span class="line">│   └── 192.168.210.239.pcap</span><br><span class="line">└── white</span><br><span class="line">    ├── 192.168.119.23.pcap</span><br><span class="line">    ├── 192.168.122.37.pcap</span><br><span class="line">		├── ...</span><br><span class="line">    └── 192.168.96.180.pcap</span><br></pre></td></tr></table></figure>

<p>使用 <code>mergecap</code> 命令将 pcap 文件合并为三个大的 pcap 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  mergecap -w black.pcap ./eta_1/black/*.pcap</span><br><span class="line">➜  tree -s -h .     </span><br><span class="line">.</span><br><span class="line">├── [418M]  black.pcap</span><br><span class="line">├── [1.0G]  test.pcap</span><br><span class="line">└── [1.7G]  white.pcap</span><br></pre></td></tr></table></figure>

<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>参考了多篇加密恶意流量检测的研究论文，我们初步确定了以下四类需要提取的 Features，包括<strong>TLS客户端指纹信息</strong>、<strong>数据包元数据</strong>、<strong>HTTP头部信息</strong>和<strong>DNS响应信息</strong>。</p>
<h4 id="TLS-client-fingerprinting："><a href="#TLS-client-fingerprinting：" class="headerlink" title="TLS client fingerprinting："></a>TLS client fingerprinting：</h4><p>在进行TLS握手时，会进行如下几个步骤：</p>
<ol>
<li><strong>Client Hello</strong>，客户端提供支持的加密套件数组（cipher suites）；</li>
<li><strong>Server Hello</strong>，由服务器端选择一个加密套件，传回服务器端公钥，并进行认证和签名授权（<strong>Certificate</strong> + Signature）；</li>
<li>客户端传回客户端公钥（<strong>Client Key Exchange</strong>），客户端确立连接；</li>
<li>服务器端确立连接，开始 HTTP 通信。</li>
</ol>
<p><img data-src="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/1.png" alt="5b01483a65bdc17c68873508796bb85e.png"></p>
<p>以上加粗的四种消息类型可以通过 TLS 握手协议的 <strong>Handshake Type</strong> 做区分：</p>
<p><img data-src="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/2.png" alt="bff6a460bcaa7c442014c3eb89deb26f.png"></p>
<p>基于此，我们选取了以下特征：</p>
<ul>
<li><strong>客户端支持的加密套件数组</strong>（Cipher suites），<strong>服务器端选择的加密套件</strong>。</li>
<li><strong>支持的扩展</strong>（TLS extensions），若分别用向量表示客户端提供的密码套件列表和 TLS 扩展列表，可以从服务器发送的确认包中的信息确定两组向量的值。</li>
<li><strong>客户端公钥长度</strong>（Client public key length），从密钥交换的数据包中，得到密钥的长度。</li>
<li><strong>Client version</strong>，the preferred TLS version for the client</li>
<li><strong>是否非CA自签名</strong>，统计数据表示，恶意流量约70%出现非CA认证服务器且自签名的情况，非恶意流量约占0.1%。此项判断的依据是：未出现 <code>CA: True</code> 字段（默认非 CA 机构）且 <code>signedCertificate</code> 中的 <code>issuer</code> 字段等于 <code>subject</code> 字段。</li>
</ul>
<h4 id="数据包元数据："><a href="#数据包元数据：" class="headerlink" title="数据包元数据："></a>数据包元数据：</h4><ul>
<li><strong>数据包的大小</strong>，数据包的长度受 UDP、TCP 或者 ICMP 协议中数据包的有效载荷大小影响，如果数据包不属于以上协议，则被设置为 IP 数据包的大小。</li>
<li><strong>到达时间序列</strong></li>
<li><strong>字节分布</strong></li>
</ul>
<h4 id="HTTP头部信息："><a href="#HTTP头部信息：" class="headerlink" title="HTTP头部信息："></a>HTTP头部信息：</h4><ul>
<li><strong>Content-Type</strong>，正常流量 HTTP 头部信息汇总值多为 <code>image/*</code>，而恶意流量为 <code>text/*、text/html、charset=UTF-8</code> 或者 <code>text/html;charset=UTF-8</code>。</li>
<li><strong>User-Agent</strong></li>
<li><strong>Accept-Language</strong></li>
<li><strong>Server</strong></li>
<li><strong>HTTP响应码</strong></li>
</ul>
<h4 id="DNS响应信息："><a href="#DNS响应信息：" class="headerlink" title="DNS响应信息："></a>DNS响应信息：</h4><ul>
<li><strong>域名的长度</strong>：正常流量的域名长度分布为均值为6或7的高斯分布（正态分布）；而恶意流量的域名（FQDN全称域名）长度多为6（10）。</li>
<li><strong>数字字符及非字母数字(non-alphanumeric character)的字符占比</strong>：正常流量的DNS响应中全称域名的数字字符的占比和非字母数字字符的占比要大。</li>
<li><strong>DNS解析出的IP数量</strong>：大多数恶意流量和正常流量只返回一个IP地址；其它情况，大部分正常流量返回2-8个IP地址，恶意流量返回4或者11个IP地址。</li>
<li><strong>TTL值</strong>：正常流量的TTL值一般为60、300、20、30；而恶意流量多为300，大约22%的DNS响应汇总TTL为100，而这在正常流量中很罕见。</li>
<li><strong>域名是否收录在Alexa网站</strong>：恶意流量域名信息很少收录在Alexa top-1,000,000中，而正常流量域名多收录在其中。</li>
</ul>
<h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>特征提取我们采用的工具是 <strong>Zeek</strong>，它的前身是 Bro，一款网络安全监视（Network Security Monitoring）工具，它定义了自己的 DSL 语言，支持直接处理 pcap 文件生成各类日志文件，包括 dns、http、smtp 等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ls</span><br><span class="line">conn.log	dhcp.log		 files.log	infected.pcap	  packet_filter.log	  smb_files.log	</span><br><span class="line">smtp.log	lce_rpc.log	 dns.log	  http.log	 kerberos.log	   pe.log		smb_mapping.log	</span><br><span class="line">ssl.log		weird.log		 x5Q9.log</span><br></pre></td></tr></table></figure>



<p>Zeek 网上有一些现成的脚本，我们采用的是 <strong>Zeek FlowMeter</strong>，它基于 OSI 七层协议的网络层和传输层，可以分析并生成一些 Packets 到达时间序列、Packet 字节大小和元数据等新特征。</p>
<p>在使用时，我们需要在 <code>local.zeek</code> 配置文件中加入 <code>@load flowmeter</code>，这样 Zeek 在执行时会加载 <code>flowmeter.zeek</code> 并生成对应的 <code>flowmeter.log</code>，下面列出了 FlowMeter 提取出的一些特征，包括上下行包总数、包负载均值方差等。其他详细的特征请见 <a target="_blank" rel="noopener" href="https://github.com/zeek-flowmeter/zeek-flowmeter">zeek-flowmeter GitHub官方文档</a>。</p>
<table>
<thead>
<tr>
<th>Feature Name</th>
<th>Description</th>
<th>exists in FlowMeter</th>
</tr>
</thead>
<tbody><tr>
<td>uid</td>
<td>The ID of the flow as given by Zeek</td>
<td>No</td>
</tr>
<tr>
<td>flow_duration</td>
<td>The length of the flow in seconds (maximal precision ms). If only on packet was seen the duration is 0.</td>
<td>Yes</td>
</tr>
<tr>
<td>fwd_pkts_tot</td>
<td>The number of packets travelling in the forward direction.</td>
<td>Yes</td>
</tr>
<tr>
<td>bwd_pkts_tot</td>
<td>The number of packets travelling in the backwards direction.</td>
<td>Yes</td>
</tr>
<tr>
<td>fwd_pkts_per_sec</td>
<td>The average number of forward packets transmitted per second during the flow. If the duration is 0 then this feature is also set to 0.</td>
<td>Yes</td>
</tr>
<tr>
<td>fwd_pkts_payload.avg</td>
<td>The average payload size, in bytes, seen in the forward direction.</td>
<td>Yes</td>
</tr>
<tr>
<td>fwd_pkts_payload.std</td>
<td>The standard deviation of the payload size, in bytes, seen in the forward direction.</td>
<td>Yes</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>除 <code>flowmeter.log</code> 之外我们还需要关注 <code>conn.log</code>、<code>ssl.log</code> 和 <code>X509.log</code>。这几个日志共同字段 <code>uid</code> 是 Zeek 根据一次连接的源/目的 IP、源/目的端口四元组生成的唯一 ID。为了方便后续的处理，我们将这几个日志文件统一读入，使用 <code>uid</code> 字段连接后转成 csv 格式输出到文件。<strong>最终我们提取的特征如下：</strong></p>
<p><img data-src="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/3.jpeg" alt="7d1475ca9c4d88e2c3e078a126fdfd52.jpeg"></p>
<h3 id="特征向量化"><a href="#特征向量化" class="headerlink" title="特征向量化"></a>特征向量化</h3><p>因为模型训练不支持 <code>str</code> 类型的特征，所以需要对 <code>version</code> 和 <code>server_cipher</code> 等字段进行特征向量化。</p>
<table>
<thead>
<tr>
<th>version</th>
<th>cipher</th>
</tr>
</thead>
<tbody><tr>
<td>TLSv10</td>
<td>TLS_RSA_WITH_3DES_EDE_CBC_SHA</td>
</tr>
<tr>
<td>TLSv10</td>
<td>TLS_RSA_WITH_3DES_EDE_CBC_SHA</td>
</tr>
<tr>
<td>TLSv12</td>
<td>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</td>
</tr>
<tr>
<td>TLSv10</td>
<td>TLS_RSA_WITH_RC4_128_MD5</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p><code>DictVectorizer</code> 是 scikit-learn 库中用于将 Python <code>dict</code> 对象表示的特征数组转换为 scikit-learn Estimator 使用的 NumPy/SciPy 表示形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_by_dict</span>(<span class="params">src_file, dest_file</span>):</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line">    vec = DictVectorizer()</span><br><span class="line"></span><br><span class="line">    df = pd.read_csv(src_file)</span><br><span class="line">    vs1 = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: &#123;<span class="string">&#x27;version&#x27;</span>: x&#125;, df[<span class="string">&#x27;version&#x27;</span>]))</span><br><span class="line">    vs2 = vec.fit_transform(vs1).toarray()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(vec.get_feature_names()):</span><br><span class="line">        df[name] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x[index]), vs2))</span><br><span class="line"></span><br><span class="line">    df.to_csv(dest_file, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>向量化后的效果：</p>
<table>
<thead>
<tr>
<th>version=SSLv3</th>
<th>version=TLSv10</th>
<th>version=TLSv12</th>
<th>version=TLSv11</th>
<th>cipher=TLS_RSA_WITH_3DES_EDE_CBC_SHA</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>另外需要注意的是，<strong>需要对特征列进行补全</strong>，否则在进行模型训练时会出现特征个数不匹配的问题。例如：white.pcap 文件中 TLS versions 包含 <code>[&#39;TLSv1.0&#39;, &#39;TLSv1.2&#39;, &#39;SSLv3&#39;]</code> 三个版本，而 black 和 test 的 pcap 文件中除这三个版本外还包含 <code>&#39;TLSv1.1&#39;</code> 版本，所以需要在 white 中加入 <code>version=TLSv1.1</code> 全为 0 的列。</p>
<h3 id="模型选取及参数"><a href="#模型选取及参数" class="headerlink" title="模型选取及参数"></a>模型选取及参数</h3><p>需要注意的是：white 已明确没有被恶意软件感染，所以产生的流量可以全部标注为正常流量，而 black 明确的只是客户端感染了恶意软件，但产生的流量不一定全为恶意流量。所以实际上是<strong>对不平衡样本数据进行训练和预测</strong>。遵循这个思路，可以采用 <strong>Anomaly Detector</strong> + <strong>Misuse Detector</strong> 的联合分类器进行训练。</p>
<p><img data-src="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/4.png" alt="fe7a1c020a03492fd8b465e8541a410e.png"></p>
<p>基于全正常流量的 white.pcap 文件进行 <strong>one-class classification</strong> 训练异常检测器 Anomaly Detector；再用该分类器对 black.pcap 文件进行推理预测恶意流量；结合 black 中检测的恶意流量和 white 正常流量训练二分类器；最终采用二分类器对 test 中的流量进行检测。</p>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>数据集是我们之前经过 Zeek 特征提取、特征向量化后产生的 <code>white.csv</code>、<code>black.csv</code> 和 <code>test.csv</code> 三个 csv 文件，使用 pandas 读入后定义一个列名数组 <code>data_f</code> 来获取相应特征：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">white_df = pd.read_csv(<span class="string">&quot;white.csv&quot;</span>,index_col=<span class="number">0</span>)</span><br><span class="line">black_df = pd.read_csv(<span class="string">&quot;black.csv&quot;</span>,index_col=<span class="number">0</span>)</span><br><span class="line">test_df = pd.read_csv(<span class="string">&quot;test.csv&quot;</span>,index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">white_flow = white_df[data_f]</span><br><span class="line">black_flow = black_df[data_f]</span><br><span class="line">test_flow = test_df[data_f]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源 IP 用于生成结果 result.txt 文件时使用</span></span><br><span class="line">test_ip = test_df[<span class="string">&#x27;id.oirg_h&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>将 white_flow 和 black_flow 两个数据集合并做归一化处理，得到total_data：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">merge_flow = white_flow.append(black_flow, ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">min_max_scaler = preprocessing.MinMaxScaler()</span><br><span class="line">total_data = min_max_scaler.fit_transform(merge_flow.values)</span><br></pre></td></tr></table></figure>

<p>然后我们从 total_data 中提取 white 的训练集和测试集，同时需要提取 black 的测试集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># white 训练集和测试集(标签1表示正常流量)</span></span><br><span class="line">x_train,x_valid,y_train,y_valid=train_test_split(total_data[<span class="number">0</span>:<span class="number">4834</span>],np.ones(<span class="number">4834</span>,np.<span class="built_in">int</span>),random_state=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># black 测试集</span></span><br><span class="line">black_data = total_data[<span class="number">4834</span>:]</span><br></pre></td></tr></table></figure>

<h4 id="Anomaly-Detector"><a href="#Anomaly-Detector" class="headerlink" title="Anomaly Detector"></a>Anomaly Detector</h4><p>在 black 数据集中同时存在恶意流量和正常流量，没有明确的标注，无法直接用于训练分类器。而 white 数据集中都是正常流量，可以先用 white 数据集来训练一个 Anomaly Detector 分类器。然后用这个分类器在 black 数据集中推理得到哪些是恶意流量。我们的模型选取的隔离森林 <code>IsolationForest</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">clf = IsolationForest(max_samples=<span class="built_in">len</span>(x_train), contamination=<span class="number">0.3</span>)</span><br><span class="line">clf.fit(x_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证集正确率</span></span><br><span class="line">y_pred_valid = clf.predict(x_valid)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;valid_accuracy：&quot;</span> + <span class="built_in">str</span>(np.mean(y_valid == y_pred_valid)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由 black 测试集得到的恶意流量占比</span></span><br><span class="line">y_black_test = clf.predict(black_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;black_anomaly_ratio：&quot;</span> + <span class="built_in">str</span>(<span class="number">1</span> - np.mean(y_black_test==np.ones(<span class="number">3980</span>, np.<span class="built_in">int</span>))))</span><br></pre></td></tr></table></figure>

<h4 id="训练误用检测器-Misuse-Detector"><a href="#训练误用检测器-Misuse-Detector" class="headerlink" title="训练误用检测器 Misuse Detector"></a>训练误用检测器 Misuse Detector</h4><p>假设这些由异常检测器识别的可疑流量是恶意流量，我们就有了恶意流量的标注。接下来我们用这些恶意流量 labels，结合 white 数据集中的正常流量 labels，来训练一个 Misuse Detector。我们选取了 XGBoost 基于树的模型，目标选取为多分类问题（分类数为2）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># XGbooster Model     gbtree    multi:softmax   2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># label标签  1:white  0:black</span></span><br><span class="line">white_flow[<span class="string">&#x27;label&#x27;</span>] = <span class="number">1</span></span><br><span class="line">black_flow[<span class="string">&#x27;label&#x27;</span>] = y_black_test</span><br><span class="line">black_flow[<span class="string">&#x27;label&#x27;</span>] = black_flow[<span class="string">&#x27;label&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留 black 中的恶意流量数据</span></span><br><span class="line">balack_anomaly_flow = black_flow[black_flow[<span class="string">&#x27;label&#x27;</span>] == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到模型训练数据集</span></span><br><span class="line">model_data = white_flow.append(balack_anomaly_flow, ignore_index=<span class="literal">True</span>) </span><br></pre></td></tr></table></figure>

<p>下一步对于数据做 Max/Min 归一化，然后分割出训练集、验证集、测试集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Max/Min 归一化</span></span><br><span class="line">X_flow = model_data[data_f]</span><br><span class="line">label_flow = model_data[<span class="string">&#x27;label&#x27;</span>].values</span><br><span class="line">model_total_flow = X_flow.append(test_flow, ignore_index=<span class="literal">True</span>)</span><br><span class="line">data_normal = preprocessing.scale(model_total_flow.values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分出训练集和测试集</span></span><br><span class="line">model_train = data_normal[:model_data.shape[<span class="number">0</span>]]</span><br><span class="line">model_test = data_normal[model_data.shape[<span class="number">0</span>]:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集中分割出验证集(根据 label_flow 来层次化分割)</span></span><br><span class="line">X_train, X_valid, Y_train, Y_valid = train_test_split(model_train, label_flow, random_state=<span class="number">50</span>,stratify = label_flow)</span><br><span class="line"></span><br><span class="line">xgboost_train = xgb.DMatrix(X_train, label=Y_train)</span><br><span class="line">xgboost_valid = xgb.DMatrix(X_valid, label=Y_valid)</span><br></pre></td></tr></table></figure>

<p>进行 XGBoost 模型训练：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalerror</span>(<span class="params">preds, dtrain</span>):</span>    </span><br><span class="line">    labels = dtrain.get_label()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;error&#x27;</span>, math.sqrt(metrics.mean_squared_error(preds,labels))</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;booster&#x27;</span>: <span class="string">&#x27;gbtree&#x27;</span>,  <span class="comment"># 树模型</span></span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;multi:softmax&#x27;</span>,  <span class="comment"># 多分类</span></span><br><span class="line">    <span class="string">&#x27;num_class&#x27;</span>: <span class="number">2</span>,  <span class="comment"># 类别数</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;gamma&#x27;</span>: <span class="number">0.1</span>,  <span class="comment"># 指定了节点分裂所需的最小损失函数下降值，越大越不易分裂</span></span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">7</span>,  <span class="comment"># 树的深度</span></span><br><span class="line">    <span class="string">&#x27;subsample&#x27;</span>: <span class="number">0.75</span>,  <span class="comment"># 每棵树随机采样的占比（训练集中）</span></span><br><span class="line">    <span class="string">&#x27;colsample_bytree&#x27;</span>: <span class="number">0.75</span>,  <span class="comment"># 每棵树随机采样的列数的占比（每一列是一个特征）</span></span><br><span class="line">    <span class="string">&#x27;min_child_weight&#x27;</span>: <span class="number">0.06</span>, <span class="comment"># 决定最小叶子节点样本权重和</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;eta&#x27;</span>: <span class="number">0.05</span>,  <span class="comment"># 学习率</span></span><br><span class="line">    <span class="string">&#x27;seed&#x27;</span>: <span class="number">100</span>, <span class="comment"># 随机种子</span></span><br><span class="line">    <span class="string">&#x27;nthread&#x27;</span>: <span class="number">6</span>  <span class="comment"># cpu 线程数</span></span><br><span class="line">&#125;</span><br><span class="line">rounds = <span class="number">200</span> <span class="comment"># 迭代次数</span></span><br><span class="line">watchlist = [(xgboost_train, <span class="string">&#x27;train&#x27;</span>), (xgboost_valid, <span class="string">&#x27;valid&#x27;</span>)]</span><br><span class="line">bst = xgb.train(params, xgboost_train, rounds, watchlist,feval=evalerror)</span><br></pre></td></tr></table></figure>

<p>用模型去预测结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test 数据集上使用模型进行预测</span></span><br><span class="line">xgboost_test = xgb.DMatrix(model_test)</span><br><span class="line">y_predicted = bst.predict(xgboost_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_ip.txt 是 test 文件夹中的所有文件名</span></span><br><span class="line">ip = pd.read_table(<span class="string">&#x27;test_ip.txt&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名去掉对应的 .pcap 就是要预测的 IP</span></span><br><span class="line">ip[<span class="number">0</span>] = ip[<span class="number">0</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x.replace(<span class="string">&#x27;.pcap&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">ip_list = <span class="built_in">list</span>(ip[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先将所有客户端 IP 对应的类型标记为 white</span></span><br><span class="line">ip[<span class="number">1</span>] = [<span class="string">&#x27;white&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ip.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历预测结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_predicted)):</span><br><span class="line">    <span class="comment"># 如果第 i 条流量为 black</span></span><br><span class="line">    <span class="keyword">if</span> y_predicted[i] == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 读取第 i 条流量的源 IP</span></span><br><span class="line">        tmp_ip = <span class="built_in">list</span>(test_ip[i:i+<span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历所有要预测的客户端 IP</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ip_list)):</span><br><span class="line">            <span class="comment"># 如果是第 i 条流量（恶意）的源 IP</span></span><br><span class="line">            <span class="keyword">if</span> tmp_ip == ip_list[j]:</span><br><span class="line">            <span class="comment"># 将该客户端 IP 标记为 black</span></span><br><span class="line">                ip.loc[j,<span class="number">1</span>] = <span class="string">&#x27;black&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test 数据集恶意 IP 计数</span></span><br><span class="line">malware_ip_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ip.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">if</span> ip.loc[i,<span class="number">1</span>] == <span class="string">&#x27;black&#x27;</span>:</span><br><span class="line">        malware_ip_count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test数据集恶意ip个数&quot;</span> + <span class="built_in">str</span>(malware_ip_count) )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将最终结果写入 result.txt</span></span><br><span class="line">ip.to_csv(<span class="string">&#x27;result.txt&#x27;</span>,sep=<span class="string">&#x27;,&#x27;</span>,index=<span class="literal">False</span>,header=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h2 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h2><p>这次比赛几次提交点的最好成绩是 72.5 分，距离复赛要求的名次差几名，很遗憾无缘复赛。总结了失利的几点原因：</p>
<ol>
<li>对恶意流量的特征不熟悉，导致花了很多时间去确定需要提取哪些 Features，浪费了前面的检查点。其实我们最后提取的 Features 还有很大的提升空间，比如数据包的时间序列特征，我们只提取了均值、方差等特征，还有字节分布等重要特征未进行有效提取。<br><img data-src="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/5.png" alt="e67c9834b783a0c2b314e2dd35719671.png"></li>
<li>对模型的选择和参数认识不够，只是盲目的更换模型和调参，一开始发现模型和参数对结果的影响很大，实际上还是特征提取的不够好。当提取了能有效区分正常/恶意流量的特征后，模型的选择和参数对结果影响就较小了，所以最重要的依然是有效特征的提取。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Shekhawat, A. S. (2018). <em>Analysis of Encrypted Malicious Traffic.</em></li>
<li>Jenseg, O. (2019). <em>A machine learning approach to detecting malware in TLS traffic using resilient network features (Master’s thesis, NTNU).</em></li>
<li>Shekhawat, A. S., Di Troia, F., &amp; Stamp, M. (2019). <em>Feature analysis of encrypted malicious traffic. Expert Systems with Applications, 125, 130-141.</em></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@melanijan93/https-medium-com-melanijan93-analysing-pcaps-with-bro-zeek-33340e710012">Analysing PCAPs with Bro/Zeek</a></li>
<li><a target="_blank" rel="noopener" href="https://www.intechopen.com/online-first/machine-learning-applications-in-misuse-and-anomaly-detection">Machine Learning Applications in Misuse and Anomaly Detection</a></li>
<li><a target="_blank" rel="noopener" href="https://machinelearningmastery.com/imbalanced-classification-with-python/">imbalanced-classification-with-python</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/scikit-learn/scikit-learn/blob/master/doc/modules/feature_extraction.rst">scikit-learn GitHub doc: Feature extraction</a></li>
<li><a target="_blank" rel="noopener" href="https://www.secrss.com/articles/18679">基于机器学习的TLS恶意加密流量检测方案</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bonelee/p/9604530.html">利用背景流量数据（contexual flow data）识别TLS加密恶意流量</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="s1mple"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">s1mple</p>
  <div class="site-description" itemprop="description">春光恰与少年同，十里清风慕天青</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/s1mplecc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;s1mplecc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:s1mple951205@gmail.com" title="E-Mail → mailto:s1mple951205@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">s1mple</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 33231,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
