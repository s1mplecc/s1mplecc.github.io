<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"s1mplecc.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="春光恰与少年同，十里清风慕天青">
<meta property="og:type" content="website">
<meta property="og:title" content="芥子屋">
<meta property="og:url" content="https://s1mplecc.github.io/page/3/index.html">
<meta property="og:site_name" content="芥子屋">
<meta property="og:description" content="春光恰与少年同，十里清风慕天青">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="s1mple">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://s1mplecc.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>芥子屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">芥子屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/s1mplecc" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/07/13/%E5%9B%BE%E6%B5%81%E7%AE%97%E6%B3%95%E4%B9%8B-Bipartiteness-Check/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/13/%E5%9B%BE%E6%B5%81%E7%AE%97%E6%B3%95%E4%B9%8B-Bipartiteness-Check/" class="post-title-link" itemprop="url">图流算法之 Bipartiteness Check</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-13 21:28:17" itemprop="dateCreated datePublished" datetime="2020-07-13T21:28:17+08:00">2020-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是二分图"><a href="#什么是二分图" class="headerlink" title="什么是二分图"></a>什么是二分图</h2><blockquote>
<p><strong>定义</strong>：设 G=(V, E) 是一个无向图，如果顶点 V 可分割为两个互不相交的子集｛U｝、｛V｝，并且图中的每条边 (i, j) 所关联的两个顶点 i 和 j 分别属于这两个不同的顶点集 i∈ U，j∈ V，则称图 G 为一个二分图。<strong>二分图的一个等价定义是：不含有「含奇数条边的环」的图</strong>。</p>
</blockquote>
<p>二分图（Bipartite Graph）是指<strong>图中的顶点可以划分到两个不相交的集合中，同一个集合中的顶点不相邻</strong>，即同一个集合中的两个顶点之间不存在边。如下图，我可以将左侧的蓝色和紫色构成的图转化为右图的二分图，集合 A 中全由紫色顶点构成，集合 B 中全由蓝色顶点构成，只存在<code>蓝-紫</code>（<code>紫-蓝</code>）边，同色顶点间不存在边。</p>
<p><img data-src="0.png" alt="bab01ea393c68a26dee629ce0d7e4de3.png"></p>
<p>所以二分图又可以等价于二色图（Two-colorable Graph），以下是一些二分图的常见示例，如星状图、网格图、齿轮图等。</p>
<p><img data-src="1.png" alt="14bf3a04408d7eacdf1b4dc323acf58c.png"></p>
<h2 id="Bipartiteness-Check"><a href="#Bipartiteness-Check" class="headerlink" title="Bipartiteness Check"></a>Bipartiteness Check</h2><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>那么如何检测一个图是否为二分图呢？在批处理情形下，即一个图的所有顶点和所有边的信息都已明确，我们借助于二色图的思想，可以通过<strong>染色法</strong>来判断一个图是否为二分图。算法可以通过 BFS 广度优先算法来实现，具体步骤如下：</p>
<ol>
<li>从任意一个顶点出发，将该顶点染成黑色。</li>
<li>遍历该顶点的所有相邻顶点，将其染成白色。</li>
<li>采用 BFS 依次遍历各个顶点的相邻顶点，将其染成与自身颜色相反的颜色。</li>
<li>当出现<strong>已访问过的相邻顶点颜色与自己相同，则该图不是二分图</strong>。否则，该图为二分图。</li>
</ol>
<h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h3><p>在流处理情形下，我们无法预知图的所有信息，取而代之的是，图的边（Edge）作为输入持续不断的流入我们的系统中。在这种情况下，考虑如何实时地判断当前所有边构成的图是否为二分图？</p>
<p>我们可以参考 GitHub 上的 <a target="_blank" rel="noopener" href="https://github.com/vasia/gelly-streaming">Gelly Streaming 项目</a>，该项目是 Flink 的一个轻量级图流处理 API，提供了一些图流分析接口，并实现了部分图的流处理算法。</p>
<p>Gelly Streaming 的算法核心思想仍然是染色法，具体步骤如下：</p>
<ol>
<li>在一条边进入系统时，如果该边是已经存在的边，则丢弃；如果该边的两个顶点均不存在，则将其染成两个不同的颜色；如果该边有且仅有一个顶点已存在（已染色），则将另一个顶点染成相反的颜色。</li>
<li>如果该边的两个顶点均已存在，则可能出现三种情况：</li>
</ol>
<ul>
<li>新边的加入使原先的图构成了「含奇数条边的环」，如下图此时若到来一条 <code>2 - 4</code> 或 <code>7 - 8</code> 的边，均破坏了二分图的性质。此时的判断条件是：<strong>两个顶点同属于一个 Component 且两个顶点的颜色相同</strong>。</li>
<li>新边的加入使原先的图构成了「含偶数条边的环」，则图依然保持二分图的性质。此时的判断条件是：<strong>两个顶点同属于一个 Component 且两个顶点的颜色相异</strong>。</li>
<li>新边的两个顶点分属不同的 Componets，如下图此时若到来一条 <code>1 - 4</code> 边，图依然保持二分图的性质。我们可以做简单的证明：由于之前的两个单独的 Components 均是二分图，则我们可以分别将它们的顶点划分到两个不相交的集合中｛U1｝、｛V1｝和｛U2｝、｛V2｝中且令新边（i，j）的顶点i∈ U1，j∈ V2，由此可得出由｛U1｝、｛U2｝构成的集合｛U｝与｛V1｝、｛V2｝构成的集合｛V｝不相交，未破环二分图的性质。此时的判断条件：<strong>两个顶点分属于不同的 Components</strong>。在算法实现时，我们需要将两个 Components 合并为一个 Component，即 Gelly 算法中的 <code>merge</code> 操作。需要注意的是，此时若两个顶点（已染色）颜色不同，则直接合并，若两个顶点颜色相同，则需要将其中的一个 Component <strong>颜色反转</strong>。</li>
</ul>
<p><img data-src="2.png" alt="2bb51c94931f8c2b1ec93c3162d54501.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.educative.io/edpresso/what-is-a-bipartite-graph">What is a bipartite graph?</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/vasia/gelly-streaming">Gelly Streaming：An experiemental API for single-pass graph streaming analytics on Apache Flink.</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/01/03/%E4%BD%BF%E7%94%A8%E6%B5%81%E7%95%85%E6%8E%A5%E5%8F%A3%E7%BC%96%E5%86%99-Kafka-%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/03/%E4%BD%BF%E7%94%A8%E6%B5%81%E7%95%85%E6%8E%A5%E5%8F%A3%E7%BC%96%E5%86%99-Kafka-%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">使用流畅接口编写 Kafka 集成测试框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-03 19:26:40" itemprop="dateCreated datePublished" datetime="2020-01-03T19:26:40+08:00">2020-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design/" itemprop="url" rel="index"><span itemprop="name">Design</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该文档是我在团队中负责集成测试模块时为团队成员编写的 API 接口文档，这次拿过来修改了一下，并已经将业务无关的代码剥离出来上传到 <a target="_blank" rel="noopener" href="https://github.com/s1mplecc/kafka-integration-test">GitHub</a> 上。主要是向大家展示一种流畅接口设计框架代码的模式。</p>
<p>所谓流畅接口，可以参考我之前翻译的 Martin Flower 的<a target="_blank" rel="noopener" href="https://s2mple.xyz/2019/01/23/Fluent-Interface-%E2%80%94%E2%80%94-Martin-Fowler-%E5%8D%9A%E5%AE%A2%E8%AF%91%E6%96%87/">博客译文</a>。简单来说，流畅接口被设计为<strong>可读的</strong>和<strong>流式的</strong>，使用起来几乎和自然语言一般流畅，并且配合 IDE 的智能提示，易于 API 使用者的理解和使用。譬如下面我编写的集成测试用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundToOutboundExampleJobTest</span> <span class="keyword">extends</span> <span class="title">JobIntegrationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_send_ACTT_and_receive_trigger_event_from_kafka</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        kafkaSuite.send(<span class="keyword">new</span> ResourceFile(<span class="string">&quot;sample/send/pek/ACTT.xml&quot;</span>))</span><br><span class="line">                .toTopic()</span><br><span class="line">                .ofConfig(<span class="string">&quot;inbound_imf&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SubjectEvent event = kafkaSuite</span><br><span class="line">                .await().latestOne()</span><br><span class="line">                .fromTopic()</span><br><span class="line">                .ofConfig(<span class="string">&quot;trigger&quot;</span>)</span><br><span class="line">                .toJavaObject(SubjectEvent.class);</span><br><span class="line"></span><br><span class="line">        assertThat(event.getEventName()).isEqualTo(<span class="string">&quot;FLOP_ACTT&quot;</span>);</span><br><span class="line">        assertThat(event.getGids().size()).isEqualTo(<span class="number">1</span>);</span><br><span class="line">        assertThat(event.getGids().get(<span class="number">0</span>)).isEqualTo(<span class="string">&quot;PEK_80664162170310656&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码读起来非常明了，<code>KafkaSuite</code> 是我编写的 Kafka 集成测试套件，负责将 xml 文件发送至 Kafka 的一个 Topic 中，该 Topic 配置在配置文件中，对应着 <code>inbound_imf</code> 项。同时 <code>KafkaSuite</code> 监听另一个 Topic <code>trigger</code> 的最新一条消息并转换成 Java 对象，对结果进行验证（其间过程 xml 文件会被其他模块解析并经过一系列的业务处理）。</p>
<p>上述代码中，<code>assertThat().isEqualTo()</code> 就是断言框架 <code>assertj</code> 的 API，它是一个非常优秀的流畅接口的框架，建议大家阅读其源代码。我在编写 Kafka 集成测试框架时就借鉴了这种编码模式。</p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>代码目前完成了 Kafka 集成测试的发送和监听功能。我们的流处理框架采用的是 Flink，将任务分解为一个个 Job 独立运行，所以集成测试首先得启动 Job，并且加载包括 Kafka IP地址等相关配置。为此我编写了 <code>JobIntegrationTest</code> 类，并规定所有集成测试用例必须继承该类。此外，<code>KafkaSuite</code> 是负责 Kafka 集成测试的套件，封装了各种流畅接口 API。</p>
<h3 id="JobIntegrationTest"><a href="#JobIntegrationTest" class="headerlink" title="JobIntegrationTest"></a>JobIntegrationTest</h3><p>所有的集成测试必需继承 JobIntegrationTest 类，该类提供 final 的 <code>setUp()</code> 方法和 <code>tearDown()</code> 方法。</p>
<p>集成测试运行的流程是 <code>SetUp -&gt; All Tests -&gt; TearDown</code>：</p>
<ol>
<li><p><code>setUp()</code> 方法中使用了单独的线程启动 Job，所以<strong>不会阻塞主线程（测试方法）的运行</strong>。</p>
</li>
<li><p>测试方法主体由集成测试使用者编写，如果用到 KafkaSuite 的 send 和 await 方法则会被阻塞，直到<strong>成功发送或者接收到消息</strong>，或者<strong>超时抛出异常</strong>退出。</p>
</li>
<li><p><code>tearDown()</code> 方法关闭 Job 和用到的资源。</p>
</li>
</ol>
<h3 id="KafkaSuite"><a href="#KafkaSuite" class="headerlink" title="KafkaSuite"></a>KafkaSuite</h3><p>目前集成测试实现了 Kafka 消息的<strong>阻塞发送</strong>和<strong>阻塞监听</strong>，抽象出来的 KafkaSuite 提供了流畅接口以支持集成测试。<code>kafkaSuite</code> 作为 JobIntegrationTest 的 protected 字段可以直接在集成测试类中使用。我将 KafkaSuite 的流畅接口分为三大阶段：配置阶段（PrepareStep）、发送阶段（SendStep）和接受阶段（AwaitStep）。具体的流畅接口使用可以查看 KafkaSuiteTest 或者直接阅读源码 JavaDoc。</p>
<h4 id="PrepareStep"><a href="#PrepareStep" class="headerlink" title="PrepareStep"></a>PrepareStep</h4><p>由于 JobIntegrationTest 会加载配置文件并由此创建 KafakSuite 实例，所以正常情况下不需要独立配置 IP、端口等。但为提供给特殊需求使用，仍设计相关接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kafkaSuite.clusterIps(<span class="string">&quot;172.20.10.120:9092,172.20.10.152:9092,172.20.10.171:9092&quot;</span>)</span><br><span class="line">            .noSsl()</span><br><span class="line">            .send() <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<h4 id="SendStep"><a href="#SendStep" class="headerlink" title="SendStep"></a>SendStep</h4><p>KafkaSuite 发送消息是阻塞的，设置的超时时间是 10s，<strong>如果 10s 未发送成功则会抛出 SendTimeoutException 异常</strong>，这时候需要检查配置文件中的 IP 和 SSL 配置是否正确。</p>
<p>API 使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kafkaSuite.send(<span class="keyword">new</span> ResourceFile(<span class="string">&quot;kafka/test-suite.json&quot;</span>))</span><br><span class="line">            .toTopic()</span><br><span class="line">            .ofConfig(<span class="string">&quot;INTEGRATION-TEST&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>send()</code> 方法提供发送字符串、文件或数据流的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DSLSendStep</span> </span>&#123;</span><br><span class="line">    <span class="function">DSLSendToStep <span class="title">send</span><span class="params">(String value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLSendToStep <span class="title">send</span><span class="params">(ResourceFile file)</span> <span class="keyword">throws</span> ResourceFileNotFoundException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLSendToStep <span class="title">send</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toTopic()</code> 方法可以直接 <code>toTopic(&quot;xxx&quot;)</code> 指定明确 Topic，但更加推荐从配置文件读取的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DSLSendToStep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toTopic</span><span class="params">(String topic)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLSentLoadConfigStep <span class="title">toTopic</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AwaitStep"><a href="#AwaitStep" class="headerlink" title="AwaitStep"></a>AwaitStep</h4><p>KafkaSuite 监听消息同样是阻塞的。设置的<strong>默认超时时间是 60s</strong>，也提供自定义超时时间的接口如 <code>await(300)</code>，单位为秒，<strong>超过这个时间未接收到消息则抛出 AwaitTimeoutException</strong>。理论上我们都是先发再收，所以如果发送成功则代表 Kafka 连接不存在问题（也就是配置没有问题），接收不到就应该是业务代码有问题，这时候就需要 Debug 排查问题。</p>
<p>监听结果提供<strong>监听一条</strong>和<strong>监听多条</strong>的 API，但不管是使用哪一个，<code>await()</code> 后会取到 Kafka 该 Topic 的上一个 offset 以来的所有新消息，然后变更 offset。可以根据 Index 获取多条消息里的某一条，Index 从 0 开始计算。大致用法是：使用 <code>await().latestOne()</code> 获取最新一条，<code>await().multi()</code> 或者直接 <code>await()</code> 获取多条。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DSLAwaitIndexStep</span> <span class="keyword">extends</span> <span class="title">DSLAwaitMultiFromStep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Kafka Consumer Fetch latest one record</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">latestOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">lastOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Kafka Consumer Fetch record by index in records</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">one</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">firstOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">secondOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">thirdOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Kafka Consumer Fetch all latest records</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitMultiFromStep <span class="title">all</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitMultiFromStep <span class="title">multi</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Kafka Consumer Fetch multi records directly from topic</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">DSLAwaitMultiLoadConfigStep <span class="title">fromTopic</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">DSLAwaitMultiRecordsStep <span class="title">fromTopic</span><span class="params">(String topic)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">DSLAwaitMultiRecordsStep <span class="title">fromTopic</span><span class="params">(String topic, String groupId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是<strong>监听一条并且验证消息是否正确</strong>的写法，这里使用了 <code>toJavaObject()</code> 转成了 Java 对象，这个是我提供的转换消息的 API，后面会有介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kafkaSuite.send(<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;jack\&quot;,\&quot;age\&quot;:25&#125;&quot;</span>)</span><br><span class="line">                .toTopic()</span><br><span class="line">                .ofConfig(<span class="string">&quot;INTEGRATION-TEST&quot;</span>);</span><br><span class="line">                </span><br><span class="line">Person record = kafkaSuite</span><br><span class="line">                .await().latestOne()</span><br><span class="line">                .fromTopic()</span><br><span class="line">                .ofConfig(<span class="string">&quot;INTEGRATION-TEST&quot;</span>)</span><br><span class="line">                .toJavaObject(Person.class);</span><br><span class="line">                </span><br><span class="line">assertThat(record.getName()).isEqualTo(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">assertThat(record.getAge()).isEqualTo(<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<p><strong>由于有的业务场景会出口多条消息，所以接下来演示验证多条消息的正确写法</strong>。提供了 <code>fetchFirstOne()</code> 和 <code>fetchOne(int index)</code> 根据 Index 获取多条中的一条等 API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">kafkaSuite.send(<span class="string">&quot;&#123;\&quot;name\&quot;: \&quot;jack\&quot;, \&quot;age\&quot;: 25&#125;&quot;</span>)</span><br><span class="line">        .toTopic()</span><br><span class="line">        .ofConfig(<span class="string">&quot;INTEGRATION-TEST&quot;</span>);</span><br><span class="line"></span><br><span class="line">kafkaSuite.send(<span class="string">&quot;&#123;\&quot;name\&quot;: \&quot;tony\&quot;, \&quot;age\&quot;: 20&#125;&quot;</span>)</span><br><span class="line">        .toTopic()</span><br><span class="line">        .ofConfig(<span class="string">&quot;INTEGRATION-TEST&quot;</span>);</span><br><span class="line"></span><br><span class="line">DSLAwaitMultiRecordsStep records = kafkaSuite</span><br><span class="line">        .await().multi()</span><br><span class="line">        .fromTopic()</span><br><span class="line">        .ofConfig(<span class="string">&quot;INTEGRATION-TEST&quot;</span>);</span><br><span class="line"></span><br><span class="line">Person jack = records.fetchFirstOne().toJavaObject(Person.class);</span><br><span class="line">Person tony = records.fetchOne(<span class="number">1</span>).toJavaObject(Person.class);</span><br><span class="line"></span><br><span class="line">assertThat(jack.getName()).isEqualTo(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">assertThat(jack.getAge()).isEqualTo(<span class="number">25</span>);</span><br><span class="line">assertThat(tony.getName()).isEqualTo(<span class="string">&quot;tony&quot;</span>);</span><br><span class="line">assertThat(tony.getAge()).isEqualTo(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>最后结果的<strong>输出提供了转换和输出到文件的 API</strong>。需要注意，输出到文件只是方便调试 Bug 时使用，不应该出现在正式的代码中；输出的文件被写入到 <code>target/test-classes/resources</code> 下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DSLAwaitOneRecordStep</span> <span class="keyword">extends</span> <span class="title">DSLAwaitRecordStep</span>, <span class="title">DSLAwaitOneRecordOutputStep</span>, <span class="title">DSLAwaitOneRecordConvertStep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">JsonObject <span class="title">toJsonObject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">JSONArray <span class="title">toJsonArray</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toXml</span><span class="params">()</span></span>; <span class="comment">// 编码未完成</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">toJavaObject</span><span class="params">(Class&lt;T&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeAsTxt</span><span class="params">(String absolutePath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeAsTxt</span><span class="params">(ResourceFile resourceFile)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>流畅接口 API 的设计一个重中之重就是<strong>接口和抽象类的使用</strong>，为了契合流式接口，有时不能按照面向对象的模式设计接口继承关系。简言之，在编写流畅接口 API 框架时，大致思路是先编写接口（Interface），按照流式的原则设计接口之间的继承关系，然后再编写具体的实现类。以下是我的代码结构，与 <code>impl</code> 文件夹并列的都是接口。具体代码详见我的 <a target="_blank" rel="noopener" href="https://github.com/s1mplecc/kafka-integration-test">GitHub</a> 项目。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Assertions.java</span><br><span class="line">├── JobIntegrationTest.java</span><br><span class="line">├── KafkaSuite.java</span><br><span class="line">└── core</span><br><span class="line">    ├── dsl</span><br><span class="line">    │   ├── await</span><br><span class="line">    │   │   ├── DSLAwaitFromStep.java</span><br><span class="line">    │   │   ├── DSLAwaitIndexStep.java</span><br><span class="line">    │   │   ├── DSLAwaitLoadConfigStep.java</span><br><span class="line">    │   │   ├── DSLAwaitMultiFromStep.java</span><br><span class="line">    │   │   ├── DSLAwaitMultiLoadConfigStep.java</span><br><span class="line">    │   │   ├── DSLAwaitMultiRecordsConvertStep.java</span><br><span class="line">    │   │   ├── DSLAwaitMultiRecordsFetchOneStep.java</span><br><span class="line">    │   │   ├── DSLAwaitMultiRecordsStep.java</span><br><span class="line">    │   │   ├── DSLAwaitOneFromStep.java</span><br><span class="line">    │   │   ├── DSLAwaitOneLoadConfigStep.java</span><br><span class="line">    │   │   ├── DSLAwaitOneRecordConvertStep.java</span><br><span class="line">    │   │   ├── DSLAwaitOneRecordOutputStep.java</span><br><span class="line">    │   │   ├── DSLAwaitOneRecordStep.java</span><br><span class="line">    │   │   ├── DSLAwaitRecordStep.java</span><br><span class="line">    │   │   ├── DSLAwaitStep.java</span><br><span class="line">    │   │   └── impl</span><br><span class="line">    │   │       ├── AbstractDSLAwaitFromStep.java</span><br><span class="line">    │   │       ├── AbstractDSLAwaitLoadConfigStep.java</span><br><span class="line">    │   │       ├── DSLAwaitIndexStepImpl.java</span><br><span class="line">    │   │       ├── DSLAwaitMultiFromStepImpl.java</span><br><span class="line">    │   │       ├── DSLAwaitMultiLoadConfigStepImpl.java</span><br><span class="line">    │   │       ├── DSLAwaitMultiRecordsStepImpl.java</span><br><span class="line">    │   │       ├── DSLAwaitOneFromStepImpl.java</span><br><span class="line">    │   │       ├── DSLAwaitOneLoadConfigStepImpl.java</span><br><span class="line">    │   │       └── DSLAwaitOneRecordStepImpl.java</span><br><span class="line">    │   ├── send</span><br><span class="line">    │   │   ├── DSLSendStep.java</span><br><span class="line">    │   │   ├── DSLSendToStep.java</span><br><span class="line">    │   │   ├── DSLSentLoadConfigStep.java</span><br><span class="line">    │   │   └── impl</span><br><span class="line">    │   │       ├── DSLSendToStepImpl.java</span><br><span class="line">    │   │       └── DSLSentLoadConfigStepImpl.java</span><br><span class="line">    │   └── start</span><br><span class="line">    │       ├── DSLPrepareStep.java</span><br><span class="line">    │       └── DSLStartStep.java</span><br><span class="line">    └── exceptions</span><br><span class="line">        ├── AwaitTimeoutException.java</span><br><span class="line">        ├── InvalidIntegrationTestNameException.java</span><br><span class="line">        ├── SendNullValueException.java</span><br><span class="line">        └── SendTimeoutException.java</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2019/04/10/%E6%90%AD%E5%BB%BA-SSR-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/10/%E6%90%AD%E5%BB%BA-SSR-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" class="post-title-link" itemprop="url">搭建 SSR 科学上网</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-10 15:02:32" itemprop="dateCreated datePublished" datetime="2019-04-10T15:02:32+08:00">2019-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ops/" itemprop="url" rel="index"><span itemprop="name">Ops</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本教程也是由于本人平时工作学习有 Google 的需求，所以就自己搭了一个梯子，并记录了搭建的过程方便以后重搭。大家搭建后小规模使用就好了，这样网速较快且不容易被封。<strong>特此申明：严禁用于商业用途！</strong></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li><strong>VPS 服务器</strong>，需要选择国外的，推荐 <a target="_blank" rel="noopener" href="https://www.vultr.com/">Vultr</a>，速度不错、稳定且性价比高，按小时计费，能够随时开通和删除服务器。<strong>操作系统选择 CentOS 6</strong>，为了更换内核方便不宜选择版本过高的操作系统。</li>
<li>MacOS 自带的 Terminal，或者 Windows 的 XShell。用于 ssh 连接远程服务器并执行命令。</li>
<li><strong>ShadowsocksR 客户端</strong>，简称 SSR，是 Shadowsocks 的增强版，在其基础上增加了一些数据混淆方式。SSR 下载地址：<a target="_blank" rel="noopener" href="https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases">Mac 版</a>，<a target="_blank" rel="noopener" href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases">Windows 版</a>。</li>
</ul>
<h2 id="部署SSR服务端"><a href="#部署SSR服务端" class="headerlink" title="部署SSR服务端"></a>部署SSR服务端</h2><p>执行 <code>ssh root@&#123;IP&#125;</code> 连接上 VPS 服务器，并安装 SSR 服务端一件部署脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure>

<p>等待下载完成后出现如下界面，按照提示一步步进行配置</p>
<p><img data-src="0.png" alt="6e65c95d5ad590eec8be684361594373.png"></p>
<p>依次会配置：</p>
<ol>
<li>端口和密码（端口建议设置 1000 ～ 65535 之间）</li>
<li>加密方式（随意）</li>
<li>协议插件（随意）</li>
<li>是否兼容原版 SS 客户端（即兼容没有协议和混淆的客户端，建议选 N）</li>
<li>每个端口的连接设备数限制、速度限制（auth_* 系列协议，并且不兼容原版时才有效）</li>
</ol>
<p>配置完成后等待部署完成，终端会打印配置信息，这些就是需要在 SSR 客户端填入的配置。现在可以直接进入下一个章节：配置SSR客户端。</p>
<p><img data-src="1.jpeg" alt="6a90ecf445798cb2c69a8bc05abd0a0a.png"></p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>默认情况下部署的是单端口模式，即多人共享一个端口。可以切换为多端口模式，一个用户一个端口，方便管理。直接执行 <code>bash ssr.sh</code> 键入 9 即可。</p>
<p>此外，键入 7 你可以随时修改 SSR 服务端的配置，以及在多端口模式下添加新用户，为他们分配新的端口号和密码。</p>
<p><img data-src="2.jpeg" alt="17f12e5ebc74a4105bacbeb69662a1f0.png"></p>
<h2 id="配置SSR客户端"><a href="#配置SSR客户端" class="headerlink" title="配置SSR客户端"></a>配置SSR客户端</h2><p>打开 SSR 客户端，按照服务端的配置填入对应配置。</p>
<p><img data-src="3.png" alt="7a34639c35446ec3808356b7eef07dc4.png"></p>
<p>至此就可以 Google 了，但网速较慢，可以使用锐速进行加速。锐速也有一键部署脚本，加速后对速度的提升很明显，所以推荐部署加速脚本。该加速方法是开机自动启动，部署一次就可以了。</p>
<h2 id="锐速加速"><a href="#锐速加速" class="headerlink" title="锐速加速"></a>锐速加速</h2><h3 id="更换操作系统内核"><a href="#更换操作系统内核" class="headerlink" title="更换操作系统内核"></a>更换操作系统内核</h3><p>安装锐速前需要先更换操作系统内核，下载更换内核脚本并执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://blog.asuhu.com/sh/ruisu.sh &amp;&amp; bash ruisu.sh</span><br></pre></td></tr></table></figure>

<p>成功替换内核后服务器会自动重启。等待重启完成后，重连服务器。</p>
<h3 id="一键安装锐速"><a href="#一键安装锐速" class="headerlink" title="一键安装锐速"></a>一键安装锐速</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh</span><br></pre></td></tr></table></figure>

<p>等待安装完成后即可体验飞一般的上网速度。</p>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>Vultr 提供方便快捷的快照 Snapshot 功能用于备份服务器。为防止服务器 IP 被封，我们可以备份服务器，方便将来重新部署。</p>
<p>在 Vultr 用户界面的 Servers 中添加快照，快照创建需要一点时间</p>
<p><img data-src="4.png" alt="1d8690c7a6d4d85711e11f2485996ba8.png"></p>
<p>将来在 Deploy new instance 新建实例时，服务器类型选择快照即可</p>
<p><img data-src="5.png" alt="1c652a6a3177df0e85958f81faa58043.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B">自建ss服务器教程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2019/02/25/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/25/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">代理模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-25 21:35:58" itemprop="dateCreated datePublished" datetime="2019-02-25T21:35:58+08:00">2019-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design/" itemprop="url" rel="index"><span itemprop="name">Design</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理模式（Proxy Pattern）是一种常见的设计模式，也是 GoF 提出的 23 种设计模式中的一种，属于结构型设计模式。<strong>它使用代理对象完成用户请求，屏蔽用户对真实对象的访问</strong>。代理模式用处很多，本文主要介绍如何使用代理模式实现<strong>延迟加载</strong>和<strong>面向切面编程</strong>，并着重介绍动态代理的几种实现方式。本文涉及到的示例代码以上传到 <a target="_blank" rel="noopener" href="https://github.com/s1mplecc/proxy-pattern-demo">GitHub</a> 上。</p>
<h2 id="角色及职责"><a href="#角色及职责" class="headerlink" title="角色及职责"></a>角色及职责</h2><p>代理模式中的几个角色：</p>
<ul>
<li><strong>Subject</strong>，接口，定义了代理类和被代理类对外暴露的方法。代理类和被代理类都需要实现该接口。</li>
<li><strong>RealSubject</strong>，真实对象（被代理类），真正实现功能的对象。</li>
<li><strong>Proxy</strong>，代理类，用来<strong>封装</strong>真实对象。</li>
</ul>
<p><img data-src="0.png" alt="0d73af744af2fd7ecfd3326888c3d69b.png"></p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>代理模式通常用于解决以下几类问题：</p>
<ul>
<li><strong>需要控制对象的访问权限</strong></li>
<li><strong>需要扩展一个对象的功能</strong></li>
</ul>
<p>对此，代理模式使用 Proxy 封装真实对象，以达到控制真实对象的访问权限，并在此基础上提供额外功能。代理模式有以下几个典型的应用场景：</p>
<ul>
<li>远程代理，在分布式对象通信中，使用一个本地对象代表远程对象（分属不同地址空间）。本地对象是远程对象的代理，本地对象上的方法调用将导致远程对象上的方法调用。一个例子是 ATM 实现，其中 ATM 可以保存位于远程服务器上的银行信息的代理对象。</li>
<li>虚拟代理，如果一个对象很复杂或很重，可以使用虚拟代理。比如当图像很大时，可以按需的去加载用到的部分（亦即<strong>延迟加载</strong>）。</li>
<li>保护代理，可以控制资源的访问权限。</li>
</ul>
<h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>我们先来看看如何使用代理模式进行延迟加载。假设现在有一个数据库查询类 DBQuery，它执行查询返回一个字符串。由于数据查询需要连接数据库，所以在构造时会比较耗时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBQuery</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// create datebase connection</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;query result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，如果在程序启动的时候我们就去 new 这个对象，一旦存在大量类似的操作，系统的启动速度必定会受影响。而采用代理类替代 DBQuery，可以做到轻量级启动。</p>
<p>首先需要创建一个接口，对应着代理模式角色中的 Subject：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDBQuery</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实对象 DBQuery 和代理类 DBQueryProxy 都需要实现这个接口。<strong>在代理类内部封装了真实对象，实际调用时使用委派（Delegation）调用被代理类的方法</strong>。这也是代理模式的核心所在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBQueryProxy</span> <span class="keyword">implements</span> <span class="title">IDBQuery</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DBQuery dbQuery;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dbQuery == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dbQuery = <span class="keyword">new</span> DBQuery();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dbQuery.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在启动时初始化代理类，由于代理类 DBQueryProxy 的构造函数什么也没做，所以启动是相当迅速的（下述代码第 1 步）。而真正查询数据库（第 2 步）时才创建 DBQuery 对象执行耗时操作，从而实现了<strong>需要的时候才加载</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IDBQuery query = <span class="keyword">new</span> DBQueryProxy(); <span class="comment">// 1</span></span><br><span class="line">    query.query(); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>现在来考虑一件事，如果需要在查询语句的前后添加日志该怎么做？在没有代理类之前，我们可能只能在真实对象中添加两行日志。但严格来说，日志记录不属于 DBQuery 的职责，它破坏了类的纯粹性（违背了迪米特法则）。所以现在有了代理类 DBQueryProxy，我们理所因当的应该将日志记录放在代理类中。即如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBQueryProxy</span> <span class="keyword">implements</span> <span class="title">IDBQuery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dbQuery == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dbQuery = <span class="keyword">new</span> DBQuery();</span><br><span class="line">            log.info(<span class="string">&quot;Create database connection.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String result = dbQuery.query();</span><br><span class="line">        log.info(<span class="string">&quot;Query response is &#123;&#125;.&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以将日志功能与 DBQuery 解耦，我们做到了将业务功能与系统级功能解耦，但这还不够。我们实现解耦的方式是采用的<strong>静态代理</strong>，即代码在编译前就得写死了。虽然静态代理可以做到在不修改目标对象的功能前提下，对目标功能扩展，但它的缺点也显而易见，就是代码的冗余。一个 DBQuery，就需要一个代理类，那如果有一千个 DBQuery 难道要写一千个代理类吗？</p>
<p><strong>AOP（Aspect Oriented Programming）</strong>，面向切面编程的出现就是为了解决这类问题。它通过<strong>预编译</strong>方式和运行期<strong>动态代理</strong>实现程序功能的统一维护。最为人熟知的应该就是 Spring AOP 了。在 Spring 中提供了面向切面编程的丰富支持，允许<strong>通过分离应用的业务逻辑与系统级服务进行内聚性的开发</strong>。业务对象只做它应该做的 —— 完成业务逻辑 —— 仅此而已。它们并不负责其它的系统级关注点，诸如日志记录，性能统计，安全控制，事务处理，异常处理等。通过这种分离我们可以做到改变系统级服务代码时不影响业务代码的逻辑。</p>
<p>关于预编译的方式就不多说了，它的典型代表是 AspectJ，它需要专门的 Java 编译器将系统级代码织入业务代码中。除此之外，还可以通过运行时织入，也就是动态代理。<strong>Spring AOP 就构建在动态代理基础之上</strong>。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><strong>动态代理使用字节码动态生成加载技术，在运行时生成并加载类</strong>。与静态代理相比，动态代理有诸多好处。首先，不需要为真实主题创建一个形式上完全一样的封装类，假如主题接口中方法很多，为每个方法重写一个代理方法也是非常麻烦的事，一旦接口发生变更，意味着真实主题与代理类都要修改，不利于系统维护；其次，使用动态代理的生成方法可以指定代理类的执行逻辑，从而提升系统的灵活性。</p>
<p>生成动态代理的方式很多，包括 JDK 自带的动态代理、<strong>CGLIB</strong>、<strong>Javassist</strong> 等，本文只介绍前两种的使用方式。</p>
<h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>JDK 从 1.3 开始提供了对动态代理的支持，它可以动态的创建代理类并动态的处理对所代理方法的调用。在动态代理上所做的所有调用都会被重定向到单一的<strong>调用处理器</strong>上，它的工作是揭示调用的类型并确定相应的对策。</p>
<p>调用处理器需要实现 InvocationHandler 接口，重写 invoke 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DynamicProxyHandler.class);</span><br><span class="line">    <span class="keyword">private</span> Object proxied;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Dynamic proxy &#123;&#125; class &#123;&#125;() method.&quot;</span>, proxied.getClass().getSimpleName(), method.getName());</span><br><span class="line">        Object invoke = method.invoke(proxied, args);</span><br><span class="line">        log.info(<span class="string">&quot;result is &#123;&#125;.&quot;</span>,invoke);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面代码在 main 方法中生成了一个实现了 IDBQuery 接口的代理类，代理类的内部逻辑由 DynamicProxyHandler 决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IDBQuery proxy = (IDBQuery) Proxy.newProxyInstance(</span><br><span class="line">            IDBQuery.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;IDBQuery.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> DynamicProxyHandler(<span class="keyword">new</span> DBQuery()));</span><br><span class="line">    proxy.query();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [main] INFO DynamicProxyHandler - Dynamic proxy DBQuery class query() method.</span></span><br><span class="line"><span class="comment">// [main] INFO DynamicProxyHandler - result is query result.</span></span><br></pre></td></tr></table></figure>

<p>通过调用静态方法 <code>Proxy.newProxyInstance()</code> 可以创建动态代理，该方法需要得到一个类加载器（通常可以从已经被加载的对象中获取其类加载器，然后传递给它），一个你希望该代理实现的接口列表（不是类或抽象类），以及 InvocationHandler 接口的一个实现。动态代理可以将所有调用重定向到调用处理器，因此通常会向调用处理器的构造器传入一个“实际”对象的引用，从而使得调用处理器在执行其中介任务时，可以将请求转发。</p>
<p>invoke 方法中传入了代理对象（即参数 proxy）以备你需要区分请求的来源，但在多数情况下你并不关心这一点。然而，在 invoke 内部，在代理上调用方法需要格外当心，因为对接口的调用将被重定向为对代理的调用。通常，你会执行被代理的操作，然后使用 <code>method.invoke()</code> 将请求转发给被代理对象，并传入必需的参数。</p>
<h3 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h3><p>Java 提供的动态代理使用简单，它内置在 JDK 中，因此不需要引入第三方 Jar 包，但相对功能较弱。除此之外，CGLIB 动态代理库为 JDK 的动态代理提供了很好的补充，并且性能更好。</p>
<p><strong>CGLIB 为没有实现接口的类提供代理</strong>，它针对代理的类，动态生成一个子类，然后子类覆盖代理类中的方法。如果是 private 或是 final 类修饰的方法，则不会被重写。通常可以使用 Java 的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB 是一个好的选择。</p>
<p>CGLIB 作为一个开源项目，其代码托管在 <a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">GitHub</a> 上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cglib proxy begin&quot;</span>);</span><br><span class="line">        Object result = method.invoke(target, objects);</span><br><span class="line">        System.out.println(result + <span class="string">&quot;\ncglib proxy end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> CglibProxy(target));</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DBQuery proxy = (DBQuery) CglibProxy.getProxy(<span class="keyword">new</span> DBQuery());</span><br><span class="line">        proxy.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cglib proxy begin</span></span><br><span class="line"><span class="comment">// query result</span></span><br><span class="line"><span class="comment">// cglib proxy end</span></span><br></pre></td></tr></table></figure>

<p>与 JDK 自带的代理类似，基于 CGLIB 的代理类需要实现 MethodInterceptor 接口，重写 intercept 方法。使用 Enhancer 生成需要被代理的类的子类的实例。</p>
<p>在 Spring 的 AOP 编程中，如果加入容器的目标对象有实现接口，使用 JDK 代理。如果目标对象没有实现接口，则使用 CGLIB 代理。</p>
<h3 id="Hibernate-对动态代理的应用"><a href="#Hibernate-对动态代理的应用" class="headerlink" title="Hibernate 对动态代理的应用"></a>Hibernate 对动态代理的应用</h3><p>动态代理的一个经典应用就是 Hibernate 框架。当 Hibernate 加载实体 Bean 时，并不会一次性将数据库所有的数据都装载，而是采用延迟加载的机制，以提高系统的性能。这里以属性的延迟加载为例，展示 Hibernate 是如何使用动态代理的。</p>
<p>从数据库载入 ID 为 1 的 User 用户，并且打印它的类名、父类名、实现的接口名。最后调用 getName 方法取得数据库数据。演示代码采用的 Hibernate 版本为 3.2.6，不同的 Hibernate 版本实现会有差异。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">User user = (User)sessionFactory.getSession().load(User.class, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Class name: &quot;</span> + user.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">&quot;Superclass name: &quot;</span> + user.getClass().getSuperclass().getName());</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; anInterface : user.getClass().getInterfaces()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Interface name: &quot;</span> + anInterface.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;\n&quot;</span> + user.getName());</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class name: com.github.s1mplecc.gof.proxy.User$EnhancerByCGLIB$N8wfgVhe</span><br><span class="line">Superclass name: com.github.s1mplecc.gof.proxy.User</span><br><span class="line">Interface name: org.hibernate.proxy.HibernateProxy</span><br><span class="line"></span><br><span class="line">Hibernate: select user0_.id as id1_0_0_, user0_.name as name2_0_0_ from t_user user0_ where user0_.id=?</span><br><span class="line">Geym</span><br></pre></td></tr></table></figure>

<p>从输出来看，load 方法加载出的 User 类并不是我们定义的 User 类，而是名为 <code>com.github.s1mplecc.gof.proxy.User$EnhancerByCGLIB$N8wfgVhe</code> 的类。从名称上可以推测它是使用 CGLIB 的 Enhancer 生成的动态类。该类的父类才是我们自定义的 User 类，此外，它还实现了 HibernateProxy 接口。由此可见，<strong>Hibernate 使用一个动态代理生成的子类替代用户定义的类</strong>。只有在真正使用对象数据时，才去数据库加载实际的数据。从输出结果来看，在调用 getName 方法之前从未输出过一条 SQL 语句，这说明 User 对象被加载时根本没有访问数据库。Hibernate 正是用这种方式实现了延迟加载。</p>
<p>另外，由于 CGLIB 停止维护很长一段时间了，Hibernate 从 3.5.5 版本开始弃用 CGLIB 而使用 Javassist。感兴趣的同学可以自行下去研究。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Proxy_pattern">Proxy pattern —— Wiki</a></li>
<li>《Java 编程思想》</li>
<li>《Java 程序性能优化 —— 让你的 Java 程序更快、更稳定》</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2019/02/15/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88Java-%E7%89%88%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/15/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88Java-%E7%89%88%EF%BC%89/" class="post-title-link" itemprop="url">一道有趣的路径规划算法题（Java 版）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-15 15:09:14" itemprop="dateCreated datePublished" datetime="2019-02-15T15:09:14+08:00">2019-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>图中有一个无向图，其中圈内数字代表一个地点，边线上的数字代表长度 Le（双向相同）。机场一辆小型VIP电动摆渡车在起点 A，要去 3 个贵宾厅（V1，V2，V3）接贵宾（每个贵宾厅限1个VIP），送到 3 个对应航班机位（S1，S2，S3），即 V1 至 S1，V2 至 S2，V3 至 S3。VIP 电动摆渡车同时最多装下 2 个 VIP。</p>
<p><img data-src="1.jpg" alt="ff858a30049f1753177d2691a50f09b1.jpeg"></p>
<p><strong>要求</strong>：VIP 电动摆渡车该怎么走路径最短？这个最短路径的长度是多少？这里 A 是出发点，最后一个 VIP（不限次序）送达地为终点。为了简化问题，假设贵宾厅VIP已在贵宾厅等候上车，VIP 电动摆渡车在接送期间不用等待。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看到最短路径，不难想到 Dijkstra 等最短路径算法，这些算法用于求出一个图（Graph）中任意两个顶点（Vertex）的最短距离。但是本文待求解的问题不止于此，而是包含起始点 A 在内的 7 个点（A、V1、V2、V3、S1、S2、S3），我们需要先<strong>规划路线</strong>使得摆渡车依次通过这 7 个点，再求出这些路线中的最短路线。</p>
<p>综上所诉，该问题被拆解为以下两步：<br>第一步，<strong>列出从 A 出发经由其余 6 个点的所有可能的路线</strong>。<br>第二步，<strong>对于给定的任意两个点，求出它们之间的最短路径</strong>（例如给定 A、V2 两个点，可得从 A 到 V2 的最短路径为 2 -&gt; 6 -&gt; 7）。<br>然后对于每条路线，计算每一段（即两个点之间）的最短路径即可得到整条路线的最短路径。</p>
<p>由此，可以看出本题涉及两个算法，即第一步中的<strong>排序算法</strong>，和第二步中的<strong>最短路径算法</strong>。</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>我们需要对 V1、V2、V3、S1、S2、S3 六个点进行排序。当然为满足题目的要求，排序得出的路线必须满足以下几个条件：</p>
<ol>
<li><strong>第一个点必须是 V，最后一个点必须是 S</strong></li>
<li>因为摆渡车最多载两个，所以<strong>不能出现连续的三个 V</strong></li>
<li>为确保将用户送达目的点，<strong>对应的 V 不能排在对应的 S 后面</strong>，比如不能排出 S1 … V1</li>
</ol>
<h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p><strong>Point</strong>，枚举类，对应着包括起点 A 在内的七个点。阔号中的整数类型表示点在图中的索引。同时基于 Java 面向对象的思想，赋予它一些验证方法以验证当前路径是否符合上述三个条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    A(<span class="number">2</span>, START),</span><br><span class="line">    V1(<span class="number">3</span>, VIP),</span><br><span class="line">    V2(<span class="number">7</span>, VIP),</span><br><span class="line">    V3(<span class="number">4</span>, VIP),</span><br><span class="line">    S1(<span class="number">12</span>, DESTINATION),</span><br><span class="line">    S2(<span class="number">11</span>, DESTINATION),</span><br><span class="line">    S3(<span class="number">13</span>, DESTINATION);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> index; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isV</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isS</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">matchedV</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        VIP, DESTINATION, START</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Route</strong>，对应着路线，下面粘贴了部分代码，包括验证当前路线是否合法的 <code>isLegal()</code> 方法，路径上追加点的 <code>add(Point)</code> 方法，以及预留的 <code>minDistance()</code> 方法用于计算这条路径的最短距离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Route</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Point&gt; route;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLegal</span><span class="params">()</span> </span>&#123; ... &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Point point)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>排序算法的核心思路是：</p>
<ol>
<li>首先需要一个容器用于所有装符合条件的 Route。</li>
<li>Route 用来装当前<strong>已入队列</strong>的 Point。</li>
<li>Remain Points Container 用于存放<strong>尚未入队列</strong>的 Point。</li>
<li>从 Remain Points Container <strong>依次拿出一个 Point，追加入 Route，判断是否合法</strong>，合法则继续，不合法则退出。</li>
<li>第 4 步是一个<strong>递归</strong>的步骤，如下图，假设第一个点装入了 V1，第二个点在装入的时候可以装入 V2、V3、S1、S2、S3，其中 S2、S3 因为不合法而终止递归，剩下的 V2、V3、S1 三个点 fork 出三种情况继续向下递归。</li>
<li>直到 Route 将六个点全部装入后，将该 Route 加入第 1 步的容器中。</li>
</ol>
<p><img data-src="2.jpeg" alt="3921ebbd368ce17e79a7b2f574d7673c.jpeg"></p>
<p><strong>RouteGenerator</strong> 类，用于生成所有符合条件的路线。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Route&gt; routes = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 第 1 步的容器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Route&gt; <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fork(<span class="keyword">new</span> Route(), List.of(V1, V2, V3, S1, S2, S3));</span><br><span class="line">        <span class="keyword">return</span> routes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fork</span><span class="params">(<span class="keyword">final</span> Route route, <span class="keyword">final</span> List&lt;Point&gt; remain)</span> </span>&#123; <span class="comment">// 入参分别对应 2、3 步</span></span><br><span class="line">        <span class="keyword">if</span> (!route.isLegal()) &#123; <span class="comment">// 判断是否合法，不合法则中断递归</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (route.size() == <span class="number">6</span>) &#123; <span class="comment">// 当六个点全部装入后，将该路线加入第 1 步的容器并中断递归</span></span><br><span class="line">            routes.add(route); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; remain.size(); i++) &#123;</span><br><span class="line">            List&lt;Point&gt; temp = Lists.newArrayList(remain);</span><br><span class="line">            Point next = temp.remove(i); <span class="comment">// 从未入队列的点中选出一个加入路线</span></span><br><span class="line">            Route route1 = route.copy();</span><br><span class="line">            route1.add(next);</span><br><span class="line"></span><br><span class="line">            fork(route1, temp); <span class="comment">// 递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>排序后得到结果，一共 54 种符合条件的情况。算法耗时在 40ms 左右。该算法相较于全排列后再进行筛选，可以避免创建不必要的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; V1 -&gt; V2 -&gt; S1 -&gt; V3 -&gt; S2 -&gt; S3</span><br><span class="line">A -&gt; V1 -&gt; V2 -&gt; S1 -&gt; V3 -&gt; S3 -&gt; S2</span><br><span class="line">A -&gt; V1 -&gt; V2 -&gt; S1 -&gt; S2 -&gt; V3 -&gt; S3</span><br><span class="line">...</span><br><span class="line">A -&gt; V2 -&gt; V3 -&gt; S3 -&gt; V1 -&gt; S1 -&gt; S2</span><br><span class="line">A -&gt; V2 -&gt; V3 -&gt; S3 -&gt; V1 -&gt; S2 -&gt; S1</span><br><span class="line">A -&gt; V2 -&gt; V3 -&gt; S3 -&gt; S2 -&gt; V1 -&gt; S1</span><br><span class="line">...</span><br><span class="line">A -&gt; V3 -&gt; S3 -&gt; V2 -&gt; V1 -&gt; S1 -&gt; S2</span><br><span class="line">A -&gt; V3 -&gt; S3 -&gt; V2 -&gt; V1 -&gt; S2 -&gt; S1</span><br><span class="line">A -&gt; V3 -&gt; S3 -&gt; V2 -&gt; S2 -&gt; V1 -&gt; S1</span><br></pre></td></tr></table></figure>

<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><p>本题中的最短路径算法我选用的 Dijkstra 算法，亦就是大学数据结构课程中最为常知的最短路径算法。算法的详细步骤这里就不再赘述了，可以参考一篇博客 <a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html">Dijkstra最短路算法
</a>。</p>
<h3 id="建模-1"><a href="#建模-1" class="headerlink" title="建模"></a>建模</h3><p>Dijkstra 算法的核心建模思想是使用一个二维数组，记录每个顶点到其他顶点的距离，如果不能直达，则设为 ∞。那么本题的图可以使用如下二维数组来表示，由于是无向图，所以关于对角线对称。</p>
<p><img data-src="3.png" alt="afe039363dc9b79e775321fa5a6dee22.png"></p>
<p>反应在 Java 代码中则是如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> I = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INFINITY = I;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo: maybe read from graph with python</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrix() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line"><span class="comment">//               1  2  3  4  5  6  7  8  9  10 11 12 13 14 15</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, I, I, <span class="number">1</span>, I, I, I, I, I, I, I, I, I, I&#125;, <span class="comment">// 1</span></span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, I, I, <span class="number">2</span>, I, I, I, I, I, I, I, I, I&#125;, <span class="comment">// 2</span></span><br><span class="line">                &#123;I, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, I, I, I, <span class="number">2</span>, I, I, I, I, I, I, I&#125;, <span class="comment">// 3</span></span><br><span class="line">                &#123;I, I, <span class="number">1</span>, <span class="number">0</span>, I, I, I, I, I, I, I, I, I, I, <span class="number">3</span>&#125;, <span class="comment">// 4</span></span><br><span class="line">                &#123;<span class="number">1</span>, I, I, I, <span class="number">0</span>, <span class="number">1</span>, I, I, <span class="number">1</span>, I, I, I, I, I, I&#125;, <span class="comment">// 5</span></span><br><span class="line">                &#123;I, <span class="number">2</span>, I, I, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, I, I, I, I, I, I, I, I&#125;, <span class="comment">// 6</span></span><br><span class="line">                &#123;I, I, I, I, I, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, I, <span class="number">1</span>, I, I, I, I, I&#125;, <span class="comment">// 7</span></span><br><span class="line">                &#123;I, I, <span class="number">2</span>, I, I, I, <span class="number">1</span>, <span class="number">0</span>, I, I, <span class="number">1</span>, I, I, I, I&#125;, <span class="comment">// 8</span></span><br><span class="line">                &#123;I, I, I, I, <span class="number">1</span>, I, I, I, <span class="number">0</span>, <span class="number">3</span>, I, <span class="number">2</span>, I, I, I&#125;, <span class="comment">// 9</span></span><br><span class="line">                &#123;I, I, I, I, I, I, <span class="number">1</span>, I, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, I, <span class="number">2</span>, I, I&#125;, <span class="comment">// 10</span></span><br><span class="line">                &#123;I, I, I, I, I, I, I, <span class="number">1</span>, I, <span class="number">1</span>, <span class="number">0</span>, I, I, <span class="number">1</span>, I&#125;, <span class="comment">// 11</span></span><br><span class="line">                &#123;I, I, I, I, I, I, I, I, <span class="number">2</span>, I, I, <span class="number">0</span>, <span class="number">2</span>, I, I&#125;, <span class="comment">// 12</span></span><br><span class="line">                &#123;I, I, I, I, I, I, I, I, I, <span class="number">2</span>, I, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, I&#125;, <span class="comment">// 13</span></span><br><span class="line">                &#123;I, I, I, I, I, I, I, I, I, I, <span class="number">1</span>, I, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, <span class="comment">// 14</span></span><br><span class="line">                &#123;I, I, I, <span class="number">3</span>, I, I, I, I, I, I, I, I, I, <span class="number">1</span>, <span class="number">0</span>&#125;, <span class="comment">// 15</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p>Dijkstra 算法的核心思想是：每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下：</p>
<ol>
<li>使用一个 <code>dis[]</code> 数组记录源点到其余所有点的最短路径。初始化为 matrix 二维数组的对应行。</li>
<li>将所有的顶点分为两部分：已知最短路程的顶点集合 P 和未知最短路径的顶点集合 Q。最开始，已知最短路径的顶点集合 P 中只有源点一个顶点。我们这里用一个  <code>book[]</code> 数组来记录哪些点在集合 P 中。例如对于某个顶点 i，如果 <code>book[i]</code> 为 1 则表示这个顶点在集合 P 中，如果 <code>book[i]</code> 为 0 则表示这个顶点在集合 Q 中。</li>
<li>在集合 Q 的所有顶点中选择一个离源点 s 最近的顶点 u（即 <code>dis[u]</code> 最小）加入到集合 P。并考察所有以点 u 为起点的边，对每一条边进行松弛操作。例如存在一条从 u 到 v 的边，使得 <code>s -&gt; u -&gt; v</code> 的长度 <code>dis[u] + e[u][v]</code> 比目前已知的 <code>dis[v]</code> 的值更小，那么我们就可以用新值来更新当前 <code>dis[v]</code> 中的值（即<strong>松弛</strong>）。</li>
<li>重复第 3 步，如果集合 Q 为空，算法结束。最终 dis 数组中的值就是源点到所有顶点的最短路径。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] e;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dijkstra</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.e = graph.matrix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = e[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init dis[]</span></span><br><span class="line">        <span class="keyword">int</span>[] dis = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        System.arraycopy(e[start - <span class="number">1</span>], <span class="number">0</span>, dis, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init book[]</span></span><br><span class="line">        <span class="keyword">int</span>[] book = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        book[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = INFINITY;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (book[j] == <span class="number">0</span> &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">                    min = dis[j];</span><br><span class="line">                    u = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            book[u] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e[u][v] &lt; INFINITY) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dis[v] &gt; dis[u] + e[u][v]) &#123;</span><br><span class="line">                        dis[v] = dis[u] + e[u][v];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dis[end - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 Dijkstra 算法我有想过使用缓存 Cache 去进行优化，为了避免重复计算两个点之间的最短距离，但实际上效果反而不好，其实这是一种空间换时间的取舍，虽然不用重复计算，但是需要额外的空间存储已计算过的路径。然而在本题中并不适用这种优化。</p>
<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p>结合 Dijkstra 算法，我们可以补全之前 Route 类中预留的 <code>minDistance()</code> 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Route.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AtomicReference&lt;Point&gt; pre = <span class="keyword">new</span> AtomicReference&lt;&gt;(Point.A);</span><br><span class="line">    <span class="keyword">return</span> route.stream()</span><br><span class="line">            .map(p -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> min = dijkstra.min(pre.get().index(), p.index());</span><br><span class="line">                pre.set(p);</span><br><span class="line">                <span class="keyword">return</span> min;</span><br><span class="line">            &#125;)</span><br><span class="line">            .reduce(<span class="number">0</span>, (i1, i2) -&gt; i1 + i2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在主方法中运行可得答案，运行耗时在 100ms 左右。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> before = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    List&lt;Route&gt; routes = <span class="keyword">new</span> RouteGenerator().generate();</span><br><span class="line">    routes.forEach(route -&gt; System.out.println(route + <span class="string">&quot; 最短路径长度: &quot;</span> + route.minDistance()));</span><br><span class="line">    Route shortestRoute = routes.stream().min(Comparator.comparing(Route::minDistance)).get();</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;\n其中最短路径为 %s, 路径长度为 %s.&quot;</span>, shortestRoute, shortestRoute.minDistance()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> after = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;运行耗时:&quot;</span> + (after - before) + <span class="string">&quot;ms.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中最短路径为 A -&gt; V2 -&gt; S2 -&gt; V1 -&gt; V3 -&gt; S3 -&gt; S1, 路径长度为 16.</span></span><br><span class="line"><span class="comment">// 运行耗时:108ms.</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是想向大家展示 Java <strong>面向对象处理问题</strong>的优势。虽然可能代码量会多一些，但是在重构和梳理编码过程的时候，这种面向对象的思想无疑会带来很多好处。例如本文中 Route、Point、Graph 这些类的建模相较于面向过程编码更符合人的直觉；以及<strong>为避免贫血对象，我们赋予类丰富的行为</strong>，例如一些验证方法、<code>minDistance()</code> 等方法；同时还要多写<strong>单元测试</strong>，这样可以随时验证算法的正确性，而不用等到编码完成的最后再去肉眼比对结果。</p>
<p>代码已经上传到 <a target="_blank" rel="noopener" href="https://github.com/s1mplecc/route-plan">GitHub</a> 上，包含了相对全面的单元测试，需要注意的是使用的 Java 11 版本。以后可能会使用 Python 编码实现，再比较两种语言的优劣势。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2019/01/23/Fluent%20Interface%20--%20Martin%20Fowler%20%E5%8D%9A%E5%AE%A2%E8%AF%91%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/23/Fluent%20Interface%20--%20Martin%20Fowler%20%E5%8D%9A%E5%AE%A2%E8%AF%91%E6%96%87/" class="post-title-link" itemprop="url">Fluent Interface —— Martin Fowler 博客译文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-23 14:15:45" itemprop="dateCreated datePublished" datetime="2019-01-23T14:15:45+08:00">2019-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Translations/" itemprop="url" rel="index"><span itemprop="name">Translations</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a target="_blank" rel="noopener" href="https://www.martinfowler.com/bliki/FluentInterface.html">Fluent Interface</a>，Matrin Fowler 博客，发表于 2005 年 12 月 20 日。</p>
<h2 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h2><p>几个月前我和 Eric Evans 进行了一次讨论会，他谈到一种接口的设计风格，我们称之为流畅接口（Fluent Interface）。它不是一种常见的风格，但我们觉得应该广为人知。描述它的最直观的方式就是例子。</p>
<p>最简单的例子可能就来自 Eric 编写的 <a target="_blank" rel="noopener" href="http://timeandmoney.sourceforge.net/">TimeAndMoney Library</a>。为了指定一段时间间隔，我们通常这么做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TimePoint fiveOClock, sixOClock;</span><br><span class="line">...</span><br><span class="line">TimeInterval meetingTime = <span class="keyword">new</span> TimeInterval(fiveOClock, sixOClock);</span><br></pre></td></tr></table></figure>

<p>但是 TimeAndMoney 库的使用者会这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeInterval meetingTime = fiveOClock.until(sixOClock);</span><br></pre></td></tr></table></figure>

<p>下面我继续演示“客户下订单”这个例子。一个订单包含多个订单项，每个订单项包含商品项和购买的数量。在提交订单时一个订单项应当是可跳过的，这意味着我更希望在没有此订单项（缺货）的情况下提交订单，而不是推迟提交整个订单。所以这里可以给整个订单一个“急促（rush）”的状态标识。</p>
<p>要实现上述功能，最常见的编码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeNormal</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">    Order o1 = <span class="keyword">new</span> Order();</span><br><span class="line">    customer.addOrder(o1);</span><br><span class="line">    OrderLine line1 = <span class="keyword">new</span> OrderLine(<span class="number">6</span>, Product.find(<span class="string">&quot;TAL&quot;</span>));</span><br><span class="line">    o1.addLine(line1);</span><br><span class="line">    OrderLine line2 = <span class="keyword">new</span> OrderLine(<span class="number">5</span>, Product.find(<span class="string">&quot;HPK&quot;</span>));</span><br><span class="line">    o1.addLine(line2);</span><br><span class="line">    OrderLine line3 = <span class="keyword">new</span> OrderLine(<span class="number">3</span>, Product.find(<span class="string">&quot;LGV&quot;</span>));</span><br><span class="line">    o1.addLine(line3);</span><br><span class="line">    line2.setSkippable(<span class="keyword">true</span>);</span><br><span class="line">    o1.setRush(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上我们创建了多个对象然后将它们组装在一起。如果无法在构造函数中设置所有内容，那么就需要创建临时变量来帮助我们完成组装 —— 尤其是将集合项添加到集合中。</p>
<p>下面是使用流畅接口实现相同的组装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeFluent</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">    customer.newOrder()</span><br><span class="line">            .with(<span class="number">6</span>, <span class="string">&quot;TAL&quot;</span>)</span><br><span class="line">            .with(<span class="number">5</span>, <span class="string">&quot;HPK&quot;</span>).skippable()</span><br><span class="line">            .with(<span class="number">3</span>, <span class="string">&quot;LGV&quot;</span>)</span><br><span class="line">            .priorityRush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这种风格最重要的一点就是，基于 Internal DomainSpecificLanguage 将要做的事沿着一条线进行编码（译者注：Domain Specific Language，DSL，领域专用语言）。实际上这也是为什么我们选择用 “Fluent” 一词来描述它，在很多方面这两个术语是同义词。<strong>这种 API 被设计为可读的和流式的，这种流畅性的代价是在设计和构建 API 时需要花更多的功夫</strong>。构造函数、setter 和 add 方法的 API 简单且容易编写，但要想提供一个漂亮的流畅接口则需要更多的思考。</p>
<p>事实上，刚才我想用在 Calgary 咖啡店吃早餐的时间完成这个小例子的编码，但是我搞砸了，看来好的流畅接口需要花费一些时间去实现。如果你想找一个比较成熟的例子，可以看看 <a target="_blank" rel="noopener" href="http://jmock.org/">JMock</a>。与任何 mocking 库一样，JMock 需要创建复杂的行为规范。在过去几年中已经构建了许多 mocking 库，而 JMock 的这个则包含了非常漂亮的流畅接口，使用体验非常好。这是它的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mock.expects(once())</span><br><span class="line">    .method(<span class="string">&quot;m&quot;</span>)</span><br><span class="line">    .with(or(stringContains(<span class="string">&quot;hello&quot;</span>), stringContains(<span class="string">&quot;howdy&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>我看到 Steve Freeman 和 Nat Price 在 <a target="_blank" rel="noopener" href="https://www.martinfowler.com/bliki/JAOO2005.html">JAOO2005</a> 上就 JMock API 的演变发表了精彩的演讲，演讲相关的内容他们已经发表到一篇 <a target="_blank" rel="noopener" href="http://www.mockobjects.com/files/evolving_an_edsl.ooplsa2006.pdf">OOPSLA论文</a> 上。</p>
<p>到目前为止，我们看到用于创建对象配置的流畅接口通常会涉及到 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Value_object">值对象</a>。我不确定这是否属于流畅接口的一个定义特征，虽然我怀疑它们出现在声明性上下文中有某种关联。对我们而言，<strong>流畅性的关键考验在于领域特定语言的质量</strong>。API 使用起来越像流式的语言，它就越流畅。</p>
<p>像这样构建一个流畅接口会导致一些不符合使用习惯的 API。其中最明显的一个就是 setter 会有返回值（在订单示例中，<code>with</code> 方法为订单添加一个订单项并返回整个订单），而惯例是修改性质的方法返回 <code>void</code>，因为这样遵循 <a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/CommandQuerySeparation.html">CommandQuerySeparation</a> 原则（译者注：CQS，命令查询分离原则）。这个约定确实妨碍了流畅接口，所以我倾向于暂不遵循这个惯例。</p>
<p>你应该<strong>根据流畅接口的下一个行为（fluent action）去选择返回类型</strong>。JMock 提出了一个重点：根据接下来的需要改变其返回类型。<strong>这种风格的一个很好的优点是方法补完后（intellisense）有助于告诉你接下来要键入什么 —— 有点像 IDE 中的智能提示</strong>。总的来说，我发现动态语言对于 DSL 来说效果更好，因为它们的语法往往更简洁。但是，使用方法补完是静态语言的一个优点。</p>
<p>流畅接口定义的方法的一个问题是它们可能名不符实。举个例子，你去查看 <code>with</code> 方法的文档可能并没有什么意义，因为这个方法的实现和 <code>with</code> 并没有什么关联。我承认光就方法的命名来说这不是一个好的命名，因为它根本不能表达该方法实际做了什么。只有在流畅行为的上下文中这种命名才能显示出它的优势（译者注：这点我在编码时也深有体会，流畅接口的方法实现与方法命名常常做的是两回事，比如说把值对象传递下去）。解决此问题的一种可能的方法是只在此上下文中使用 builder 对象（译者注：可以参考 Builder Pattern，比如 <code>new BankAccount.Builder(4567L).withOwner(&quot;Homer&quot;).atBranch(&quot;Springfield&quot;).build();</code>，只在最后一步 <code>build()</code> 中进行构建）。</p>
<p>Eric 提到的一点是，到目前为止，他使用并看到了流畅的接口大多是关于值对象的配置。值对象不具有领域意义的标识（Identity），因此你可以轻松创建并丢弃它们。所以接口的流畅度取决于使用旧值构造新值。从这个意义上讲，订单案例并不典型，因为它属于 <a target="_blank" rel="noopener" href="https://www.martinfowler.com/bliki/EvansClassification.html">EvansClassification</a> 中的实体对象（Entity）。（译者注：Evans Classification，Evans 关于领域对象的分类 Entity、Value Object 和 Service）</p>
<p>目前为止我还没有看到很多的流畅接口，可以得出结论，我们对它们的优缺点了解还不够。所以任何使用它们的劝告都只能是初步的 —— 但我认为它们已经成熟，可以进行更多的尝试。</p>
<p><a target="_blank" rel="noopener" href="https://bofh.org.uk/2005/12/21/fluent-interfaces/">Piers Cawley</a> 对本文有一个很好的跟进。</p>
<p><strong>更新</strong>（2008年6月23日）。自从我写这篇文章以来，这个术语被广泛使用，这给了我一种令人愉快的满足感。在我一直在研究的书中，我已经提炼了关于流畅接口和内部 DSLs 的想法。我也注意到了一个常见的误解 —— 很多人似乎将流畅接口与方法链（Method Chaining）等同起来。当然链式接口是使用了流畅接口的一种常用的技术，但真正的流畅接口远不止于此。</p>
<p>我上面展示的 JMock 示例使用了方法链，但同时也使用嵌套函数和对象作用域。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2019/01/13/Java-%E6%97%A5%E5%BF%97%E4%BA%8C%E4%B8%89%E4%BA%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/13/Java-%E6%97%A5%E5%BF%97%E4%BA%8C%E4%B8%89%E4%BA%8B/" class="post-title-link" itemprop="url">Java 日志二三事</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-13 18:10:44" itemprop="dateCreated datePublished" datetime="2019-01-13T18:10:44+08:00">2019-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Concepts/" itemprop="url" rel="index"><span itemprop="name">Concepts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 拥有功能和性能都非常强大的日志库，但另一方面，Java 日志库依赖看起来丰富的让人眼花缭乱。相信大家或多或少都有这样的疑问，Log4j，SLF4J，Logback，Log4j2 这些日志框架我该如何选择？它们彼此间又有什么关系？本篇文章将介绍这些日志库的历史演进和之间的关系，方便你选择最适合的日志库。文章最后还有日志库使用的最佳实践。</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p><strong>Log4j</strong> (Log For Java) 可以当之无愧地说是 Java 日志框架的元老，1999 年发布首个版本，2012 年发布最后一个版本，2015 年正式宣布终止，至今还有无数的系统在使用 Log4j，甚至很多新系统的日志框架选型仍在选择 Log4j。</p>
<p>然而老的不等于好的，在 IT 技术层面更是如此。尽管 Log4j 有着出色的历史战绩，但早已不是 Java 日志框架的最优选择。</p>
<p>在 Log4j 被 Apache Foundation 收入门下之后，由于理念不合， Log4j 的作者 Ceki Gülcü 离开并开发了 SLF4J 和 Logback。</p>
<p><strong>SLF4J</strong> (Simple Log Facade For Java) 因其优秀的性能和理念很快受到了广泛欢迎，2016 年的统计显示，GitHub 上的热门 Java 项目中，SLF4J 是使用率第二名的类库（第一名是 Junit）。</p>
<p><strong>Logback</strong> 则吸取了 Log4j 的经验，实现了很多强大的新功能，再加上它和 SLF4J 能够无缝集成，也受到了欢迎。</p>
<p>在这期间，Apache Logging 则一直在关门憋大招，<strong>Log4j2</strong> 在 beta 版鼓捣了几年，终于在 2014 年发布了 GA 版，不仅吸收了 Logback 的先进功能，更通过优秀的锁机制、LMAX Disruptor、”无垃圾”机制等先进特性，在性能上全面超越了 Log4j 和 Logback。</p>
<h3 id="Log4j-1-x"><a href="#Log4j-1-x" class="headerlink" title="Log4j 1.x"></a>Log4j 1.x</h3><p>Log4j (Log For Java) 是在 Logback 出现之前被广泛使用的日志库，由 Gülcü 于 2001 年发布，后来成为 Apache 基金会的顶级项目。Log4j 在设计上非常优秀，对后续的 Java Log 框架有长久而深远的影响，也产生了 Log4c、Log4s、Log4perl 等到其他语言的移植。Log4j 的短板在于性能，在Logback 和 Log4j2 出来之后，Log4j 的使用也减少了。</p>
<h3 id="Commons-Logging"><a href="#Commons-Logging" class="headerlink" title="Commons Logging"></a>Commons Logging</h3><p>Commons Logging，简称 JCL，是 Apache 下属项目。JCL 是一个 <strong>Log Facade，只提供 Log API，不提供实现</strong>，然后有 Adapter 来使用 Log4j 或者 JDK 中自带的 JUL（Java Util Logging）作为 <strong>Log Implementation</strong>。</p>
<p>不同的项目可能各自使用了不同的日志库，如果你的项目依赖的其他项目各自使用了不同的日志库，你想控制日志行为，就需要针对每个日志库都写一个配置文件，那岂不是很麻烦?所以这个时候 JCL 就出现了。</p>
<p>在程序中日志创建和记录都是用 JCL 中的接口，而真正运行时会搜索当前 ClassPath 中有什么实现，如果有 Log4j 就是用 Log4j，如果啥都没有则使用 JDK 的 JUL。这样，在你的项目中，还有第三方的项目中，大家记录日志都使用 JCL 的接口，然后最终运行程序时，可以按照自己的需求(或者喜好)来选择使用合适的 Log Implementation。比如你想使用 Log4j，就添加 Log4j 的依赖并编写一个 Log4j 的配置文件（通常命名为 <code>log4j.properties</code>）。</p>
<h3 id="SLF4J-Logback"><a href="#SLF4J-Logback" class="headerlink" title="SLF4J/Logback"></a>SLF4J/Logback</h3><p>SLF4J (Simple Logging <strong>Facade</strong> for Java) 和 Logback 也是 Gülcü 创立的项目，其创立主要是为了提供更高性能的实现。其中，SLF4j 是类似于 JCL 的 Log Facade，Logback 是类似于 Log4j 的 Log Implementation。</p>
<p>SLF4J 出现的缘由是 Gülcü 认为 JCL 的 API 设计得不好，容易让使用者写出性能有问题的代码。比如在用 JCL 输出一个 debug 级别的 log：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;start process request, url: &quot;</span> + url);</span><br></pre></td></tr></table></figure>

<p>这个有什么问题呢？一般生产环境 log 级别都会设到 info 或者以上，那这条 log 是不会被输出的。然而不管会不会输出，这其中都会做一个字符串连接操作，然后生产一个新的字符串。如果这条语句在循环或者被调用很多次的函数中，就会多做很多无用的字符串连接，影响性能。所以 JCL 的最佳实践推荐这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;start process request, url: &quot;</span> + url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然作为 API 来说这太为繁琐，所以 SLF4J 提供了新的 API，方便开发者使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;start process request, url: &#123;&#125;&quot;</span>, url);</span><br></pre></td></tr></table></figure>

<p>这样的话，在不输出 log 的时候避免了字符串拼接的开销；在输出的时候需要做一个字符串 format，代价比手工拼接字符串大一些，但是可以接受。</p>
<p>而 Logback 则是作为 Log4j 的取缔者来开发的，提供了性能更好的实现，以及异步 logger，Filter 等更多的特性。</p>
<h3 id="Log4j2"><a href="#Log4j2" class="headerlink" title="Log4j2"></a>Log4j2</h3><p>现在有了更好的 SLF4J 和 Logback 正慢慢取代 JCL 和 Log4j，然而维护 Log4j 的人不想坐视用户一点点被 SLF4J /Logback 蚕食，所以 Log4j2 诞生了。Log4j2 和 Log4j1.x 并不兼容，设计上很大程度上模仿了 SLF4J/Logback，性能上也获得了很大的提升。Log4j2 也做了 Facade/Implementation 分离的设计，分成了 log4j-api 和 log4j-core。</p>
<h2 id="Facade-amp-Implementation"><a href="#Facade-amp-Implementation" class="headerlink" title="Facade &amp; Implementation"></a>Facade &amp; Implementation</h2><p>JCL、SLF4J 和 Log4j2 日志框架都使用了 GoF 设计模式中的门面模式（<strong>Facade Pattern</strong>），将接口和实现分离，定义统一的接口，而实现可以由用户自由选择。现在我们有了三个流行的 Log Facade，以及多个 Log Implementation，那么该如何配合使用呢？</p>
<h3 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h3><p>Gülcü 是个追求完美的人，他决定让 SLF4J 和这些 Log 之间都能够方便的互相替换，所以做了各种 <strong>Adapter</strong> 和 <strong>Bridge</strong> 来连接:</p>
<p><img data-src="0.jpg" alt="0a9ca27a6fcb038fca91153b1147e5cc.jpeg"></p>
<p>有趣的是，唯独没有 slf4j-over-log4j2 的桥接库，而且 log4j-to-slf4j 和 log4j-slf4j-impl 也是由 Apache 自己开发的。</p>
<p>slf4j-api 只是 Log Facade 的依赖，添加了该依赖意味着在编码时你能够使用 <code>Logger log = LoggerFactory.getLogger(Main.class);</code> 和 <code>log.info(&quot;hello, &#123;&#125;&quot;, &quot;world&quot;);</code> 这种方式。除此之外，还需要添加 Log Implementation 的依赖。</p>
<p>下图是 <a target="_blank" rel="noopener" href="https://www.slf4j.org/manual.html">SLF4J官网</a> 介绍可以绑定的日志实现框架。其中 slf4j-simple 是为小项目提供的简单实现；logback-classic 是官方的原生实现，不需要额外的适配器。而 <code>slf4j-log4j12</code> 和 <code>slf4j-jdk14</code> 分别是适配到 Log4j 和 JUL 的依赖，JUL 由于是 JDK 自带所以不需要额外依赖，而 Log4j 则还需要添加自己的底层实现依赖。</p>
<p><img data-src="1.png" alt="b7d8f119aca4c91e4d72283f7198148f.png"></p>
<p>下面这张图展示了 SLF4J 绑定不同日志实现框架需要的依赖：</p>
<p><img data-src="2.png" alt="d8261ab119309917e25180ef0ae42abe.png"></p>
<h3 id="Log4j2-1"><a href="#Log4j2-1" class="headerlink" title="Log4j2"></a>Log4j2</h3><p>关于 Log Facade 选择 SLF4J 还是 Log4j2，个人觉得要看项目需求。总的来说 SLF4J 的兼容性更好，日志实现可以随意搭配使用；虽然 Log4j2 可以通过 log4j-to-slf4j 桥接到 SLF4J 再使用其他的 Log Implementation，但这必然带来多余的性能消耗。</p>
<p>而 Log4j2 的优点则在于性能，在 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41498021/is-it-worth-to-use-slf4j-with-log4j2">Is it worth to use slf4j with log4j2</a> 这个问题中推荐直接面向 Log4j2 API 编程，理由如下：</p>
<ul>
<li>Message API</li>
<li>Lambdas for lazy logging</li>
<li>Log any Object instead of just Strings</li>
<li>Garbage-free: avoid creating varargs or creating Strings where possible</li>
<li>CloseableThreadContext automatically removes items from the MDC when you’re finished with them</li>
</ul>
<p>Logback 和 Log4j2 都宣称自己是 Log4j 的后代，一个是出自同一作者，另一个则是在名字上根正苗红。撇开血统不谈，比较一下 Log4j2 和 Logback：</p>
<ul>
<li>Log4j2 比 Logback 更新。Log4j2 的 GA 版在 2014 年底才推出，比 Logback 晚了好几年，这期间 Log4j2 确实吸收了 SLF4J 和 Logback 的一些优点（比如日志模板），同时应用了不少的新技术</li>
<li>由于采用了更先进的锁机制和 LMAX Disruptor 库，Log4j2 的性能优于 Logback，尤其是在多线程环境下和使用异步日志的环境下</li>
<li>二者都支持 Filter（应该说是 Log4j2 借鉴了 Logback 的 Filter），能够实现灵活的日志记录规则（例如仅对一部分用户记录 DEBUG 级别的日志）</li>
<li>二者都支持对配置文件的动态更新</li>
<li>二者都能够适配 SLF4J， Logback 与 SLF4J 的适配应该会更好一些，毕竟省掉了一层适配库</li>
<li>Logback 能够自动压缩/删除旧日志</li>
<li>Logback 提供了对日志的 HTTP 访问功能</li>
<li>Log4j2 实现了“无垃圾”和“低垃圾”模式。简单地说，Log4j2 在记录日志时，能够重用对象（如String等），尽可能避免实例化新的临时对象，减少因日志记录产生的垃圾对象，减少垃圾回收带来的性能下降</li>
</ul>
<p>这是 Apache 官方提供的同步和异步写日志时的性能对比图：</p>
<p><img data-src="3.png" alt="900a0952b7540882925dd50699dc3e29.png"></p>
<p><img data-src="4.png" alt="c5b42a899b63e265a3e2f4300d443ecb.png"></p>
<p>所以综上所诉，个人的看法是：<strong>如果对性能有要求，且 Log Implementation 想选用 Log4j2 的话，推荐 Log Facade 直接使用 Log4j2 API</strong>。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="总是使用-Log-Facade，而不是具体-Log-Implementation"><a href="#总是使用-Log-Facade，而不是具体-Log-Implementation" class="headerlink" title="总是使用 Log Facade，而不是具体 Log Implementation"></a>总是使用 Log Facade，而不是具体 Log Implementation</h3><p>正如之前所说的，使用 Log Facade 可以方便的切换具体的日志实现。而且，如果依赖多个项目，使用了不同的 Log Facade，还可以方便的通过 Adapter 转接到同一个实现上。如果依赖项目使用了多个不同的日志实现，就麻烦的多了。</p>
<p>具体来说，现在<strong>推荐使用 Log4j2 API 或者 SLF4j</strong>，不推荐继续使用 JCL。</p>
<h3 id="只添加一个-Log-Implementation-依赖"><a href="#只添加一个-Log-Implementation-依赖" class="headerlink" title="只添加一个 Log Implementation 依赖"></a>只添加一个 Log Implementation 依赖</h3><p>毫无疑问，项目中应该只使用一个具体的 Log Implementation，<strong>建议使用 Logback 或者 Log4j2</strong>。如果有依赖的项目中，使用的 Log Facade 不支持直接使用当前的 Log Implementation，就添加合适的桥接器依赖。</p>
<h3 id="总是为-Log-Implementation-依赖设置-optional-和-runtime-scope"><a href="#总是为-Log-Implementation-依赖设置-optional-和-runtime-scope" class="headerlink" title="总是为 Log Implementation 依赖设置 optional 和 runtime scope"></a>总是为 Log Implementation 依赖设置 optional 和 runtime scope</h3><p>在项目中，Log Implementation 的依赖强烈建议设置为 runtime scope，并且设置为 optional。例如项目中使用了 SLF4J 作为 Log Facade，然后想使用 Logback 作为 Implementation，那么使用 POM 文件应该这么写：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;logback.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设为 optional，<strong>依赖不会传递</strong>，这样如果你的项目被别的项目依赖，它就不会引入不想要的 Log Implementation 依赖，即<strong>使用你提供的库的用户可以自定义 Log Implementation</strong>；</p>
<p>Scope 设置为 runtime，是为了防止开发人员在项目中直接使用 Log Implementation 中的类，而不适用 Log Facade 中的类，即<strong>编码时程序员只可见 Log Facade 层面而不必关注实现层面</strong>。</p>
<h3 id="如果有必要，排除依赖的第三方库中的-Log-Impementation-依赖"><a href="#如果有必要，排除依赖的第三方库中的-Log-Impementation-依赖" class="headerlink" title="如果有必要，排除依赖的第三方库中的 Log Impementation 依赖"></a>如果有必要，排除依赖的第三方库中的 Log Impementation 依赖</h3><p>这是很常见的一个问题，第三方库的开发者未必会把具体的日志实现或者桥接器的依赖设置为 optional，然后你的项目继承了这些依赖。然而具体的日志实现未必是你想使用的，比如他依赖了 Log4j，你想使用 Logback，这样程序在运行时会检测到有多个日志实现类，如下图。另外，如果不同的第三方依赖使用了不同的桥接器和 Log 实现，也容易形成环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/Users/s1mple/.m2/repository/org/slf4j/slf4j-log4j12/1.7.5/slf4j-log4j12-1.7.5.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/Users/s1mple/.m2/repository/com/caacitc/slf4j-jdk14-1.6.1.jar/1.0.2/slf4j-jdk14-1.6.1.jar-1.0.2.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br></pre></td></tr></table></figure>

<p>这种情况下，推荐的处理方法，是<strong>使用 exclude 来排除所有的这些 Log 实现和桥接器的依赖，只保留第三方库里面对 Log Facade 的依赖</strong>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.jstorm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstorm-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外，在 IntelliJ IDEA 中，可以使用 <strong>Show Maven Dependencies</strong> 查看依赖关系图，可以方便的搜索依赖并 exclude 掉。</p>
<h3 id="避免为不会输出的-log-付出代价"><a href="#避免为不会输出的-log-付出代价" class="headerlink" title="避免为不会输出的 log 付出代价"></a>避免为不会输出的 log 付出代价</h3><p>Log 库都可以灵活的设置输出界别，所以每一条程序中的 log，都是有可能不会被输出的。这时候要注意不要额外的付出代价。</p>
<p>先看两个有问题的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;start process request, url: &quot;</span> + url);</span><br><span class="line">logger.debug(<span class="string">&quot;receive request: &#123;&#125;&quot;</span>, toJson(request));</span><br></pre></td></tr></table></figure>

<p>第一条是直接做了字符串拼接，所以即使日志级别高于 debug 也会做一个字符串连接操作；第二条虽然用了 SLF4J/Log4j2 中的懒求值方式来避免不必要的字符串拼接开销，但是 <code>toJson()</code> 这个函数却是都会被调用并且开销更大。</p>
<p>推荐的写法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;start process request, url:&#123;&#125;&quot;</span>, url); <span class="comment">// SLF4J/LOG4J2</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123; <span class="comment">// SLF4J/LOG4J2</span></span><br><span class="line">    logger.debug(<span class="string">&quot;receive request: &quot;</span> + toJson(request)); </span><br><span class="line">&#125;</span><br><span class="line">logger.debug(<span class="string">&quot;receive request: &#123;&#125;&quot;</span>, () -&gt; toJson(request)); <span class="comment">// LOG4J2</span></span><br><span class="line">logger.debug(() -&gt; <span class="string">&quot;receive request: &quot;</span> + toJson(request)); <span class="comment">// LOG4J2</span></span><br></pre></td></tr></table></figure>

<h3 id="日志中尽量避免输出行号，函数名等字段"><a href="#日志中尽量避免输出行号，函数名等字段" class="headerlink" title="日志中尽量避免输出行号，函数名等字段"></a>日志中尽量避免输出行号，函数名等字段</h3><p>原因是，为了获取语句所在的函数名，或者行号，log 库的实现都是获取当前的 stacktrace，然后分析取出这些信息，而获取 stacktrace 的代价是很昂贵的。如果有很多的日志输出，就会占用大量的 CPU。在没有特殊需要的情况下，建议不要在日志中输出这些这些字段。</p>
<p>正确做法是使用日志打印的类名和内容定位到代码位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Main.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16:08:14.913 [main] INFO com.github.s1mplecc.log.Main - hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24272450">Java 日志框架解析(上) - 历史演进</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24275518">Java 日志框架解析(下) - 最佳实践</a></li>
<li><a target="_blank" rel="noopener" href="http://codepub.cn/2017/03/08/Programming-to-the-log4j2-API-instead-of-slf4j/">面向log4j2 API编程而不是slf4j</a></li>
<li><a target="_blank" rel="noopener" href="https://www.slf4j.org/manual.html">SLF4J 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://logging.apache.org/log4j/2.x/performance.html">Apache Log4j2 官方文档</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/12/27/%E8%BF%81%E7%A7%BB-Ghost-%E5%8D%9A%E5%AE%A2%E8%87%B3-Hexo-%E5%B9%B6%E4%BD%BF%E7%94%A8-GitHub-Pages-%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/27/%E8%BF%81%E7%A7%BB-Ghost-%E5%8D%9A%E5%AE%A2%E8%87%B3-Hexo-%E5%B9%B6%E4%BD%BF%E7%94%A8-GitHub-Pages-%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">迁移 Ghost 博客至 Hexo 并使用 GitHub Pages 部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-27 13:45:37" itemprop="dateCreated datePublished" datetime="2018-12-27T13:45:37+08:00">2018-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ops/" itemprop="url" rel="index"><span itemprop="name">Ops</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么迁移"><a href="#为什么迁移" class="headerlink" title="为什么迁移"></a>为什么迁移</h2><h3 id="Ghost"><a href="#Ghost" class="headerlink" title="Ghost"></a>Ghost</h3><p>优点：</p>
<ol>
<li>提供后台管理界面，支持在线编辑文章，随时更新随时发布。</li>
<li>图片上传方便，直接拷贝到正文即可，会自动上传到服务器并生成 Markdown 链接。</li>
<li>支持多人同时使用，可用作团队博客。</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要在服务器上部署 Ghost。</li>
<li>本地和服务器端文章同步麻烦（这也是我换用 Hexo 的主要原因）。</li>
<li>不支持离线编辑文章。虽说这个可以本地写完了再一次性拷贝到服务器上，但这又回到了第 2 点。</li>
<li>Themes 配置麻烦，不够统一。Kaldorei 主题是我废了很大劲才搜罗到的，还得每次修改完源码后压缩上传（调样式的时候调的我头疼）。</li>
</ol>
<p><img data-src="0.png" alt="dbdd8ad99f065192aa340cf474709b2d.png"><br><img data-src="1.png" alt="fa0a3c8ae59030f8e5ef80a9b04d8c7d.png"></p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>优点：</p>
<ol>
<li>文档本地化。在本地编写博客，一条指令即可生成静态网页（具体体现就是你在 <code>source/_posts</code> 下编写 Markdown，写完了执行 <code>hexo g</code> 就可以生成样式美观的 <code>index.html</code>）。</li>
<li>一条指令即可部署到 GitHub Pages，不需要额外的服务器（配合第 1 条超级好用好嘛！）。</li>
<li>丰富的插件和主题，配置也统一化了。比如图中我使用的 Next 主题，主题的配置修改 <code>theme/next/_config.yml</code>；Hexo 的配置修改主目录的 <code>_config.yml</code> 即可。</li>
<li>图片上传还算方便。在与文章同名的文件夹下保存图片即可。这个下面会细说。</li>
</ol>
<p><img data-src="2.png" alt="6bc65c0ff0fb6d62ea90ce4c35c04ac9.png"><br><img data-src="3.png" alt="8b1c5aa127adbfef220cfb30a6d55e1d.png"></p>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="创建-GitHub-Pages-仓库"><a href="#创建-GitHub-Pages-仓库" class="headerlink" title="创建 GitHub Pages 仓库"></a>创建 GitHub Pages 仓库</h3><p>GitHub Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 GitHub 上，你可以选择使用 GitHub Pages 默认提供的域名 <code>github.io</code> 或者自定义域名来发布站点。</p>
<p>GitHub Pages 分为两类，用户主页和项目主页。我们需要部署的是用户主页。需要在 GitHub 上新建一个仓库，<strong>仓库名必须为</strong> <code>$&#123;github-username&#125;.github.io</code>，这样才会被识别为用户主页。用户主页是唯一的，填其他名称只会被当成普通项目。通过 <code>https://$&#123;github-username&#125;.github.io</code> 进行访问。</p>
<p>创建完成后将仓库 clone 至本地。</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>GitHub Pages 会自动部署静态网页文件，并<strong>将 master 分支作为部署的默认分支</strong>。为将静态网页和源文件（包含文章、主题等）分离开，强烈建议创建新分支。<code>git checkout -b hexo</code> 创建 hexo 分支。<strong>应当只将 master 分支当作静态网页的发布分支，而文档编辑和 Hexo 命令操作等都在 hexo 分支上完成</strong>。这样在执行 <code>hexo generate -deploy</code> 时就会将生成的静态文件（整个 <code>public</code> 文件夹）发布到 GitHub 的 master 分支上。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  github.io git:(hexo) ✗ git branch -v    </span><br><span class="line"></span><br><span class="line">* hexo                  0d03653 dump ghost markdown files to hexo</span><br><span class="line">  master                673d037 initial commit</span><br></pre></td></tr></table></figure>

<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>Hexo 和 Ghost 一样，都是使用 Node.js 编写的，所以使用 npm 安装。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>完成后执行 <code>hexo -v</code> 验证是否正确安装。</p>
<h3 id="生成-Hexo-项目"><a href="#生成-Hexo-项目" class="headerlink" title="生成 Hexo 项目"></a>生成 Hexo 项目</h3><p>现在你可以使用 <code>hexo</code> 命令了，在生成 Hexo 项目前需要确保一件事：你已将 Git 仓库 clone 至本地，并且处于 hexo 分支上。由于只能在<strong>空文件夹</strong>下生成 Hexo 项目，所以我们先将 <code>.git</code> 文件夹整个移出去，然后执行 <code>hexo init</code> 命令。最后别忘了将 <code>.git</code> 文件夹移回来。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  github.io git:(hexo) ✗ mv .git ../</span><br><span class="line">➜  github.io ✗ hexo init </span><br><span class="line">➜  github.io ✗ mv ../.git ./</span><br></pre></td></tr></table></figure>

<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  github.io git:(hexo) ✗ ls -F         </span><br><span class="line">_admin-config.yml  node_modules/      public/            themes/</span><br><span class="line">_config.yml        package-lock.json  scaffolds/         yarn.lock</span><br><span class="line">db.json            package.json       <span class="built_in">source</span>/</span><br></pre></td></tr></table></figure>

<p>主要打交道的是下面这几个文件：</p>
<ul>
<li><code>_config.yml</code> Hexo 的配置文件，你的自定义配置会在该文件中修改</li>
<li><code>scaffolds/</code> 保存了 hexo 生成新文章所用的模版文件</li>
<li><code>source/</code> 主要保存文章的 Markdown 源文件</li>
<li><code>themes/</code> 保存主题的源代码</li>
<li><code>public/</code> 生成的静态文件，包括图片、Tags、Categories 等都保存在这里。执行 <code>hexo g</code> 生成；<code>hexo clean</code> 则会清空该文件夹。部署到 GitHub Pages 上的亦即该文件夹下的内容。</li>
</ul>
<h3 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h3><p>最开始 <code>source</code> 文件夹中会自带一篇介绍 Hexo 的文章，我们可以直接拿它来测试部署是否成功。</p>
<p>Hexo 支持本地启动，命令为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo serve</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>启动后访问 <code>http://localhost:4000</code>，就应该能看到自带的那篇文章。但为了能部署到 GitHub Pages 上，我们还需要做两件事：<strong>安装插件</strong>和<strong>修改配置</strong>。</p>
<p>在项目所在目录下执行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>修改 <code>_config.yml</code> 将 repo 指定为自己的仓库地址，发布到的分支默认为 master：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>现在，执行如下命令即可将发布文章：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo generate -deploy</span></span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>访问你的网址 <code>https://$&#123;github-username&#125;.github.io</code> 去见证成果吧！</p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>Hexo 自带的默认主题是 landscape，不过我们可以从 <a target="_blank" rel="noopener" href="https://hexo.io/themes/">Hexo主题库</a> 或 GitHub 上找到自己喜欢的主题。Next 是 Hexo 最受欢迎的主题之一，下面我将用它向大家演示如何更换主题。</p>
<p>Ps: 目前 Next 主题已经升级到 v6.0 版本以上，GitHub 上的仓库从原先的旧版本（v5.1.4 及以下）：<code>https://github.com/iissnan/hexo-theme-next</code> 迁移到了新仓库中：<code>https://github.com/theme-next/hexo-theme-next</code>，目前版本是 v6.6.0。如果安装的是 v5 版本，在启动时会提示升级。</p>
<p><strong>下载源码</strong>，直接将 Next 项目克隆到 Hexo 目录的 <code>themes</code> 文件夹下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p><strong>启用 Next 主题</strong>，修改 Hexo 的 <code>_config.yml</code></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># theme: landscape</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>v6.0 版本以上的 <a target="_blank" rel="noopener" href="https://theme-next.org/docs/getting-started/">Next官方文档</a> 也做了迁移，描述的很详细，包含了主题设置、三方服务和插件的配置等。所有要找的 <code>themes/next/_config.yml</code> 中的配置项在官方文档中都能找到。</p>
<h2 id="更换域名"><a href="#更换域名" class="headerlink" title="更换域名"></a>更换域名</h2><p>部署到 GitHub Pages 上会提供 <code>https://$&#123;github-username&#125;.github.io</code> 默认的域名以供访问。除此之外，GitHub Pages 也提供绑定自定义域名的功能。</p>
<p>首先，你需要在阿里云万网、腾讯云或者 GoDaddy 上购买域名（我选择 GoDaddy 是因为它不需要备案），然后<strong>配置域名解析</strong>。下表是我的个性域名 <code>s1mple.online</code> 的配置项。其中：</p>
<ul>
<li>CNAME 项用于将所有 <code>*.s1mple.online</code> 包含三级域名（不包括 <code>s1mple.online</code>）的访问路由到 <code>s1mplecc.github.io</code>。</li>
<li>A 项将二级域名 <code>s1mple.online</code> 路由到 <code>192.30.252.153</code>。此值可通过 <code>ping s1mplecc.github.io</code> 获得。</li>
</ul>
<table>
<thead>
<tr>
<th>记录类型</th>
<th>记录类型</th>
<th>记录值</th>
</tr>
</thead>
<tbody><tr>
<td>记录类型</td>
<td>主机记录</td>
<td>记录值</td>
</tr>
<tr>
<td>CNAME</td>
<td>*</td>
<td>s1mplecc.github.io</td>
</tr>
<tr>
<td>A</td>
<td>@</td>
<td>192.30.252.153</td>
</tr>
</tbody></table>
<p>第二步，在本地 Hexo 的 <code>source</code> 文件夹下添加<strong>名为 CNAME 的文件</strong>，内容为个人域名地址，比如我的 <code>s1mple.online</code>。并执行 <code>hexo g -d</code> 部署到服务器。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;s1mple.online&#x27;</span> &gt; ./<span class="built_in">source</span>/CNAME</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>第三步，在 GitHub Pages 项目的配置中<strong>绑定个人域名</strong>，记得将 Enforce HTTPS 选项勾选上（GitHub 提供免费的 HTTPS 服务）。保存成功后如下图提示即可通过 <code>https://s1mple.online</code> 访问。</p>
<p><img data-src="5.png" alt="5"></p>
<h2 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h2><p>当项目中只用到少量图片时，可以将图片统一放在 <code>source/images</code> 文件夹中，通过绝对路径访问。比如头像。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Markdown</span></span><br><span class="line"><span class="type">![avatar](/images/avatar.jpeg)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># themes/next/_config.yml</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpeg</span></span><br></pre></td></tr></table></figure>

<p>除此之外，图片还可以放在 <code>source/_posts</code> 下与文章同名的目录中。需要先将 Hexo 配置文件中的开关打开。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo _config.yml</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>这样在执行 <code>hexo new xxx</code> 后会在 <code>source/_posts</code> 中会生成文章 <code>xxx.md</code> 和同名文件夹 <code>xxx</code>。将图片资源放在 <code>xxx</code> 中，然后在 <code>xxx.md</code> 中使用图片的文件名引用它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure>

<h2 id="ghost-to-hexo-migrater"><a href="#ghost-to-hexo-migrater" class="headerlink" title="ghost-to-hexo-migrater"></a>ghost-to-hexo-migrater</h2><p>我自己用 Python 写了一个迁移 Ghost 博客至 Hexo 的程序，项目已经提交到 <a target="_blank" rel="noopener" href="https://github.com/s1mplecc/ghost-to-hexo-migrater">GitHub</a>。</p>
<p>主要做了如下事情：</p>
<ul>
<li>通过 Ghost API 将 Ghost 博客上的所有文章和图片下载到本地。</li>
<li>给每篇文章加上 Hexo 规定的 header，包括 Title、创建日期、Tags；由于 Ghost 博客不支持分类，所以保留 categories 默认为空。</li>
<li>按照 Hexo 的规定，创建与文章标题一致的文件夹用于存放文章中的图片，并更换文章中图片的 Markdown 链接。</li>
</ul>
<p>这样可以将整个 <code>downloads</code> 文件夹拷贝到 Hexo 的 <code>source/_posts</code> 目录下发布即可！</p>
<p><img data-src="4.png" alt="7292889b7bb90233a1ac2dd1ac2cd97a.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pages.github.com/">GitHub Pages官网</a></li>
<li><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo官网</a></li>
<li><a target="_blank" rel="noopener" href="https://theme-next.org/docs/getting-started/">Next官方文档</a> </li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5acf02086fb9a028b92d8652#heading-17">GitHub Pages部署个人博客（Hexo篇）—— 掘金</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/12/03/50%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B9%B6%E5%8F%91%E7%9A%84%20Python%20%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/03/50%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B9%B6%E5%8F%91%E7%9A%84%20Python%20%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">50 行代码实现一个并发的 Python 爬虫程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-03 13:41:09" itemprop="dateCreated datePublished" datetime="2018-12-03T13:41:09+08:00">2018-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Projects/" itemprop="url" rel="index"><span itemprop="name">Projects</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>得益于 Python 丰富的库，我们可以不用重复造轮子而是直接拿人家现成的库用，比如爬虫所需的解析 Html 功能都不用自己亲自写。所以，我在用 Python 改写之前的 Java 爬虫时，只用了 50 行代码就实现了原有功能。本文主要介绍编码时用到的库，以及总结了一些 Python 编码的知识点。</p>
<p>案例还是用的之前 <a target="_blank" rel="noopener" href="https://s2mple.xyz/2018/11/05/Java%20%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/">Java 网络爬虫</a> 的案例。所需 <code>Python Version &gt;= 3.6</code>，用到的库有：</p>
<ul>
<li><strong>beautifulsoup4</strong> 三方库用于解析 Html，执行 <code>pip install beautifulsoup4</code> 安装</li>
<li>内置的 <strong>urllib</strong> 用于发起网络请求获取响应内容</li>
<li>内置的 <strong>concurrent.futures</strong> 并发库中的 <strong>ProcessPoolExecutor</strong> 用于创建进程池</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>源码已经上传到 <a target="_blank" rel="noopener" href="https://gist.github.com/s1mplecc/dfd15f58cbbe5fad2ab13bc2246d49f4">GitHub</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">WWW_BIQUGE_CM = <span class="string">&#x27;http://www.biquge.cm&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__fetch_html</span>(<span class="params">url, decode=<span class="string">&#x27;UTF-8&#x27;</span></span>):</span></span><br><span class="line">    req = request.Request(url)</span><br><span class="line">    req.add_header(<span class="string">&#x27;User-Agent&#x27;</span>, <span class="string">&#x27;Mozilla/5.0&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> request.urlopen(req) <span class="keyword">as</span> res:</span><br><span class="line">        <span class="keyword">return</span> res.read().decode(decode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__parse_title_and_hrefs</span>(<span class="params">index</span>):</span></span><br><span class="line">    html = __fetch_html(<span class="string">f&#x27;<span class="subst">&#123;WWW_BIQUGE_CM&#125;</span>/<span class="subst">&#123;index&#125;</span>/&#x27;</span>, <span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    links = soup.find_all(<span class="string">&#x27;a&#x27;</span>, href=re.<span class="built_in">compile</span>(<span class="string">rf&#x27;/<span class="subst">&#123;index&#125;</span>/&#x27;</span>))</span><br><span class="line">    hrefs = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="string">&#x27;href&#x27;</span>], links))</span><br><span class="line">    title = soup.h1.string</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;title: <span class="subst">&#123;title&#125;</span>\nhrefs: size=<span class="subst">&#123;<span class="built_in">len</span>(hrefs)&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> title, hrefs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__fetch_content</span>(<span class="params">href</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;parsing <span class="subst">&#123;href&#125;</span>&#x27;</span>)</span><br><span class="line">    html = __fetch_html(<span class="string">f&#x27;<span class="subst">&#123;WWW_BIQUGE_CM&#125;</span>/<span class="subst">&#123;href&#125;</span>&#x27;</span>, <span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">r&#x27;&lt;div id=&quot;content&quot;&gt;|&lt;/div&gt;|&lt;br/&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="built_in">str</span>(soup.find(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;content&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__append_contents_to_file</span>(<span class="params">title, hrefs</span>):</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(<span class="number">16</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        contents = executor.<span class="built_in">map</span>(__fetch_content, hrefs)</span><br><span class="line">    os.makedirs(<span class="string">&#x27;downloads&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;./downloads/<span class="subst">&#123;title&#125;</span>.txt&#x27;</span>, <span class="string">&#x27;wt+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">            f.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">index=<span class="string">&#x27;12/12481&#x27;</span></span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    title, hrefs = __parse_title_and_hrefs(index)</span><br><span class="line">    __append_contents_to_file(title, hrefs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;spend time: <span class="subst">&#123;time.time() - start&#125;</span>s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run(<span class="string">&#x27;9/9422&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h3><p>模拟浏览器发起一个 HTTP 请求，我们需要用到 <code>urllib.request</code> 模块。其 <code>urlopen()</code> 方法用于发起请求并获取响应结果，该方法可单独传入一个 <code>urllib.request.Request</code> 对象，并返回一个 <code>http.client.HTTPResponse</code> 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__fetch_html</span>(<span class="params">url, decode=<span class="string">&#x27;UTF-8&#x27;</span></span>):</span></span><br><span class="line">    req = request.Request(url)</span><br><span class="line">    req.add_header(<span class="string">&#x27;User-Agent&#x27;</span>, <span class="string">&#x27;Mozilla/5.0&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> request.urlopen(req) <span class="keyword">as</span> res:</span><br><span class="line">        <span class="keyword">return</span> res.read().decode(decode)</span><br></pre></td></tr></table></figure>

<p>使用 <code>Request</code> 包装请求头。如果不设置 headers 中的 <strong>User-Agent</strong>，默认的 User-Agent 是 Python-urllib。可能一些网站会将该请求拦截，所以需要伪装成浏览器发起请求。</p>
<h3 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h3><blockquote>
<p>Beautiful Soup is a Python library for pulling data out of HTML and XML files. It works with your favorite parser to provide idiomatic ways of navigating, searching, and modifying the parse tree. It commonly saves programmers hours or days of work.</p>
</blockquote>
<p>Beautiful Soup 用于从 HTML 或 XML 文件中提取数据，提供的功能非常强大。它支持 Python 标准库中的 HTML 解析器：<code>BeautifulSoup(markup, &quot;html.parser&quot;)</code>，还支持一些第三方的解析器（如 html5lib、lxml 等）。</p>
<p>Beautiful Soup 将 HTML 文档转换成一个复杂的树形结构,每个节点都是 Python 对象,所有对象可以归纳为4种: <code>Tag</code>，<code>NavigableString</code>，<code>BeautifulSoup</code>，<code>Comment</code>。<code>Tag</code> 对象与 XML 或 HTML 原生文档中的 tag 相同，所以非常适合用于<strong>定位</strong>。下面列出一些常见用法，感兴趣的同学可以查阅 <a target="_blank" rel="noopener" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">官方文档</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">soup.title</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;</span></span><br><span class="line"></span><br><span class="line">soup.a</span><br><span class="line"><span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line">soup.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.find(<span class="string">&#x27;a&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;link3&#x27;</span>)</span><br><span class="line"><span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(link.get(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">    <span class="comment"># http://example.com/elsie</span></span><br><span class="line">    <span class="comment"># http://example.com/lacie</span></span><br><span class="line">    <span class="comment"># http://example.com/tillie</span></span><br></pre></td></tr></table></figure>

<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>从 Python3.2 开始 <code>concurrent.futures</code> 被纳入了标准库，这个模块中有2个类：<code>ThreadPoolExecutor</code> 和 <code>ProcessPoolExecutor</code>，分别对 <code>threading</code> 多线程库和 <code>multiprocessing</code> 多进程库的进行了高级别的抽象，封装了统一的接口。</p>
<p>关于是使用多线程还是多进程，大部分人可能有所耳闻，Python 推荐使用多进程而不是多线程。我自己测试的情况也是爬取 3000 章时使用 <code>ProcessPoolExecutor</code> 大约需要 20s，使用 <code>ThreadPoolExecutor</code> 需要大概 40s，性能差了一倍。</p>
<p>其他语言，CPU 是多核时是支持多个线程同时执行的。但在 Python 中，无论是单核还是多核，<strong>同时只能由一个线程在执行</strong>，其根源是 <strong>GIL</strong> 的存在（只存在于 CPython，PyPy 和 Jython 中没有）。</p>
<p>GIL 全称 <strong>Global Interpreter Lock</strong>(全局解释器锁)，是 Python 设计之初为了数据安全所做的决定。某个线程想要执行，必须先拿到 GIL，并且在一个 Python 进程中只有一个 GIL。并且每次释放 GIL 锁时线程会进行锁竞争，切换线程也会消耗资源。这就是为什么在多核 CPU 上 Python 的多线程效率并不高的原因所在，以至于 Python 的专家们精心制作了一个标准答案：<strong>不要使用多线程，请使用多进程</strong>。</p>
<p>此外，Python 可使用 <strong>perf</strong> 库进行性能测试，以下是爬取 50 章时的性能：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(venv) ➜  crawler ✗ python3 -m perf timeit <span class="string">&#x27;import app;app.run(&quot;12/12455&quot;)&#x27;</span></span><br><span class="line">...</span><br><span class="line">* the standard deviation (281 ms) is 24% of the mean (1.16 sec)</span><br><span class="line">* the maximum (2.02 sec) is 73% greater than the mean (1.16 sec)</span><br><span class="line"></span><br><span class="line">Mean +- std dev: 1.16 sec +- 0.28 sec</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h3><p><strong>venv</strong>，全称 <strong>virtualenv</strong> 虚拟环境。用过 JavaScript 的同学都知道，执行 <code>npm install xxx</code> 时会在当前目录生成一个 <code>node_modules</code> 目录，依赖会被安装在这个目录下，除非你加上 <code>-g/--global</code> 全局参数，否则安装的依赖只对当前项目生效（不是全局依赖）。这其实相当于做了一层隔离，将当前项目的环境与全局环境隔离开，有利于版本的管理。</p>
<p>venv 也是这样的作用，用于<strong>为一个应用创建一套隔离的 Python 运行环境</strong>。在这个环境中，你可以管理 Python 版本，pip 版本，以及你所用的三方库的版本，而不会与全局环境冲突。</p>
<p>如果你使用的是 PyCharm，那么创建项目时就可以勾选使用 venv（这也是建议的选择）。效果如下图：<br><img data-src="/0.png" alt="Screen-Shot-2018-12-03-at-11.01.47-AM">命令行多了 (venv) 前缀：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) ➜  crawler ✗</span><br></pre></td></tr></table></figure>

<p>如果你不是使用的 PyCharm，参考这篇文档：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/smilesb101/python3_x/298883">virtualenv</a></p>
<h3 id="风格规范"><a href="#风格规范" class="headerlink" title="风格规范"></a>风格规范</h3><p>Python 风格规范我参考的 <a target="_blank" rel="noopener" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#id16">Google 开源项目风格指南</a>。推荐使用 <strong>PyCharm</strong> IDE，和 IntelliJ IDEA 一样产自 JetBrains 公司，非常良心的软件，会有一些风格提示，并且可以使用快捷键（Ctrl/Cmd + Shift + L）自动格式化。这里主要说说命名吧。</p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p><strong>应该避免的名称</strong></p>
<ol>
<li>单字符名称, 除了计数器和迭代器</li>
<li>包/模块名中的连字符(-)</li>
<li>双下划线开头并结尾的名称( Python 保留, 例如<code>__init__</code>)</li>
</ol>
<p><strong>命名约定</strong></p>
<ol>
<li>用<strong>单下划线(_)开头</strong>表示模块变量或函数是 protected 的(使用 <code>from module import *</code> 时不会包含)。</li>
<li>用<strong>双下划线(__)开头</strong>的实例变量或方法表示类内私有。</li>
<li>对类名使用大写字母开头的单词(如 CapWords，即 Pascal 风格)，但是模块名应该用小写加下划线的方式(如 lower_with_under.py )。尽管已经有很多现存的模块使用类似于CapWords.py 这样的命名，但现在已经不鼓励这样做，因为如果模块名碰巧和类名一致，这会让人困扰。</li>
</ol>
<p><strong>Python之父Guido推荐的规范</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Public</th>
<th>Internal</th>
</tr>
</thead>
<tbody><tr>
<td>Modules</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr>
<td>Packages</td>
<td>lower_with_under</td>
<td></td>
</tr>
<tr>
<td>Classes</td>
<td>CapWords</td>
<td>_CapWords</td>
</tr>
<tr>
<td>Exceptions</td>
<td>CapWords</td>
<td></td>
</tr>
<tr>
<td>Functions</td>
<td>lower_with_under()</td>
<td>_lower_with_under()</td>
</tr>
<tr>
<td>Global/Class Constants</td>
<td>CAPS_WITH_UNDER</td>
<td>_CAPS_WITH_UNDER</td>
</tr>
<tr>
<td>Global/Class Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr>
<td>Instance Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under (protected) or __lower_with_under (private)</td>
</tr>
<tr>
<td>Method Names</td>
<td>lower_with_under()</td>
<td>_lower_with_under() (protected) or __lower_with_under() (private)</td>
</tr>
<tr>
<td>Function/Method Parameters</td>
<td>lower_with_under</td>
<td></td>
</tr>
<tr>
<td>Local Variables</td>
<td>lower_with_under</td>
<td></td>
</tr>
</tbody></table>
<h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><p><strong>所有的顶级代码在模块导入时都会被执行</strong>。即使是一个打算被用作脚本的文件，也应该是可导入的。并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行，这是一种副作用。主功能应该放在一个函数中，并在执行主程序前总是检查 <code>if __name__ == &#39;__main__&#39;</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p><code>__name__</code> 是内置变量，指代<strong>当前模块名</strong>，当模块被直接运行时模块名为 <code>__main__</code>。这句话的意思就是，当模块被直接运行时，下面代码块将被运行，当模块是被导入时，代码块不被运行。</p>
<h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(<span class="string">&#x27;downloads&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;./downloads/<span class="subst">&#123;title&#125;</span>.txt&#x27;</span>, <span class="string">&#x27;wt+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">        f.write(content)</span><br></pre></td></tr></table></figure>

<p>第一句用于创建 downloads 文件夹，<code>exist_ok=True</code> 参数允许创建的文件夹已存在，否则会抛出 <code>FileExistsError</code> 异常。</p>
<p>第二句 <code>with ... as ...</code> 的用法和 Java 中的 <code>try with resources</code> 有点类似，这里它会自动关闭打开的文件流。它的核心思想是 with 所求值的对象必须有一个 <code>__enter()__</code> 方法和一个 <code>__exit()__</code> 方法，在 with 代码块开始和结束这两个方法会被执行。如果出现异常则会执行 <code>__exit()__</code>，并传入三个参数 <code>exc_type</code>，<code>exc_value</code>，<code>exc_traceback</code> 用于异常处理。</p>
<p><code>open(&#39;abc.txt&#39;, &#39;a+&#39;)</code> 打开文件时不同的参数有不同的作用，我这里用的 <code>wt+</code> 表示以文本格式打开一个文件用于读写，如果该文件已存在则将其覆盖，如果该文件不存在则创建新文件。还有其他参数，例如 <code>a+</code> 代表 append 追加，<code>r</code> 表示只读等等。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.kancloud.cn/smilesb101/python3_x/295557">廖雪峰的Python3.x教程</a></li>
<li><a target="_blank" rel="noopener" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#id16">Python 风格指南 —— Google 开源项目风格指南</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2e190438bd9c">详解 python3 urllib</a></li>
<li><a target="_blank" rel="noopener" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">Beautiful Soup 4 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/concurrent.futures.html">concurrent.futures — Launching parallel tasks 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.louie.lu/2017/08/01/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-python-%E6%A8%99%E6%BA%96%E5%87%BD%E5%BC%8F%E5%BA%AB%E7%94%A8%E6%B3%95-06-concurrent-futures/">concurrent.futures 性能分析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/11/29/%E7%BB%93%E5%90%88%E6%A1%88%E4%BE%8B%E4%BD%BF%E7%94%A8%20Java%20%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/29/%E7%BB%93%E5%90%88%E6%A1%88%E4%BE%8B%E4%BD%BF%E7%94%A8%20Java%20%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">结合案例使用 Java 注解和反射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-29 04:53:50" itemprop="dateCreated datePublished" datetime="2018-11-29T04:53:50+08:00">2018-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index"><span itemprop="name">Coding</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在项目开发时遇到这样一个场景：从上游传过来一个实体类对象 <code>newEntity</code>，但它只有部分字段，需要去库中查出对应的旧对象 <code>oldEntity</code> 做一次补全（相当于一次部分更新）。</p>
<p>一开始我们这样编码的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FlightBasic <span class="title">merge</span><span class="params">(FlightBasic newEntity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newEntity.getAirportCode() != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setAirportCode(newEntity.getAirportCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newEntity.getCraftNo() != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setCraftNo(newEntity.getCraftNo());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newEntity.getCraftType() != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setCraftType(newEntity.getCraftType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// too long ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很快我们发现了问题：不仅类的字段很多，这样的 Entity 也有很多，所以到处都是又臭又长的 <code>merge</code> 方法。</p>
<p>其实不难总结这些代码的共性：</p>
<ul>
<li>一个 Entity 只能和本身的类型 Merge</li>
<li>代码都是判空后对属性的 <code>getter/setter</code> 方法的重复调用</li>
</ul>
<p>为了简化代码（偷懒），就在想能不能通过统一的处理完成这些 Merge 逻辑。首先想到的是代码生成，类似 MyBatis Generator，重复的工作交给脚本或者工具多好。但是很快就否定了这种方案，配置这些类的工作量也不小，而且很多类中有自己的业务逻辑，一不小心覆盖了也不行。那注解行不行呢？Spring Boot 就大量使用注解替换了之前配置繁杂的 XML 文件。实际编码后验证是可行的！本文将介绍如何<strong>配合使用 Java 的注解和反射</strong>实现上述问题中的 Merge 操作。示例代码已上传到 <a target="_blank" rel="noopener" href="https://github.com/s1mplecc/merging">GitHub</a> 上。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>每当你创建描述符性质的类或者接口时，一旦其中包含重复性的工作，就可以考虑使用注解来简化与自动化该过程。一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有<strong>解析</strong>它的代码，它可能连注释都不如。而解析注解往往有两种方式，一种是<strong>编译期扫描</strong>，典型的例如 <code>@Override</code>，这种只适用于编译器已经认识的注解，一般都是 JDK 内置注解；另一种则是通过<strong>运行期反射</strong>，也是在我们自定义注解后需要自己编码的。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>Java提供了四种元注解，专门负责<strong>修饰其他注解</strong>：</p>
<ul>
<li><code>@Target</code>：注解的作用目标</li>
<li><code>@Retention</code>：注解的生命周期</li>
<li><code>@Documented</code>：注解是否要包含在 JavaDoc 文档中</li>
<li><code>@Inherited</code>：子类是否继承该注解</li>
</ul>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p><code>@Target</code> 用于定义注解的<strong>作用域</strong>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>ElementType</code> 是一个枚举类型，包含以下值：</p>
<ul>
<li><code>ElementType.TYPE</code>：允许注解作用在类、接口和枚举上</li>
<li><code>ElementType.FIELD</code>：允许作用在属性字段上</li>
<li><code>ElementType.METHOD</code>：允许作用在方法上</li>
<li><code>ElementType.PARAMETER</code>：允许作用在方法参数上</li>
<li><code>ElementType.CONSTRUCTOR</code>：允许作用在构造器上</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：允许作用在本地局部变量上</li>
<li><code>ElementType.ANNOTATION_TYPE</code>：允许作用在注解上</li>
<li><code>ElementType.PACKAGE</code>：允许作用在包上</li>
</ul>
<p>当允许有多个作用域时使用花括号 <code>&#123;&#125;</code> 包裹，比如这样：<code>@Target(&#123; ElementType.TYPE, ElementType.FIELD &#125;)</code></p>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p><code>@Retention</code> 用于标明注解存在的<strong>生命周期</strong>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RetentionPolicy</code> 也是一个枚举类型，包含以下值：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>：在源文件中保留，编译为 .class 文件时会被丢弃，比如 <code>@Override</code>、<code>@SuppressWarnings</code></li>
<li><code>RetentionPolicy.CLASS</code>：.class 文件中会保留，但运行时丢弃</li>
<li><code>RetentionPolicy.RUNTIME</code>：运行时保留，可以通过<strong>反射获取</strong></li>
</ul>
<p>剩下两种类型的注解用的不多，也比较简单，这里不再详细的介绍了，只需要知道他们各自的作用即可。<code>@Documented</code> 修饰的注解，当执行 JavaDoc 文档打包时会被保存进文档，否则将被丢弃。<code>@Inherited</code> 注解修饰的注解是有<strong>继承性</strong>的，也就说我们的注解修饰了一个类，而该类的子类将自动继承父类的该注解。该注解只作用于类，对属性或方法无效。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Java 反射机制是指在<strong>程序运行时（Runtime）识别和使用对象的类型信息</strong>。以下内容摘自《Thinking in Java》，是我认为的有利于理解反射的核心概念。</p>
<blockquote>
<p>要理解反射的工作原理，首先必须知道<strong>类型信息</strong>在运行时是如何表示的。这项工作是由称为 <strong>Class</strong> 对象的特殊对象完成的，它包含了与类有关的信息。事实上，Class 对象就是用来创建类的所有“常规”对象的。</p>
<p>类是程序的一部分，每个类都有一个 Class 对象。换言之，每当编写并且编译了一个新类，就会产生一个 Class 对象（更恰当地说，是被保存在一个同名的 <code>.class</code> 文中）。为了生成这个类的对象，运行这个程序的 Java 虚拟机（JVM）将使用被称为<strong>类加载器</strong>的子系统。类加载器首先检查这个类的 Class 对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找 <code>.class</code> 文件。<strong>一旦某个类的 Class 对象被载入内存，它就被用来创建这个类的所有对象</strong>。</p>
<p><code>Class</code> 类和 <code>java.lang.reflect</code> 类库一起对反射的概念提供了支持，该类库包含 <code>Field</code>、<code>Method</code> 以及 <code>Constructor</code> 类。这些类型的对象是由 JVM 在运行时创建的，用以<strong>表示未知类里对应的成员</strong>。这样你就可以使用 <code>Constructor</code> 创建新的对象，用 <code>get()</code> 和 <code>set()</code> 方法读取和修改与 <code>Field</code> 对象关联的字段，用 <code>invoke()</code> 方法调用与 <code>Method</code> 对象关联的方法等等。另外，还可以调用 <code>getFields()</code>、<code>getMethods()</code> 和 <code>getConstructors()</code> 等方法以返回表示字段、方法以及构造器的对象的数组（可以查看 Class 类源码了解更多资料）。</p>
<p>重要的是，要认识到反射机制并没有什么神奇之处。当通过反射与一个未知类型的对象打交道时，JVM 只是简单地检查这个对象，看它属于哪个特定的类。在用它做其他事情之前必须先加在那个类的 Class 对象。对于反射机制来说，<code>.class</code> 文件在编译时是不可获取的，所以是在运行时打开和检查 <code>.class</code> 文件。</p>
</blockquote>
<p>这里简单的介绍一下我们编码时用到的与反射有关的方法：</p>
<ul>
<li><code>obj.getClass();</code> Java 提供了三种方式获取类的 Class 对象的引用：<code>Class.forName()</code> 通过类名获取；<code>obj.getClass();</code> 通过对象获取和 <code>Object.class</code> 通过类字面常量获取。</li>
<li><code>getDeclaredFields();</code> 获取类中声明的所有字段，不包括父类和接口中的字段。它与 <code>getFields()</code> 的区别在于，<code>getFields()</code> 是获取所在类以及父类和接口中的所有访问修饰符为 <code>public</code> 的字段。</li>
<li><code>getAnnotation();</code> 获取标注的注解实例对象。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Merge-粒度与等级"><a href="#Merge-粒度与等级" class="headerlink" title="Merge 粒度与等级"></a>Merge 粒度与等级</h3><p>回到我们的问题上来，首先考虑一个问题：Merge 的粒度应该位于什么层次？如果是类级别的，意味着整个类的所有属性将一视同仁，要么都合并要么都不，显然这样是不行的。Merge 的<strong>粒度应该在属性字段上</strong>，为此，我们专门定义了字段的 Merge 等级 <code>Level</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Level</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 无论新值为何值，都会覆盖旧值 */</span></span><br><span class="line">    Mandatory,</span><br><span class="line">    <span class="comment">/* 如果新值不为null，覆盖旧值，否则不覆盖 */</span></span><br><span class="line">    Required,</span><br><span class="line">    <span class="comment">/* 忽略，不做合并处理 */</span></span><br><span class="line">    Ignored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义注解-MergeOn"><a href="#自定义注解-MergeOn" class="headerlink" title="自定义注解 @MergeOn"></a>自定义注解 @MergeOn</h3><p>接下来就需要自定义我们的注解：<code>@MergeOn</code>，作用在字段上，在运行时有效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MergeOn &#123;</span><br><span class="line">    <span class="function">Level <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> Level.Required</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>default</code> 关键字可以设置缺省等级为 <code>Required</code>。</p>
<h3 id="通过反射将字段设值"><a href="#通过反射将字段设值" class="headerlink" title="通过反射将字段设值"></a>通过反射将字段设值</h3><p>现在，还差最后一步，就是如何通过反射将字段设值。要想让实体类实现 Merge，首先需要定义一个接口 <code>Merging</code> 让实体类去继承它，然后接口中得有一个默认方法 <code>mergeWith(T newEntity)</code>，它将做下面这几件事：</p>
<ul>
<li>通过反射获取 Entity 声明的所有字段</li>
<li>通过反射获取字段上 <code>@MergeOn</code> 注解的 Level</li>
<li>通过 Level 走不同的分支去给字段设值，是强制或是忽略亦或是只有非空情况下才设值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Merging</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Merging</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">mergeWith</span><span class="params">(T newEntity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getClass() != newEntity.getClass()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MergeWithDifferentClassTypeException(</span><br><span class="line">                    String.format(<span class="string">&quot;&lt;%s&gt; can not merge with other class type &lt;%s&gt;&quot;</span>, <span class="keyword">this</span>.getClass().getName(), newEntity.getClass().getName()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field[] fields = <span class="keyword">this</span>.getClass().getDeclaredFields(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            MergeOn mergeOn = field.getAnnotation(MergeOn.class); <span class="comment">// 2</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mergeOn == <span class="keyword">null</span> || mergeOn.level().isRequired()) &#123; <span class="comment">// 4...</span></span><br><span class="line">                    Object newFieldValue = field.get(newEntity);</span><br><span class="line">                    <span class="keyword">if</span> (newFieldValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        field.set(<span class="keyword">this</span>, newFieldValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mergeOn.level().isMandatory()) &#123; <span class="comment">// 4...</span></span><br><span class="line">                    field.set(<span class="keyword">this</span>, field.get(newEntity)); <span class="comment">// 5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MergeOnFieldIllegalAccessException(field.getName(), ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看代码具体的实现步骤（注释中标明了顺序）：</p>
<ol>
<li><code>this.getClass().getDeclaredFields();</code> 获取类中声明的所有字段，不包含父类和接口中的字段。<code>this</code> 指向的是实现接口的实体类。</li>
<li><code>field.getAnnotation(MergeOn.class);</code> 获取字段上的 <code>@MergeOn</code> 注解实例。</li>
<li><code>field.setAccessible(true);</code> 由于字段通常是 <code>private</code> 修饰的，就需要<strong>获取访问权</strong>（并不是修改实际权限），否则将抛出 <code>IllegalAccessException</code> 异常。由此可见，反射有可能破环封装性。</li>
<li>根据 Level 做相应设值。如果无注解或 Level 为 Required，则新值非空时覆盖旧值；如果是强制（Mandatory）则始终覆盖；否则（Ignored），忽略不做处理。</li>
<li><code>field.set(this, field.get(newEntity));</code> 字段设值的实际操作，接口设计看上去有点反人类。第一个参数为需要设置字段的对象，此处为 oldEntity，第二个参数为要设置的值，此处为新对象的字段值。</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>接下来我将演示如何使用这个接口，并编写单元测试验证其正确性。</p>
<p>首先定义实体类 Entity。</p>
<ul>
<li>为了测试全面性，加入了各种类型的属性字段，包括基础类型、集合、数组和类；同时，<code>@MergeOn</code> 注解覆盖了所有 Level，还包括缺省和无注解的情况。</li>
<li>为了简单，直接在字段声明时赋初值。即 <code>new Entity()</code> 出来的可以看成旧的模型对象（oldEntity）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entity</span> <span class="keyword">implements</span> <span class="title">Merging</span>&lt;<span class="title">Entity</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@MergeOn(level = Level.Ignored)</span></span><br><span class="line">    <span class="keyword">private</span> String string = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    <span class="meta">@MergeOn</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> anInt = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@MergeOn(level = Level.Mandatory)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; stringList = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="meta">@MergeOn(level = Level.Required)</span></span><br><span class="line">    <span class="keyword">private</span> String[] strings = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;sArr1&quot;</span>, <span class="string">&quot;sArr2&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Email email = <span class="keyword">new</span> Email(<span class="string">&quot;zz@163.com&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Email&gt; emails = Sets.newLinkedHashSet(<span class="keyword">new</span> Email(<span class="string">&quot;zz@163.com&quot;</span>), <span class="keyword">new</span> Email(<span class="string">&quot;zz@gmail.com&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Email</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理想情况下，<code>string</code> 字段新值应当被忽略；<code>stringList</code> 在新值为 null 时也会被强制覆盖；其他缺省和无注解的应当行为与 <code>@MergeOn(level = Level.Required)</code> 一致，即非空时才会覆盖旧值。以下为测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_merge_new_entity_with_different_merge_level</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity newEntity = <span class="keyword">new</span> Entity();</span><br><span class="line">    newEntity.setString(<span class="string">&quot;newString&quot;</span>);  <span class="comment">// Ignored</span></span><br><span class="line">    newEntity.setAnInt(<span class="number">2</span>);</span><br><span class="line">    newEntity.setStringList(<span class="keyword">null</span>);  <span class="comment">// Mandatory</span></span><br><span class="line">    newEntity.setStrings(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;newS1&quot;</span>, <span class="string">&quot;newS2&quot;</span>, <span class="string">&quot;newS3&quot;</span>&#125;);</span><br><span class="line">    newEntity.setEmail(<span class="keyword">new</span> Entity.Email(<span class="string">&quot;newEmail@163.com&quot;</span>));</span><br><span class="line">    newEntity.setEmails(<span class="keyword">null</span>); <span class="comment">// Required, wished not be overwrited</span></span><br><span class="line"></span><br><span class="line">    Entity entity = <span class="keyword">new</span> Entity(); <span class="comment">// oldEntity</span></span><br><span class="line">    entity.mergeWith(newEntity);</span><br><span class="line"></span><br><span class="line">    assertThat(entity.getString()).isEqualTo(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">    assertThat(entity.getAnInt()).isEqualTo(<span class="number">2</span>);</span><br><span class="line">    assertThat(entity.getStringList()).isNull();</span><br><span class="line">    assertThat(entity.getStrings()).containsSequence(<span class="string">&quot;newS1&quot;</span>, <span class="string">&quot;newS2&quot;</span>, <span class="string">&quot;newS3&quot;</span>);</span><br><span class="line">    assertThat(entity.getEmail().getValue()).isEqualTo(<span class="string">&quot;newEmail@163.com&quot;</span>);</span><br><span class="line">    assertThat(entity.getEmails()).hasSize(<span class="number">2</span>);</span><br><span class="line">    assertThat(entity.getEmails()).contains(<span class="keyword">new</span> Entity.Email(<span class="string">&quot;zz@163.com&quot;</span>));</span><br><span class="line">    assertThat(entity.getEmails()).contains(<span class="keyword">new</span> Entity.Email(<span class="string">&quot;zz@gmail.com&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b45bd715188251b3a1db54f">JAVA 注解的基本原理 —— 掘金</a></li>
<li>Thinking in Java 第14章：类型信息</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="s1mple"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">s1mple</p>
  <div class="site-description" itemprop="description">春光恰与少年同，十里清风慕天青</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/s1mplecc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;s1mplecc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:s1mple951205@gmail.com" title="E-Mail → mailto:s1mple951205@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">s1mple</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 33231,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
