<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"s1mplecc.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="春光恰与少年同，十里清风慕天青">
<meta property="og:type" content="website">
<meta property="og:title" content="芥子屋">
<meta property="og:url" content="https://s1mplecc.github.io/page/2/index.html">
<meta property="og:site_name" content="芥子屋">
<meta property="og:description" content="春光恰与少年同，十里清风慕天青">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="s1mple">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://s1mplecc.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>芥子屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">芥子屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/s1mplecc" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/04/26/Python-%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/Python-%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6/" class="post-title-link" itemprop="url">Python 属性、特性和描述符</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-26 11:18:39" itemprop="dateCreated datePublished" datetime="2021-04-26T11:18:39+08:00">2021-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><p>在 Python 中，数据属性和处理数据的方法统称为属性（attribute），方法也可称为方法属性，本质上是可调用的（callable）属性。Python 提供了丰富的 API 用于控制访问属性，以及实现动态属性。即使访问不存在的属性，也可以通过特殊方法实现“虚拟属性”，从而即时计算属性的值。</p>
<h3 id="处理属性的特殊属性"><a href="#处理属性的特殊属性" class="headerlink" title="处理属性的特殊属性"></a>处理属性的特殊属性</h3><p>为了方便处理属性，Python 定义了一些特殊属性，包括：</p>
<ul>
<li><code>__class__</code>：对象所属类的引用。<code>obj.__class__</code> 与 <code>type(obj)</code> 效果一致。类和类的实例都具有属性，有些属性只能在类中查询，比如特殊方法；</li>
<li><code>__dict__</code>：存储类或实例的可写属性的字典。如果设置了 <code>__slots__</code> 属性，实例可能没有 <code>__dict__</code> 属性；</li>
<li><code>__slots__</code>：类可以定义这个属性，限制实例能拥有哪些属性。该属性的值可以是个可迭代对象，但通常会使用元组。如果类设置了 <code>__slots__</code> 属性且 <code>__slots__</code> 中不包含 <code>&#39;__dict__&#39;</code>，那么该类的实例没有 <code>__dict__</code> 属性。</li>
</ul>
<h4 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a><code>__dict__</code></h4><p>默认情况下，Python 会使用名为 <code>__dict__</code> 的字典存储类和实例中的可写属性。其中，<strong>类属性字典</strong>由名为 <code>mappingproxy</code> 的代理对象包装，<code>mappingproxy</code> 定义在 <code>collections.abc</code> 模块中，特别指代类属性字典的类型：<code>mappingproxy = type(type.__dict__)</code>。类属性字典包含显式定义在类中的字段和方法，以及一些可写的特殊属性，包括模块、字典、弱引用和文档字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.b = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, </span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function Foo.__init__ at <span class="number">0x1051fe8b0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;Foo&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;Foo&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>类属性不仅限于类字典中所展示的，还包含一些不可变的类属性，比如所属类的引用 <code>__class__</code>，直接父类组成的元组 <code>__bases__</code> 等。</p>
<p><strong>实例属性字典</strong>则是普通的字典类型，为实例属性赋值，会动态的修改实例字典。如果属性不存在，则将其添加到字典中，包括在初始化方法 <code>__init__</code> 中赋值的实例属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.c = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h4><p>Python 解释器会默认在类的构造方法 <code>__new__</code> 中创建 <code>__dict__</code> 存放实例属性，在访问时通过访问实例字典读取属性值。由于字典底层使用了散列表结构，对属性的存取会相当迅速。但同时，为了减少散列冲突，散列表的大小通常要远大于键的数量，这种基于空间换时间的考量会导致字典会消耗大量内存。为此，Python 提供了 <code>__slots__</code> 属性，该属性会覆盖 <code>__dict__</code> 属性，<strong>使用类似元组的结构存储实例变量</strong>，从而达到节省内存的目的。</p>
<p>我沿用之前定义的 Person 类做了测试，它包含 name 和 age 两个实例属性。使用列表推导生成一百万个 Person 对象，分别对默认使用 <code>__dict__</code> 和添加了 <code>__slots__</code> 属性的内存占用情况进行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ time python3 slots.py --use-dict </span><br><span class="line">Initial RAM Usage:    5,472,256</span><br><span class="line">  Final RAM Usage:  186,380,288</span><br><span class="line">python3 slots.py --use-dict  1.11s user 0.07s system 99% cpu 1.187 total</span><br><span class="line">➜ time python3 slots.py --use-slots</span><br><span class="line">Initial RAM Usage:    5,476,352</span><br><span class="line">  Final RAM Usage:   76,369,920</span><br><span class="line">python3 slots.py --use-slots  0.74s user 0.04s system 99% cpu 0.788 total</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>__slots__</code> 后内存占用得到显著优化，只占了使用 <code>__dict__</code> 的一半不到，运行速度也更快。</p>
<p><strong>定义 <code>__slots__</code> 的方式</strong>是，创建一个名为 <code>__slots__</code> 的类属性，把它的值设为一个字符串构成的可迭代对象（通常使用元组），其中的元素名称代表实例属性，比如<code>__slots__ = (&#39;name&#39;, &#39;age&#39;)</code>。定义 <code>__slots__</code> 属性相当于告诉解释器：这个类的所有实例属性都在这儿了。<strong>实例不能再有 <code>__slots__</code> 所列之外的其他属性</strong>。但应该明白，<code>__slots__</code> 并不是用来禁止类的用户新增实例属性的手段，而只是一种内存优化方案。</p>
<p>如果你阅读 <code>collections.abc</code> 模块的源码，会发现其中的类都存在一行 <code>__slots__ = ()</code> 代码。即使这些类没有实例属性，使用空元组定义的 <code>__slots__</code> 属性可以避免类的构造方法创建 <code>__dict__</code> 空字典，空字典也会在堆上分配内存空间。对于集合这种基本数据类型，有必要为其声明空元组形式的 <code>__slots__</code> 属性。此外，对于模式固定的数据库记录，以及特大型数据集，也有必要声明 <code>__slots__</code> 属性。</p>
<p>上面介绍的这些特殊属性，在一些访问和处理属性的内置函数和特殊方法中会被使用。下面列出这些函数和方法。</p>
<h3 id="处理属性的内置函数"><a href="#处理属性的内置函数" class="headerlink" title="处理属性的内置函数"></a>处理属性的内置函数</h3><p><code>dir([object])</code>：列出对象的大多数属性。object 参数是可选的，缺省时会列出当前模块的属性。dir 函数能够审查对象有没有 <code>__dict__</code> 和 <code>__slots__</code> 属性，并列出其中的键。</p>
<p><code>getattr(object, name[, default])</code>：从对象中读取属性值。获取的属性可能来自对象所属的类或超类。如果没有找到指定属性，则抛出 AttributeError 异常，或返回预设默认值。</p>
<p><code>hasattr(object, name)</code>：会调用 getattr 函数查看能否获取指定的属性，当抛出 AttributeError 异常时返回 False。</p>
<p><code>setattr(object, name, value)</code>：为对象指定的属性设值。这个函数可能会创建一个新属性，或者覆盖现有的属性。前提是对象能够接受这个值，比如设定了 <code>__slots__</code> 的对象不能添加新属性。</p>
<p><code>vars([object])</code>：返回对象的 <code>__dict__</code> 属性，参数缺省时返回当前模块的 <code>__dict__</code> 属性。vars 函数不能处理设定了 <code>__slots__</code> 属性的对象。</p>
<h3 id="处理属性的特殊方法"><a href="#处理属性的特殊方法" class="headerlink" title="处理属性的特殊方法"></a>处理属性的特殊方法</h3><p><code>__getattribute__(self, name)</code>：除了访问特殊属性和特殊方法，尝试获取指定的属性时总会调用这个方法。dot 运算符、<code>getattr</code> 和 <code>hasattr</code> 会调用这个方法。该方法内部定义了属性访问规则，当未找到指定属性时抛出 AttributeError 异常，<code>__getattr__</code> 方法会被调用。</p>
<p><code>__getattr__(self, name)</code>：仅当获取指定属性失败时，即处理不存在的属性时被调用。用户自定义的类可以实现 <code>__getattr__</code> 方法从而动态计算属性的值。</p>
<p><code>__setattr__(self, name, value)</code>：尝试为指定属性设值时总会调用该方法。dot 运算符和 <code>setattr</code> 会调用这个方法。该方法内部定义了属性设值规则。</p>
<p><code>__delattr__(self, name)</code>：使用 del 关键字删除属性时会调用这个方法。</p>
<p><code>__dir__(self)</code>：内置函数 <code>dir()</code> 会调用这个方法。</p>
<h3 id="属性访问规则"><a href="#属性访问规则" class="headerlink" title="属性访问规则"></a>属性访问规则</h3><p>Python 解释器在访问属性时会按照一定的规则，从入口方法 <code>__getattribute__</code> 开始，按照顺序依次查找，如果找到则返回，未找到则抛出异常，调用 <code>__getattr__</code> 动态计算虚拟属性。属性访问规则如下：</p>
<ol>
<li><code>__getattribute__</code> 方法</li>
<li>数据描述符</li>
<li>实例对象的字典</li>
<li>类的字典</li>
<li>非数据描述符</li>
<li>父类的字典</li>
<li><code>__getattr__</code> 方法</li>
</ol>
<p>注：其中，数据描述符是实现了 <code>__get__</code> 和 <code>__set__</code> 描述符协议的类。描述符的内容，会在后面做详细介绍。</p>
<p>查询属性的入口方法 <code>__getattribute__</code> 实现逻辑的伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">name</span>)：</span></span><br><span class="line"><span class="function">    # 先在类(<span class="params">包括父类、祖先类</span>)字典中查找数据描述符</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">find</span> <span class="title">data</span> <span class="title">descriptor</span> <span class="title">in</span> <span class="title">class</span> <span class="title">and</span> <span class="title">base</span> <span class="title">class</span> <span class="title">__dict__</span>:</span></span><br><span class="line">        <span class="comment"># 如果是数据描述符，则调用该数据描述符的 __get__ 方法并将结果返回</span></span><br><span class="line">        <span class="keyword">return</span> descriptor.__get__(instance, instance.__class__)</span><br><span class="line">    <span class="comment"># 如果不是数据描述符，继续查询实例字典</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> instance.__dict__:</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[name]</span><br><span class="line">    <span class="comment"># 实例字典中没有，则继续查询类字典</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> instance.__class__.__dict__:</span><br><span class="line">        <span class="keyword">return</span> instance.__class__.__dict__[name]</span><br><span class="line">    <span class="comment"># 在类和父类字典中查询非数据描述符</span></span><br><span class="line">    <span class="keyword">if</span> find non-data descriptor <span class="keyword">in</span> <span class="class"><span class="keyword">class</span> <span class="title">and</span> <span class="title">base</span> <span class="title">class</span> <span class="title">__dict__</span>:</span></span><br><span class="line">        <span class="comment"># 如果找到，返回描述符实例</span></span><br><span class="line">        <span class="keyword">return</span> descriptor.instance</span><br><span class="line">    <span class="comment"># 如果不是描述符，继续在父类字典中查找</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> baseclass __dict__:</span><br><span class="line">        <span class="keyword">return</span> baseclass.__dict__[name]</span><br><span class="line">    <span class="comment"># 如果依然没有找到，抛出异常，__getattr__ 函数会被调用</span></span><br><span class="line">    <span class="keyword">raise</span> AttributeError</span><br></pre></td></tr></table></figure>

<p>为实例属性赋值则没有这么麻烦，<code>__setattr__</code> 作为入口方法，只需要判断属性是否是数据描述符，如果是则调用其 <code>__set__</code> 方法，如果不是则为实例字典添加新的属性。<code>__setattr__</code> 实现逻辑的伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__setattr__(name, value):</span><br><span class="line">    <span class="comment"># 先在类(包括父类、祖先类)字典中查找描述符</span></span><br><span class="line">    <span class="keyword">if</span> find data descriptor <span class="keyword">in</span> <span class="class"><span class="keyword">class</span> <span class="title">and</span> <span class="title">base</span> <span class="title">class</span> <span class="title">__dict__</span>:</span></span><br><span class="line">        <span class="comment"># 如果是数据描述符，则调用描述符的 __set__ 方法进行设值</span></span><br><span class="line">        descriptor.__set__(instance, value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 否则，为实例属性字典添加新值</span></span><br><span class="line">        instance.__dict__[name] = value</span><br></pre></td></tr></table></figure>

<p>由此也可以发现，Python 存取属性的方式特别不对等。通过实例访问属性时，如果实例中没有指定属性，那么会尝试获取类属性。而为实例中的属性赋值时，如果属性不存在会在实例中创建该属性，根本不影响类。</p>
<p>下面介绍如何使用 <code>__getattr__</code> 方法动态计算虚拟属性。</p>
<h3 id="自定义-getattr-即时计算属性"><a href="#自定义-getattr-即时计算属性" class="headerlink" title="自定义 __getattr__ 即时计算属性"></a>自定义 <code>__getattr__</code> 即时计算属性</h3><p>处理 JSON 是非常常见的需求，JavaScript 对 JSON 具有天生的支持，可以使用 dot 运算符链式获取属性的值，如 <code>res.cities[0].ext.province</code>。而 Python 原生的字典不支持使用 dot 运算符直接获取属性，只能使用 <code>res[&#39;cities&#39;][0][&#39;ext&#39;][&#39;province&#39;]</code> 的形式，会显得格外冗长。但可以通过实现一个近似字典的类，达到同样的效果。如下是 Python 中的效果演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> json_parser <span class="keyword">import</span> JsonParser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json = &#123;</span><br><span class="line"><span class="meta">... </span>  <span class="string">&quot;code&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line"><span class="meta">... </span>  <span class="string">&quot;cities&quot;</span>: [</span><br><span class="line"><span class="meta">... </span>    &#123;</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;lat&quot;</span>: <span class="string">&quot;41.2334465&quot;</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;lng&quot;</span>: <span class="string">&quot;116.9772857&quot;</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;citycode&quot;</span>: <span class="number">207</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;ext&quot;</span>: &#123;</span><br><span class="line"><span class="meta">... </span>        <span class="string">&quot;province&quot;</span>: <span class="string">&quot;河北省&quot;</span>,</span><br><span class="line"><span class="meta">... </span>        <span class="string">&quot;city&quot;</span>: <span class="string">&quot;承德市&quot;</span></span><br><span class="line"><span class="meta">... </span>      &#125;</span><br><span class="line"><span class="meta">... </span>    &#125; </span><br><span class="line"><span class="meta">... </span>  ]</span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = JsonParser(json)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.code</span><br><span class="line"><span class="string">&#x27;200&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.cities[<span class="number">0</span>].citycode</span><br><span class="line"><span class="number">207</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.cities[<span class="number">0</span>].ext.province</span><br><span class="line"><span class="string">&#x27;河北省&#x27;</span></span><br></pre></td></tr></table></figure>

<p>能够使用 dot 运算符链式获取属性的关键在于定义在 JsonParser 中的 <code>__getattr__</code> 方法。前面已经说过，Python 解释器在查询对象属性失败时会调用 <code>__getattr__</code> 方法动态计算属性。下面代码定义了动态计算的逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonParser</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, arg</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(arg, Mapping):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(arg, MutableSequence):</span><br><span class="line">            <span class="keyword">return</span> [cls(i) <span class="keyword">for</span> i <span class="keyword">in</span> arg]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self._data = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> JsonParser(self._data[name])</span><br></pre></td></tr></table></figure>

<p>通过 <code>__getattr__</code> 方法递归地创建 JsonParser 类，并将下级的 JSON 结构  <code>_data[name]</code> 作为构造参数传入。构造方法 <code>__new__</code> 会判断传入参数的类型，如果是映射类型直接创建 JsonParser 对象，如果是可变序列，则通过列表推导式返回 JsonParser 列表。之所以要这么处理是因为 JSON 结构可能是数组，除了映射结构还需要对数组类型进行解析，以支持 <code>cities[0]</code> 式的访问。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>在 Java 中，为了控制属性的访问权限，一般会将属性设置为私有属性，并为可以公开的属性设置公有的 getter 和 setter 方法。这样做还有一个好处，可以在方法内添加对属性的验证，比如保证商品的数量不会是负数。如果想更进一步，可以按照领域驱动设计的理念，可以将属性设置为实体类 Entity，在类中对属性进行校验。这两种思想在 Python 中也都有对应的实现，前一种对应于特性，后一种对应于描述符。</p>
<p>特性经常用于把公开的属性变成使用读值方法和设置方法管理的属性，且在不影响客户端代码的前提下实施业务规则。使用 <code>get/set + 属性名</code> 的命名方式不符合 Python 一贯的简约作风，为此 Python 提供了特性，即 property。property 是一个类形式的函数装饰器，本质上它是一个<strong>描述符类</strong>（实现了描述符协议）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">property</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        fget: <span class="type">Optional</span>[<span class="type">Callable</span>[[<span class="type">Any</span>], <span class="type">Any</span>]] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">        fset: <span class="type">Optional</span>[<span class="type">Callable</span>[[<span class="type">Any</span>, <span class="type">Any</span>], <span class="literal">None</span>]] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">        fdel: <span class="type">Optional</span>[<span class="type">Callable</span>[[<span class="type">Any</span>], <span class="literal">None</span>]] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">        doc: <span class="type">Optional</span>[<span class="built_in">str</span>] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span>(<span class="params">self, fget: <span class="type">Callable</span>[[<span class="type">Any</span>], <span class="type">Any</span>]</span>) -&gt; <span class="built_in">property</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span>(<span class="params">self, fset: <span class="type">Callable</span>[[<span class="type">Any</span>, <span class="type">Any</span>], <span class="literal">None</span>]</span>) -&gt; <span class="built_in">property</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleter</span>(<span class="params">self, fdel: <span class="type">Callable</span>[[<span class="type">Any</span>], <span class="literal">None</span>]</span>) -&gt; <span class="built_in">property</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj: <span class="type">Any</span>, <span class="built_in">type</span>: <span class="type">Optional</span>[<span class="built_in">type</span>] = ...</span>) -&gt; <span class="type">Any</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, obj: <span class="type">Any</span>, value: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, obj: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fget</span>(<span class="params">self</span>) -&gt; <span class="type">Any</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fset</span>(<span class="params">self, value: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fdel</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br></pre></td></tr></table></figure>

<p>使用函数形式的装饰器会返回一个嵌套的高阶函数，类形式的装饰器也类似，使用 <code>@property</code> 装饰的方法会被包装成特性类。特性类具有 getter、setter 和 deleter 方法属性，这三个属性也都返回 property 对象。</p>
<p>因此，用 <code>@property</code> 装饰的读值方法，如下的 <code>amount(self)</code> 方法，相当于返回一个 <code>property(amount)</code> 特性对象，将读值方法作为初始化参数 fget 传入。而后可以使用 <code>@amount.setter</code> 装饰设值方法，此时设值方法 amount 返回的是特性对象，setter 是它的方法属性。相当于 <code>property(amount).setter(amount)</code>，第二个 amount 是设值方法，将设值方法作为 fset 参数传入 setter 方法。也因此，<code>@amount.setter</code> 必须要定义在被 <code>@property</code> 装饰的设置方法之后。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, price, amount</span>):</span></span><br><span class="line">        self.price = price</span><br><span class="line">        self.amount = amount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.amount</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">amount</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._amount</span><br><span class="line"></span><br><span class="line"><span class="meta">    @amount.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">amount</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> value &gt;= <span class="number">0</span>:</span><br><span class="line">            self._amount = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;item amount must &gt;= 0&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>读值方法可以不与实例属性名一致，但要保证，读值方法名称、设值方法名称和 <code>@amount.setter</code> 装饰器中的名称三者保持一致，即都为 amount。这样，在访问属性时可以通过 <code>item.amount</code> 的形式对真正的实例属性 <code>self._amount</code> 进行读值和赋值。其实，初始化函数中的 <code>self.amount = amount</code> 语句就已经在使用特性的设置方法了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;_amount&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.total_price()</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.total_price()</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount = -<span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: item amount must &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到，真正被操作的实例属性 <code>_amount</code> 被保存在实例字典中。</p>
<p>任何对 <code>item.amount</code> 的读值和设值操作，都会经过由特性包装的读值和设值方法进行处理。由于在设值方法中对属性值做了非负验证，所以将其设置为负值会抛出 ValueError 异常。</p>
<p>需要注意的是，特性是类属性，被保存于类的 <code>__dict__</code> 字典中。在使用 <code>obj.attr</code> 这样的表达式时，不会从 obj 开始查询 attr 属性，而是从实例所属的类，即 <code>obj.__class__</code> 开始，仅当类中没有名为 attr 的特性时，才会去查询实例字典。也就是说，<strong>特性的读值和设值方法要优先于实例字典</strong>，只有直接存取 <code>__dict__</code> 属性才能跳过特性的处理逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;attribute&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function LineItem.__init__ at <span class="number">0x105459a60</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;total_price&#x27;</span>: &lt;function LineItem.total_price at <span class="number">0x105459af0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;amount&#x27;</span>: &lt;<span class="built_in">property</span> <span class="built_in">object</span> at <span class="number">0x105487680</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;_amount&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__[<span class="string">&#x27;_amount&#x27;</span>] = -<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这条规则不仅适用于特性，还适用于数据描述符，其实，特性也是数据描述符。或者换句话说，正是由于数据描述符的访问优先级要高于实例字典，特性的读值和设值方法访问才优先于实例字典。下面我们介绍描述符。</p>
<h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><p>描述符是 Python 的独有特征，不仅在应用层，内置库和标准库中也有使用。除了特性之外，使用描述符的还有方法、classmethod 和 staticmethod 装饰器，以及 functools 模块中的诸多类。理解描述符是精通 Python 的关键，本章的话题就是描述符。</p>
<p><strong>描述符是实现了特定协议的类</strong>，这个协议包括 <code>__get__</code>、<code>__set__</code> 和 <code>__delete__</code> 方法。特性类 property 实现了完整的描述符协议。通常，可以只实现部分协议。其实，我们在真实代码中见到的大多数描述符只实现了 <code>__get__</code> 和 <code>__set__</code> 方法，还有很多只实现了其中的一个。</p>
<h3 id="定制描述符实现属性验证"><a href="#定制描述符实现属性验证" class="headerlink" title="定制描述符实现属性验证"></a>定制描述符实现属性验证</h3><p><strong>描述符是对多个属性运用相同存取逻辑的一种方式</strong>。假设我们想为之前定义的 LineItem 类中的 price 和 amount 属性都设置非负验证，一种方式是为它们都编写读值和设值方法，但这会造成代码重复。为了避免这个问题，Python 提出了一种面向对象的解决方式，那就是定制描述符类。</p>
<p>在下面的代码中，定义了一个名为 Quantity 的描述符类，用于管理 LineItem 的属性。我们将 LineItem 类称为托管类，被管理的属性称为托管属性。Quantity 类的实例属性 attribute 指代托管属性的名称，由初始化方法传入。通过在托管类中声明类属性的形式，如 <code>price = Quantity(&#39;price&#39;)</code> 将描述符实例绑定给 price 属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, attribute</span>):</span></span><br><span class="line">        self.attribute = attribute</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> value &gt;= <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.attribute] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;<span class="subst">&#123;self.attribute&#125;</span> must &gt;= 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    price = Quantity(<span class="string">&#x27;price&#x27;</span>)</span><br><span class="line">    amount = Quantity(<span class="string">&#x27;amount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, price, amount</span>):</span></span><br><span class="line">        self.price = price</span><br><span class="line">        self.amount = amount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.amount</span><br></pre></td></tr></table></figure>

<p>描述符类中定义了 <code>__set__</code> 方法，当尝试为托管属性赋值时，会调用这个方法并对值做验证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;amount&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount = -<span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: amount must &gt;= <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.price = -<span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: price must &gt;= <span class="number">0</span>                            </span><br></pre></td></tr></table></figure>

<p><strong><code>__set__</code> 方法的签名</strong>：<code>def __set__(self, instance, value) -&gt; None: ...</code>。第一个参数 self 是<strong>描述符实例</strong>，即 <code>LineItem.price</code> 或 <code>LineItem.amount</code>；第二个参数 instance 是<strong>托管类实例</strong>，即 LineItem 实例；第三个参数 value 是要设置的值。在为属性赋值时，必须直接操作托管实例的 <code>__dict__</code>，如果使用内置的 setattr 函数，将会重复调用 <code>__set__</code> 导致无限递归。</p>
<p>由于读值方法不需要特殊的逻辑，所以这个描述符类没有定义 <code>__get__</code> 方法。一般情况下，如果没有 <code>__get__</code> 方法，为了给用户提供内省和其他元编程技术支持，通过托管类访问属性会返回描述符实例。通过实例访问则会去实例字典中查询对应属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.attribute]</span><br></pre></td></tr></table></figure>

<p><strong><code>__get__</code> 方法的签名</strong>：<code>def __get__(self, instance, owner) -&gt; Any: ...</code>。与 <code>__set__</code> 方法相同，<code>__get__</code> 方法的第一个参数代表描述符实例，第二个参数代表托管类实例。而第三个参数 owner 是<strong>托管类的引用</strong>，当通过托管类访问属性时会被使用，返回类字典中的描述符实例，可以理解为 <code>instance.__class__</code>。</p>
<p>此时通过托管类访问属性会得到描述符实例，通过实例访问属性会得到托管属性的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.amount</span><br><span class="line">&lt;lineitem_with_descriptor.Quantity <span class="built_in">object</span> at <span class="number">0x108c52760</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;lineitem_with_descriptor&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;price&#x27;</span>: &lt;lineitem_with_descriptor.Quantity <span class="built_in">object</span> at <span class="number">0x10abd1910</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;amount&#x27;</span>: &lt;lineitem_with_descriptor.Quantity <span class="built_in">object</span> at <span class="number">0x10ac037f0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function LineItem.__init__ at <span class="number">0x10abd8af0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;total_price&#x27;</span>: &lt;function LineItem.total_price at <span class="number">0x10abd8b80</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>同一时刻，内存中可能存在许多 LineItem 实例，但只会存在两个描述符实例：<code>LineItem.price</code> 和 <code>LineItem.amount</code>。这是因为描述符实例被定义为 LineItem 的类属性，会出现在 LineItem 的类字典中，由全部实例共享。</p>
<h3 id="描述符分类"><a href="#描述符分类" class="headerlink" title="描述符分类"></a>描述符分类</h3><p>我们将同时实现了 <code>__get__</code> 和 <code>__set__</code> 方法的描述符类称为<strong>数据描述符</strong>，将只实现了 <code>__get__</code> 的描述符类称为<strong>非数据描述符</strong>。在 CPython 的描述符对象 <a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/master/Objects/descrobject.c">descrobject</a> 的源码中，会检查描述符是否有 <code>__set__</code> 方法来返回描述符是否是数据描述符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyDescr_IsData</span><span class="params">(PyObject *ob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Py_TYPE(ob)-&gt;tp_descr_set != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python 社区在讨论这些概念时会用不同的术语，数据描述符也被称为<strong>覆盖型描述符</strong>或强制描述符，非数据描述符也被称为<strong>非覆盖型描述符</strong>或遮盖型描述符。总之，这两者的区别在于是否实现了 <code>__set__</code> 方法。之所以这么分类，是由于 Python 中<strong>存取属性方式的不对等性</strong>，我们在属性访问规则一节中提到了这点。这种不对等的处理方式也对描述符产生影响。</p>
<p>描述符的覆盖体现在，如果实现了 <code>__set__</code> 方法，即使描述符是类属性，也会覆盖对实例属性的赋值操作。比如 <code>item.amount = -1</code> 不会直接修改实例字典，而是强制执行描述符的 <code>__set__</code> 方法对数值进行非负验证。</p>
<p>如果没有实现 <code>__set__</code> 方法，比如 Python 中的方法就是以非覆盖型描述符实现的，只定义了 <code>__get__</code> 方法。如果类中定义了名为 method 的方法，使用 <code>obj.method = 1</code> 会直接修改实例字典，即<strong>实例属性会遮盖同名描述符属性</strong>，但类中的描述符属性依然存在。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span>():</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.method = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;method&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.method</span><br><span class="line">&lt;function C.method at <span class="number">0x10f7ff940</span>&gt;</span><br></pre></td></tr></table></figure>

<p>综上所述，数据描述符的表现形式更像可以被随意赋值的数据，提供了完备的取值方法 <code>__get__</code> 和设值方法 <code>__set__</code>。而非数据描述符表现形式不像数据，比如 Python 中的方法，为非数据描述符赋值会遮盖掉实例的同名描述符属性。</p>
<p>以上讨论的都是是否存在 <code>__set__</code> 方法的情形，其实，也可以没有读值方法 <code>__get__</code>，比如我们定义的 Quantity 描述符。一般情况下，没有读值方法时访问属性会返回描述符对象本身。然而访问 LineItem 实例属性 <code>item.amount</code> 会得到对应数值。这是因为在它的初始化方法 <code>__init__</code> 中已经调用了描述符的 <code>__set__</code> 方法，该方法为实例字典 <code>__dict__</code> 创建了同名实例属性，由于实例属性会遮盖同名描述符属性，读取属性会返回实例字典中的值而不是描述符对象。这也是为什么将实现了 <code>__set__</code> 的描述符称为遮盖型描述符的原因。</p>
<p>总之，<strong>按照属性访问规则，数据描述符在实例字典之前被访问（调用 <code>__get__</code> 和<code>__set__</code> 方法），非数据描述符在实例字典之后被访问（可能会被遮盖）</strong>。</p>
<h3 id="方法是描述符"><a href="#方法是描述符" class="headerlink" title="方法是描述符"></a>方法是描述符</h3><p>定义在类中的方法会变成绑定方法（bound method），这是 Python 语言底层使用描述符的最好例证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span>():</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.method</span><br><span class="line">&lt;bound method C.method of &lt;__main__.C <span class="built_in">object</span> at <span class="number">0x10f837580</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.method</span><br><span class="line">&lt;function C.method at <span class="number">0x10fff6b80</span>&gt;</span><br></pre></td></tr></table></figure>

<p>通过类和实例访问函数返回的是不同的对象。CPython 中定义的函数对象 <a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/master/Objects/funcobject.c">funcobject</a> 实现了描述符协议的 <code>__get__</code> 方法，即如下的 <code>func_descr_get</code> 方法。与描述符一样，通过托管类访问函数时，传入的 obj 参数为空，函数的 <code>__get__</code> 方法会返回自身的引用。通过实例访问函数时，返回的是绑定方法对象，并把托管实例绑定给函数的第一个参数（即 self），这与 functool.partial 函数的行为一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bind a function to an object */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject *</span></span><br><span class="line"><span class="function"><span class="title">func_descr_get</span><span class="params">(PyObject *func, PyObject *obj, PyObject *type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == Py_None || obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(func);</span><br><span class="line">        <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyMethod_New(func, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Method objects are used for bound instance methods returned by instancename.methodname.</span></span><br><span class="line"><span class="comment">   ClassName.methodname returns an ordinary function. */</span></span><br><span class="line"><span class="function">PyObject * <span class="title">PyMethod_New</span><span class="params">(PyObject *func, PyObject *self)</span></span></span><br></pre></td></tr></table></figure>

<p>绑定方法对象还有个 <code>__call__</code> 方法，用于处理真正的调用过程。这个方法会调用 <code>__func__</code> 属性引用的原始函数，把函数的第一个参数设为绑定方法的 <code>__self__</code> 属性。这就是<strong>形参 self 的隐式绑定过程</strong>。</p>
<h3 id="使用描述符的最佳实践"><a href="#使用描述符的最佳实践" class="headerlink" title="使用描述符的最佳实践"></a>使用描述符的最佳实践</h3><p><strong>使用特性以保持简单</strong>：内置的 property 类创建的是数据描述符，<code>__get__</code> 和 <code>__set__</code> 方法都实现了。特性的 <code>__set__</code> 方法默认抛出 AttributeError: can’t set attribute，因此创建只读属性最简单的方式是使用特性。且由于特性存在 <code>__set__</code> 方法，不会被同名实例属性遮盖。</p>
<p><strong>只读描述符也要实现 <code>__set__</code> 方法</strong>：如果使用描述符类实现只读数据属性，要记住，<code>__get__</code> 和 <code>__set__</code> 方法必须都定义。否则，实例的同名属性会遮盖描述符。只读属性的 <code>__set__</code> 方法只需抛出 AttributeError 异常，并提供合适的错误消息。</p>
<p><strong>非特殊的方法可以被实例属性遮盖</strong>：Python 的方法只实现了 <code>__get__</code> 方法，所以对与方法名同名的属性将会遮盖描述符，也就是说 <code>obj.method = 1</code> 负值后通过实例访问 method 将会得到数字 1，但不影响类或其他实例。然而，特殊方法不受这个问题影响。因为解释器只会在类中查询特殊方法。也就是说 <code>repr(x)</code> 执行的其实是 <code>x.__class__.__repr__(x)</code>，因此 x 的 <code>__repr__</code> 属性对 <code>repr(x)</code> 方法调用没有影响。出于同样的原因，实例的 <code>__getattr__</code> 属性不会破坏常规的属性访问规则。</p>
<p><strong>用于验证的描述符可以只实现 <code>__set__</code> 方法</strong>：对仅用于验证的描述符来说，<code>__set__</code> 方法应该检查 value 参数是否有效，如果有效，使用与描述符实例同名的名称作为键，直接在实例字典中设值，如 Quantity 中的 <code>instance.__dict__[self.attribute] = value</code> 语句。这样，从实例字典中读取同名属性就不需要经过 <code>__get__</code> 方法处理。</p>
<p><strong>仅有 <code>__get__</code> 方法的描述符可以实现高效缓存</strong>：如果仅实现了 <code>__get__</code> 方法，那么创建的是非数据描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例字典中获取值，而不会再出发描述符的 <code>__get__</code> 方法。</p>
<h3 id="描述符应用场景"><a href="#描述符应用场景" class="headerlink" title="描述符应用场景"></a>描述符应用场景</h3><p>当将描述符逻辑抽象到单独的代码单元中，如 Quantity 类中，就可以在整个应用中进行重用。在一些框架中，会将描述符定义在单独的工具模块中，比如 Django 框架中与数据库交互的模型字段类，就是描述符类。你会发现下面这段 Django 的测试用例的代码与我们定义的 LineItem 非常类似。只不过我们的描述符类 Quantity 换成了他们的 models.CharFiled 等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    books = models.ManyToManyField(Book)</span><br><span class="line">    person = models.OneToOneField(<span class="string">&#x27;Person&#x27;</span>, models.CASCADE, null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>当然，目前定义的描述符类还有提升的空间，比如 <code>price = Quantity(&#39;price&#39;)</code> 使用字符串对属性名进行初始化可能并不那么可靠。又比如想为字段设置更多限定，比如 Django 中设置的字段 max_length 等。其实，Django 框架使用到了 Python 更高阶的类元编程的特性 —— 元类。除了开放框架，一般用不到这个特性。后面我们会对元类加以介绍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/04/12/Python-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/12/Python-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Python 函数详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-12 22:48:57" itemprop="dateCreated datePublished" datetime="2021-04-12T22:48:57+08:00">2021-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>除了用户定义的函数，调用运算符，即 “()” 括号对，还能应用到其他对象上。我们将能应用调用运算符的对象称为<strong>可调用对象</strong>，通过内置的 <code>callable()</code> 方法可以判断对象是否是可调用对象。在 Python 3 的<a target="_blank" rel="noopener" href="https://docs.python.org/3/reference/datamodel.html">数据模型文档</a>中，一共列出了 7 种可调用对象：</p>
<ul>
<li><strong>内置函数和内置方法</strong>：使用 C 语言（CPython）实现的函数和方法，如 <code>len()</code> 和 <code>alist.append()</code>；</li>
<li><strong>用户定义的函数</strong>：包括使用 def 创建的普通函数和 lambda 创建的匿名函数；</li>
<li><strong>实例方法与类方法</strong>：定义在类中的方法，实例方法是指第一个参数为 <code>self</code> 的方法，类方法是指第一个参数为 <code>cls</code> 的方法；</li>
<li><strong>类</strong>：对类使用调用运算符，如 <code>C()</code>，会执行类的 <code>__new__</code> 方法创建类的实例，然后执行 <code>__init__</code> 初始化；</li>
<li><strong>类的实例</strong>：如果类定义了 <code>__call__</code> 方法，那它的实例可以作为函数调用；</li>
<li><strong>生成器函数</strong>：内部使用了 yield 关键字的函数，调用生成器函数会返回生成器对象；</li>
<li><strong>协程函数和异步生成器函数</strong>：从 Python 3.5 开始支持使用 <code>async def</code> 关键字来定义协程函数，如果内部包含 yield 关键字则被称为异步生成器函数。该函数被调用时会返回一个异步迭代器对象。</li>
</ul>
<h3 id="自定义的可调用类型"><a href="#自定义的可调用类型" class="headerlink" title="自定义的可调用类型"></a>自定义的可调用类型</h3><p>在装饰器一节，我们已经认识到了，装饰器不仅可以是函数，也可以是类。任何类只要实现了 <code>__call__</code> 方法，那它就是可调用对象，就可以表现的如同函数。因此，我们可以编写用户自定义的可调用类型，将其用在任何期待函数的地方。下面我将通过 Java 和 Python 两种语言，展现它们在可调用类型上的异同。</p>
<p>假设现有一副扑克，要求按照 <code>A, 2 ~ 10, J, Q, K</code> 的顺序进行排序。在 Java 中，可以通过 <code>Collections.sort()</code> 集合类的接口对一个集合进行排序。Python 也提供了内置的 <code>sorted()</code> 方法，对可迭代对象进行排序。但两种语言都不支持直接对字符串和数字类型进行比较，所以还需要实现特定的排序逻辑。</p>
<p>Java 中要实现排序逻辑通常有两种方法。一种是让类实现 Comparable 接口，重写其中的 <code>compareTo()</code> 抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Poker</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Poker otherPoker)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重点想展示第二种方法：新建一个实现了 Comparator 接口的比较器类，重写其 <code>compare()</code> 抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PokerComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Poker</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Poker firstPoker, Poker secondPoker)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// return ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PokerComparator pokerComparator = <span class="keyword">new</span> PokerComparator();</span><br><span class="line">Collections.sort(pokers, pokerComparator);</span><br></pre></td></tr></table></figure>

<p>对于这种方法，需要将比较器对象作为第二个参数传入 <code>Collections.sort()</code> 接口中。由于 Java 对象不能将函数作为参数的限制，我们定义了一个辅助类，实际上这个类对我们而言只有一个方法有用，那就是 <code>compare()</code> 方法，<code>Collections.sort()</code> 接口会去调用该方法，所以它就是对应的排序逻辑，只不过是用类实现的。</p>
<p>Python 的函数可以直接作为参数传递，但我们接下来要讲的是如何定义一个类似 Comparator 的类，让它能实现排序逻辑。</p>
<p>Python 内置的排序方法 <code>sorted()</code>，<strong>允许接收一个关键字参数 key 作为排序的键</strong>，比如 <code>key=len</code> 时依照元素的长度进行排序。对于扑克牌 A ~ K，可以维护一个映射数字类型的字典，比如将 ‘K’ 映射到 13，排序时直接通过映射的数值大小排序。维护一个字典，函数当然可以做到，但将其作为类的属性更加合适。可以定义一个扑克序列类，在初始化这个类时就构建好字典。为了让类可被调用，还需要实现 <code>__call__</code> 方法，直接返回字典中扑克牌对应的数值作为排序的键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PokerOrder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._seq = &#123;<span class="built_in">str</span>(i): i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)&#125;</span><br><span class="line">        self._seq.setdefault(<span class="string">&#x27;J&#x27;</span>, <span class="number">11</span>)</span><br><span class="line">        self._seq.setdefault(<span class="string">&#x27;Q&#x27;</span>, <span class="number">12</span>)</span><br><span class="line">        self._seq.setdefault(<span class="string">&#x27;K&#x27;</span>, <span class="number">13</span>)</span><br><span class="line">        self._seq.setdefault(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._seq.get(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self._seq)</span><br></pre></td></tr></table></figure>

<p>由于 PokerOrder 类实现了 <code>__call__</code> 方法，它的实例会被 <code>callable()</code> 方法判定为可调用对象，可以直接应用调用运算符，传入扑克牌值返回对应数值。在排序时，将 PokerOrder 类的实例作为关键字传入，相当于将序列中的每项元素执行 <code>__call__</code> 方法返回的值作为键进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pokerorder = PokerOrder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pokerorder.show()</span><br><span class="line">&#123;<span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;10&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;J&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;Q&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;K&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(pokerorder)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pokerorder(<span class="string">&#x27;K&#x27;</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;2&#x27;</span>], key=pokerorder)</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;K&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>将类定义为可调用类型，不仅能维护内部属性，还能自定义方法，比如如上代码中的 <code>show()</code> 方法。除此之外，在实现更复杂的排序逻辑时，比如按照花色排序等，使用类要比使用函数更合适。甚至如果你觉的 PokerOrder 类应该被实现为单例模式，还可以添加 <code>__new__</code> 方法保证创建类中的字典只会被创建一次。</p>
<h2 id="函数对象与方法对象"><a href="#函数对象与方法对象" class="headerlink" title="函数对象与方法对象"></a>函数对象与方法对象</h2><p>Python 中一切皆对象，不管是函数还是类中定义的方法都是对象。对于类中的实例方法来说，通过类访问该实例方法，如 <code>C.foo</code>，会返回一个<strong>函数对象</strong>，即 <code>function</code> 类型；通过实例访问实例方法，如 <code>c.foo</code>，会返回一个<strong>绑定方法对象</strong>，即 <code>method</code> 类型，该方法对象绑定在实例上。对于类方法而言，无论是通过类还是实例访问，都返回绑定方法对象，该方法对象绑定在类上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self, x</span>):</span> <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span>    @<span class="built_in">classmethod</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">cls, x</span>):</span> <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.foo</span><br><span class="line">&lt;function C.foo at <span class="number">0x10d613f70</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(C.foo)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">function</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span> = <span class="title">C</span>()</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">C</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10b0a5820</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span>.<span class="title">foo</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">C</span>.<span class="title">foo</span> <span class="title">of</span> &lt;<span class="title">__main__</span>.<span class="title">C</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10b0a5820</span>&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">c.foo</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">method</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">C</span>.<span class="title">bar</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">C</span>.<span class="title">bar</span> <span class="title">of</span> &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">C</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span>.<span class="title">bar</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">C</span>.<span class="title">bar</span> <span class="title">of</span> &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">C</span>&#x27;&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法对象中包含一些特殊的只读属性：</p>
<ul>
<li><code>__self__</code> 为类实例对象本身；</li>
<li><code>__func__</code> 为函数对象；</li>
<li><code>__doc__</code> 为方法的文档，与 <code>__func__.__doc__</code> 作用相同；</li>
<li><code>__name__</code> 为方法名称，与 <code>__func__.__name__</code> 作用相同；</li>
<li><code>__module__</code> 为方法所属模块的名称，没有则为 None。</li>
</ul>
<p><strong>访问方法对象的 <code>__func__</code> 属性会获得函数对象</strong>。虽然两者都能通过调用运算符 “()” 调用，但函数对象还需要手动传入第一个位置的参数，即 <code>self</code> 和 <code>cls</code> 参数，方法对象则不需要。原因在于，<strong>调用方法对象会调用对应的下层函数对象 <code>__func__</code>，并将 <code>__self__</code> 参数插入到参数列表的开头</strong>，如果是实例方法则插入类实例，如果是类方法则插入类本身。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self, x</span>):</span> <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span>    @<span class="built_in">classmethod</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">cls, x</span>):</span> <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.foo(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.foo.__func__(c, <span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.bar(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.bar.__func__(C, <span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>就如同上述代码所展示的，对于实例方法 <code>foo()</code> 来说，调用 <code>c.foo(1)</code> 相当于调用 <code>c.foo.__func__(c, 1)</code>。对于类方法 <code>bar()</code> 来说，无论是调用 <code>c.bar(1)</code> 还是 <code>C.bar(1)</code> 都相当于调用 <code>C.bar.__func__(C, 1)</code>。</p>
<h3 id="函数内省"><a href="#函数内省" class="headerlink" title="函数内省"></a>函数内省</h3><p>将函数作为对象处理，可以用于运行时内省，类似于 Java 中的反射，可以在运行时获取函数的信息，比如注解、闭包、参数默认值等。下面列出了一些函数对象特有的属性和方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="built_in">set</span>(<span class="built_in">dir</span>(func)) - <span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="built_in">object</span>)))</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__call__&#x27;</span>, <span class="string">&#x27;__closure__&#x27;</span>, <span class="string">&#x27;__code__&#x27;</span>, <span class="string">&#x27;__defaults__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__get__&#x27;</span>, <span class="string">&#x27;__globals__&#x27;</span>, <span class="string">&#x27;__kwdefaults__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p><code>dir()</code> 函数可以查看一个模块或一个类中的所有属性，当然方法也算方法属性。上述代码将 func 函数对象与常规对象 object 的属性集合做了一个差集，只打印函数对象特有的属性。下表对这些特有属性做了简要说明。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>__annotations__</code></td>
<td>dict</td>
<td>参数和返回值的注解</td>
</tr>
<tr>
<td><code>__call__</code></td>
<td>method-wrapper</td>
<td>实现 () 运算符，即可调用对象协议</td>
</tr>
<tr>
<td><code>__closure__</code></td>
<td>tuple</td>
<td>函数闭包，即自由变量的绑定（没有则是None）</td>
</tr>
<tr>
<td><code>__code__</code></td>
<td>code</td>
<td>编译成字节码的函数元数据和函数定义体</td>
</tr>
<tr>
<td><code>__defaults__</code></td>
<td>tuple</td>
<td>形式参数的默认值</td>
</tr>
<tr>
<td><code>__get__</code></td>
<td>method-wrapper</td>
<td>实现只读描述符协议</td>
</tr>
<tr>
<td><code>__globals__</code></td>
<td>dict</td>
<td>函数所在模块中的全局变量</td>
</tr>
<tr>
<td><code>__kwdefaults__</code></td>
<td>dict</td>
<td>仅限关键字形式参数的默认值</td>
</tr>
<tr>
<td><code>__name__</code></td>
<td>str</td>
<td>函数名称</td>
</tr>
<tr>
<td><code>__qualname__</code></td>
<td>str</td>
<td>函数的限定名称，如 Random.choice</td>
</tr>
</tbody></table>
<p>函数内省经常被一些框架使用发挥出强大效果。比如 <code>__defaults__</code>、<code>__code__</code> 和 <code>__annotations__</code> 属性，经常被 IDE 用来提取关于函数签名的信息，我们之前也提到过 IDE 和 lint 工具使用函数注解做静态类型检查。还比如一些 Python Web 后端框架，可以自动解析 HTTP 请求中的参数将其注入到接口函数中执行，而不用程序员手动处理。</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>Python 最好的特性之一就是提供了极为灵活的参数处理机制。除了基础的定位参数（positional argument）之外，Python 还支持传入关键字参数（keyword argument），如我们之前所使用的内置方法 <code>sorted()</code>，就支持关键字参数 key 与 reverse。关键字参数允许提供默认值，如果无默认值一般为 None。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Return a new list containing all items from the iterable in ascending order.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">A custom key function can be supplied to customize the sort order, and the</span></span><br><span class="line"><span class="string">reverse flag can be set to request the result in descending order.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">sorted</span>(iterable, /, *, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>Java 5 中引入了不定长参数，允许在形参后添加 <code>...</code> 表示该形参可以接收多个参数值，多个参数将被当做数组传入，如 <code>void foo(String... args)</code>。Python 也支持<strong>不定长参数</strong>，它的形式是在参数名称前添加星号运算符，如 <code>*args</code>，不定长参数将被打包成<strong>元组</strong>传入。除此之外，Python 还支持传入<strong>非具名关键字参数</strong>，即没有明确指定名称的关键字参数，如 <code>**kwargs</code>，参数将会被打包成一个<strong>字典</strong>传入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;args: &#x27;</span>, args)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;kwargs: &#x27;</span>, kwargs)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="string">&#x27;b&#x27;</span>) </span><br><span class="line">args: (<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">kwargs: &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;b&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果同时使用 <code>*args</code> 和 <code>**kwargs</code>，<code>*args</code> 参数必须要在 <code>**kwargs</code> 之前。它们可以与其他类型的参数混合使用，但<strong>参数的顺序必须是：定位参数，默认参数，不定长参数，具名关键字参数和非具名关键字参数</strong>。即如下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">record</span>(<span class="params">name, age=<span class="number">18</span>, *phones, email=<span class="literal">None</span>, **other</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;name: &#x27;</span>, name)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;age: &#x27;</span>, age)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;phones: &#x27;</span>, phones)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;email: &#x27;</span>, email)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;other: &#x27;</span>, other)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="number">123456</span>, <span class="number">654321</span>, email=<span class="string">&#x27;abc@email.com&#x27;</span>, height=<span class="number">180</span>, weight=<span class="number">90</span>)</span><br><span class="line">name: Jack</span><br><span class="line">age: <span class="number">20</span></span><br><span class="line">phones: (<span class="number">123456</span>, <span class="number">654321</span>)</span><br><span class="line">email: abc@email.com</span><br><span class="line">other: &#123;<span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">90</span>&#125;</span><br></pre></td></tr></table></figure>

<p>其中，默认参数与具名关键字参数形式上一样，默认参数通常是用来简化函数调用者的传参的。这两者可以通过位置进行区分，在不定长参数之前的是默认参数，之后的是关键字参数。如果要传入不定长参数，默认参数就不能省略，此时默认参数被视为定位参数（默认值失去了意义），其后的非关键字参数会被不定长参数 <code>*phones</code> 捕获。如果省略了默认参数，那么不定长参数的第一个元素会被赋值给默认参数。具名关键字参数则没有这一限制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>record(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">123456</span>, <span class="number">654321</span>, height=<span class="number">180</span>)</span><br><span class="line">name:  Jack</span><br><span class="line">age:  <span class="number">123456</span></span><br><span class="line">phones:  (<span class="number">654321</span>,)</span><br><span class="line">email:  <span class="literal">None</span></span><br><span class="line">other:  &#123;<span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>仅限关键字参数</strong>（keyword-only argument）是 Python 3 新增的特性。如果定义函数时想指定仅限关键字参数，需要将它们放在带有 <code>*</code> 的不定长参数之后。如果不想支持不定长参数，可以在签名中放一个 <code>*</code>，标志着定位参数到此终结，之后的参数只能以关键字形式提供，即仅限关键字参数。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, *, b, c=<span class="number">3</span></span>):</span> </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a, b, c</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，仅限关键字参数不一定要有默认值，但如果没有默认值，调用函数时必须传入该参数。内置方法 <code>sorted()</code> 的参数就包含一个 <code>*</code>，其后的 key 和 reverse 参数就是带有默认值的仅限关键字参数。</p>
<h3 id="函数参数的最佳实践"><a href="#函数参数的最佳实践" class="headerlink" title="函数参数的最佳实践"></a>函数参数的最佳实践</h3><p>对于函数参数如何正确的使用，《Effective Python》给出了一些建议。我结合自己的一些看法，给出如下几点建议。</p>
<p>第一点，<strong>使用不定长参数减少视觉杂讯</strong>。这是一种比喻，目的是使函数签名内容不要过于过多，而应凸显重要部分。如果一个函数支持传入多个相同类型的对象，或对不同类型的对象做相同处理，可以考虑不定长参数（或者组合成一个可迭代对象传入）。拿 Python 的内置方法来举例，<code>map()</code> 的最后一个参数就是不定长参数 <code>*iterables</code>，支持传入多个可迭代对象；<code>print()</code> 方法的第一个参数 <code>*values</code> 也是不定长参数，对于传入多个参数，不管它们是什么类型都能将其打印。</p>
<p>第二点，<strong>使用关键字参数来表达可选的行为</strong>。关键字参数的名称可以辅助调用者明确参数的用途，比如 <code>sorted()</code> 方法中的 reverse 参数用来反向排序。关键字参数还能提供默认值，就如同一个开关，如果使用函数默认功能，就不需要操心这些参数，还可以避免传参时的重复代码。如果想开启附加功能，可以传入指定的关键字参数。带有默认值的关键字参数还能在不改变调用代码的基础上为函数添加新功能，保证了代码的兼容性。从另一种角度看，带有默认值的关键字参数提供了类似多态重载的动态语言特性，虽然 Python 并不支持函数重载。</p>
<p>第三点，<strong>使用仅限关键字参数来确保代码清晰</strong>。关键字参数可以提高可读性，但不能保证调用者一定使用关键字来明确指出参数的含义，关键字参数可以通过位置来赋值，比如定义的函数 <code>def func(a, b=1)</code> 可以通过 <code>func(1, 2)</code> 来为关键字参数 b 赋值。如果有必要，可以使用仅限关键字参数来强制调用者使用关键字。比如 <code>sorted()</code> 方法签名 <code>*</code> 后指定的仅限关键字参数 key 和 reverse。</p>
<p>第四点，<strong>使用 None 而不是可变序列为参数默认值赋空</strong>。绝对不要将参数默认值指定为空的可变序列 <code>[]</code> 和 <code>&#123;&#125;</code>。参数的默认值会在模块被加载时执行一次并绑定，如果默认值定义为了可变序列，那么以默认形式调用函数的代码都会共享同一份序列，从而导致难以预料的结果。比如如下解析 JSON 的函数，默认值为空字典，在解析出错时将其返回，导致两个对象共用一个字典。解决的方法是使用 None 作为参数默认值，在函数内重新赋值为空字典，并添加文档说明参数默认值的实际行为。如果参数默认值是动态变化的，如当前时间，也应如此做。总之，要避免参数默认值是可变的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">data, default=&#123;&#125;</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> json.loads(data)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ValueError:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> default</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = decode(<span class="string">&#x27;bad data&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar = decode(<span class="string">&#x27;also bad&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo <span class="keyword">is</span> bar</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>第五点，<strong>避免修改传入参数的值</strong>。函数式编程中非常强调的一点是，函数要无副作用。无副作用指的是函数内部不与外部互动（最典型的情况是，修改全局变量的值），产生除函数本身运算以外的其他效果。函数无副作用，意味着函数要保持独立，不依赖于上下文环境，不得修改外部变量包括传入参数的值。即使函数要在传入参数本身上做运算，也应该新建一个副本将其返回。就拿 <code>sorted()</code> 来说，即使排序前后元素位置没有变化，也返回一个全新的列表。除此之外，<code>map()</code>、<code>filter()</code> 等其他内置方法也都遵循这一点，不对参数本身做修改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(l)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(l) <span class="keyword">is</span> l</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义的-sorted-函数"><a href="#自定义的-sorted-函数" class="headerlink" title="自定义的 sorted() 函数"></a>自定义的 <code>sorted()</code> 函数</h3><p>在本章中我一直拿内置的 <code>sorted()</code> 函数来举例，不妨自己来实现一个。借此案例我想演示：如何使用仅限关键字参数，如何编写高阶函数，以及如何使用卫语句对异常参数进行处理。</p>
<p>这里的排序算法不是关键，使用的是最简单的冒泡排序算法。函数签名上尽可能与 <code>sorted()</code> 保持一致，为了保证函数无副作用，函数内部新建了一个列表副本保存传入可迭代序列的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">iterable, *, key=<span class="literal">None</span>, reverse=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">callable</span>(key):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">type</span>(key)&#125;</span> object is not callable&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    _l = <span class="built_in">list</span>(iterable)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(_l)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> _l[j] &gt; _l[i]:</span><br><span class="line">                    _l[j], _l[i] = _l[i], _l[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> key(_l[j]) &gt; key(_l[i]):</span><br><span class="line">                    _l[j], _l[i] = _l[i], _l[j]</span><br><span class="line">    <span class="keyword">if</span> reverse:</span><br><span class="line">        _l.reverse()</span><br><span class="line">    <span class="keyword">return</span> _l</span><br></pre></td></tr></table></figure>

<p>仅限关键字参数是指在 <code>*</code> 运算符之后定义的关键字参数，在调用时必须指定关键字名称，如上述函数中的 key 和 reverse 关键字。</p>
<p>在函数的开头，首先判断传入的 key 参数在非 None 情况下是否是可调用的，若不可调用则抛出 TypeError 异常。这种 if 条件分支语句叫做<strong>卫语句</strong>（guard clause），目的是将可能出错的每个分支做单独检查，要么抛出异常要么立即返回。通过在函数头部的集中处理及早抛出各种可能的异常（又称迅速失败），避免无效的运算。函数真正的实现代码放在卫语句之后，保证运行到此处时所有条件都已通过。</p>
<p>通过了卫语句检测的 key 参数是可调用的，在函数内部直接使用 <code>key()</code> 调用。对于接收函数作为参数的 <code>sort()</code> 函数，我们将其称之为<strong>高阶函数</strong>，这也是 Python 函数式编程特性之一。</p>
<p>下面是测试方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_should_sort_number_sequence</span>(<span class="params">self</span>):</span></span><br><span class="line">    _l = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>]</span><br><span class="line">    result = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">    <span class="keyword">assert</span> sort(_l) == result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_should_sort_sequence_with_key_function</span>(<span class="params">self</span>):</span></span><br><span class="line">    _l = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;aab&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;aabb&#x27;</span>]</span><br><span class="line">    result = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;aab&#x27;</span>, <span class="string">&#x27;aabb&#x27;</span>]</span><br><span class="line">    <span class="keyword">assert</span> sort(_l, key=<span class="built_in">len</span>) == result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_should_sort_sequence_with_key_function_and_reverse</span>(<span class="params">self</span>):</span></span><br><span class="line">    _l = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;aab&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;aabb&#x27;</span>]</span><br><span class="line">    result = [<span class="string">&#x27;aabb&#x27;</span>, <span class="string">&#x27;aab&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    <span class="keyword">assert</span> sort(_l, key=<span class="built_in">len</span>, reverse=<span class="literal">True</span>) == result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_should_raise_error_when_key_function_is_not_callable</span>(<span class="params">self</span>):</span></span><br><span class="line">    _l = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>]</span><br><span class="line">    <span class="keyword">with</span> pytest.raises(TypeError) <span class="keyword">as</span> e:</span><br><span class="line">        sort(_l, key=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>pytest 框架支持对抛出异常的测试，使用 with 语句加 <code>pytest.raises()</code> 方法可以断言定义体内调用的方法是否会抛出对应的异常。</p>
<h3 id="与-运算符"><a href="#与-运算符" class="headerlink" title="* 与 ** 运算符"></a><code>*</code> 与 <code>**</code> 运算符</h3><p>在 Python 中，<code>*</code> 与 <code>**</code> 运算符除了能用作数学运算符中的乘法和乘方之外，还有一些其他的巧妙用法。之前讨论的函数中的不定长参数 <code>*args</code> 和不具名关键字参数 <code>**kwargs</code> 是它们的经典用法之一。此外，这两个运算符还可以用来对参数列表进行<strong>拆包</strong>。</p>
<p>运用 <code>*</code> 运算符可以把一个可迭代对象拆开作为函数的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>, b=<span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a=<span class="number">1</span>, b=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(*t)</span><br><span class="line">a=<span class="number">1</span>, b=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>类似的，运用 <code>**</code> 运算符可以把一个字典拆开作为函数的参数，同名键会绑定到对应的具名参数上，如果函数还定义了非具名关键字参数 <code>**kwargs</code>，除了绑定的同名键外余下参数会被 <code>**kwargs</code> 捕获。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a=<span class="literal">None</span>, b=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>, b=<span class="subst">&#123;b&#125;</span>, kwargs=<span class="subst">&#123;kwargs&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(**d)</span><br><span class="line">a=<span class="number">1</span>, b=<span class="number">2</span>, kwargs=&#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>*</code> 运算符对于函数参数中的可迭代对象拆包概念，在 Python 3 被扩展到了<strong>平行赋值</strong>。在平行赋值中，<code>*</code> 前缀只能被用在一个变量名前，但这个变量可以出现在赋值表达式的任何位置，用来处理剩下的元素。拆包所赋值的元素是列表类型，即使其中只有一个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *rest, d, e = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, rest, d, e</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *rest, c, d, e = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, rest, c, d, e</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>Python 中的 lambda 关键字用于创建<strong>匿名函数</strong>。lambda 表达式的格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments : statement</span><br></pre></td></tr></table></figure>

<p>表达式以 lambda 关键字开头，冒号 “:” 左侧是函数的<strong>传入参数</strong>，当有多个入参时使用逗号划分开，冒号右侧是<strong>返回值</strong>的表达式语句，函数会根据表达式计算结果并将其返回。lambda 表达式会创建一个函数对象，可以对其赋值并如同普通函数一样使用。下面定义了一个求平方的 lambda 表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>square = <span class="keyword">lambda</span> x : x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x101631e50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(<span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>lambda 句法只是语法糖，上述定义的 lambda 表达式与如下使用 def 关键字定义的普通函数没有本质区别，甚至 lambda 表达式的功能要更加受限。由于 Python 简单的句法限制了 lambda 定义体只能使用纯表达式，不能进行赋值，也不能使用 while 和 try 等 Python 语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square</span><br><span class="line">&lt;function square at <span class="number">0x101631dc0</span>&gt;</span><br></pre></td></tr></table></figure>

<p>在 Python 中，<strong>lambda 表达式的通常作用是作为参数传入给高阶函数</strong>。比如在列表推导一节介绍的 map、filter 和 reduce 函数，这些函数接收一个函数作为参数，如果不想额外定义函数，那么使用 lambda 表达式创建匿名函数就是最佳的应用场景。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x : x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x : x &lt; <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>除了上述这种应用场景之外，Python 很少使用匿名函数。受到句法的限制，lambda 表达式无法实现复杂的函数功能。同时，在使用 lambda 表达式时要尽可能保证表达式的清晰简短，否则冗长的 lambda 表达式将会导致代码难以阅读。此时，应该使用 def 关键字创建普通函数，即《Effective Python》所提倡的：<strong>使用辅助函数来取代复杂的表达式</strong>，并赋予函数清晰的名称以提高代码可读性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/04/01/Python-%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%BF%AD%E4%BB%A3%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/Python-%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%BF%AD%E4%BB%A3%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">Python 中的可迭代类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-01 17:11:20" itemprop="dateCreated datePublished" datetime="2021-04-01T17:11:20+08:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>之前我们已经讨论过，Python 的“序列协议”是指：任何类，只要使用标准的签名和语义实现了 <code>__getitem__</code> 和 <code>__len__</code> 方法，就能用在任何期待序列的地方，解释器会为这些类做特殊的支持，比如支持迭代和 in 运算符。序列协议的接口定义可以查阅官方的 CPython API 接口文档：<a target="_blank" rel="noopener" href="https://docs.python.org/3.8/c-api/sequence.html">Python/C API Reference Manual – Sequence Protocol</a>，其中有这样一个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PySequence_Check</span><span class="params">(PyObject *o)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* Return 1 if the object provides sequence protocol, and 0 otherwise. Note that it returns 1 for Python classes with a __getitem__() method unless they are dict subclasses since in general case it is impossible to determine what the type of keys it supports. This function always succeeds. */</span></span></span><br></pre></td></tr></table></figure>

<p>这个函数的作用是检查并返回对象是否支持序列协议 —— 只在实现了 <code>__getitem__</code> 方法且不是字典子类时才返回 1。这也符合我们之前所说的，协议是非正式的，没有强制力，只要你知道类的具体使用场景，可以只实现协议的一部分。比如，仅为了支持迭代，甚至不需要提供 <code>__len__</code> 方法。</p>
<p>Python 常用的内置序列类型包括：字符串 str、列表 list、元组 tuple 和范围 range。尽管字典 dict 和集合 set 实现了序列协议中的 <code>__getitem__</code> 和 <code>__len__</code> 方法，但它们并不算序列类型，因为它们的特征与序列有本质差异，比如这两个类型不支持通过整数下标索引访问元素，不支持切片，并且字典和集合内的元素是无序的。</p>
<p>序列类 Sequence，定义在标准库 <code>collections.abc</code> 模块中，继承自 Reversible 和 Collection 类，而 Collection 又继承自 Sized、Iterable 和 Container，体现了序列类可反转、具有规模、可迭代和是一个容器的语义。</p>
<p>从 <code>collections.abc</code> 模块的源码中，我们还能了解到序列类包含哪些子类。除了显示继承了 Sequence 的子类，如 ByteString 和 MutableSequence，还有通过 register 关键字绑定为 Sequence 虚拟子类的一些内置类型，在绑定虚拟子类一节中也提到过这一点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> <span class="type">Sequence</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="built_in">issubclass</span>(i, <span class="type">Sequence</span>) <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="built_in">str</span>, <span class="built_in">list</span>, <span class="built_in">tuple</span>, <span class="built_in">range</span>, <span class="built_in">bytes</span>, <span class="built_in">bytearray</span>, <span class="built_in">memoryview</span>)])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>([<span class="built_in">issubclass</span>(i, <span class="type">Sequence</span>) <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="built_in">dict</span>, <span class="built_in">set</span>)])</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>上面列表推导表达式中的所有类型都是定义在 builtsin 模块中的内置类型，可以看到，除了 dict 和 set 之外，第二行的所有内置类型都是序列类型。除此之外，标准库中还定义了其他序列类型，比如 array 模块的 array 数组类型，collections 模块中的 deque 双端队列类型。</p>
<p>对于这些序列类型，按照序列内可容纳的类型，可以划分为以下两组：</p>
<ul>
<li><strong>容器序列</strong>：list、tuple 和 collections.deque 这些序列类能存放不同类型的数据；</li>
<li><strong>扁平序列</strong>：str、bytes、bytearray、memoryview、array.array 和 range 这类序列类只能容纳一种或某种特定类型的数据。</li>
</ul>
<p>容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列存放的是值而不是引用。扁平序列存储在一段连续的内存空间之上，只能存放诸如字符、字节和数值这种基础类型。</p>
<p>序列类型还能按照能否被修改来分类：</p>
<ul>
<li><strong>可变序列</strong>：list、bytearray、memoryview、array.array 和 collections.deque；</li>
<li><strong>不可变序列</strong>：tuple、str、bytes 和 range。</li>
</ul>
<p>可变序列 MutableSequence 也定义在 <code>collections.abc</code> 模块中，并在继承 Sequence 的基础上还添加了一些支持序列修改的默认方法，如 <code>append()</code>、<code>pop()</code> 方法等。除了 Sequence 基类中要实现的 <code>__getitem__</code> 和 <code>__len__</code> 方法外，可变序列还要求具体子类必须实现 <code>__setitem__</code>、<code>__delitem__</code> 和 <code>insert()</code> 方法。</p>
<p>序列不可变意味着序列一旦被声明赋值，序列的大小就固定下来，其内的元素也不能被修改。这里用来说明序列可变不可变的典型案例是列表和元组。在 Python 中，列表是可变的，元组是不可变的。列表可变体现在它支持对元素的增加删除和直接赋值，且列表支持<strong>就地运算</strong>，比如使用 “+=” 运算符可以直接将一个可迭代对象中的元素添加到当前列表的末尾。而元组是不可变的，元组一经定义大小就已固定，不能增加删除元素，也不对其内元素重新赋值。即使元组也支持就地运算符，但会生成一个新的元组对象重新绑定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>]  <span class="comment"># list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4411278528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4411278528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4410964416</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t += (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4411277824</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>此外，Python 中的可散列对象一定是不可变类型，散列方法 <code>__hash__</code> 通常和 <code>__eq__</code> 方法一起用来判断两个对象是否相等，如集合 set 和字典的键要求元素是可散列的，这被用来判断元素是否重复。所以，元组可以作为集合的元素和字典的键，而列表却不可以。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t1) == <span class="built_in">id</span>(t2)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(t1) == <span class="built_in">hash</span>(t2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>,)])</span><br><span class="line">&#123;(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>,)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(&#123;(<span class="number">1</span>, <span class="number">2</span>): <span class="number">1</span>&#125;)</span><br><span class="line">&#123;(<span class="number">1</span>, <span class="number">2</span>): <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注：在散列时，元组内的每一项元素会被散列然后进行 XOR 异或运算，因此只有当元组中的每个元素都是不可变类型时，该元组才能被散列。</p>
<h2 id="map、filter-与列表推导"><a href="#map、filter-与列表推导" class="headerlink" title="map、filter 与列表推导"></a>map、filter 与列表推导</h2><p>列表是 Python 中非常重要且常用的内置类型，列表被注册为可变序列的虚拟子类，<code>MutableSequence.register(list)</code>，所以列表的性质与可变序列性质相符，可以阅读 <code>collections.abc</code> 模块中 MutableSequence 类的源码进行了解。列表的性质不做过多介绍，这一节我想介绍一下列表推导。在上一节中就曾经使用 <code>all()</code>、<code>any()</code> 方法结合列表推导，巧妙地展示了哪些内置类型是序列类的子类。</p>
<p>在介绍列表推导之前，有必要先介绍以下几个函数：<code>map()</code>、<code>filter()</code> 和 <code>reduce()</code> 函数。这几个函数是函数式编程的范例函数。它们都是用于处理可迭代序列的基本函数，所以被视为可迭代数据集函数式编程的基石，包含了数据集的映射、过滤和规约三个思想。所有支持函数式编程的语言都提供了这些函数的接口。Java 8 新增的 Stream API 配合箭头函数可以写出很优雅的链式函数，同样，JavaScript 中也支持链式写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&gt; l.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x)</span><br><span class="line">[ <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> ]</span><br><span class="line">&gt; l.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x).filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">10</span>)</span><br><span class="line">[ <span class="number">16</span>, <span class="number">25</span> ]</span><br><span class="line">&gt; l.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x).filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">10</span>).reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)</span><br><span class="line"><span class="number">41</span></span><br></pre></td></tr></table></figure>

<p>相比之下，Python 中的写法就不那么优雅了，map、filter 和 reduce 函数作为内置库或者标准库中的函数提供，序列本身并没有实现这些方法，所以不能通过 dot 运算符直接调用，而需要将序列作为这些函数的参数传入。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a><code>map()</code></h3><blockquote>
<p><code>map(func, *iterables) --&gt; map object</code></p>
<p>Make an iterator that computes the function using arguments from each of the iterables.  Stops when the shortest iterable is exhausted.</p>
</blockquote>
<p>map 函数，又称映射函数，定义在内置模块 builtins 模块中。map 函数将可迭代对象的每个元素依次应用于 func 函数进行映射，返回的 map object 是一个可以依次产出映射后元素的生成器对象，可以使用 <code>list()</code> 包装一次性输出。传入的函数 func 可以是预先定义好的函数，也可以是 lambda 表达式定义的匿名函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(square, <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x106ebb910</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(square, <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>

<p>从函数签名来看，map 函数能够接受多个可迭代对象，映射时将依次从每个可迭代对象中各取出一个元素应用于 func 函数，因此 func 也须接受同样数量的参数。如果这些可迭代对象的元素个数不一致，以个数最少的为标杆，即个数最少的可迭代对象遍历完毕时终止迭代。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x * y, <span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x * y, <span class="built_in">range</span>(<span class="number">10</span>), <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a><code>filter()</code></h3><blockquote>
<p><code>filter(function or None, iterable) --&gt; filter object</code></p>
<p>Return an iterator yielding those items of iterable for which function(item) is true. If function is None, return the items that are true.</p>
</blockquote>
<p>filter 函数，又称过滤函数，定义在内置模块 builtins 模块中。过滤函数将可迭代对象中的每个元素应用于谓词函数 function 后为 True 的保留下来。返回的 filter object 也是一个生成器对象，可以依次产出过滤后为真的元素。如果 function 为 None，直接判断元素是否为真值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">5</span>, <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="literal">None</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="number">0.0</span>, -<span class="number">1</span>, [], (<span class="number">1</span>, <span class="number">2</span>)]))</span><br><span class="line">[<span class="number">1</span>, <span class="literal">True</span>, -<span class="number">1</span>, (<span class="number">1</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a><code>reduce()</code></h3><blockquote>
<p><code>reduce(function, sequence[, initial]) -&gt; value</code></p>
<p>Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. For example, reduce(lambda x, y: x + y, [1, 2, 3, 4, 5]) calculates ((((1 + 2) + 3) + 4) + 5).  If initial is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty.</p>
</blockquote>
<p>reduce 函数，又称规约函数，定义在 functools 模块中。规约函数的参数除了函数和序列之外，还接收一个可选的初始值。规约函数会将一个序列从左至右逐步规约为一个值。参数 function 接收两个参数，第一个参数代表每步规约后的累积值（首次规约为初始值），第二个参数代表每次迭代的序列中的元素，返回值为规约的结果，作为下一步规约的第一个参数传入。也就是说，function 函数的第一个参数、每步规约的返回值和 reduce 函数的返回值应为同一类型，function 的第二个参数为迭代序列的元素类型，两者可以是相同类型也可以是不同类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x + y, <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="number">45</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">concat_string</span>(<span class="params">s, ch</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> s + <span class="built_in">str</span>(ch)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(concat_string, [<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>], <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;0a1b&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h3><p>如果想像 JavaScript 代码演示的那样，依次对一个序列数据流进行映射、过滤和规约操作，Python 的写法会显得不那么优雅。由于序列必须作为参数传入，无法放在左侧使用 dot 运算符进行链式书写，我们不得不编写多层嵌套的表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &lt; <span class="number">50</span>, <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, <span class="built_in">range</span>(<span class="number">10</span>))))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(operator.add, (<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &lt; <span class="number">50</span>, <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, <span class="built_in">range</span>(<span class="number">10</span>)))))</span><br><span class="line"><span class="number">140</span></span><br></pre></td></tr></table></figure>

<p>且不说冗余的 lambda 关键字，即使预先定义了函数使用函数名代替，整个表达式从右至左的执行循序也会不利于理解。所幸的是，Python 提供了一种精炼的表达式，来代替多层嵌套下纠缠不清的 map 和 filter 方法，那就是<strong>列表推导</strong>（list comprehension）。</p>
<p>列表推导是一个语法糖，可以根据可迭代对象构建出一个新的列表。列表推导使用一对中括号 “[]”，内部至少包含一个 for 循环表达式，对应 map 方法；以及可选的 if 条件表达式，对应 filter 方法。列表推导返回的是列表类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x &lt; <span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[_ * _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> _ &lt; <span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>,)] <span class="keyword">for</span> x <span class="keyword">in</span> y]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>表达式内的变量是一个局部变量，作用域仅限于该列表推导表达式。但 Python2 中的列表推导存在变量泄漏问题，表达式内的变量会影响到上下文中的同名变量，在 Python 3 中这个缺陷已被修复。</p>
<p>列表推导也支持<strong>多重循环</strong>，即多个 for 循环表达式，这些 for 表达式会按照从左至右的顺序来嵌套。与多层嵌套的 for 循环函数一致，先定义（左侧）的 for 循环在外层，后定义（右侧）的 for 循环在内层。外层定义的变量可用作内层的 for 循环，如上述代码中的最后一个列表推导式。如果用函数形式书写，那么代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>,)] <span class="keyword">for</span> x <span class="keyword">in</span> y]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">flat</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>,)]:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> x <span class="keyword">in</span> y:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(flat())</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>字典和集合也有类似的推导机制，可以通过这些推导机制创建衍生的数据结构。字典推导可以从任何以键值对为元素的可迭代对象中构建出字典。集合推导可以从可迭代对象中去除重复元素，构建集合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;i: j <span class="keyword">for</span> j, i <span class="keyword">in</span> d.items()&#125;  <span class="comment"># 字典推导</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;i <span class="keyword">for</span> i <span class="keyword">in</span> d.keys()&#125;  <span class="comment"># 集合推导</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="列表推导的最佳实践"><a href="#列表推导的最佳实践" class="headerlink" title="列表推导的最佳实践"></a>列表推导的最佳实践</h4><p>使用列表推导的原则是：<strong>只用于创建新的列表，并且尽量保持简短，不建议使用含有两个以上表达式的列表推导</strong>。依照函数式编程中的纯函数定义，函数不应该对传入的参数进行修改，否则会产生副作用。所以列表推导不该对传入序列做修改，而应该只用于创建新的列表。尽量保持简短则是出于可读性的考量。如果包含两个较长的表达式，可以考虑拆分为两行。Python 会忽略 []、{} 和 () 中换行，所以可以省略不太好看的续行符 \。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>

<p>如果列表推导式过长，就要考虑是否需要使用函数形式改写，有时命名清晰且带有缩进的函数可读性要更高。</p>
<p>列表推导也不是银弹，相较于生成器表达式的惰性求值，它会<strong>及早求值</strong>（eager evaluation）。在声明了一个列表推导式时，序列中的所有数据都会被即时处理，并将处理后的完整列表存放在内存中。并且在推导过程中，对于输入序列的每个值都可能创建一个仅含一项元素的全新列表。所以当序列的数据量很大时，如读文件或读数据库，将会消耗大量内存并导致程序崩溃。所以，列表推导另一个最佳实践是：<strong>使用生成器表达式代替数据量较大的列表推导</strong>。生成式表达式将在后续章节进行介绍。</p>
<h2 id="可迭代对象、迭代器和生成器源码分析"><a href="#可迭代对象、迭代器和生成器源码分析" class="headerlink" title="可迭代对象、迭代器和生成器源码分析"></a>可迭代对象、迭代器和生成器源码分析</h2><p>迭代，或称循环，是数据处理的基石。Python 中的可迭代类型的抽象基类定义在 <code>collections.abc</code> 模块中，从抽象层次来说，可以分为以下三类：</p>
<ul>
<li><strong>可迭代对象</strong>，<code>class Iterable(metaclass=ABCMeta)</code>，抽象类；</li>
<li><strong>迭代器</strong>，<code>class Iterator(Iterable)</code>，继承自 Iterable 的抽象类；</li>
<li><strong>生成器</strong>，<code>class Generator(Iterator)</code>，继承自 Iterator 的抽象类。</li>
</ul>
<p>在这三个抽象基类的实现中，都有一个名为 <code>__subclasshook__</code> 的钩子方法，用于将实现了特定方法的类绑定为这些抽象基类的虚拟子类。如下是可迭代对象 Iterable 的部分代码，钩子方法检查了类中有无实现 <code>__iter__</code> 方法，对于实现了的类，会被绑定为 Iterable 的虚拟子类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterable</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span>(<span class="params">cls, C</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterable:</span><br><span class="line">            <span class="keyword">return</span> _check_methods(C, <span class="string">&quot;__iter__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br></pre></td></tr></table></figure>

<p>联系到鸭子类型一节中所说的“协议”的概念，可以得出结论：可迭代对象的协议需要实现 <code>__iter__</code> 方法；类似的，迭代器协议需要同时实现 <code>__iter__</code> 和 <code>__next__</code> 方法；生成器协议要更复杂一些，除了这两个方法外还需要实现  <code>send()</code>、<code>throw()</code> 和 <code>close()</code> 方法，这三个方法体现了生成器除了迭代之外的功能：可以用作<strong>协程</strong>。</p>
<p>除了钩子方法之外，<code>collections.abc</code> 模块中还使用 register 关键字手动绑定了 Iterator 和 Generator 的虚拟子类。这里截取了部分源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dict_keyiterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(&#123;&#125;.keys()))</span><br><span class="line">dict_valueiterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(&#123;&#125;.values()))</span><br><span class="line">dict_itemiterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(&#123;&#125;.items()))</span><br><span class="line">list_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>([]))</span><br><span class="line">range_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(<span class="built_in">range</span>(<span class="number">0</span>)))</span><br><span class="line">set_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(<span class="built_in">set</span>()))</span><br><span class="line">str_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">tuple_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(()))</span><br><span class="line"></span><br><span class="line">Iterator.register(dict_keyiterator)</span><br><span class="line">Iterator.register(dict_valueiterator)</span><br><span class="line">Iterator.register(dict_itemiterator)</span><br><span class="line">Iterator.register(list_iterator)</span><br><span class="line">Iterator.register(range_iterator)</span><br><span class="line">Iterator.register(set_iterator)</span><br><span class="line">Iterator.register(str_iterator)</span><br><span class="line">Iterator.register(tuple_iterator)</span><br><span class="line"></span><br><span class="line">generator = <span class="built_in">type</span>((<span class="keyword">lambda</span>: (<span class="keyword">yield</span>))())</span><br><span class="line">Generator.register(generator)</span><br></pre></td></tr></table></figure>

<p>上述代码出现的所有内置类型，包括 list、range、set、str 和 tuple，都实现了 <code>__iter__</code> 方法，所以都是可迭代对象。特殊一点的是字典的键、值和键值对，也都分别被定义为可迭代的视图类型 KeysView、ValuesView 和 ItemsView。这些类型都是 Python 的集合类型，集合由于继承了 Iterable 类，所以 <strong>Python 中的所有集合都是可迭代对象</strong>。此处说的集合不是内置类型 set 而是 Collection，定义在 <code>collections.abc</code> 模块中。也有人将 Collection 称之为“容器”的，这里将其称之为集合而不是容器是为了与 <code>collections.abc</code> 模块中的另一个类 Container 做区分。集合类的钩子方法会去检测是否实现了 <code>__len__</code>、<code>__iter__</code> 和 <code>__contains__</code> 这三个方法。</p>
<p>尽管上述所说的这些内置类型都是可迭代对象，但要注意它们并不是迭代器，被注册的是经过 <code>iter()</code> 方法包装后的类型。也就是说，访问这些内置类型的 <code>__iter__</code> 方法将会返回一个迭代器，即 <code>iter(iterable) -&gt; iterator</code>。迭代器除了能被 for 循环遍历外，还能使用 <code>next()</code> 方法产出下一个值。编码时如果要使用 <code>next()</code> 方法，首先要注意对象是不是一个迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(l, Iterator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">iter</span>(l)</span><br><span class="line">&lt;list_iterator <span class="built_in">object</span> at <span class="number">0x106e2f640</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(<span class="built_in">iter</span>(l))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>除了可迭代对象和迭代器之外，<code>collections.abc</code> 模块中还定义了生成器类 Generator，并将形如 <code>type((lambda: (yield))())</code> 的类型注册为了生成器的虚拟子类。其中，yield 是一个关键字，意为产出一个值。<strong>只要 Python 函数的定义中含有 yield 关键字，该函数就是生成器函数，调用生成器函数时会返回一个生成器对象</strong>。<code>lambda: (yield)</code> 语句其实是定义了一个返回生成器函数的匿名函数，再调用这个生成器函数得到生成器对象，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> (<span class="keyword">yield</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen()</span><br><span class="line">&lt;generator <span class="built_in">object</span> gen at <span class="number">0x104b36660</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(gen())</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">generator</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">(<span class="params"><span class="keyword">lambda</span>: (<span class="params"><span class="keyword">yield</span></span>)</span>)(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">generator</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>生成器尤为重要，有必要将其作为单独的一节进行介绍。下一节我们将介绍生成器函数的执行过程，以及如何使用生成器表达式返回一个生成器对象。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>所有生成器都是迭代器，因为生成器完全实现了迭代器接口。不过，根据《设计模式：可复用面向对象软件的基础》一书的定义，迭代器用于从集合中取出元素，而生成器用于“凭空”生成元素。通过斐波那契数列能很好地说明二者之间的区别：斐波纳契数列中的数有无穷多个，无法将它们都装在一个集合里，但是生成器可以在每次需要时生成一项元素。因此，尽管 Python 社区中经常将迭代器和生成器视为同一概念，你也要明白生成器所具有的特殊语义。</p>
<h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><p>前面我们说到，生成器函数是包含了 yield 关键字的函数，调用生成器函数时会返回一个生成器对象。也就是说，生成器函数是生成器的工厂函数。因此，生成器函数和普通的函数有着显著的行为差异：即使没有 return 语句，生成器函数依然会返回一个生成器对象。就算有，定义在 yield 语句后的 return 返回值也会被忽略。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen()</span><br><span class="line">&lt;generator <span class="built_in">object</span> gen at <span class="number">0x10ddd9820</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(gen())</span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>“yield” 这个单词，除了产出还有<strong>让步</strong>的含义，对于生成器函数中的 yield 来说，这两个含义都成立。让步体现在，生成器函数在执行到 yield 语句产出值后，会作出让步，暂停执行生成器，让调用方继续工作，直到需要下一个值时再调用 <code>next()</code>。下面使用 for 循环来更清楚地说明生成器函数定义体的执行过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;continue&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> gen_AB():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, c)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">start</span><br><span class="line">--&gt; A</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">--&gt; B</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>迭代时，for 机制的作用与 <code>g = iter(gen_AB())</code> 一样，生成器的 <code>__iter__</code> 方法会返回生成器对象本身，然后每次迭代时调用 <code>next(g)</code>。</p>
<ul>
<li>在 for 循环中第一次隐式调用 next 函数时，会打印 ‘start’，然后停留在第一个 yield 语句，产出值 ‘A’；</li>
<li>第二次隐式调用 next 函数时，会打印 ‘continue’，然后停留在第一个 yield 语句，产出值 ‘B’；</li>
<li>第三次隐式调用 next 函数时，打印 ‘end’，到达函数定义体的末尾，导致生成器对象抛出 StopIteration 异常。for 机制会捕获异常，因此循环终止时不会报错。</li>
</ul>
<p>如果显式调用 <code>next()</code> 方法，那么生成器函数定义体被执行的过程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = <span class="built_in">iter</span>(gen_AB())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line">start</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line">end</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>在这个例子中你可以看到，定义在生成器函数体内的 print 语句并没有在生成器函数被调用时就立即打印，而被延迟到调用 <code>next(g)</code> 时才打印。同样，如果在生成器函数中加入复杂的处理逻辑，该逻辑只在被 <code>next()</code> 调用时才进行处理，从而达到延迟处理的目的。我们将生成器的这一特性归纳为<strong>惰性求值</strong>（lazy evaluation），即尽可能地延后求值，只在需要时才进行求值。这样做的优点是可以节省内存，还可能避免无用的处理。</p>
<p>与惰性求值相对的是<strong>及早求值</strong>（eager evaluation），比如之前介绍的列表推导，列表这种数据结构一定要求内部的元素是已明确其值的，并且会将完整的列表保存在内存中。因此，《Effective Python》中提出这么一条：<strong>考虑用生成器来改写直接返回列表的函数</strong>。实际上，Python 3 已经对一些原本原本返回列表的函数使用生成器进行了改写。比如 Python 2 中返回完整列表的 <code>range()</code> 函数，现在也返回一个类似生成器的对象。如果一定要让 <code>range()</code> 函数返回列表，必须明确指明，如 <code>list(range(100))</code>。</p>
<p>定义生成器函数时，唯一需要留意的就是：<strong>函数返回的那个迭代器是有状态的</strong>，调用者不应该反复使用它。</p>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>除了定义包含 yield 关键字的生成器函数可以返回生成器外，生成器表达式也可以返回生成器对象。相比于列表推导的及早求值，生成器表达式能够进行惰性求值：不会迫切地构建列表，而是返回一个生成器，按需产出元素。也就是说，如果说列表推导时构建列表的工厂，那么生成器表达式就是构建生成器的工厂。</p>
<p>生成器表达式与列表推导的唯一区别是使用了一对圆括号 “()” 代替列表推导中的中括号 “[]”。我们使用之前定义的生成器函数 <code>gen_AB()</code> 来演示生成器表达式与列表推导之间的区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()]  <span class="comment"># list comprehension</span></span><br><span class="line">start</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> res1:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">--&gt; A</span><br><span class="line">--&gt; B</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB())  <span class="comment"># generator expression</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x10dea8f20</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> res2:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">start</span><br><span class="line">--&gt; A</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">--&gt; B</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>归因于列表的及早求值，在声明列表推导表达式时，<code>gen_AB()</code> 函数中的 print 语句被立即执行了，函数产出的两个值 ‘A’、’B’ 也被存放在构建出的列表中。而生成器表达式则将这个过程推迟到值真正需要之时，即 for 循环隐式调用 <code>next()</code> 之时。</p>
<p>前面提到，生成器对象是有状态的，这里体现在，一个生成器对象产出的值只能被消费一次，除非定义一个新的个生成器对象重新绑定。你可以想象成，生成器对象中存在不能回头的“指针”，每次调用 <code>next()</code> 方法时指向下一个元素，这个过程不可逆。所以对于同一个生成器对象重复调用时可能会产生意想不到的结果。比如下面代码中第二次调用 <code>list(res2)</code> 返回一个空列表，因为第一次调用时“指针”就已经到头了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(res2)</span><br><span class="line">start</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(res2)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(res2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>所以如果要对生成器对象进行多次迭代，一种方法是使用列表将生成器中的所有元素备份下来，另一种是定义一个新的生成器对象重新绑定。由此可见，尽管生成器对象相比列表能够通过惰性求值节省内存，但如果每次迭代时定义新的生成器对象，求值过程也会被重复多次。而列表推导只会在声明时进行一次求值，并将结果保存在列表中可供多次迭代调用，这其实是一种空间消耗和时间消耗的权衡。</p>
<h3 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h3><p>刚才所提到的生成器产出值被消费的概念，也侧面体现了生成器可以作为“协程”的语义。“协程”从字面意思理解就是协作的进程，协作的进程之间需要进行通信，就需要消费者和生产者之间建立通道。从 Python 3.3 开始引入了一个新的句法：<code>yield from</code>，类似于其他语言中的 await 关键字。它可以在两个生成器之间建立通道，将产出的值从一个生成器传输到另一个生成器。</p>
<p>如果生成器函数需要产出其他生成器的值，传统的做法是使用 for 循环遍历生成器的元素并产出。以下定义了一个能够产出多个生成器产出值的生成器函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">chain</span>(<span class="params">*iterables</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> i</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1 = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(chain(g1, g2))</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>引入的 <code>yield from</code> 句法可以直接将一个生成器的所有产出值产出，而不用遍历生成器对象。因此我们可以编写只有一层的 for 循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">chain</span>(<span class="params">*iterables</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> <span class="keyword">from</span> it</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1 = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain(g1, g2)</span><br><span class="line">&lt;generator <span class="built_in">object</span> chain at <span class="number">0x10dea8e40</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(chain(g1, g2))</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>chain 函数依然返回一个生成器对象，其中的 <code>yield from it</code> 语句对 it 对象所做的第一件事是调用 <code>iter(it)</code> 获得一个迭代器，所以 it 对象可以是任何可迭代对象。我们将 <code>yield from &lt;iterable&gt;</code> 表达式中用于获取值的 <code>&lt;iterable&gt;</code> 称为<strong>子生成器</strong>（subgenerator），即上面代码中的 g1、g2；将包含了 <code>yield from</code> 语句的生成器函数，即 chain 函数，称为委派生成器。<code>yield from</code> 的主要功能是打开双向通道，把最外层的调用层与最内层的子生成器连接起来，这样二者可以直接发送和产出值。</p>
<p>上述的例子只能勉强算一个协程的案例，其中的“协作”部分体现的不够明显，只是简单的将一个生成器的值传输给另一个生成器产出。真正的协作应该是通过生成器对象的 <code>send()</code> 方法将值从客户端传输给生成器。在后面章节我们会专门介绍协程，里面会提及生成器的 <code>send()</code>、<code>throw()</code> 和 <code>close()</code> 方法，以及 <code>yield from</code> 句法的其他作用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/03/18/Python-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/18/Python-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" class="post-title-link" itemprop="url">Python 运算符重载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-18 11:44:40" itemprop="dateCreated datePublished" datetime="2021-03-18T11:44:40+08:00">2021-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>运算符重载这个语言特性其实一直备受争议，鉴于太多 C++ 程序员滥用这个特性，Java 之父 James Gosling 很干脆的决定不为 Java 提供运算符重载功能。但另一方面，正确的使用运算符重载确实能提高代码的可读性和灵活性。为此，Python 施加了一些限制，在灵活性、可用性和安全性之间做到了平衡。主要包括：</p>
<ul>
<li>不能重载内置类型的运算符</li>
<li>不能新建运算符，只能重载现有的</li>
<li>is、and、or 和 not 运算符不能重载（但位运算符 &amp;、| 和 ~ 可以）</li>
</ul>
<p>Python 的运算符重载非常方便，只需要<strong>重写对应的特殊方法</strong>。在上面一节我们已经介绍了如何重载一个向量类的 “+” 和 “==” 运算符，实现还算简单，接下来我们考虑一个更复杂的情形：不只限于二维向量相加的 Vector 类，以引入 Python 运算符重载更全面的知识点。</p>
<h3 id="改进版的-Vector"><a href="#改进版的-Vector" class="headerlink" title="改进版的 Vector"></a>改进版的 Vector</h3><p>考虑到高维向量的应用场景，我们应当支持不同维度向量的相加操作，并且为低维向量的缺失值做默认添 0 处理，这也是一些统计分析应用的常用缺失值处理方式。基于此，首先要确定的便是，Vector 类的构造函数不再只接收固定数量和位置的参数，而应当接收可变参数。</p>
<p>通常情况下，Python 函数接收可变参数有两种处理方式。一种是接收不定长参数，即 <code>*args</code>，这样我们就可以用类似 <code>Vector(1, 2)</code> 或 <code>Vector(1, 2, 3)</code> 的方式来初始化不同维数的向量类。在这种情况下，函数会将不定长参数打包成名为 <code>args</code> 的元组进行处理，当然能满足迭代的需求。虽然这种方式看上去很直观，但考虑到向量类从功能上讲也是一个序列类，而 Python 中的内置序列类型的构造方法基本上都是接收<strong>可迭代对象</strong>（Iterable）作为参数，考虑到一致性我们也采取这种形式，并且通过重写 <code>__repr__</code> 输出更直观的向量类的数学表示形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, components: Iterable</span>):</span></span><br><span class="line">        self._components = array(<span class="string">&#x27;i&#x27;</span>, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self._components))</span><br></pre></td></tr></table></figure>

<p>为了方便之后对向量分量的处理，将其保存在一个数组中，第一个参数 ‘i’ 标明这是一个整型数组。这样做还有一个好处就是，保证了向量序列的不可变性，这一点同 Python 内置类型不可变列表 tuple 类似。如此定义后，我们可以这样实例化 Vector 类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector(<span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>由于 Vector 类接收 Iterable 对象作为构造参数，而任何实现了 <code>__iter__</code> 方法的类都会被绑定为 Iterable 的子类，所以可以传入 list、tuple 和 range 等可迭代对象。</p>
<p>接下来，重载 Vector 类的加号运算符，为了满足之前所说的低维向量默认添 0 处理，我们引入迭代工具包下的 <code>zip_longest</code> 方法，它可以接收多个可迭代对象，将其打包成一个个的元组，如 <code>zip_longest(p, q, ...) --&gt; (p[0], q[0]), (p[1], q[1]), ...</code>。同时关键字参数 fillvalue 可以指定填充的默认值。但在这之前，由于 <code>zip_longest</code> 参数必须是可迭代对象，我们还需要为 Vector 类实现 <code>__iter__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br></pre></td></tr></table></figure>

<p><code>__add__</code> 的实现逻辑很简单，按位相加返回一个新的 Vector 对象，在构造 Vector 对象时使用到了生成器表达式，而生成器 Generator 是 Iterable 的子类，所以也符合构造参数的要求。</p>
<p>为了验证效果，还需要重载 <code>==</code> 运算符，考虑到两个向量维度可能不同，首先要对维度，也就是向量分量的个数进行比较，为此需要重写 <code>__len__</code> 方法。其次是进行按位比较，内置的 zip 函数可以将两个迭代对象打包从而同时进行遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self) == <span class="built_in">len</span>(other) <span class="keyword">and</span> <span class="built_in">all</span>(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(self, other))</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践：用 zip 函数同时遍历两个迭代器</strong>。《Effective Python》的第 11 条提到了这一点。在 Python 中经常会遇到需要平行地迭代两个序列的情况。一般的做法是，写一个 for 循环对一个序列进行迭代，然后想办法获得其索引，通过索引访问第二个序列的对应元素。常见的做法是借助 enumerate 函数，通过 <code>for index, item in enumerate(items)</code> 的方式获取索引。现在有一种更优雅的写法，使用内置的 zip 函数，它可以将两个及以上的迭代器封装成生成器，这个生成器能在每次迭代时从每个迭代器中取出下一个值构成元组，再结合元组拆包就能达到平行取值的目的，如上述代码中的 <code>for a, b in zip(self, other)</code>。显然，这种方式可读性更高。但如果待遍历序列不等长，zip 函数会提前终止，这可能导致意外的结果。所以在<strong>不确定序列是否等长</strong>的条件下，可以考虑使用 itertools 模块中过的 <code>zip_longest</code> 函数。</p>
<p>至此，重载的 “+” 和 “==” 运算符初步完成了，可以编写测试用例进行验证了，作为本系列第一个比较全面的测试类，我将在文末贴出完整的测试代码，这里先在控制台演示重载之后的效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + Vector((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>由于 <code>__add__</code> 方法中的 other 只要求是可迭代对象而没有类型限制，所以重载的加号运算符不止可以对两个 Vector 实例进行相加，也支持 Vector 实例与一个可迭代对象相加，不管是 list、tuple 还是其他 Iterable 类型。但需要注意的是，可迭代对象必须作为第二个操作数，也就是 “+” 右侧的操作数。理解这一点并不难，因为我们只实现了 Vector 的 <code>__add__</code> 方法，而 Python 的内置类型类可不明白怎么对加上一个向量进行处理，比如下面报错提示的 tuple 类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">1</span>) + v1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate <span class="built_in">tuple</span> (<span class="keyword">not</span> <span class="string">&quot;Vector&quot;</span>) to <span class="built_in">tuple</span></span><br></pre></td></tr></table></figure>

<h4 id="反向运算符"><a href="#反向运算符" class="headerlink" title="反向运算符"></a>反向运算符</h4><p>那么有什么方法，不需要重写 tuple 类中的 <code>__add__</code> 方法（显然这种方式也不合理），也能使重载的加号运算符支持 <code>(1, 1) + v1</code> 呢？答案是有的，在此之前，不得不提到 Python 的<strong>运算符分派机制</strong>。</p>
<p>对于中缀运算符，Python 提供了特殊的分派机制。对于表达式 <code>a + b</code>，解释器会执行以下几步操作：</p>
<ol>
<li>如果 a 有 <code>__add__</code> 方法且不返回 NotImplemented，调用 <code>a.__add__(b)</code>；</li>
<li>如果 a 没有 <code>__add__</code> 方法或调用返回 NotImplemented，检查 b 有没有 <code>__radd__</code> 方法，如果有且不返回 NotImplemented，调用 <code>b.__radd__(a)</code>；</li>
<li>如果 b 没有 <code>__radd__</code> 方法或调用返回 NotImplemented，抛出 TypeError。</li>
</ol>
<p>注：NotImplemented 是 Python 内置的特殊单例值，如果运算符特殊方法不能处理给定的操作数，那么要把它返回给解释器。</p>
<p>如果将 <code>__add__</code> 称为正向方法，那么 <code>__radd__</code> 就可以称为 <code>__add__</code> 方法的<strong>反向方法</strong>，或者右向方法，这个方法的作用是支持操作数从右至左进行计算。因此，为了支持 <code>(1, 1) + v1</code>，我们需要定义 Vector 类的反向方法。而反向方法只需要委托给已经定义好的 <code>__add__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self + other</span><br></pre></td></tr></table></figure>

<p><code>__radd__</code> 通常就是这么简单，由于解释器调用的是 <code>b.__radd__(a)</code>，而这里的 b 即 v1 是一个 Vector 实例，能够与一个元组相加，所以这时 <code>(1, 1) + v1</code> 不会再报错。同时，还对 <code>__add__</code> 方法做了些修改：<strong>捕获 TypeError 异常并返回 NotImplemented</strong>。这也是一种重载中缀运算符时的最佳实践，抛出异常将导致算符分派机制终止，而抛出 NotImplemented 则会让解释器再尝试调用反向运算符方法。当运算符左右操作数是不同类型时，反向方法也许能够正常运算。</p>
<p>现在，验证重载的反向运算符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">1</span>) + v1</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] + v1</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>对于比较运算符，正向和反向调用使用的是同一系列方法，只不过对调了参数。注意是同一系列而不是同一方法。例如，对 “==” 来说，正向调用是 <code>a.__eq__(b)</code>，那么反向调用就是 <code>b.__eq__(a)</code>；而对 “&gt;” 来说，正向 <code>a.__gt__(b)</code> 的反向调用是 <code>b.__lt__(a)</code>。</p>
<p>如果正向调用左操作数的 <code>__eq__</code> 方法返回 NotImplemented，Python 解释器会去尝试反向调用右操作数的 <code>__eq__</code> 方法，若右操作数也返回 NotImplemented，解释器不会抛出 TypeError 异常，而是会比较对象的 ID 作最后一搏。</p>
<p>对元组和 Vector 实例比较的具体步骤如下：</p>
<ol>
<li>尝试调用 tuple 的 <code>__eq__</code> 方法，由于 tuple 不认识 Vector 类，返回 NotImplemented；</li>
<li>尝试调用 Vector 的 <code>__eq__</code> 方法，返回 True。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">2</span>) == Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>另外，对于 “!=” 运算符，Python 3 的最佳实践是只实现 <code>__eq__</code> 方法而不实现它，因为从 object 继承来的 <code>__ne__</code> 方法会对 <code>__eq__</code> 返回的结果取反。而 Python 2 则不同，重载 “==” 的同时也应重载 “!=” 运算符。Python 之父 Guido 曾提到这是 Python 2 的一个设计缺陷且已在 Python 3 中修复了。</p>
<h4 id="就地运算符"><a href="#就地运算符" class="headerlink" title="就地运算符"></a>就地运算符</h4><p>增量赋值运算符，也称就地运算符，如 “+=”，有两种运算方式。对于不可变类型来说，<code>a += b</code> 的作用与 <code>a = a + b</code> 完全一致，增量赋值不会修改不可变目标，而是<strong>新建实例</strong>，然后重新绑定，也就是说运算前后的 a 不是同一对象。对于不可变类型，这是预期的行为。</p>
<p>而对于实现了就地运算符方法，如 <code>__iadd__</code>，的可变类型来说，<code>a += b</code> 会调用该方法就地修改左操作数，而不是创建一个新的对象。这一点，Python 的内置类型，不可变的 tuple 和可变的 list 就可以很好的说明。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4359598592</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t += (<span class="number">3</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4359584960</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4360054336</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4360054336</span></span><br></pre></td></tr></table></figure>

<p>阅读源码你会发现，list 类 实现了 <code>__iadd__</code> 方法而 tuple 类没有实现。对 list 而言，”+=” 就地运算符的逻辑与其 <code>extend()</code> 方法相同，将一个可迭代对象的元素依次追加到当前列表的末尾。而对 tuple 而言，即使没有定义 <code>__iadd__</code> 方法，使用 “+=” 也会委托给 <code>__add__</code> 方法进行运算返回一个新的 tuple 对象。</p>
<p>从设计层面考虑，Vector 应当与元组一致，被设计成不可变类型，即每次对向量进行运算后生成一个新的向量。站在函数式编程的角度，这种设计无副作用（不在函数内部修改传入参数状态），从而避免一些难以预料的问题。因此<strong>对于不可变类型，一定不能实现就地特殊方法</strong>。对 Vector 使用 “+=” 运算符会调用现有的 <code>__add__</code> 方法生成一个新的 Vector 实例。<code>v1 += (1, 1)</code> 与 <code>v1 = v1 + (1, 1)</code> 行为一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(v1)</span><br><span class="line"><span class="number">4360163280</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 += (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(v1)</span><br><span class="line"><span class="number">4359691376</span></span><br></pre></td></tr></table></figure>

<h3 id="附录：代码"><a href="#附录：代码" class="headerlink" title="附录：代码"></a>附录：代码</h3><h4 id="vector-py"><a href="#vector-py" class="headerlink" title="vector.py"></a>vector.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, components: Iterable</span>):</span></span><br><span class="line">        self._components = array(<span class="string">&#x27;i&#x27;</span>, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self._components))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self) == <span class="built_in">len</span>(other) <span class="keyword">and</span> <span class="built_in">all</span>(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(self, other))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self + other</span><br></pre></td></tr></table></figure>

<h4 id="vector-test-py"><a href="#vector-test-py" class="headerlink" title="vector_test.py"></a>vector_test.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestVector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_compare_two_vectors_with_override_compare_operators</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        v2 = Vector((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        v3 = Vector([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">        v4 = Vector([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> v1 == v2</span><br><span class="line">        <span class="keyword">assert</span> v3 != v2</span><br><span class="line">        <span class="keyword">assert</span> v4 != v3</span><br><span class="line">        <span class="keyword">assert</span> (<span class="number">1</span>, <span class="number">2</span>) == v2</span><br><span class="line">        <span class="keyword">assert</span> v2 == [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_add_two_same_dimension_vectors_with_override_add_operator</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        v2 = Vector((<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        result = Vector([<span class="number">2</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> result == v1 + v2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_add_two_different_dimension_vectors_with_override_add_operator</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        v2 = Vector((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        result = Vector([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> result == v1 + v2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_add_vector_and_iterable_with_override_add_operator</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> v1 + (<span class="number">1</span>, <span class="number">1</span>) == (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">assert</span> v1 + [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] == (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_add_iterable_and_vector_with_override_radd_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> (<span class="number">1</span>, <span class="number">1</span>) + v1 == (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] + v1 == (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_create_new_vector_when_use_incremental_add_operator</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        id1 = <span class="built_in">id</span>(v1)</span><br><span class="line">        v1 += (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">id</span>(v1) != id1</span><br></pre></td></tr></table></figure>

<h3 id="附录：常见可重载运算符"><a href="#附录：常见可重载运算符" class="headerlink" title="附录：常见可重载运算符"></a>附录：常见可重载运算符</h3><h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">特殊方法</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center"><code>__neg__</code></td>
<td align="left">一元取负算术运算符</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center"><code>__pos__</code></td>
<td align="left">一元取正算术运算符</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center"><code>__invert__</code></td>
<td align="left">对整数按位取反，定义为 ~x == -(x+1)</td>
</tr>
</tbody></table>
<h4 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">正向方法</th>
<th align="center">反向方法</th>
<th align="center">就地方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center"><code>__add__</code></td>
<td align="center"><code>__radd__</code></td>
<td align="center"><code>__iadd__</code></td>
<td align="center">加法或拼接</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><code>__sub__</code></td>
<td align="center"><code>__rsub__</code></td>
<td align="center"><code>__isub__</code></td>
<td align="center">减法</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center"><code>__mul__</code></td>
<td align="center"><code>__rmul__</code></td>
<td align="center"><code>__imul__</code></td>
<td align="center">乘法或重复复制</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center"><code>__truediv__</code></td>
<td align="center"><code>__rtruediv__</code></td>
<td align="center"><code>__itruediv__</code></td>
<td align="center">除法</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center"><code>__floordiv__</code></td>
<td align="center"><code>__rfloordiv__</code></td>
<td align="center"><code>__ifloordiv__</code></td>
<td align="center">整除</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center"><code>__mod__</code></td>
<td align="center"><code>__rmod__</code></td>
<td align="center"><code>__imod__</code></td>
<td align="center">取模</td>
</tr>
<tr>
<td align="center"><code>divmod()</code></td>
<td align="center"><code>__divmod__</code></td>
<td align="center"><code>__rdivmod__</code></td>
<td align="center"><code>__idivmod__</code></td>
<td align="center">返回由整除的商和模数组成的元组</td>
</tr>
<tr>
<td align="center">**，<code>pow()</code></td>
<td align="center"><code>__pow__</code></td>
<td align="center"><code>__rpow__</code></td>
<td align="center"><code>__ipow__</code></td>
<td align="center">取幂</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center"><code>__matmul__</code></td>
<td align="center"><code>__rmatmul__</code></td>
<td align="center"><code>__imatmul__</code></td>
<td align="center">矩阵乘法</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center"><code>__and__</code></td>
<td align="center"><code>__rand__</code></td>
<td align="center"><code>__iand__</code></td>
<td align="center">按位与</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center"><code>__or__</code></td>
<td align="center"><code>__ror__</code></td>
<td align="center"><code>__ior__</code></td>
<td align="center">按位或</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center"><code>__xor__</code></td>
<td align="center"><code>__rxor__</code></td>
<td align="center"><code>__ixor__</code></td>
<td align="center">按位异或</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center"><code>__lshift__</code></td>
<td align="center"><code>__rlshift__</code></td>
<td align="center"><code>__ilshift__</code></td>
<td align="center">按位左移</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center"><code>__rshift__</code></td>
<td align="center"><code>__rrshift__</code></td>
<td align="center"><code>__irshift__</code></td>
<td align="center">按位右移</td>
</tr>
</tbody></table>
<h4 id="比较运算符-1"><a href="#比较运算符-1" class="headerlink" title="比较运算符"></a>比较运算符</h4><table>
<thead>
<tr>
<th align="center">分组</th>
<th align="center">中缀运算符</th>
<th align="center">正向方法调用</th>
<th align="center">反向方法调用</th>
<th align="center">后备机制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">相等性</td>
<td align="center">a == b</td>
<td align="center"><code>a.__eq__(b)</code></td>
<td align="center"><code>b.__eq__(a)</code></td>
<td align="center">返回 <code>id(a) == id(b)</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a != b</td>
<td align="center"><code>a.__ne__(b)</code></td>
<td align="center"><code>b.__ne__(a)</code></td>
<td align="center">返回 <code>not (a == b)</code></td>
</tr>
<tr>
<td align="center">排序</td>
<td align="center">a &gt; b</td>
<td align="center"><code>a.__gt__(b)</code></td>
<td align="center"><code>b.__lt__(a)</code></td>
<td align="center">抛出 TypeError</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a &lt; b</td>
<td align="center"><code>a.__lt__(b)</code></td>
<td align="center"><code>b.__gt__(a)</code></td>
<td align="center">抛出 TypeError</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a &gt;= b</td>
<td align="center"><code>a.__ge__(b)</code></td>
<td align="center"><code>b.__le__(a)</code></td>
<td align="center">抛出 TypeError</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a &lt;= b</td>
<td align="center"><code>a.__le__(b)</code></td>
<td align="center"><code>b.__ge__(a)</code></td>
<td align="center">抛出 TypeError</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/03/10/Python-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/10/Python-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Python 鸭子类型和特殊方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-10 22:19:15" itemprop="dateCreated datePublished" datetime="2021-03-10T22:19:15+08:00">2021-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Python-是动态强类型语言"><a href="#Python-是动态强类型语言" class="headerlink" title="Python 是动态强类型语言"></a>Python 是动态强类型语言</h2><blockquote>
<p><strong>Dynamic programming language</strong>: In computer science, a dynamic programming language is a class of high-level programming languages, which at runtime execute many common programming behaviours that <strong>static programming languages perform during compilation</strong>. These behaviors could include an extension of the program, by <strong>adding new code, by extending objects and definitions, or by modifying the type system</strong>.</p>
</blockquote>
<p>以上内容摘自维基百科对于动态编程语言（Dynamic programming language）的定义。动态语言是相对于静态语言而言的。相比之下，静态语言有更严格的语法限制，在编译阶段就能够确定数据类型，典型的静态语言包括 C、C++ 和 Java 等。这一类语言的优势在于代码结构规范，易于调试和重构。缺点则是语法冗杂，编码方式不灵活。</p>
<p>而动态语言最典型的特点在于不需要编码时指定数据类型，类型信息由运行时推断得出。常见的动态语言都是一些脚本语言，比如 JavaScript、Python、PHP 等。这类语言虽然调试和重构的支持不如静态语言，但由于没有类型约束编码更加灵活。</p>
<p>Python 就是一门动态编程语言，编码时不用指定类型，且运行时可以变更数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">a</span> = &#x27;1&#x27;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">a</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>尽管 “PEP 484 – Type Hints” 引入了类型提示，但它明确指出：Python 依旧是一门动态类型语言，作者从未打算强制要求使用类型提示，甚至不会把它变成约定。但是 API 作者能够添加可选的类型注解，执行某种静态类型检查。</p>
<p>另外值得注意的是，虽然 Python 支持运行时变更数据类型，但变量所指向的内存地址空间已经在变更时发生了变化。也就是说，数据类型变更后不再指向原先的内存地址空间。我们可以用查看对象内存地址的 <code>id()</code> 函数加以验证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">4316699376</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">123456</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">4316579216</span></span><br></pre></td></tr></table></figure>

<h3 id="强弱类型"><a href="#强弱类型" class="headerlink" title="强弱类型"></a>强弱类型</h3><p>确定了 Python 是动态语言后，接下来我们讨论<strong>强弱类型</strong>语言。首先，强弱类型与是否是动态语言没有必然联系，动态语言并不一定就是弱类型语言，Python 就是一门动态强类型语言。这里的“强弱”可以理解为用以<strong>描述编程语言对于混入不同类型的值进行运算时的处理方式</strong>。</p>
<p>比如在弱类型语言 JavaScript 中，我们可以直接对字符串和数值类型进行相加，虽然得出的结果并不一定是我们想要的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">&#x27;1&#x27;</span> + <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>

<p>出现这种现象的原因是 JavaScript 支持<strong>变量类型的隐式转换</strong>。上面的例子就是将数值类型隐式转换为了字符串类型再进行相加。也因此，JavaScript 中才会存在三个等号的判等运算符 <code>===</code>。与 <code>==</code> 不同，<code>===</code> 在判等时不会进行隐式转换，所以才会有下面这样的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span> == <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="number">1</span> === <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>而 Python 作为强类型语言，不支持类型的隐式转换，所以整型和字符型相加会直接报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> + <span class="string">&#x27;2&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">&#x27;int&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>

<p>所以，强弱类型语言的区别体现在：强类型语言在遇到函数声明类型和实际调用类型不符合的情况时会直接出错或者编译失败；而弱类型的语言可能会进行隐式转换，从而产生难以意料的结果。</p>
<h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><p>在面向对象的静态类型语言中，如果要实现一个带特定功能的序列类型，你可能会想到使用继承，以期能在添加特定功能的同时尽可能的重用代码。这符合面向对象的设计原则，但在 Python 中，继承却不是首选方案。</p>
<p>在 Python 这类动态类型语言中，有一种风格叫做<strong>鸭子类型</strong>（duck typing）。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口决定的，而是由”<strong>当前方法和属性的集合</strong>“决定。这个概念最早来源于 James Whitcomb Riley 提出的“鸭子测试”，“鸭子测试”可以这样表述：“如果一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么它就可以被称为鸭子。”</p>
<p>在 Python 中创建功能完善的序列类型无需使用继承，只需实现符合序列协议的方法。那么，协议又是什么呢？在面向对象编程中，协议是非正式的接口，只在文档中定义，不在代码中定义，可以看作是约定俗成的惯例。例如，Python 的迭代器协议就包含 <code>__iter__</code> 和 <code>__next__</code> 两个方法，任何实现了 <code>__iter__</code> 和 <code>__next__</code> 方法的类，Python 解释器会将其视为迭代器，所有迭代器支持的操作，该类也会支持，譬如 <code>next()</code> 方法和 <code>for</code> 循环。用鸭子类型来解释就是：这个类看起来像是迭代器，那它就是迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">IterDuck</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = IterDuck()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(IterDuck, Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(i, Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>由于实现了迭代器协议，上面代码中的 IterDuck 类甚至不需要显式的继承 Iterator 类，Python 解释器就已经将它绑定为 Iterator 类的子类。</p>
<p><strong>在鸭子类型中，关注点在于对象的行为，即提供的方法，而不在于对象所属的类型。</strong></p>
<h3 id="序列协议"><a href="#序列协议" class="headerlink" title="序列协议"></a>序列协议</h3><p>序列协议之所以要专门作为单独的一节，是因为序列在 Python 中尤为重要，Python 会特殊对待看起来像是序列的对象。序列协议包含 <code>__len__</code> 和 <code>__getitem__</code> 两个方法。任何类，只要实现了 <code>__len__</code> 和 <code>__getitem__</code> 方法，就可以被看作是一个序列，即使这一次 Python 解释器不再将其绑定为 Sequence 类的子类。</p>
<p>由于序列的特殊性，如果你知道类的具体应用场景，甚至只需要实现序列协议的一部分。下面的代码演示了一个只实现了 <code>__getitem__</code> 方法的类，对于序列操作的支持程度：尽管只实现了 <code>__getitem__</code> 方法，但 SeqDuck 实例却可以使用 <code>for</code> 循环迭代以及 <code>in</code> 运算符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">SeqDuck</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">range</span>(<span class="number">3</span>)[index]</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SeqDuck()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>]  <span class="comment"># __getitem__</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> s: <span class="built_in">print</span>(i)  <span class="comment"># __iter__</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> <span class="keyword">in</span> s  <span class="comment"># __contains__</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>即使没有 <code>__iter__</code> 方法，SeqDuck 实例依然是可迭代的对象，因为当 Python 解释器发现存在 <code>__getitem__</code> 方法时，会尝试调用它，传入从 0 开始的整数索引进行迭代（这是一种后备机制）。同样的，即使没有 <code>__contains__</code> 方法，但 Python 足够智能，能够迭代 SeqDuck 实例检查有没有指定元素。</p>
<p>综上，鉴于序列协议的重要性，如果没有 <code>__iter__</code> 和 <code>__contains__</code> 方法，Python 会尝试调用 <code>__getitem__</code> 方法设法让迭代和 <code>in</code> 运算符可用。</p>
<h3 id="绑定虚拟子类"><a href="#绑定虚拟子类" class="headerlink" title="绑定虚拟子类"></a>绑定虚拟子类</h3><p>你也许会有个疑问，为什么 IterDuck 和 SeqDuck 都没有显示继承父类，但 IterDuck 却是 Iterator 类的子类，而 SeqDuck 不是 Sequence 的子类呢？这要归因于 Python 的<strong>虚拟子类</strong>机制。一般情况下，使用 <code>register()</code> 方法可以将一个类注册为另一个类的虚拟子类，比如 <code>collections.abc</code> 模块中是这样将内置类型 tuple、str、range 和 memoryview 注册为序列类 Sequence 的虚拟子类的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">tuple</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">str</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">range</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">memoryview</span>)</span><br></pre></td></tr></table></figure>

<p>这也是为什么这些类的显示继承父类是 object，但同样能应用序列类的诸多方法。而对于用户自定义的类型来说，<strong>即使不注册，抽象基类也能把一个类识别为虚拟子类，这需要抽象基类实现一个名为 <code>__subclasshook__</code> 的特殊的钩子方法</strong>。如下是 <code>collections.abc</code> 模块中 Iterator 抽象基类的源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _collections_abc.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>(<span class="params">Iterable</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span>(<span class="params">cls, C</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterator:</span><br><span class="line">            <span class="keyword">return</span> _check_methods(C, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__next__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br></pre></td></tr></table></figure>

<p>对于实现了迭代器协议，即 <code>__iter__</code> 和 <code>__next__</code> 方法的类来说，它就会被钩子方法检测到并绑定为 Iterator 的虚拟子类，这解释了为什么 <code>issubclass(IterDuck, Iterator)</code> 会验证通过。类似的，可迭代对象 Iterable 协议要更加宽松，因为它只检查了 <code>__iter__</code> 方法。</p>
<p>那么为什么 SeqDuck 没有被绑定为 Sequence 的子类呢？因为 Sequence 类没有实现 <code>__subclasshook__</code> 钩子方法。Python 对序列的子类要求更加严格，即使实现了序列协议 <code>__len__</code> 和 <code>__getitem__</code> 方法的类可以被视为一个序列，但依然不能称之为序列的子类。最典型的例子就是内置类型字典。虽然字典实现了这两个方法，但它不能通过整数偏移值获取元素，且字典内的元素顺序是无序的，所以不能将其视为 Sequence 的子类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> <span class="type">Sequence</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;__getitem__&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">dict</span>) <span class="keyword">and</span> <span class="string">&#x27;__len__&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">dict</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">dict</span>, <span class="type">Sequence</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(d, <span class="type">Sequence</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">1</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>想要更深入地理解鸭子类型，必须要了解 Python 中的特殊方法。前面我们提到的以双下划线开头和结尾的方法，比如 <code>__iter__</code>，就称为<strong>特殊方法</strong>（special methods），或称为<strong>魔法方法</strong>（magic methods）。</p>
<p>Python 标准库和内置库包含了许多特殊方法，需要注意的是，永远不要自己命名一个新的特殊方法，因为你不知道下个 Python 版本会不会将其纳入到标准库中。我们需要做的，是重写现有的特殊方法，并且通常情况下，不需要显式的调用它们，应当使用更高层次的封装方法，比如使用 <code>str()</code> 代替 <code>__str__()</code>，对特殊方法的调用应交由 Python 解释器进行。</p>
<p>Python 对于一些内置方法及运算符的调用，本质上就是调用底层的特殊方法。比如在使用 <code>len(x)</code> 方法时，实际上会去查找并调用 x 对象的 <code>__len__</code> 方法；在使用 <code>for</code> 循环时，会去查找并调用对象的 <code>__iter__</code> 方法，如果没有找到这个方法，那会去查找对象的 <code>__getitem__</code> 方法，正如我们之前所说的这是一种后备方案。</p>
<p>可以说，特殊方法是 Python 语言灵活的精髓所在，下面我们结合鸭子类型一章中的 SeqDuck 类与特殊方法，尝试还原 Python 解释器运行的逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqDuck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, pos</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">range</span>(<span class="number">3</span>)[pos]</span><br></pre></td></tr></table></figure>

<ol>
<li>Python 解释器读入 SeqDuck 类，对所有双下划线开头结尾的特殊方法进行检索。</li>
<li>检索到 <code>__getitem__</code> 方法，方法签名符合序列协议。</li>
<li>当需要对 SeqDuck 实例进行循环迭代时，首先查找 <code>__iter__</code> 方法，未找到。</li>
<li>执行 <code>__getitem__</code> 方法，传入从 0 开始的整数索引进行迭代直至索引越界终止循环。</li>
</ol>
<p>该过程可以理解为 Python 解释器对 SeqDuck 类的功能进行了<strong>运行时扩充</strong>。显然这增强了 Python 语言的动态特性，但另一方面也解释了为什么 Python 运行效率较低。</p>
<p>下面我将对一些常用特殊方法进行介绍。</p>
<h3 id="new-amp-init"><a href="#new-amp-init" class="headerlink" title="__new__ &amp; __init__"></a><code>__new__</code> &amp; <code>__init__</code></h3><p>在 Java 和 C# 这些语言中，可以使用 <code>new</code> 关键字创建一个类的实例。Python 虽然没有 <code>new</code> 关键字，但提供了 <code>__new__</code> 特殊方法。在实例化一个 Python 类时，最先被调用的就是 <code>__new__</code> 方法。大多数情况下不需要我们重写 <code>__new__</code> 方法，Python 解释器也会执行 object 中的 <code>__new__</code> 方法创建类实例。但如果要使用单例模式，那么 <code>__new__</code> 方法就会派上用场。下面的代码展示了如何通过 <code>__new__</code> 控制只创建类的唯一实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line"><span class="meta">... </span>    _instance = <span class="literal">None</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>        cls._instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> cls._instance</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = Singleton()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Singleton()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 <span class="keyword">is</span> s2  <span class="comment">## id(s1) == id(s2)</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><code>__init__</code> 方法则类似于构造函数，如果需要对类中的属性赋初值，可以在 <code>__init__</code> 中进行。在一个类的实例被创建的过程中，<code>__new__</code> 要先于 <code>__init__</code> 被执行，因为要先创建好实例才能进行初始化。<code>__new__</code> 方法的第一个参数必须是 <code>cls</code> 类自身，<code>__init__</code> 方法的第一个参数必须是 <code>self</code> 实例自身。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;__new__ magic method is called&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span> (<span class="string">&quot;__init__ magic method is called&quot;</span>)</span><br><span class="line"><span class="meta">... </span>        self.name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Employee()</span><br><span class="line">__new__ magic method <span class="keyword">is</span> called</span><br><span class="line">__init__ magic method <span class="keyword">is</span> called</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.name</span><br><span class="line"><span class="string">&#x27;Jack&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于 Python 不支持方法重载，即同名方法只能存在一个，所以 Python 类只能有一个构造函数。如果需要定义和使用多个构造器，可以使用带默认参数的 <code>__init__</code> 方法，但这种方法实际使用还是有局限性。另一种方法则是使用带有 <code>@classmethod</code> 装饰器的类方法，可以像使用类的静态方法一样去调用它生成类的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, sex=<span class="string">&#x27;MAlE&#x27;</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">male</span>(<span class="params">cls, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">female</span>(<span class="params">cls, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls(name, <span class="string">&#x27;FEMALE&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">p1 = Person(<span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line">p2 = Person(<span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;FEMALE&#x27;</span>)</span><br><span class="line">p3 = Person.female(<span class="string">&#x27;Neo&#x27;</span>)</span><br><span class="line">p4 = Person.male(<span class="string">&#x27;Tony&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="str-amp-repr"><a href="#str-amp-repr" class="headerlink" title="__str__ &amp; __repr__"></a><code>__str__</code> &amp; <code>__repr__</code></h3><blockquote>
<p>str() is used for creating output for end user while repr() is mainly used for debugging and development. repr’s goal is to be <strong>unambiguous</strong> and str’s is to be <strong>readable</strong>.</p>
</blockquote>
<p><code>__str__</code> 和 <code>__repr__</code> 都可以用来输出一个对象的字符串表示。使用 <code>str()</code> 时会调用 <code>__str__</code> 方法，使用 <code>repr()</code> 时则会调用 <code>__repr__</code> 方法。<code>str()</code> 可以看作 string 的缩写，类似于 Java 中的 <code>toString()</code> 方法；<code>repr()</code> 则是 representation 的缩写。</p>
<p>这两个方法的区别主要在于受众。<code>str()</code> 通常是输出给终端用户查看的，可读性更高。而 <code>repr()</code> 一般用于调试和开发时输出信息，所以更加强调含义准确无异义。在 Python 控制台以及 Jupyter notebook 中输出对象信息会调用的 <code>__repr__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="literal">True</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x  <span class="comment"># list.__repr__</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="literal">True</span>]</span><br></pre></td></tr></table></figure>

<p>如果类没有定义 <code>__repr__</code> 方法，控制台会调用 object 类的 <code>__repr__</code> 方法输出对象信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a  <span class="comment"># object.__repr__</span></span><br><span class="line">&lt;__main__.A <span class="built_in">object</span> at <span class="number">0x104b69b50</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>__str__</code> 和 <code>__repr__</code> 也可以提供给 <code>print</code> 方法进行输出。如果只定义了一个方法则调用该方法，如果两个方法都定义了，会优先调用 <code>__str__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;repr: Foo&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;str: Foo&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line"><span class="built_in">repr</span>: Foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">str</span>: Foo</span><br></pre></td></tr></table></figure>

<h3 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h3><p>在 Python 中，函数是一等公民。这意味着 Python 中的函数可以作为参数和返回值，可以在任何想调用的时候被调用。为了扩充类的函数功能，Python 提供了 <code>__call__</code> 特殊方法，允许类的实例表现得与函数一致，可以对它们进行调用，以及作为参数传递。这在一些需要保存并经常更改状态的类中尤为有用。</p>
<p>下面的代码中，定义了一个从 0 开始的递增器类，它保存了计数器状态，并在每次调用时计数加一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Incrementor</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.counter = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.counter += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.counter</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inc = Incrementor()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inc()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inc()</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>允许将类的实例作为函数调用，如上面代码中的 <code>inc()</code>，本质上与 <code>inc.__call__()</code> 直接调用对象的方法并无区别，但它可以以一种更直观且优雅的方式来修改对象的状态。</p>
<p><code>__call__</code> 方法可以接收可变参数, 这意味着可以像定义任意函数一样定义类的 <code>__call__</code> 方法。当 <code>__call__</code> 方法接收一个函数作为参数时，那么这个类就可以作为一个函数装饰器。基于类的函数装饰器就是这么实现的。如下代码我在 func 函数上使用了类级别的函数装饰器 Deco，使得在执行函数前多打印了一行信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Deco</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.func = func</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;decorate...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@Deco</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;execute function&#x27;</span>, name)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">decorate...</span><br><span class="line">execute function foo</span><br></pre></td></tr></table></figure>

<p>实际上类级别的函数装饰器必须要实现 <code>__call__</code> 方法，因为本质上函数装饰器也是一个函数，只不过是一个接收被装饰函数作为参数的高阶函数。有关装饰器可以详见装饰器一章。</p>
<h3 id="add"><a href="#add" class="headerlink" title="__add__"></a><code>__add__</code></h3><p>Python 中的运算符重载也是通过重写特殊方法实现的。比如重载 “+” 加号运算符需要重写 <code>__add__</code>，重载比较运算符 “==” 需要重写 <code>__eq__</code> 方法。合理的重载运算符有助于提高代码的可读性。下面我将就一个代码示例进行演示。</p>
<p>考虑一个平面向量，由 x，y 两个坐标构成。为了实现向量的加法（按位相加），重写了加号运算符，为了比较两个向量是否相等重写了比较运算符，为了在控制台方便验证结果重写了 <code>__repr__</code> 方法。完整的向量类代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Vector(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x + other.x, self.y + other.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.x == other.x <span class="keyword">and</span> self.y == other.y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ne__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.__eq__(other)</span><br></pre></td></tr></table></figure>

<p>在控制台验证结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v2</span><br><span class="line">Vector(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == v2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v1 == Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>重载了 “+” 运算符后，可以直接使用 <code>v1 + v2</code> 对 Vector 类进行向量相加，而不必要编写专门的 <code>add()</code> 方法，并且重载了 <code>==</code> 运算符取代了 <code>v1.equals(v2)</code> 的繁冗写法。从代码可读性来讲直接使用运算符可读性更高，也更符合数学逻辑。</p>
<p>当然，运算符重载涉及的知识点不止于此，《流畅的 Python》将其作为单独的一章，可见其重要性。下一节我们将就运算符重载进行深入的讨论。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://foofish.net/dynamic_type_and_duck_type.html">Python：动态语言与鸭子类型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.tutorialsteacher.com/python/magic-methods-in-python">Python - Magic or Dunder Methods
</a></li>
<li><a target="_blank" rel="noopener" href="https://www.pythonlikeyoumeanit.com/Module4_OOP/Special_Methods.html">Python Like You Mean It - Special Methods</a></li>
<li><a target="_blank" rel="noopener" href="https://sikasjc.github.io/2018/09/02/magicmethods2/">全面学习Python魔法方法(magic methods)</a></li>
<li><a target="_blank" rel="noopener" href="https://hellowac.github.io/programing%20teach/2017/06/06/fluentpython13.html">流畅的python - 重载运算符</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="s1mple"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">s1mple</p>
  <div class="site-description" itemprop="description">春光恰与少年同，十里清风慕天青</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/s1mplecc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;s1mplecc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:s1mple951205@gmail.com" title="E-Mail → mailto:s1mple951205@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">s1mple</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 33231,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
