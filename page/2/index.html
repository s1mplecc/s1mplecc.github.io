<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"s1mplecc.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="春光恰与少年同，十里清风慕天青">
<meta property="og:type" content="website">
<meta property="og:title" content="芥子屋">
<meta property="og:url" content="https://s1mplecc.github.io/page/2/index.html">
<meta property="og:site_name" content="芥子屋">
<meta property="og:description" content="春光恰与少年同，十里清风慕天青">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="s1mple">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://s1mplecc.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>芥子屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">芥子屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/s1mplecc" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/01/18/Python-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/18/Python-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/" class="post-title-link" itemprop="url">Python 环境准备</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-18 12:41:16" itemprop="dateCreated datePublished" datetime="2021-01-18T12:41:16+08:00">2021-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Python-版本"><a href="#Python-版本" class="headerlink" title="Python 版本"></a>Python 版本</h2><p>目前 Python 主要活跃的有 Python 2.x 和 Python 3.x 两个大版本，与 C++ 和 Java 这种向后兼容的语言不同，Python 的两个版本互不兼容。舍弃兼容性是一种设计上的取舍，在我看来 Python 这种尤为注重“简约”的语言，敢于大胆摒弃一些有设计缺陷的旧包袱，从而拥抱新特性的作风，未尝不是一种 Pythonic 的体现，很大程度上避免了走向像 C++ 一样越来越臃肿晦涩的道路。</p>
<p>Python 核心团队已于 2019 年正式宣布将在 2020 年停止对 Python2 的更新，在此期间会对 Python2 版本进行一些 bug 修复、安全增强以及移植等工作，以便使开发者顺利的从 Python2 迁移到 Python3。Python 2.7 是 2.x 系列的最后一个版本，官网上最新的 Python 2.7.18 版本发布于 2020 年 4 月 20 日。官方停止 Python2 更新的主要动机是想进行 Python3 的推广，以及同时维护两个版本给他们带来的工作负担。目前大部分 Python 开源项目已经兼容 Python3 了，所以<strong>强烈建议使用 Python3 来开发新的项目</strong>。</p>
<p>一般较新的 Linux 发行版已经预装了 Python2 和 Python3，如果没有，也可以通过各自的包管理器进行安装和更新。Mac OS 环境下可以通过 Homebrew 工具来安装 Python，可以附加 <code>@ + 版本号</code> 安装指定版本。在一般情况下（不手动修改软链接），命令行中的 <code>python</code> 通常是 python 2.7 或其旧版本的别名，<code>python3</code> 才指代 Python3 版本，可以通过 <code>--version</code> 参数来查看安装的具体版本。由于两个版本互不兼容，在命令行运行 Python 脚本前需要先确定其所用的 Python 版本。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ brew install python  <span class="comment"># brew install python@2.7</span></span><br><span class="line">➜ python --version </span><br><span class="line">Python 2.7.10</span><br><span class="line"></span><br><span class="line">➜ brew install python3  <span class="comment"># brew install python@3.8</span></span><br><span class="line">➜ python3 --version</span><br><span class="line">Python 3.8.6</span><br></pre></td></tr></table></figure>

<p>有时也需要在代码中，也就是<strong>运行时确定 Python 版本</strong>，此时用到的是内置的 sys 模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(sys.version)</span><br><span class="line"><span class="number">3.8</span><span class="number">.6</span> (default, Oct  <span class="number">8</span> <span class="number">2020</span>, <span class="number">14</span>:07:<span class="number">53</span>) </span><br><span class="line">[Clang <span class="number">11.0</span><span class="number">.0</span> (clang-<span class="number">1100.0</span><span class="number">.33</span><span class="number">.17</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(sys.version_info)</span><br><span class="line">sys.version_info(major=<span class="number">3</span>, minor=<span class="number">8</span>, micro=<span class="number">6</span>, releaselevel=<span class="string">&#x27;final&#x27;</span>, serial=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>可以通过在运行时判断 Python 版本从而达到较好的兼容性，这在 Python 的内置模块以及标准库中使用较多。由于 <code>version_info</code> 本身是个 tuple 类型，重载了比较运算符，所以可以像下面这样直接进行比较：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># builtins.pyi</span></span><br><span class="line"><span class="keyword">if</span> sys.version_info &gt;= (<span class="number">3</span>, <span class="number">9</span>):</span><br><span class="line">    <span class="keyword">from</span> types <span class="keyword">import</span> GenericAlias</span><br><span class="line"></span><br><span class="line"><span class="comment"># contextlib2.py</span></span><br><span class="line"><span class="keyword">if</span> sys.version_info[:<span class="number">2</span>] &gt;= (<span class="number">3</span>, <span class="number">4</span>):</span><br><span class="line">    _abc_ABC = abc.ABC</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    _abc_ABC = abc.ABCMeta(<span class="string">&#x27;ABC&#x27;</span>, (<span class="built_in">object</span>,), &#123;<span class="string">&#x27;__slots__&#x27;</span>: ()&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的源码来自于两个不同的文件，阅读源码可以发现一些 Python 版本变更的内容。比如自 Python 3.9 引入的 GenericAlias 类型；Python 3.4 之前继承抽象类时还得使用 ABCMeta 形式。</p>
<p>一般情况下，除非你开发的是供他人使用的第三方库，并不需要你在运行时显式判断版本。一方面是版本对于你是可控的，另一方面是如果滥用版本判断会降低代码的整洁性。如果不得不这么做，可以像内置模块 builtins.pyi 一样在存根文件中统一进行处理。</p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><blockquote>
<p><strong>pip</strong> - The Python Package Installer. You can use pip to install packages from the Python Package Index (PyPI) and other indexes.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://pip.pypa.io/en/stable/">pip</a> 是 Python 的包安装和管理工具，类似于 npm 之于 JavaScript。Python 3.x 以上的发行版本中都是自带 pip 的。在使用之前先确定 pip 的版本，Python3 中的 pip 是 pip3 的别名，但如果安装了 Python2 的 pip，那么在为 Python3 项目安装依赖时请使用 pip3 命令，因为这两个命令会将依赖安装在不同的目录下。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ pip --version</span><br><span class="line">pip 20.3.3 from /usr/<span class="built_in">local</span>/lib/python3.8/site-packages/pip (python 3.8)</span><br></pre></td></tr></table></figure>

<p>常见的 pip 命令使用可以查阅官方文档，或者 <code>pip -h</code> 查阅帮助文档。与 JavaScript 的 package.json 一样，Python 也提供了统一管理依赖的配置文件 <strong>requirements.txt</strong>。文件中可以指定依赖的版本号，如果缺省则默认安装最新依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">####### example-requirements.txt #######</span><br><span class="line">beautifulsoup4              # Requirements without Version Specifiers</span><br><span class="line">docopt == 0.6.1             # Version Matching. Must be version 0.6.1</span><br><span class="line">keyring &gt;= 4.1.1            # Minimum version 4.1.1</span><br><span class="line">coverage != 3.5             # Version Exclusion. Anything except version 3.5</span><br><span class="line">Mopidy-Dirble ~= 1.1        # Compatible release. Same as &gt;= 1.1, == 1.*</span><br></pre></td></tr></table></figure>

<p>使用 <code>-r</code> 参数指定通过 requirements.txt 文件安装依赖：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>有时我们需要进行项目迁移，比如将本地项目部署至服务器，为了保证重新安装依赖时不影响项目的正常运行，可以使用 freeze 指令将所需的依赖和具体版本号写入 requirements.txt 文件中，再一次性安装所有依赖。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ pip freeze &gt; requirements.txt</span><br><span class="line">➜ cat requirements.txt </span><br><span class="line">certifi==2020.11.8</span><br><span class="line">matplotlib==3.3.2</span><br><span class="line">numpy==1.19.4</span><br><span class="line">six==1.15.0</span><br></pre></td></tr></table></figure>

<h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>在 JavaScript 中，使用 npm 安装依赖会在当前目录下生成一个 node_modules 文件夹，依赖会被安装在这个文件夹中。除非指定 <code>-g</code> 或 <code>--global</code> 参数，将会在全局环境中安装依赖，在 Mac OS 或 Linux 系统中一般会被安装到 <code>/usr/local/lib/node_modules</code> 目录下。这样做的好处是将全局环境与局部环境隔离，避免依赖冲突，尤其是两个项目依赖同一个库的不同版本时。</p>
<p>Python 中也有类似的问题，《Effective Python – 编写高质量Python代码的59个有效方法》一书中的协作开发章节就提到：<strong>使用虚拟环境隔离项目</strong>。问题在于，通过 pip 命令安装的依赖是全局性的，这意味着这些安装好的模块可能会影响系统内的所有 Python 程序。全局依赖会被安装在特定 Python 版本的目录下，如 <code>/usr/local/lib/python3.8/site-packages</code>，对于使用 Python 3.8 的所有项目来说依赖是共享的。</p>
<p>为此，Python 提供了一种解决方案，类似于 JavaScript 的局部环境，隔离出一个单独的 Python 局部环境，这种方案的典型就是 venv。</p>
<h3 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h3><blockquote>
<p><strong>venv</strong> (for Python 3) and <strong>virtualenv</strong> (for Python 2) allow you to manage separate package installations for different projects. If you are using Python 3.3 or newer, the venv module is the preferred way to create and manage virtual environments. venv is included in the Python standard library and requires no additional installation.</p>
</blockquote>
<p>从 Python 2.7 开始，Python 社区开发了一些较底层的创建<strong>虚拟环境</strong>（virtual environment）的工具，在 Python 2.7 中这个工具叫做 virtualenv，这是一个三方工具，需要使用 pip 安装。而《Effective Python》一书中提到的工具 pyvenv 是 Python 3.3 所引入的，但由于一些缺陷在 Python 3.6 中已被弃用。取而代之的是 Python 3.5 引入的内置模块 venv，可以通过 <code>python3 -m venv</code> 使用这个命令。</p>
<p><a target="_blank" rel="noopener" href="https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#creating-a-virtual-environment">官方文档</a>中已经明确给出建议，如果使用的是 Python 3.3 及以后的版本，更加推荐使用 venv 去管理你的虚拟环境。下面我们扼要的介绍一下 venv 命令的使用方式。</p>
<p>首先创建一个空项目 myproject，在该目录下执行 <code>python3 -m venv venv</code> 命令，第二个 venv 是创建的虚拟环境的文件夹名，系统中的环境会被拷贝到该目录下，包括 bin 中的 pip 和 python 命令，而 pip 安装的依赖会存放在 lib 目录中。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ mkdir myproject; <span class="built_in">cd</span> myproject</span><br><span class="line">➜ python3 -m venv venv</span><br><span class="line">➜ ls -F</span><br><span class="line">venv/</span><br><span class="line">➜ ls -F venv</span><br><span class="line">bin/        include/    lib/        pyvenv.cfg</span><br></pre></td></tr></table></figure>

<p>为了启用这套虚拟环境需要先运行<strong>激活</strong>脚本，启用后会发现命令行多了 <code>(venv)</code>  前缀，这明确的提示了开发者现在处于虚拟环境中。默认情况下虚拟环境只安装了 pip 和 setuptools 两个初始依赖，此时的环境已经独立于全局环境，全局依赖不会影响到此项目。pip 和 python3 命令都指向虚拟环境 bin 目录下的命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ <span class="built_in">source</span> venv/bin/activate</span><br><span class="line">(venv) ➜ pip list    </span><br><span class="line">Package    Version</span><br><span class="line">---------- -------</span><br><span class="line">pip        20.2.1</span><br><span class="line">setuptools 49.2.1</span><br><span class="line">(venv) ➜ <span class="built_in">which</span> python3</span><br><span class="line">/Users/s1mple/Downloads/myproject/venv/bin/python3</span><br><span class="line">(venv) ➜ python3 --version</span><br><span class="line">Python 3.8.6</span><br></pre></td></tr></table></figure>

<p>退出虚拟环境时使用 <code>deactivate</code> 命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) ➜ deactivate</span><br><span class="line">➜ <span class="built_in">which</span> python3</span><br><span class="line">/usr/<span class="built_in">local</span>/bin/python3</span><br></pre></td></tr></table></figure>

<p>为了代替手动的在命令行创建虚拟环境，PyCharm 集成了 virtualenv 工具，并且官方文档已经标明：Python 3.3 版本之前使用第三方的 virtualenv 工具，Python 3.3 之后使用内置的 venv 模块。在新建项目时可以选择 New Virtualenv Environment 自动创建虚拟环境。</p>
<p>有了虚拟环境，我们就可以使用 <code>pip freeze</code> 命令和 requirements.txt 文件很方便的重现一套环境。此外，在使用 venv 时，应当尽量避免移动环境目录，包括重命名项目名称，因为所有的路径（包括 python3 命令所指向的路径），都以硬编码的形式写在了安装目录中，更改目录路径将导致环境失效。解决办法是修改 <code>bin/active</code> 脚本中的 VIRTUAL_ENV 路径值，并重新激活。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># active</span></span><br><span class="line">VIRTUAL_ENV=<span class="string">&quot;/Users/s1mple/Downloads/myproject/venv&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p>如果你觉得 pip + venv 的方式太过底层，也可以使用 Anaconda。Anaconda 是一个更高层次的包管理器和环境管理器，它依托于 conda 之上开发的，conda 可以理解为整合了 pip 和 venv 的功能，区别在于 conda 是跨平台和不限语言的（支持 R 语言）。PyCharm 也对 conda 提供了支持，可以直接通过 conda 创建虚拟环境。</p>
<p>Anaconda 的下载文件较大（500MB），不仅自带 Python 还附带了许多常用数据科学包，已经成为了数据科学方向百宝箱式的存在。Anaconda 也提供可视化界面。总的来说，对于不太熟悉底层操作的数据分析师来说，Anaconda 易于上手体验友好。但对于软件开发来说，Anaconda 显得过于臃肿，这也是我不选择使用它的原因。现如今的 Python 环境支持官方库已经做的很好，如果不是做数据科学方向的，建议使用原生的 pip + venv。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#creating-a-virtual-environment">官方文档 Installing packages using pip and virtual environments</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/venv.html">官方文档 venv — Creation of virtual environments</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe">What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc?</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/01/09/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB-Python-%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/09/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB-Python-%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">如何阅读 Python 源码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-09 22:34:23" itemprop="dateCreated datePublished" datetime="2021-01-09T22:34:23+08:00">2021-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>阅读源码是每个程序员都应当具备的技能，阅读源码不仅能帮助你理解一个模块实现的细节，也能让你从优秀的源码中汲取经验，遵循更好的编码规范，编写出更 Pythonic 的代码。但不可否认的是，阅读源码需要一定的编码功底，盲目的阅读并不能取得应有的效果。在阅读源码之前我们要明白阅读的目的，如果是想了解一个模块的实现细节自不必多说，但如果是想提高自己的 Python 编码水平，那么就应该从 Python 标准库以及一些优秀的第三方开源代码下手。</p>
<p>在《Python编程之美：最佳实践指南》这本书中，作者 Kenneth Reitz 从简单的 HowDoI 项目，到大一点的 requests 库（他本身也是这个库的开发者），再到后面的 Web 框架 Flask，逐步递进地展示如何阅读高质量的代码。如果想阅读优秀的第三方库源码，可以从他在书中罗列出的经典项目开始。除此之外，GitHub 上也有人整理了比较详尽的目录：<a target="_blank" rel="noopener" href="https://github.com/programthink/opensource/blob/master/libs/python.wiki">Python 开源库及示例代码</a>。项目很多，但不是每个都必读。还是强调的那一点：不要盲目的阅读源码，确定有必要的时候再去阅读。</p>
<p>抛开这些问题不谈，本篇我想结合我自己在阅读标准库源码（主要是 typing 模块和 re 模块）时的一点理解，介绍一些阅读源码前需要掌握的先验知识，以及如何结合开发工具在 PyCharm IDE 中高效地阅读源码。让我们先从 Python 代码的类型提示开始。</p>
<h2 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h2><blockquote>
<p><strong>PEP 3107 – Function Annotations</strong> : Python Version 3.0, Created Time 2-Dec-2006. This PEP introduces a syntax for adding arbitrary metadata annotations to Python functions.</p>
</blockquote>
<p>Python 3 添加了对类型提示（Type Hints）的支持，在此之前 Python 2.x 一直缺乏一种统一的方式去对函数参数和返回值进行标注，一些工具或三方库通过 docstring、注释或者函数装饰器等其他方法尝试去弥补这种缺陷。而自从 Python 3.0 开始，Python 通过 PEP 3107 提案引入了<strong>函数注解</strong>，也就是 Function Annotations，提供了一种标准的解决方案，用于<strong>为函数声明中的参数和返回值附加元数据</strong>。</p>
<p>函数注解的语法如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a: expression, b: expression = <span class="number">5</span></span>) -&gt; expression:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>函数声明中的各个参数可以在 <code>:</code> 之后添加注解表达式。如果参数有默认值，表达式后可以跟 <code>=</code> 指定默认值，且与常规函数声明一样，指定默认值参数要出现在无默认值参数之后。注解表达式最常使用的是类型（如 str 或 int），也可以是一个字符串（如 ‘int &gt; 0’）。如果想注解返回值，在 <code>)</code> 与 <code>:</code> 之间添加 <code>-&gt;</code> 和一个表达式，表达式可以是任意类型，如果函数无返回值则为 None。</p>
<p>本质上来说，PEP 3107 只是一种前导的语法规范，不对注解任何实质处理，你可以将其理解为官方规定的函数声明的注释。换句话说，<strong>注解只是元数据</strong>，Python 解释器对其不做检查、不做强制、不做验证。Python 对注解所做的唯一的事情，就是将它们存储在函数的 <code>__annotations__</code> 属性中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a: <span class="string">&#x27;x&#x27;</span>, b: <span class="number">5</span> + <span class="number">6</span>, c: <span class="built_in">list</span></span>) -&gt; <span class="built_in">max</span>(2, 9):</span> ...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__annotations__</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;c&#x27;</span>: &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt;, &#x27;<span class="title">return</span>&#x27;:</span> <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>

<p>其中 return 键保存的是返回值的注解，即函数声明里以 <code>-&gt;</code> 标记的部分。从这个例子我们可以看出，注解表达式的约束非常的宽泛，不管你是类型，还是字符串，或是个表达式。</p>
<p>注解可以供 IDE、框架和装饰器等工具使用，举个例子，框架可以对 <code>price: &#39;int &gt; 0&#39;</code> 这样的字符串注解转换为对参数的验证。注解最大的作用是为 IDE 和 lint 程序中的<strong>静态类型检查</strong>功能提供额外的类型信息，也就是我们接下来要讨论的类型提示。</p>
<p><strong>延伸</strong>：Java 中的注解也称为 Annotation，使用 <code>@</code> 符号标注，本质上也是元数据，本身 Java 解释器不会对其做任何处理，只有结合 Java 运行时的反射（getAnnotation 方法）才能获取注解内容从而针对性地制定处理逻辑，这在一些框架例如 Spring 中使用颇多。这与 Python 中的注解是否存在异曲同工之处呢？我们有理由相信，Python 中的静态类型检查工具也是获取了函数的 <code>__annotations__</code> 属性从而进行处理。</p>
<h2 id="类型提示"><a href="#类型提示" class="headerlink" title="类型提示"></a>类型提示</h2><blockquote>
<p><strong>PEP 484 – Type Hints</strong> : Python Version 3.5, Created Time 29-Sep-2014. This PEP aims to provide a standard syntax for type annotations, opening up Python code to easier static analysis and refactoring, potential runtime type checking, and (perhaps, in some contexts) code generation utilizing type information.</p>
</blockquote>
<p>在 PEP 3107 提案提出后，已经有一些第三方工具结合函数注解做了静态类型检查方面的工作，其中被采用较多的就是 Jukka Lehtosalo 开发的 mypy 项目。PEP 484 提案受 mypy 的强烈启发（Jukka 也参与了提案的制订），规定了如何给 Python 代码添加<strong>类型提示（Type Hints）</strong>，主要方式就是使用注解，以及引入了一个新模块：<strong>typing 模块</strong>。</p>
<h3 id="typing-模块"><a href="#typing-模块" class="headerlink" title="typing 模块"></a>typing 模块</h3><p>为了给 Python 静态类型检查提供统一的命名空间，标准库以渐进定型（gradual typing）的方式引入名为 <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/typing.html">typing</a> 的新模块，新模块不会影响现有程序的正常运行，只会对不规范的类型作出提示。</p>
<p>在 typing 模块中，定义了一些<strong>特殊类型</strong>（_SpecialForm），包括 Any, NoReturn, ClassVar, Union, Optional 等，从名称可以大概猜出这些类型的作用，比如：Any 代表任意类型；联合类型 <code>Union[X, Y]</code> 表示类型非 X 即 Y；Optional 作用则与 Java8 中的 Optional 类似，允许传入参数为空，可以避免空值引用的问题。</p>
<p>除此之外，还有一些常见的数据类型，比如 List、Tuple、Dict、Sequence，它们只是作为标准库类型的别名存在，如：<code>List = _alias(list, T, inst=False)</code>。typing 模块也提供了对于<strong>泛型</strong>（Generics）的支持，让我们得以像 <code>List[int]</code> 这样去定义特定类型集合。想了解更多 typing 模块的功能，建议阅读 PEP 484文档或者直接阅读源码，源码的文档注释介绍了该模块的结构，通过 <code>__all__</code> 属性也可以查明 typing 模块都提供了哪些功能。</p>
<p>PEP 484 旨在为类型注解提供一种标准语法，让 Python 代码更易于静态分析和重构，尽管 typing 模块也提供了一些潜在的用于运行时类型检查的功能模块，尤其是 <code>get_type_hints()</code> 函数，但它本身不对其做直接支持，仍然需要开发第三方库才能实现特定的运行时类型检查功能，比如使用装饰器或元类。<code>get_type_hints</code> 函数用于获取对象的类型提示，它的源码中包含这么一行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hints = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;__annotations__&#x27;</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>这验证了我们之前猜想的类型提示会去查询对象的 <code>__annotations__</code> 属性，此外该方法还会对注解字符串进行验证，我们将这个方法再应用到之前随意注解的 foo 函数时就会报错：找不到 “x” 类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> typing <span class="keyword">import</span> get_type_hints</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a: <span class="string">&#x27;x&#x27;</span>, b: <span class="number">5</span> + <span class="number">6</span>, c: <span class="built_in">list</span></span>) -&gt; <span class="built_in">max</span>(2, 9):</span> ...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__annotations__  <span class="comment"># No error</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;c&#x27;</span>: &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt;, &#x27;<span class="title">return</span>&#x27;:</span> <span class="number">9</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_type_hints(foo)  <span class="comment"># Error</span></span><br><span class="line">NameError: name <span class="string">&#x27;x&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">a: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span> ...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_type_hints(bar)</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;, &#x27;<span class="title">return</span>&#x27;:</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="变量注解"><a href="#变量注解" class="headerlink" title="变量注解"></a>变量注解</h3><blockquote>
<p><strong>PEP 526 – Syntax for Variable Annotations</strong> : Python Version 3.6, Created Time 09-Aug-2016. This PEP aims at adding syntax to Python for annotating the types of variables (including class variables and instance variables), instead of expressing them through comments.</p>
</blockquote>
<p>为了丰富类型提示的功能，Python 随即在 3.6 版本中引入了<strong>变量注解（Variable Annotations）</strong>，用于规定变量的类型。与函数注解相同，变量注解也只是元数据，Python 解释器不对其做任何处理，仅供框架和工具做类型检查。语法上变量注解与函数注解类似，使用 <code>:</code> 后接参数类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">primes: <span class="type">List</span>[<span class="built_in">int</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signal</span>(<span class="params">flag: <span class="built_in">bool</span></span>):</span></span><br><span class="line">    color: <span class="built_in">str</span>  <span class="comment"># Note: no initial value!</span></span><br><span class="line">    <span class="keyword">if</span> flag: color = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>: color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> color</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Starship</span>:</span></span><br><span class="line">    captain: <span class="built_in">str</span> = <span class="string">&#x27;Picard&#x27;</span>  <span class="comment"># instance variable with initial value</span></span><br><span class="line">    stats: ClassVar[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]] = &#123;&#125;  <span class="comment"># class variable</span></span><br></pre></td></tr></table></figure>

<p>变量注解适用于全局变量、局部变量、类属性以及实例属性。上述代码中的 ClassVar 是由 typing 模块定义的特殊类型，向静态类型检查程序标示在类实例中不允许对该变量进行赋值。注解的同时可以对变量进行初始化，如果省略初始化，也能很方面的在后续的条件分支中进行初始化。</p>
<p>全局变量的注解存储在当前模块的 <code>__annotations__</code> 字典中，如果在 Python 交互式命令行中就是 <code>__main__</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a: <span class="built_in">int</span> = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b: <span class="built_in">str</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__annotations__</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;, &#x27;<span class="title">b</span>&#x27;:</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;&#125;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; </span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">import</span> <span class="title">__main__</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">get_type_hints</span>(<span class="params">__main__</span>)</span></span><br><span class="line"><span class="class">&#123;&#x27;<span class="title">a</span>&#x27;:</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;, &#x27;<span class="title">b</span>&#x27;:</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="何时使用类型提示"><a href="#何时使用类型提示" class="headerlink" title="何时使用类型提示"></a>何时使用类型提示</h3><p>PEP 484 中强调了 Python 将继续维持作为动态语言的特性，从来没有将类型提示强制化或是惯例化的想法。那么何时采用类型提示呢？一般而言，如果你开发的是供他人使用的第三方库（尤其是在  PyPI 上发布的库中），或是在一个多人协作的稍大项目中，推荐使用类型提示。一方面，这会帮助使用库的用户正确地调用接口。另一方面，类型提示也可以帮助理解类型是如何在代码中传播的。</p>
<p>Bernat Gabor 认为类型提示与单元测试重要性一致，本质上都是为了验证你的代码库的输入输出类型，只是表现形式不同。在他的文章 <a target="_blank" rel="noopener" href="https://www.bernat.tech/the-state-of-type-hints-in-python/">the state of type hints in Python</a> 的最后总结中提到：<strong>只要值得编写单元测试，就应该添加类型提示</strong>，哪怕代码只有十行，只要你日后需要维护它。所以他给出的建议是，在编写单元测试的同时添加类型提示。虽然这会添加额外的代码量，但为了代码平稳工作值得付出这个代价，尤其是发生代码变更时。</p>
<p>我们可以在存根文件中使用类型注解来启用类型提示。并且如果参数声明带有默认值，则可以不指定实际的默认值而使用省略号 <code>...</code> 代替，这与冒号后的函数体使用省略号一样，将省略号用作占位符。对于变量，一般只声明类型不给出初值。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x: AnyStr, y: AnyStr = ...</span>) -&gt; AnyStr:</span> ...</span><br><span class="line"></span><br><span class="line">stream: IO[<span class="built_in">str</span>]</span><br></pre></td></tr></table></figure>

<h2 id="pyi-存根文件"><a href="#pyi-存根文件" class="headerlink" title=".pyi 存根文件"></a>.pyi 存根文件</h2><p>由于 Python 是动态语言，不对类型做强制约束，所以 IDE 在类型检查、类型推断、代码补全以及重构等方面必然不如 Java 等静态语言来的方便。<strong>存根文件是包含类型提示信息的文件</strong>，运行时不会用到，而是<strong>提供给第三方工具做静态类型检查和类型推断</strong>，这方面 PyCharm 做的很好。</p>
<p>在 PyCharm 中，如果某一行的左边有 * 号标识，则说明这一行（可以是类、属性或函数）在存根文件中有定义，你可以点击 * 号跳转到该文件对应的存根文件，通常是存放在 Python 库文件的 Typeshed Stubs 目录中，文件名以 <code>.pyi</code> 后缀结尾。同时，存根文件也是 GitHub 上一个单独的项目，项目地址：<a target="_blank" rel="noopener" href="https://github.com/python/typeshed">https://github.com/python/typeshed</a> ，Python 的标准库以及内置 builtins 存根可以在该项目的 stdlib 目录下找到。</p>
<p>我们来看看 Python 正则库 re 的存根文件和源文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># re.pyi</span></span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span>(<span class="params">pattern: AnyStr, flags: _FlagsType = ...</span>) -&gt; Pattern[AnyStr]:</span> ...</span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span>(<span class="params">pattern: Pattern[AnyStr], flags: _FlagsType = ...</span>) -&gt; Pattern[AnyStr]:</span> ...</span><br><span class="line">  </span><br><span class="line"><span class="comment"># re.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span>(<span class="params">pattern, flags=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;Compile a regular expression pattern, returning a Pattern object.&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">compile</span>(pattern, flags)</span><br></pre></td></tr></table></figure>

<p>这里只截取了源码中的一段 compile 函数。从形式上看，存根文件与 C 语言中的头文件有相似之处，将函数声明与函数定义分文件存放，但与其将存根文件理解为函数声明文件，不如理解为函数接口（Interface）文件，接口的意义就是让用户在调用时可以清晰地查看函数的参数和返回值类型。这也是为什么 PEP 484 的作者之一 Jukka Lehtosalo 说可以将 <code>.pyi</code> 中的 i 理解为 Interface。</p>
<p>上述源文件中的 compile 函数，调用了私有的 _compile 函数并返回一个 Pattern 对象，作用是将字符串处理（编译）成正则表达式模版。进一步 _compile 的源码会发现，如果传入的 pattern 参数本来就是 Pattern 类型的，为了避免重复处理，方法会直接返回 pattern，如下面的代码所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_compile</span>(<span class="params">pattern, flags</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(pattern, Pattern):</span><br><span class="line">        <span class="keyword">if</span> flags:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">&quot;cannot process flags argument with a compiled pattern&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> pattern</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这也解释了为什么存根文件中会存在两个 compile 函数声明，其中的第二个就是接收 Pattern 类型作为参数的。除了 compile 函数之外，re 存根文件中的大多数函数都有两个重载函数，原因就是它们实现时都调用了 _compile 函数。事实上，为了防止用户多次调用 _compile 引起不必要的开销，_compile 也设置了缓存优化，这点留给读者自行阅读源码分析。</p>
<p>在最新的 PyCharm 2020.3 版本中，支持直接创建 Python stub 类型的 Python File，只需要存根文件与源文件同名，PyCharm 就会自动按照存根文件中指定的类型进行静态类型检查。并且，你也可以像 Typeshed 项目为存根文件分配单独的文件夹，具体操作详见 JetBrains 官网的 PyCharm 手册：<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/pycharm/stubs.html">Python Stubs</a>。</p>
<h2 id="PyCharm-高效阅读源码"><a href="#PyCharm-高效阅读源码" class="headerlink" title="PyCharm 高效阅读源码"></a>PyCharm 高效阅读源码</h2><p>除了标注存根文件，PyCharm 还对子类父类方法重载进行了标注，分别用 <code>O↑</code> 表示这一行重载了父类方法，点击可以跳转到父类实现；<code>O↓</code> 表示这一行有子类重载，点击可以跳转到子类实现。其中 O 代表的是 Override 的含义。</p>
<p>比如我们阅读 Python 内置的列表 list 的源码，append 方法这一行既是重载自父类也有子类重载（存根文件中标注的）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>(<span class="params">MutableSequence[_T], <span class="type">Generic</span>[_T]</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, __object: _T</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br></pre></td></tr></table></figure>

<p>可以看到 list 多重继承自 MutableSequence 和 Generic，如果点击 append 左侧 <code>O↑</code>，就会跳转到父类 MutableSequence 的 append 实现处。如果点击 <code>O↓</code>，可以选择某个子类并进行跳转（list 存在多个子类）。这在阅读一个具有继承结构的源码时会有所帮助。</p>
<p>当然，如果想在 PyCharm 中高效阅读源码，需要结合快捷键来使用。这里列出一些 Mac OS 下的快捷键，Windows 下一般是将 Cmd 替换为 Ctrl，你也可以打开 PyCharm 设置自行查阅 Keymap 快捷键：</p>
<table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">作用</th>
<th align="left">PyCharm Keymap</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cmd + U</td>
<td align="left">跳转到父类实现</td>
<td align="left">Go to Super Method</td>
</tr>
<tr>
<td align="left">Cmd + Alt + B/Left Click</td>
<td align="left">跳转到子类实现</td>
<td align="left">Go to Implementations</td>
</tr>
<tr>
<td align="left">Cmd + B/Left Click</td>
<td align="left">跳转到定义处或调用处</td>
<td align="left">Go to Declaration or Usages</td>
</tr>
<tr>
<td align="left">Cmd + [</td>
<td align="left">跳转到鼠标停留的上一个位置</td>
<td align="left">Back</td>
</tr>
<tr>
<td align="left">Cmd + ]</td>
<td align="left">跳转到鼠标停留的下一个位置</td>
<td align="left">Forward</td>
</tr>
<tr>
<td align="left">Cmd + E</td>
<td align="left">跳转到最近浏览的文件</td>
<td align="left">Iterate Recent Files</td>
</tr>
<tr>
<td align="left">Cmd + Shift + O</td>
<td align="left">以文件名查询并跳转</td>
<td align="left">Go to File</td>
</tr>
<tr>
<td align="left">Cmd + O</td>
<td align="left">以类名查询并跳转</td>
<td align="left">Go to Class</td>
</tr>
<tr>
<td align="left">Cmd + Alt + O</td>
<td align="left">以符号查询并跳转，可以查询函数和全局变量</td>
<td align="left">Go to Symbol</td>
</tr>
<tr>
<td align="left">双击 Shift</td>
<td align="left">整合了所有查询</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Cmd + F</td>
<td align="left">搜索当前文件下内容</td>
<td align="left">Find</td>
</tr>
<tr>
<td align="left">Cmd + Shift + F</td>
<td align="left">搜索项目文件中的内容</td>
<td align="left">Find in Files</td>
</tr>
</tbody></table>
<p>这些都是 PyCharm 中非常实用的快捷键，不管是阅读源码还是自己编码，熟悉这些快捷键有助于快速定位到某个文件，某个函数或是某个变量，从而提高我们的效率。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.python-guide.org/writing/reading/">Reading Great Code – Kenneth Reitz</a></li>
<li><a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-3107/">PEP 3107 – Function Annotations</a></li>
<li><a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0484/">PEP 484 – Type Hints</a></li>
<li><a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0526/#abstract">PEP 526 – Syntax for Variable Annotations</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/typing.html">Python 官方文档：typing — Support for type hints</a></li>
<li><a target="_blank" rel="noopener" href="https://realpython.com/python-type-checking/#function-annotations">Python Type Checking (Guide)</a></li>
<li><a target="_blank" rel="noopener" href="https://sikasjc.github.io/2018/07/14/type-hint-in-python/#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA">译文：全面理解 Python 中的类型提示（Type Hints）</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/01/02/Python-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/Python-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">Python 编码规范</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 16:46:14" itemprop="dateCreated datePublished" datetime="2021-01-02T16:46:14+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>PEP，全称 Python Enhancement Proposals，译为 Python 增强提案。PEP 已经成为 Python 发布新特性的主要机制，它会收集社区对 Python 的改进意见，经过核心开发者的审查和认可最终形成提案向公众公示。<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/">PEP 的官网首页</a> 也是 PEP 0 的地址，在这里官方列举了所有的 PEP 的索引，你可以按序号、标题和类型进行检索。</p>
</blockquote>
<h2 id="Python-之禅"><a href="#Python-之禅" class="headerlink" title="Python 之禅"></a>Python 之禅</h2><p>Python 开发者喜欢用 “Pythonic” 这个单词来形容符合 Python 编码风格的代码。这种风格既不是严格的规范也不是编译器强加给开发者的规则，而是大家在使用 Python 语言协同工作的过程中逐渐形成的习惯。要记住：<strong>Python 开发者不喜欢复杂的事物，他们崇尚直观、简洁而又易读的代码</strong>。为此，Python 语言的早期贡献者 Tim Peters 提出了 <a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0020/">PEP 20 – The Zen of Python</a>，译为 Python 之禅，提出了共计 19 条 Python 编码的指导性原则。这已经作为一个彩蛋加入到 Python 标准库中，你可以在 Python 交互式命令行中敲入 <code>import this</code> 查看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&#x27;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&#x27;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&#x27;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&#x27;s do more of those!</span><br></pre></td></tr></table></figure>

<p>这 19 条指导思想强调了代码简约可读的重要性，其中的大多数条目不仅仅适用于 Python，也适用于任何一门其他语言。</p>
<h2 id="Python-风格指导"><a href="#Python-风格指导" class="headerlink" title="Python 风格指导"></a>Python 风格指导</h2><p>除此之外，<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0008/">PEP 8 – Style Guide for Python Code</a> 也是每个 Python 程序员应当阅读的，相较于 Python 之禅它提出了更为细致的建议，目的是让 Python 程序员遵循一致的编码风格。PEP 8 中的大部分都能在 Pycharm IDE 中找到智能提示，缩进、空格与空行也可以通过代码格式化快捷键（Reformat Code）来一键规范化，在 Mac OS 中默认快捷键为 <code>Cmd + Alt + L</code>，Windows 中为 <code>Ctrl + Alt + L</code>。如果你不使用 PyCharm，也可以安装 Pylint，这是一款 Python 源码静态分析工具，可以自动检测代码是否符合 PEP 8 风格指南。</p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>这里，我想强调一下 Python 中的命名规范。PEP 8 提倡采用不用的命名风格来区分 Python 语言中的不同角色：</p>
<ul>
<li>文件名（模块名）使用小写字母，单词间以下划线连接，如 <code>base_futures.py</code>；私有模块使用单个下划线开头，如 <code>_collections_abc.py</code>；</li>
<li>函数、变量及属性名，使用小写字母，单词间以下划线连接，如 <code>dict_keys</code>；</li>
<li>受保护的属性和函数（子类可以访问），使用单个下划线开头，如 <code>_protected_method</code>；</li>
<li>私有的属性和函数（子类也不能访问），使用两个下划线开头，如 <code>__private_method</code>；</li>
<li>类与异常，以每个单词首字母大写来命名，如 <code>BaseHandler</code>、<code>TypeError</code>；</li>
<li>模块级别的常量，全部用大写字母，单词间以下划线连接，如 <code>STDIN_FILENO</code>；</li>
<li>类中的实例方法（instance method），首个参数命名为 <code>self</code> 表示对象自身；类方法（class method），首个参数命名为 <code>cls</code> 表示类自身。</li>
</ul>
<p>有几点需要说明的是，Python 中<strong>下划线前缀仅仅是个约定</strong>，由于 Python 没有 public、protected、private 等访问权限控制关键字，只能以有没有下划线开头这种约定俗成的规范告诉程序员这个变量或函数的范围，注意这并不是强制约束。即使函数以下划线开头，在导入模块后仍能够通过 dot 运算符直接访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> another</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another.external_func()</span><br><span class="line">This <span class="keyword">is</span> a external_func.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another._internal_func()</span><br><span class="line">This <span class="keyword">is</span> a _internal_func.</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，如果通过 * 通配符导入的模块，单下划线以及双下划线开头的函数和属性并不会被导入到当前模块中，除非导入模块显式定义了包含这些函数和属性的 <code>__all__</code> 列表（但通常不会这么做）。此外，也不建议通过通配符导入模块，应当按照最小导入原则，显式的导入需要用到的函数和属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> another <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>external_func()</span><br><span class="line">This <span class="keyword">is</span> a external_func.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_internal_func()</span><br><span class="line">NameError: name <span class="string">&#x27;_internal_func&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<p>在命名时，尤其要<strong>避免以双下划线开头且结尾的命名格式</strong>，如 <code>__foo__</code>，这是 Python 内置的魔法方法（magic methods，或称特殊方法，如 <code>__init__</code>），以及内置属性（如 <code>__code__</code>）的命名方式。因为你不能保证在后续版本中 Python 不会将 <code>__foo__</code> 作为内置方法或属性。</p>
<p>如果你阅读 Python 标准库源码，会发现基本上私有命名都是以单下划线开头，不论是私有函数还是私有类或是私有变量和常量，很少会看到以双下划线开头的。PEP 8 也提倡对于<strong>非公有方法和属性使用单个下划线开头</strong>，只有在避免子类命名冲突时才采用双下划线开头（且不以双下划线结尾），这是由于双下划线前缀会导致 Python 解释器改写属性名称（name mangling）。比如下面代码中的 <code>__v3</code> 就被改写为 <code>_Foo__v3</code> 类名 + 变量名的格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    v1 = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    _v2 = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    __v3 = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    __v4_ = <span class="number">4</span> </span><br><span class="line"><span class="meta">... </span>    __v5__ = <span class="number">5</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[_ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">dir</span>(Foo) <span class="keyword">if</span> <span class="string">&#x27;v&#x27;</span> <span class="keyword">in</span> _]</span><br><span class="line">[<span class="string">&#x27;_Foo__v3&#x27;</span>, <span class="string">&#x27;_Foo__v4_&#x27;</span>, <span class="string">&#x27;__v5__&#x27;</span>, <span class="string">&#x27;_v2&#x27;</span>, <span class="string">&#x27;v1&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>上面代码使用一个<strong>单独的下划线</strong> <code>_</code> 作为循环中的变量名称，代表这个变量是临时的，名称无关紧要，你可以将其理解为<strong>占位符</strong>。</p>
<p>PEP 8 还提到，对于与 Python 保留关键字命名冲突的公有属性，可以采用<strong>单个下划线结尾</strong>的命名格式，这要优于使用缩略格式。比如下面的 <code>class_</code> 变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tkinter.Toplevel(master, class_=<span class="string">&#x27;ClassName&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>另外，Python 在维持语义清晰的原则上为了保证简洁性，一些<strong>简短的介词和连词间会省略下划线</strong>，并没有严格的按照单词间下划线连接，而是直接拼接，比如 <code>isinstance</code>、<code>__setattr__</code> 和 <code>getstate</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/12/20/Python-%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8E%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/20/Python-%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8E%E9%97%AD%E5%8C%85/" class="post-title-link" itemprop="url">Python 装饰器与闭包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-20 17:06:51" itemprop="dateCreated datePublished" datetime="2020-12-20T17:06:51+08:00">2020-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h2><p>虽然《流畅的Python》作者一再强调 Python 不是一门函数式编程语言，但它的的确确具备了一些函数式编程的特性。其中的一个重要特性是：Python 将<strong>函数作为一等公民</strong>。这与 JavaScript、Scala 等语言一样，意味着在这类语言中：<strong>函数与其他数据类型处于同等地位，函数可以定义在函数内部，也可以作为函数的参数和返回值</strong>。基于这个特性，我们可以很容易的定义高阶函数。来看一个 JavaScript 的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数将一个函数作为了返回值，很明显它是一个高阶函数，那么问题来了：这样定义有什么作用或者是好处呢？事实上，这段代码是 JavaScript 中的一个优雅的函数式编程库 <a target="_blank" rel="noopener" href="https://ramdajs.com/">Ramda</a> 对于加法实现的基本思路（还需要可变参数以及参数个数判断）。最终我们可以这样去使用它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> R = <span class="built_in">require</span>(<span class="string">&#x27;ramda&#x27;</span>)</span><br><span class="line">R.add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// -&gt; 3</span></span><br><span class="line"><span class="keyword">const</span> increment = R.add(<span class="number">1</span>) <span class="comment">// 返回一个函数</span></span><br><span class="line">increment(<span class="number">2</span>) <span class="comment">// -&gt; 3</span></span><br><span class="line">R.add(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// -&gt; 3</span></span><br></pre></td></tr></table></figure>

<p>既可以像代码第二行一次性传入两个参数，也可以像代码第三、四行分两个阶段传入，这与代码第五行效果一致。我们将这种特性称为<strong>函数柯里化（Currying）</strong>，这样做的好处一是可以<strong>代码重用</strong>，就像特意将 <code>R.add(1)</code> 取名为 increment 一样，它可以单独地作为一个递增函数；二是可以实现<strong>惰性求值</strong>，只有当函数收集到了所有所需参数，才进行真正的计算并返回结果，这一点在许多流处理框架中有广泛使用。</p>
<p>Python 中的函数之所以可以作为一等公民，究其原因，是因为 Python 中的<strong>一切皆是对象</strong>，即 <em>Everything in Python is an object</em>。使用 <code>def</code> 关键字定义的任何函数，都是 <code>function</code> 类的一个实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(func)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">function</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>既然函数是对象，那就可以持有属性，这也是为什么 Python 中函数可以持有外部定义的变量（也就是闭包问题）的根本原因。这一点与 Java 和 C++ 这类语言是有本质区别的。以 Java8 为例，虽然 Java8 提供了一些语法糖让我们得以编写所谓的“高阶函数”，但 Java 中的函数（方法）依然不能脱离类或者对象而存在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .stream()</span><br><span class="line">        .filter(i -&gt; i &gt;= <span class="number">3</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>上述代码第三行接收一个 Lambda 表达式作为参数，第四行接收一个方法引用，看上去函数可以作为参数传入。但实际上，Java 编译器会将它们转换为<strong>函数接口（Functional Interfaces）</strong>的具体实现，函数接口是 Java8 函数式编程引入的核心概念。例如上述代码中的 <code>System.out::println</code> 方法引用会被实例化为 Consumer 函数接口的具体实现，Consumer 是 Java8 提供的四类函数接口中的一类，称为消费者接口，它有一个 accept 抽象方法接受一个输入且返回值为空，编译器将会用 <code>System.out.println(t)</code> 重写这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer consumer = System.out::println;</span></span><br><span class="line"><span class="comment">// consumer.accept(&quot;hello&quot;);</span></span><br></pre></td></tr></table></figure>

<p>所以在 Java8 中，看似函数可以作为参数传入，但实际上传入的依旧是类的实例。如果对 Java8 的函数式编程感兴趣可以参考这篇：<a target="_blank" rel="noopener" href="https://s2mple.xyz/2018/11/16/Java8%20%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/">Java8 函数接口</a>。</p>
<p>言归正传，既然已经清楚了 Python 中可以定义高阶函数，那么接下来就可以探讨一下 Python 怎么使用高阶函数实现装饰器的。但在这之前，不得不提及一下什么是闭包。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>首先注意，只有涉及到<strong>嵌套函数</strong>才会存在闭包问题。而不要将闭包与匿名函数搞混，是不是匿名函数不是必要条件，只是人们通常将闭包与匿名函数搭配使用罢了（尤其是在 JavaScript 中）。</p>
<p>实际上，闭包是指<strong>延伸了作用域的函数</strong>，关键在于它<strong>能够访问定义体之外定义的非全局变量</strong>。听上去有些绕，不过看看下面这段代码就很好理解了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_average</span>():</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">average</span>(<span class="params">new_value</span>):</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = <span class="built_in">sum</span>(series)</span><br><span class="line">        <span class="keyword">return</span> total / <span class="built_in">len</span>(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> average</span><br></pre></td></tr></table></figure>

<p>关注点放在 series 这个变量。它定义在内层函数 average 之外并在内层函数中做了修改（末尾追加了一个值）。并且，内层函数被当作外层函数的返回值返回。显然，内层函数 average 设计出来是为了多次调用的，然而 series 是在内层函数之外定义的，当多次调用 average 时 series 作用域是否已经消亡了呢？答案是否。看看下面的输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_average()  <span class="comment"># 返回 average 函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">1</span>)  <span class="comment"># (1) / 1</span></span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">2</span>)  <span class="comment"># (1 + 2) / 2</span></span><br><span class="line"><span class="number">1.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">3</span>)  <span class="comment"># (1 + 2 + 3) / 3</span></span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p>原因在于，上述代码中的 series 变量声明语句与 average 函数定义体构成了一个闭包，average 函数的作用域延伸到函数外部，换句话说，series 已经绑定到 average 函数对象上了。我们将 series 这种变量称为<strong>自由变量</strong>（free variable）。可以通过 Python 提供的内省属性访问：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class="line">(<span class="string">&#x27;series&#x27;</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x104301400</span>: <span class="built_in">list</span> <span class="built_in">object</span> at <span class="number">0x1041a9580</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><code>__code__.co_freevars</code> 以元组形式存放了自由变量的<strong>名称</strong>。要想访问自由变量的值，需要通过 <code>__closure__</code> 属性，也就是说，实际上 series 是绑定到 <code>avg.__closure__</code> 中的。Python 在自由变量之上包装了一个 cell 对象，用 <code>cell_contents</code> 存放其真正的值。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器，又称函数装饰器，本质上是一个<strong>可调用对象</strong>（实现了 <code>__call__</code> 方法），可以是一个函数或者一个类。它的作用是可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能。装饰器接受一个函数作为参数，即被装饰的函数，可能会对这个函数进行处理然后将它返回，或者替换为另一个函数或可调用对象。</p>
<p>先来看一个最简单的装饰器示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">decorate</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;running decorator...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> func</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@decorate</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">target</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;running target...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">running decorator...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target()</span><br><span class="line">running target...</span><br></pre></td></tr></table></figure>

<p>上述代码定义了一个名为 decorate 的装饰器，然后通过 <code>@decorate</code> 标注在 target 函数上表明用它来装饰 target 函数。乍一看，这与 Java 中的注解语法是一样的，但其实两者作用是完全不同的。Java 中的注解只是元数据，不会对被修饰的对象做任何修改，必须通过运行时的反射（<code>getAnnotation</code> 方法）才能发挥它的作用。而在 Python 中，<strong>装饰器的作用就是定义一个嵌套函数</strong>。你可以理解为，通过装饰器装饰后，target 函数被重新定义为了如下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure>

<p>但装饰器与这样直接定义还是有几点区别的。第一点，<strong>装饰器是在被装饰的函数定义之后立即执行的</strong>，这通常是在<strong>导入时</strong>（import），也就是 Python 加载模块时发生的。如果你足够细心，就会发现上述代码中的 <code>&#39;running decorator...&#39;</code> 是在 target 函数定义后就被立即打印了，并且调用 target 函数时也没有重复打印。也就是说，<strong>函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行</strong>。这突出了 Python 的导入时和运行时的区别。</p>
<p>第二点，函数装饰器既然要体现它的“装饰”语义，就需要接收一个函数作为参数然后返回一个函数，无论返回的函数是原封不动的原函数还是“装饰”后的函数。也就是说，<strong>装饰器对于函数调用者是透明的</strong>。那么，装饰器返回一个其他类型就没有意义。事实证明，如果返回了其他类型，代码运行将会报出 TypeError 错误（没有找到 <code>__call__</code> 方法）。而如果只是嵌套函数 <code>decorate(target)</code> 的写法是没有返回类型的限制的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;running decorator...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TypeError: &#x27;int&#x27; object is not callable</span></span><br></pre></td></tr></table></figure>

<h3 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h3><p>事实上，<strong>大多数装饰器会在内部定义一个函数然后将其返回</strong>，原封不动地返回被装饰的函数是没有多大用处的。像这样的双层嵌套函数足以应对绝大多数的装饰器需求了，其最大的好处是：可以<strong>支持带有参数的被装饰函数</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">target</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[INFO]: the function <span class="subst">&#123;func.__name__&#125;</span>() is running...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure>

<p>不管原函数（被装饰函数）func 接收什么类型的参数，在使用 logger 装饰器时都将被打包成定位参数 <code>*args</code> 和仅限关键字参数 <code>**kwargs</code>，原封不动的传入到装饰器的内部函数 target 中，执行完装饰逻辑后通过 <code>func(*args, **kwargs)</code> 执行原函数。从而能够实现“不修改原有函数接口、不影响原有函数执行”的前提下添加额外功能。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@logger</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age=<span class="number">18</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(name, age)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line">[INFO]: the function person() <span class="keyword">is</span> running...</span><br><span class="line">Jack <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>除了被装饰函数可以带有参数外，装饰器本身也可以带有参数，如 <code>@logger(Level.INFO)</code> 在装饰器中指定日志等级，根据业务逻辑标注在不同的函数上，从而最大程度的发挥装饰器的灵活性。</p>
<p>接下来，我会结合一个更实用的例子 —— 记录被装饰函数运行时间的计时器，展示如何定义并使用一个带参装饰器。同时，你还将看到闭包问题是如何在装饰器中体现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span>(<span class="params">unit=TimeUnit.SECONDS</span>):</span>  <span class="comment"># ①</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span>  <span class="comment"># ②</span></span><br><span class="line">            start = time.perf_counter()</span><br><span class="line">            result = func(*args, **kwargs)  <span class="comment"># ③</span></span><br><span class="line">            end = time.perf_counter()</span><br><span class="line">            arg_str = <span class="string">&#x27;, &#x27;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">            <span class="keyword">if</span> unit == TimeUnit.SECONDS:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;running <span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;arg_str&#125;</span>): <span class="subst">&#123;end - start&#125;</span>s&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;running <span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;arg_str&#125;</span>): <span class="subst">&#123;(end - start) * <span class="number">1000</span>&#125;</span>ms&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure>

<p>带参装饰器比无参装饰器多了一层嵌套，这是一种妥协，原因是<strong>装饰器只能且必须接收一个函数作为参数</strong>，所以为了使装饰器接收其他参数，不得不在之上再包装一层函数。在上述代码的三层函数中，最外层定义的 clock 函数是参数化装饰器<strong>工厂函数</strong>，第二层 decorate 函数才是真正的装饰器，wrapper 函数则是执行装饰逻辑的包裹函数（被装饰函数在其中执行）。</p>
<p>此外代码中用带圈数字标注的几个需要注意的点是：</p>
<ul>
<li>① 最外层的 clock 工厂函数接收一个名为 unit 的时间单位的参数，默认值为秒（这里采用枚举类型）；</li>
<li>② <strong>如果被装饰的函数带参数，只需要把装饰器最内层函数跟被装饰函数的参数列表保持一致即可</strong>。这里 wrapper 函数接收任意个定位参数 <code>*args</code> 和仅限关键字参数 <code>**kwargs</code>，写成这样的目的是想体现 clock 计时器的泛用性，你可以在 ③ 处原封不动地将这些参数传给被装饰函数 func 调用；</li>
<li>③ func 实际上是定义在 wrapper 外层的自由变量（作为 decorate 的参数传入），所以它已经被绑定到 wrapper 的闭包中。</li>
</ul>
<p>③ 处是被装饰函数真正执行的地方，上下两行使用计时器记录并统计了 func 函数运行前后的时间差值，在打印时根据传入 clock 的参数决定打印时间单位采用秒还是毫秒。我们来看看如何使用这个装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@clock()</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">secs</span>):</span></span><br><span class="line"><span class="meta">... </span>    time.sleep(secs)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@clock(unit=TimeUnit.SECONDS)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">sleep_secs</span>(<span class="params">secs</span>):</span></span><br><span class="line"><span class="meta">... </span>    time.sleep(secs)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@clock(unit=TimeUnit.MILL_SECONDS)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">sleep_ms</span>(<span class="params">ms</span>):</span></span><br><span class="line"><span class="meta">... </span>    time.sleep(ms / <span class="number">1000</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sleep(<span class="number">0.1</span>)</span><br><span class="line">running sleep(<span class="number">0.1</span>): <span class="number">0.10221230299998751</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sleep_secs(<span class="number">1</span>)</span><br><span class="line">running sleep_secs(<span class="number">1</span>): <span class="number">1.000441283999976</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sleep_ms(<span class="number">100</span>)</span><br><span class="line">running sleep_ms(<span class="number">100</span>): <span class="number">103.84234799994374</span>ms</span><br></pre></td></tr></table></figure>

<p>需要注意，第一个空参装饰器 <code>@clock()</code>，其中的 <code>()</code> 是不能省略的，它使用了 <code>TimeUnit.SECONDS</code> 作为默认参数，这是在 clock 定义处声明的。此外，clock 装饰器中的参数并不是和函数名绑定的，打印的时间单位完全取决于传入 clock 装饰器的参数。比如，也可以让 sleep_ms 按照秒的格式打印时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@clock(unit=TimeUnit.SECONDS)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">sleep_ms</span>(<span class="params">ms</span>):</span></span><br><span class="line"><span class="meta">... </span>    time.sleep(ms / <span class="number">1000</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sleep_ms(<span class="number">100</span>)</span><br><span class="line">running sleep_ms(<span class="number">100</span>): <span class="number">0.10072612899966771</span>s</span><br></pre></td></tr></table></figure>

<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>前面提到，装饰器本质上是一个可调用对象。到目前为止，给出的示例都是函数类型的装饰器，函数当然是可调用对象。但如果阅读 Python 源码，会发现许多装饰器是用类定义的，比如内置模块中的 property、classmethod 和 staticmethod 类。这些类都可调用对象（callable），对于用户来说，自定义一个类装饰器需要让这个类实现 <code>__call__</code> 方法，这样解释器在运行时会将这个类绑定为 Callable 类的子类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="built_in">property</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="built_in">staticmethod</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span> ...</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(Foo())</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> <span class="type">Callable</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(Foo, <span class="type">Callable</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>对于不含参数的类装饰器来说，除了需要实现 <code>__call__</code> 方法之外，唯一要做的就是在构造函数 <code>__init__</code> 中初始化被装饰函数。下面定义了一个基于类的无参装饰器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[INFO]: the function <span class="subst">&#123;self._func.__name__&#125;</span>() is running...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._func(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>函数类型的装饰器是将装饰逻辑定义在嵌套函数的内部函数中，而无参类装饰器则是将装饰逻辑定义在类中的 <code>__call__</code> 方法内，类装饰器同样可以装饰带有参数的函数。两者的区别只不过是，定义函数装饰器时被装饰函数 func 作为参数传入，定义类装饰器时 func 作为属性传入。类装饰器同样是以 <code>@ + 类名</code> 的形式标注在被装饰函数上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> class_decorator <span class="keyword">import</span> Logger</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@Logger</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age=<span class="number">18</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(name, age)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line">[INFO]: the function person() <span class="keyword">is</span> running...</span><br><span class="line">Jack <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>定义类形式的装饰器与函数形式的装饰器并无太大差别，本质上 Python 解释器都将它们作为可调用对象进行处理。只不过现在最外层的装饰器工厂函数变成了类，传入的装饰器的参数变成了类的属性；而第二层对应的是 <code>__call__</code> 方法，接收被装饰函数作为参数；<code>__call__</code> 方法内还需定义执行装饰逻辑的包裹函数。用类改写的日志装饰器的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, level=<span class="string">&#x27;INFO&#x27;</span></span>):</span></span><br><span class="line">        self._level = level</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;self._level&#125;</span>]: the function <span class="subst">&#123;func.__name__&#125;</span>() is running...&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>使用时可以指定日志的输出级别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@Logger(<span class="string">&#x27;Debug&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age=<span class="number">18</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(name, age)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line">[Debug]: the function person() <span class="keyword">is</span> running...</span><br><span class="line">Jack <span class="number">18</span></span><br></pre></td></tr></table></figure>

<h3 id="面向切面的程序设计"><a href="#面向切面的程序设计" class="headerlink" title="面向切面的程序设计"></a>面向切面的程序设计</h3><p>面向切面的程序设计是一种程序设计思想，旨在将横切关注点与业务主体进行分离。<strong>横切关注点</strong>指的是一些具有横越多个模块的行为，使用传统的软件开发方法不能够达到有效的模块化的一类特殊关注点。通俗点说，面向切面编程就是<strong>使得解决特定领域问题的代码从业务逻辑中独立出来</strong>。业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过切面来封装、维护。</p>
<p>联系到本文所编写的几个装饰器，日志记录 logger、性能测试 clock 计时器，这些都是较为常见的<strong>横切关注点</strong>。试想一下，如果需要记录多个函数的运行时间，在这些函数内部硬编码计时代码是否合适？显然，这不仅会造成代码重复，更关键的是破坏了函数的存粹性（将不该属于它的计时功能强加于它），造成了代码的紧耦合。现在有了装饰器，只需要在需要计时的函数之上添加 <code>@clock</code> 标注即可，计时器的逻辑统一在装饰器中定义和维护，实现了与业务代码的解耦。</p>
<p>因此，装饰器非常适用于有切面需求的场景，诸如：插入日志、性能测试、事务处理、缓存、权限校验等。装饰器是解决这类问题的绝佳设计。通过装饰器，我们可以抽离出与函数功能本身无关的代码到装饰器中，从而实现面向切面编程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《流畅的 Python》</li>
<li><a target="_blank" rel="noopener" href="https://s2mple.xyz/2018/05/24/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.jenkster.com/2015/12/which-programming-languages-are-functional.html">Which Programming Languages Are Functional?</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/11/23/%E6%B5%81%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-Storm%E3%80%81Flink-Spark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/%E6%B5%81%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-Storm%E3%80%81Flink-Spark/" class="post-title-link" itemprop="url">流处理框架介绍: Storm、Spark & Flink</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-23 17:03:00" itemprop="dateCreated datePublished" datetime="2020-11-23T17:03:00+08:00">2020-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Concepts/" itemprop="url" rel="index"><span itemprop="name">Concepts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>与传统的批处理（Batch processing）相比，流处理（Streaming processing）处理的是实时的持续数据流，也被称为无界数据集（unbounded datasets），亦即能够持续增长的、不可预测的无限数据集。而批处理处理的是有界数据集（bounded datasets），有界数据集是有限的不变的，存在开始和结束，也被称之为历史数据集（historic datasets）。</p>
<p>通常，为了应对高速流动的无界数据流，流处理对于处理效率要求更高，内存占用要求更低，与之相对的，相较批处理对于错误的容忍度要更高。</p>
<p>本文介绍了 Apache Storm、Apache Flink 和 Spark Streaming 三种常用流处理框架，主要包含它们各自的拓扑结构和运行时架构，最后还对流处理框架的演进和流批一体化的趋势做了简要介绍。</p>
<h2 id="Apache-Storm"><a href="#Apache-Storm" class="headerlink" title="Apache Storm"></a>Apache Storm</h2><p><a target="_blank" rel="noopener" href="https://storm.apache.org/index.html">Apache Storm</a> 是一个分布式实时计算框架，主要使用 Clojure 和 Java 语言编写，目前最新版本 2.2.0。在 Storm 中，数据流被抽象为 tuples，由数据和 ID 标识符组成。Storm 的拓扑结构（Topology）是一个有向无环图，由<strong>输入节点Spouts</strong>、<strong>处理节点Bolts</strong>和<strong>代表数据流的边</strong>三部分组成，如下图所示：</p>
<p><img data-src="1.png" alt="7f120eb6c1e92b4775e84d196100e3f5.png"></p>
<p>Spouts 是整个拓扑结构的入口点，负责将输入数据流转换为 tuples，送至 Bolts 进行处理；Bolts 负责处理输入流并转换为输出流，它维护了处理逻辑，能够对 tuples 执行过滤、映射、聚合等函数式操作，还能与数据库进行交互。</p>
<p>Storm 的运行时架构与 Hadoop 类似，也是经典的主从模式（master-slave）。Storm 中的主节点（master node）运行一个叫做 <strong>Nimbus</strong> 的程序，由其负责资源分配和任务调度，用户定义的 Topology 会被提交到 Nimbus 上；从节点（worker node）运行 <strong>Supervisor</strong> 程序，负责执行 Nimbus 分配的任务，其上可以运行一个或多个工作进程（worker process），每个工作进程执行 Topology 的一个子集。Nimbus 不能直接与 Supervisor 进行交互，两者需要通过 <strong>ZooKeeper</strong> 进行协作，ZooKeeper 保存调度信息、心跳信息、集群状态和配置信息。</p>
<p><img data-src="2.png" alt="aa1882c89b70544081866ade75563064.png"></p>
<p>类似于 Hadoop 中的 MapReduce 架构，每个 Spouts 和 Bolts 也可以设置<strong>并行度</strong>（parallelism）。通过设置并行度可指定一个 Worker 运行多个 Executor，所以实际上 Executor 才是运行 Spouts 或者 Bolts 组件的最小单元。</p>
<p><strong>数据一致性</strong>方面，Storm 基于 ACK 确认机制，可以确保每个 Tuple 至少被执行一次（<strong>at-least-once</strong>）。但现如今 Storm 官方提供了一个在 Storm 之上的更高层级的抽象：<a target="_blank" rel="noopener" href="http://storm.apache.org/releases/current/Trident-tutorial.html">Trident</a>，可以确保每个 Tuple 有且只有一次被执行（exactly-once），代价是增大了数据处理的延迟。Trident 的示例 API 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TridentTopology topology = <span class="keyword">new</span> TridentTopology();        </span><br><span class="line">TridentState wordCounts =</span><br><span class="line">     topology.newStream(<span class="string">&quot;spout1&quot;</span>, spout)</span><br><span class="line">       .each(<span class="keyword">new</span> Fields(<span class="string">&quot;sentence&quot;</span>), <span class="keyword">new</span> Split(), <span class="keyword">new</span> Fields(<span class="string">&quot;word&quot;</span>))</span><br><span class="line">       .groupBy(<span class="keyword">new</span> Fields(<span class="string">&quot;word&quot;</span>))</span><br><span class="line">       .persistentAggregate(<span class="keyword">new</span> MemoryMapState.Factory(), <span class="keyword">new</span> Count(), <span class="keyword">new</span> Fields(<span class="string">&quot;count&quot;</span>))                </span><br><span class="line">       .parallelismHint(<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h2><p><a target="_blank" rel="noopener" href="https://spark.apache.org/">Apache Spark</a> 于 2009 年诞生于加州大学伯克利分校，2013 年被捐献给 Apache 基金会。Spark 的初衷是改良 Hadoop 的 MapReduce 编程模型和执行速度，它提供了更加方便易用的接口，提供 Java、Scala、Python 和 R 四种语言的 API，支持 SQL、机器学习和图计算，覆盖了绝大多数大数据计算的场景。Spark 由 Java 和 Scala 编写，目前最新版本 3.0.1。</p>
<p>Spark Streaming 是 Spark 框架中的核心组件之一，提供流处理功能。但 Spark Streaming 并不支持严格意义的实时流处理，它按照预设的时间间隔将流数据累积，对这个时间间隔上的数据做批处理。所以实际上 Spark Streaming 是一种<strong>微批处理（micro-batch）</strong>框架。</p>
<p>Spark 提出了弹性分布式数据集 <strong>RDD</strong>（resilient distributed dataset）的概念，它是 Spark 中最基本的数据抽象，它代表一个不可变、只读的，被分区的数据集，你可以像操作本地集合一样操作 RDD。而在 RDD 之上，Spark Streaming 包装了称为离散流 <strong>DStream</strong>（discretized stream）的高级抽象，底层由一系列连续的 RDD 组成。</p>
<p><img data-src="3.png" alt="557ca0d5fa2c990b57e8d1a8a625df02.png"></p>
<p>Spark 架构也是经典的 master-slave 架构。主节点上运行着 Driver，用户从客户端提交应用 Jar 包，首先会构建一个 Spark Application，并初始化程序入口 <strong>SparkContext</strong>（要运行 Spark Streaming 程序则是 StreamingContext），由 SparkContext 负责和资源管理器 Cluster Manager（可以是 Standalone，Mesos，YARN）进行通信以及资源的申请、任务的分配和监控等。</p>
<p>SparkContext 根据 RDD 之间的依赖关系构建 DAG 图，提交给 DAG 调度器 DAGScheduler 进行解析，DAGScheduler 将 DAG 图分解成多个阶段（stage），也就是任务子集（Taskset），再提交给底层的任务调度器 TaskScheduler ，最后由 Task Scheduler 将 Task 发送给 Executor 运行。</p>
<p><img data-src="4.png" alt="f987224f95342713f69ee1a0bd428474.png"></p>
<p>数据一致性方面，Spark 采用了 Checkpoint 机制保证了数据处理的 <strong>exactly-once</strong> 语义。</p>
<p>另外值得一提的是，Spark 提供了 MLlib 机器学习库，并且支持<strong>流式机器学习算法</strong>（streaming machine learning algorithms），包括 Streaming Linear Regression，Streaming KMeans 等等。这意味着可以一边使用流数据训练模型，一边将模型应用于流数据。此外，你也可以通过历史数据离线训练模型，再将模型在线地应用于实时流数据。</p>
<h2 id="Apache-Flink"><a href="#Apache-Flink" class="headerlink" title="Apache Flink"></a>Apache Flink</h2><p><a target="_blank" rel="noopener" href="https://flink.apache.org/">Apache Flink</a> 是由德国几所大学发起的的学术项目，后来不断发展壮大，并于 2014 年末成为 Apache 顶级项目。Flink 主要面向流处理，如果说 Spark 是批处理界的王者，那么 Flink 就是流处理领域的冉冉升起的新星。Flink 由 Java 和 Scala 编写，目前最新版本 1.11。</p>
<p>Flink 提供了负责流处理的  <strong>DataStream API</strong> 和负责批处理的 <strong>DataSet API</strong>，在其之上，又封装了 <strong>Table API</strong> 和 <strong>SQL</strong> 两种关系型 API。这两个 API 都是批处理和流处理统一的 API，这意味着在无边界的实时数据流和有边界的历史记录数据集上，关系型 API 会以相同的语义执行查询，并产生相同的结果。它们可以与 DataStream 和 DataSet API 无缝集成，并支持用户自定义的标量函数，聚合函数以及表值函数。</p>
<p>在 DataStream API 设计中，一个 Streaming Dataflow 被定义为由一系列 <strong>Operator</strong>（算子）组成，Operator 分为三类：Source Operator 定义入口；Sink Operator 定义出口；Transformation Operator 定义数据的中间转换操作。下图是一个使用 DataStream API 的示例：</p>
<p><img data-src="5.png" alt="7489b8c785545f3d80c397cfc32bdca3.png"></p>
<p>在一个完整的 Dataflow DAG 中，可能包含多个 Source 和 Sink，一个 Transformation 也可以包含多个算子。在执行过程中，一个流会有一个或多个流分片（stream partitions），一个算子包含一个或多个算子子任务（operator subtasks），算子子任务的个数就是该算子的并行度（parallelism）。</p>
<p>Flink 运行时架构如下图所示，主要由一个 JobManager 进程和若干个 TaskManager 进程组成。其中，客户端 Client 并不是程序运行的组成部分，而是负责将用户的 Jar 包构建成 Dataflow Graph，提交到 JobManager 上。JobManager 和 TaskManager 既可以直接以 standalone 模式启动，也可以通过 YARN 或者 Mesos 等资源管理框架进行协调工作。</p>
<p><img data-src="6.png" alt="e870b01bdb5da98f44fbc6729f928b14.png"></p>
<p><strong>JobManager</strong> 类似于 Storm 中的 Nimbus，是协调 Flink 应用分布式执行的主进程。一个 Flink 应用中至少有一个 JobManager，在高可用（High Availability）模式下可能会存在多个 JobManager，它们中的一个作为 leader，其余作为 standby。JobManager 由三个组件组成：</p>
<ul>
<li><strong>ResourceManager</strong>，负责 Flink 集群资源的分配。它管理着资源调度的最小单元 Task Slots，同时支持 YARN，Mesos，Kubernetes 等多种部署管理方式；</li>
<li><strong>Dispatcher</strong>，为用户提供了一个可以提交 Flink 应用的 REST 接口。同时  Dispatcher 也会启动一个Web UI，方便展示和监控作业执行的信息；</li>
<li><strong>JobMaster</strong>，负责管理作业图（JobGraph）的执行。多个 Job 可以同时在 Flink 集群上运行，每个 Job 会有自己独立的 JobMaster。</li>
</ul>
<p><strong>TaskManager</strong>，又称作 Worker，负责执行 Task，以及数据流的缓存和交换。Flink 很形象的将任务执行资源称为 Task Slot（插槽），每个插槽是 TaskManager 资源的一个固定子集，比如拥有 3 个插槽的 TaskManager 每个插槽能够使用 1/3 的内存。TaskManager 携有资源，而调度则是通过 JobManager。</p>
<p>数据一致性方面，Flink 通过 Checkpoint（检查点）机制，保证了数据处理的“精确一次”（<strong>exactly-once</strong>）语义。在应用程序运行期间，Flink 会定期检查状态的一致检查点。如果发生故障，Flink 会将程序状态置为最近的检查点时的状态，并重新启动处理流程，消费并处理检查点和发生故障之间的所有数据。尽管这意味着 Flink 会对一些数据处理两次（在故障之前和之后），我们仍然可以说这个机制实现了精确一次的一致性语义，因为所有算子的状态都已被重置，而重置后的状态下还不曾看到这些数据。</p>
<h2 id="流处理框架演进"><a href="#流处理框架演进" class="headerlink" title="流处理框架演进"></a>流处理框架演进</h2><p>流处理框架的演进，要从 MapReduce 编程模型开始讲起。为了解决分布式计算学习和使用成本高的问题，Google 在 2004 年提出一种编程范式，它要求程序员将分布式数据操作拆分为两大步：<code>map</code> 和 <code>reduce</code>，也就是所谓的 MapReduce 编程模型。</p>
<p>在同一年，Hadoop 的创始人受 MapReduce 编程模型等一系列论文的启发，对论文中提出的模型进行了编程实现。时至今日，Hadoop 不仅仅是整个大数据领域的先行者和领导者，更形成了一套围绕 Hadoop 的生态系统，成为企业首选的大数据解决方案。不论是 Storm、Spark 还是 Flink 都是敞开怀抱拥抱 Hadoop 生态并融入成为了生态圈的一部分。</p>
<p><img data-src="7.png" alt="e2dc809939ef9af086d3197d3e648b0e.png"></p>
<p>Hadoop 虽然已被公认为大数据分析领域无可争辩的王者，但它更加专注于批处理，并不适合做实时计算。随着 Hadoop 生态的繁荣发展，诞生了一批流处理框架，本质上它们的核心处理流程也不偏离 MapReduce 思想：</p>
<ul>
<li><strong>第一代</strong>被广泛采用的流处理框架是 Storm，但由于 Storm 只支持 “at least once” 语义，对于很多对数据准确性要求较高的应用，Storm 有一定劣势。</li>
<li><strong>第二代</strong>非常流行的流处理框架是 Spark Streaming。Spark Streaming 使用微批处理的思想，每次处理一小批数据，以接近实时处理的效果。也正是由于时间间隔的存在，导致 Spark Streaming 的“实时处理”延迟较大，一般适用于延迟是秒级别的实时计算应用。但 Spark Streaming 的优势是拥有 Spark 这个靠山，用户从 Spark 迁移到 Spark Streaming 的成本较低，因此能给用户提供一个批量和流式于一体的计算框架。</li>
<li><strong>第三代</strong>流处理框架 Flink 是一个支持在有界和无界数据流上做有状态计算的大数据引擎。它以事件为单位，并且支持 SQL、State、WaterMark 等特性。比起 Storm，它的吞吐量更高，延迟更低，准确性能得到保障；比起 Spark Streaming，它以事件为单位，达到真正意义上的实时计算，且所需计算资源相对更少。</li>
</ul>
<p><img data-src="8.jpg" alt="67fc13f9d829042f7b800522e416d280.jpeg"></p>
<p>Spark 和 Flink 各有所长，也在相互竞争、相互借鉴。可以说 Spark 是以批处理起家的，通过使用内存计算比传统 Hadoop MapReduce 具有显著性能优势，Spark 已经成为行业内大数据批处理的首选处理引擎。但在处理稍微复杂点的实时流处理场景 (比如各种窗口、状态等) ，Flink 要比 Spark Streaming 更具有显著优势。事实证明，阿里最终在流处理框架选型中选择了 Flink，并在其之上开发了自己的流处理框架 Blink，并对 Flink 社区提供了贡献，包括促进 Flink 流处理、批处理一体化等。</p>
<h2 id="流批一体"><a href="#流批一体" class="headerlink" title="流批一体"></a>流批一体</h2><p>现如今，流批一体已经越来越成为一种趋势，它旨在将流处理和批处理通过一套相同的处理逻辑来实现。流批一体意味着计算引擎同时具备流计算的低延迟和批计算的高吞吐高稳定性，提供统一编程接口开发两种场景的应用并保证它们的底层执行逻辑是一致的。</p>
<p>2015 年，Google 提出了 <a target="_blank" rel="noopener" href="https://www.vldb.org/pvldb/vol8/p1792-Akidau.pdf">Dataflow</a> 模型，旨在提供一种统一批处理和流处理的解决方案。作为 Dataflow 模型的最早采用者之一，Apache Flink 在流批一体特性的完成度上在开源项目中是十分领先的。Flink 遵循 Dataflow 模型的理念: <strong>批处理是流处理的特例</strong>，亦即批处理处理的是无界数据流上的一小段有界数据流。Flink 设计之初流处理应用和批处理应用底层都是流处理，但在编程 API 上是分开的。</p>
<p><img data-src="9.png" alt="dbcd10468cea3d61ff1f88d9c640643a.png"></p>
<p>在 Flink 架构上，负责物理执行环境的 Runtime 层是统一的流处理，上面分别有独立的 DataStream 和 DataSet 两个 API，两者基于不同的任务类型（Stream Task/Batch Task）和 UDF 接口（Transformation/Operator）。而更上层基于关系代数的 Table API 和 SQL API 表面上是统一的，但实际上编程入口（Environment）是分开的，且内部将流批作业分别翻译到 DataStream API 和 DataSet API 的逻辑也是不一致的。</p>
<p>基于批处理是流处理的特例的理念，用流处理表达批处理在语义上是完全可行的，而流批一体的难点在于批处理场景作为特殊场景的优化。对 Flink 而言，难点主要体现批处理作业在 Task 线程模型、调度策略和计算模型及算法的差异性上。因此，要实现真正的流批一体，Flink 需完成 Table/SQL API 的和 DataStream/DataSet API 两层的改造，将批处理完全移植到流处理之上，并且需要兼顾作为批处理立身之本的效率和稳定性。目前流批一体也是 Flink 长期目标中很重要一点，流批一体的完成将标志着 Flink 进入 2.0 新版本的时代。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.tutorialandexample.com/apache-storm-tutorial/">Apache Storm Tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://spark.apache.org/docs/latest/streaming-programming-guide.html">Spark Streaming Programming Guide 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/">Apache Flink 1.11 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://confucianzuoyuan.github.io/flink-tutorial/book/chapter03-05-02-%E4%BB%8E%E4%B8%80%E8%87%B4%E6%A3%80%E6%9F%A5%E7%82%B9%E4%B8%AD%E6%81%A2%E5%A4%8D%E7%8A%B6%E6%80%81.html">尚硅谷Flink教程</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94302767">从Hadoop到Spark、Flink，大数据处理框架十年激荡发展史</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/754468">Flink 流批一体的实践与探索 —— 阿里云开发者社区</a></li>
<li><a target="_blank" rel="noopener" href="https://www.vldb.org/pvldb/vol8/p1792-Akidau.pdf">The Dataflow Model: A Practical Approach to Balancing Correctness, Latency, and Cost in Massive-Scale, Unbounded, Out-of-Order Data Processing</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/10/11/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/11/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">LaTeX 数学公式语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-11 10:05:13" itemprop="dateCreated datePublished" datetime="2020-10-11T10:05:13+08:00">2020-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="特殊格式"><a href="#特殊格式" class="headerlink" title="特殊格式"></a>特殊格式</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$x^n$</td>
<td align="center"><code>x^n</code></td>
<td align="center">上标符号</td>
</tr>
<tr>
<td align="center">$x_1$</td>
<td align="center"><code>x_1</code></td>
<td align="center">下标符号</td>
</tr>
<tr>
<td align="center">$v_{\mbox{初始}}$</td>
<td align="center"><code>V_&#123;\mbox&#123;初始&#125;&#125;</code></td>
<td align="center">汉字形式</td>
</tr>
<tr>
<td align="center">$\displaystyle \frac{x+y}{y+z}$</td>
<td align="center"><code>\displaystyle \frac&#123;x+y&#125;&#123;y+z&#125;</code></td>
<td align="center">字体控制</td>
</tr>
<tr>
<td align="center">$\underline{x+y}$</td>
<td align="center"><code>\underline&#123;x+y&#125;</code></td>
<td align="center">下划线符号</td>
</tr>
<tr>
<td align="center">$\overbrace{a+b+c+d}^{2.0}$</td>
<td align="center"><code>\overbrace&#123;a+b+c+d&#125;^&#123;2.0&#125;</code></td>
<td align="center">上大括号</td>
</tr>
<tr>
<td align="center">$a+\underbrace{b+c}_{1.0}+d$</td>
<td align="center"><code>a+\underbrace&#123;b+c&#125;_&#123;1.0&#125;+d</code></td>
<td align="center">下大括号</td>
</tr>
<tr>
<td align="center">$x \stackrel{f} \rightarrow y$</td>
<td align="center"><code>x \stackrel&#123;f&#125; \rightarrow y</code></td>
<td align="center">上位符号</td>
</tr>
<tr>
<td align="center">${n+1 \choose k}={n \choose k}+{n \choose k-1}$</td>
<td align="center"><code>&#123;n+1 \choose k&#125;=&#123;n \choose k&#125;+&#123;n \choose k-1&#125;</code></td>
<td align="center">组合公式</td>
</tr>
</tbody></table>
<h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\pm$</td>
<td align="center"><code>\pm</code></td>
<td align="center">加减运算</td>
</tr>
<tr>
<td align="center">$\mp$</td>
<td align="center"><code>\mp</code></td>
<td align="center">减甲运算</td>
</tr>
<tr>
<td align="center">$\times$</td>
<td align="center"><code>\times</code></td>
<td align="center">乘法运算</td>
</tr>
<tr>
<td align="center">$\cdot$</td>
<td align="center"><code>\cdot</code></td>
<td align="center">点乘运算</td>
</tr>
<tr>
<td align="center">$\ast$</td>
<td align="center"><code>\ast</code></td>
<td align="center">星乘运算</td>
</tr>
<tr>
<td align="center">$\div$</td>
<td align="center"><code>\div</code></td>
<td align="center">除法运算</td>
</tr>
<tr>
<td align="center">$\frac{x+y}{y+z}$</td>
<td align="center"><code>\frac&#123;x+y&#125;&#123;y+z&#125;</code> 或 <code>&#123;x+y&#125; \over &#123;y+z&#125;</code></td>
<td align="center">分式运算</td>
</tr>
<tr>
<td align="center">$\overline{x}$</td>
<td align="center"><code>\overline&#123;x&#125;</code></td>
<td align="center">平均数运算</td>
</tr>
<tr>
<td align="center">$\sqrt x$</td>
<td align="center"><code>\sqrt x</code></td>
<td align="center">开根号运算</td>
</tr>
<tr>
<td align="center">$\sqrt[n]{x+y}$</td>
<td align="center"><code>\sqrt[n]&#123;x+y&#125;</code></td>
<td align="center">开方运算</td>
</tr>
<tr>
<td align="center">$\log_2 x$</td>
<td align="center"><code>\log_2 x</code></td>
<td align="center">对数运算</td>
</tr>
<tr>
<td align="center">$\lim \limits_{n \to \infty}x_n$</td>
<td align="center"><code>\lim \limits_&#123;n \to \infty&#125;x_n</code></td>
<td align="center">极限运算</td>
</tr>
<tr>
<td align="center">$\sum \limits_{i=1}^n{x_i}$</td>
<td align="center"><code>\sum \limits_&#123;i=1&#125;^n&#123;x_i&#125;</code></td>
<td align="center">求和运算</td>
</tr>
<tr>
<td align="center">$\prod \limits_{i=1}^n{x_i}$</td>
<td align="center"><code>\prod \limits_&#123;i=1&#125;^n&#123;x_i&#125;</code></td>
<td align="center">连乘运算</td>
</tr>
<tr>
<td align="center">$\int_{a}^{b} e^x, dx$</td>
<td align="center"><code>\int_&#123;a&#125;^&#123;b&#125; e^x\, dx</code></td>
<td align="center">积分运算</td>
</tr>
<tr>
<td align="center">$\iint \limits_D, dx,dy$</td>
<td align="center"><code>\iint \limits_D\, dx\,dy</code></td>
<td align="center">双重积分</td>
</tr>
<tr>
<td align="center">$\oint_{L} x+y, dx,dy$</td>
<td align="center"><code>\oint_&#123;L&#125; x+y\, dx\,dy</code></td>
<td align="center">闭合曲线积分</td>
</tr>
<tr>
<td align="center">$\partial x$</td>
<td align="center"><code>\partial x</code></td>
<td align="center">微分运算</td>
</tr>
</tbody></table>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\geq$</td>
<td align="center"><code>\geq</code></td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">$\leq$</td>
<td align="center"><code>\leq</code></td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">$\neq$</td>
<td align="center"><code>\neq</code></td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">$\ngeq$</td>
<td align="center"><code>\ngeq</code></td>
<td align="center">不大于等于</td>
</tr>
<tr>
<td align="center">$\not\geq$</td>
<td align="center"><code>\not\geq</code></td>
<td align="center">不大于等于</td>
</tr>
<tr>
<td align="center">$\nleq$</td>
<td align="center"><code>\nleq</code></td>
<td align="center">不小于等于</td>
</tr>
<tr>
<td align="center">$\not\leq$</td>
<td align="center"><code>\not\leq</code></td>
<td align="center">不小于等于</td>
</tr>
<tr>
<td align="center">$\approx$</td>
<td align="center"><code>\approx</code></td>
<td align="center">约等于</td>
</tr>
<tr>
<td align="center">$\equiv$</td>
<td align="center"><code>\equiv</code></td>
<td align="center">恒定等于</td>
</tr>
<tr>
<td align="center">$\bigodot$</td>
<td align="center"><code>\bigodot</code></td>
<td align="center">同或</td>
</tr>
<tr>
<td align="center">$\bigotimes$</td>
<td align="center"><code>\bigotimes</code></td>
<td align="center">同与</td>
</tr>
<tr>
<td align="center">$\bigoplus$</td>
<td align="center"><code>\bigoplus</code></td>
<td align="center">异或</td>
</tr>
</tbody></table>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\in$</td>
<td align="center"><code>\in</code></td>
<td align="center">属于</td>
</tr>
<tr>
<td align="center">$\notin$</td>
<td align="center"><code>\notin</code></td>
<td align="center">不属于</td>
</tr>
<tr>
<td align="center">$\subset$</td>
<td align="center"><code>\subset</code></td>
<td align="center">子集</td>
</tr>
<tr>
<td align="center">$\supset$</td>
<td align="center"><code>\supset</code></td>
<td align="center">子集</td>
</tr>
<tr>
<td align="center">$\subseteq$</td>
<td align="center"><code>\subseteq</code></td>
<td align="center">真子集</td>
</tr>
<tr>
<td align="center">$\subsetneq$</td>
<td align="center"><code>\subsetneq</code></td>
<td align="center">非真子集</td>
</tr>
<tr>
<td align="center">$\supseteq$</td>
<td align="center"><code>\supseteq</code></td>
<td align="center">真子集</td>
</tr>
<tr>
<td align="center">$\supsetneq$</td>
<td align="center"><code>\supsetneq</code></td>
<td align="center">非真子集</td>
</tr>
<tr>
<td align="center">$\not\subset$</td>
<td align="center"><code>\not\subset</code></td>
<td align="center">非子集</td>
</tr>
<tr>
<td align="center">$\not\supset$</td>
<td align="center"><code>\not\supset</code></td>
<td align="center">非子集</td>
</tr>
<tr>
<td align="center">$\cup$</td>
<td align="center"><code>\cup</code></td>
<td align="center">并集</td>
</tr>
<tr>
<td align="center">$\cap$</td>
<td align="center"><code>\cap</code></td>
<td align="center">交集</td>
</tr>
<tr>
<td align="center">$\setminus$</td>
<td align="center"><code>\setminus</code></td>
<td align="center">差集</td>
</tr>
<tr>
<td align="center">$\mathbb{R}$</td>
<td align="center"><code>\mathbb&#123;R&#125;</code></td>
<td align="center">实数集合</td>
</tr>
<tr>
<td align="center">$\mathbb{Z}$</td>
<td align="center"><code>\mathbb&#123;Z&#125;</code></td>
<td align="center">自然数集合</td>
</tr>
<tr>
<td align="center">$\emptyset$</td>
<td align="center"><code>\emptyset</code></td>
<td align="center">空集</td>
</tr>
</tbody></table>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\infty$</td>
<td align="center"><code>\infty</code></td>
<td align="center">无穷</td>
</tr>
<tr>
<td align="center">$\imath$</td>
<td align="center"><code>\imath</code></td>
<td align="center">虚数</td>
</tr>
<tr>
<td align="center">$\jmath$</td>
<td align="center"><code>\jmath</code></td>
<td align="center">虚数</td>
</tr>
<tr>
<td align="center">$\hat{a}$</td>
<td align="center"><code>\hat&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\check{a}$</td>
<td align="center"><code>\check&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\breve{a}$</td>
<td align="center"><code>\breve&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\tilde{a}$</td>
<td align="center"><code>\tilde&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\bar{a}$</td>
<td align="center"><code>\bar&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\vec{a}$</td>
<td align="center"><code>\vec&#123;a&#125;</code></td>
<td align="center">矢量符号</td>
</tr>
<tr>
<td align="center">$\acute{a}$</td>
<td align="center"><code>\acute&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\grave{a}$</td>
<td align="center"><code>\grave&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\mathring{a}$</td>
<td align="center"><code>\mathring&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\dot{a}$</td>
<td align="center"><code>\dot&#123;a&#125;</code></td>
<td align="center">一阶导数符号</td>
</tr>
<tr>
<td align="center">$\ddot{a}$</td>
<td align="center"><code>\ddot&#123;a&#125;</code></td>
<td align="center">二阶导数符号</td>
</tr>
<tr>
<td align="center">$\uparrow$</td>
<td align="center"><code>\uparrow</code></td>
<td align="center">上箭头</td>
</tr>
<tr>
<td align="center">$\Uparrow$</td>
<td align="center"><code>\Uparrow</code></td>
<td align="center">上箭头</td>
</tr>
<tr>
<td align="center">$\downarrow$</td>
<td align="center"><code>\downarrow</code></td>
<td align="center">下箭头</td>
</tr>
<tr>
<td align="center">$\Downarrow$</td>
<td align="center"><code>\Downarrow</code></td>
<td align="center">下箭头</td>
</tr>
<tr>
<td align="center">$\leftarrow$</td>
<td align="center"><code>\leftarrow</code></td>
<td align="center">左箭头</td>
</tr>
<tr>
<td align="center">$\Leftarrow$</td>
<td align="center"><code>\Leftarrow</code></td>
<td align="center">左箭头</td>
</tr>
<tr>
<td align="center">$\rightarrow$</td>
<td align="center"><code>\rightarrow</code></td>
<td align="center">右箭头</td>
</tr>
<tr>
<td align="center">$\Rightarrow$</td>
<td align="center"><code>\Rightarrow</code></td>
<td align="center">右箭头</td>
</tr>
<tr>
<td align="center">$\longrightarrow$</td>
<td align="center"><code>\longrightarrow</code></td>
<td align="center">向右长箭头</td>
</tr>
<tr>
<td align="center">$\Longrightarrow$</td>
<td align="center"><code>\Longrightarrow</code></td>
<td align="center">向右长箭头</td>
</tr>
<tr>
<td align="center">$A \xleftarrow{n=0} B \xrightarrow[T]{n&gt;0} C$</td>
<td align="center"><code>A \xleftarrow&#123;n=0&#125; B \xrightarrow[T]&#123;n&gt;0&#125; C</code></td>
<td align="center">上下方可输入公式的箭头</td>
</tr>
<tr>
<td align="center">$\triangleq$</td>
<td align="center"><code>\triangleq</code></td>
<td align="center">定义为</td>
</tr>
<tr>
<td align="center">$\because$</td>
<td align="center"><code>\because</code></td>
<td align="center">因为</td>
</tr>
<tr>
<td align="center">$\therefore$</td>
<td align="center"><code>\therefore</code></td>
<td align="center">所以</td>
</tr>
<tr>
<td align="center">$\forall$</td>
<td align="center"><code>\forall</code></td>
<td align="center">任意</td>
</tr>
<tr>
<td align="center">$\exists$</td>
<td align="center"><code>\exists</code></td>
<td align="center">存在</td>
</tr>
<tr>
<td align="center">$\ldots$</td>
<td align="center"><code>\ldots</code></td>
<td align="center">底端对齐的省略号</td>
</tr>
<tr>
<td align="center">$\cdots$</td>
<td align="center"><code>\cdots</code></td>
<td align="center">中线对齐的省略号</td>
</tr>
<tr>
<td align="center">$\vdots$</td>
<td align="center"><code>\vdots</code></td>
<td align="center">竖直对齐的省略号</td>
</tr>
<tr>
<td align="center">$\ddots$</td>
<td align="center"><code>\ddots</code></td>
<td align="center">斜对齐的省略号</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>矩阵表示</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\left[ \begin&#123;matrix&#125; 1 &amp;2 &amp;\cdots &amp;4\\5 &amp;6 &amp;\cdots &amp;8 \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ 13 &amp;14 &amp;\cdots &amp;16\end&#123;matrix&#125; \right]</span><br></pre></td></tr></table></figure>

<p>$$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8 \ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \ 13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]$$</p>
<p><strong>大括号公式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F(n)= \begin&#123;cases&#125; 1 &amp; \text&#123;n = 0 或 1&#125;\\ F(n-1)+F(n-2) &amp; \text&#123;n &gt; 1&#125; \end&#123;cases&#125;</span><br></pre></td></tr></table></figure>

<p>$$F(n)= \begin{cases} 1 &amp; \text{n = 0 或 1}\ F(n-1)+F(n-2) &amp; \text{n &gt; 1} \end{cases}$$</p>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table>
<thead>
<tr>
<th align="center">大写</th>
<th align="center">代码</th>
<th align="center">小写</th>
<th align="center">代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center"><code>A</code></td>
<td align="center">α</td>
<td align="center"><code>\alhpa</code></td>
</tr>
<tr>
<td align="center">B</td>
<td align="center"><code>B</code></td>
<td align="center">β</td>
<td align="center"><code>\beta</code></td>
</tr>
<tr>
<td align="center">Γ</td>
<td align="center"><code>\Gamma</code></td>
<td align="center">γ</td>
<td align="center"><code>\gamma</code></td>
</tr>
<tr>
<td align="center">Δ</td>
<td align="center"><code>\Delta</code></td>
<td align="center">δ</td>
<td align="center"><code>\delta</code></td>
</tr>
<tr>
<td align="center">E</td>
<td align="center"><code>E</code></td>
<td align="center">ϵ</td>
<td align="center"><code>\epsilon</code></td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center"><code>Z</code></td>
<td align="center">ζ</td>
<td align="center"><code>\zeta</code></td>
</tr>
<tr>
<td align="center">H</td>
<td align="center"><code>H</code></td>
<td align="center">η</td>
<td align="center"><code>\eta</code></td>
</tr>
<tr>
<td align="center">Θ</td>
<td align="center"><code>\Theta</code></td>
<td align="center">θ</td>
<td align="center"><code>\theta</code></td>
</tr>
<tr>
<td align="center">I</td>
<td align="center"><code>I</code></td>
<td align="center">ι</td>
<td align="center"><code>\iota</code></td>
</tr>
<tr>
<td align="center">K</td>
<td align="center"><code>K</code></td>
<td align="center">κ</td>
<td align="center"><code>\kappa</code></td>
</tr>
<tr>
<td align="center">Λ</td>
<td align="center"><code>\Lambda</code></td>
<td align="center">λ</td>
<td align="center"><code>\lambda</code></td>
</tr>
<tr>
<td align="center">M</td>
<td align="center"><code>M</code></td>
<td align="center">μ</td>
<td align="center"><code>\mu</code></td>
</tr>
<tr>
<td align="center">N</td>
<td align="center"><code>N</code></td>
<td align="center">ν</td>
<td align="center"><code>\nu</code></td>
</tr>
<tr>
<td align="center">Ξ</td>
<td align="center"><code>\Xi</code></td>
<td align="center">ξ</td>
<td align="center"><code>\xi</code></td>
</tr>
<tr>
<td align="center">O</td>
<td align="center"><code>O</code></td>
<td align="center">ο</td>
<td align="center"><code>\omicron</code></td>
</tr>
<tr>
<td align="center">Π</td>
<td align="center"><code>\Pi</code></td>
<td align="center">π</td>
<td align="center"><code>\pi</code></td>
</tr>
<tr>
<td align="center">P</td>
<td align="center"><code>P</code></td>
<td align="center">ρ</td>
<td align="center"><code>\rho</code></td>
</tr>
<tr>
<td align="center">Σ</td>
<td align="center"><code>\Sigma</code></td>
<td align="center">σ</td>
<td align="center"><code>\sigma</code></td>
</tr>
<tr>
<td align="center">T</td>
<td align="center"><code>T</code></td>
<td align="center">τ</td>
<td align="center"><code>\tau</code></td>
</tr>
<tr>
<td align="center">Υ</td>
<td align="center"><code>\Upsilon</code></td>
<td align="center">υ</td>
<td align="center"><code>\upsilon</code></td>
</tr>
<tr>
<td align="center">Φ</td>
<td align="center"><code>\Phi</code></td>
<td align="center">ϕ</td>
<td align="center"><code>\phi</code></td>
</tr>
<tr>
<td align="center">X</td>
<td align="center"><code>X</code></td>
<td align="center">χ</td>
<td align="center"><code>\chi</code></td>
</tr>
<tr>
<td align="center">Ψ</td>
<td align="center"><code>\Psi</code></td>
<td align="center">ψ</td>
<td align="center"><code>\psi</code></td>
</tr>
<tr>
<td align="center">Ω</td>
<td align="center"><code>\v</code></td>
<td align="center">ω</td>
<td align="center"><code>\omega</code></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/" class="post-title-link" itemprop="url">机器学习在网络安全中的应用 —— Chapter 1: Basics of Machine Learning in Cybersecurity</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-07 13:17:42" itemprop="dateCreated datePublished" datetime="2020-10-07T13:17:42+08:00">2020-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Translations/" itemprop="url" rel="index"><span itemprop="name">Translations</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文翻译并总结归纳自 <em><strong>Hands-On Machine Learning for Cybersecurity</strong></em> 书中的 Chapter 1: Basics of Machine Learning in Cybersecurity。该书主要着眼于机器学习在网络安全领域中的应用，介绍了多个方向的原理和解决方案，比如：包时间序列分析、垃圾邮件检测、使用 k-means 算法的网络异常检测等。总的来说，该书的动手操作很多，实战性很强。接下来我会用一个系列，整理归纳书中的各个章节。当然，除了第一章是介绍机器学习的概览之外，其他几个章节内容比较离散，所以顺序可能打乱。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自诞生以来，机器学习（Machine Learning）一直是一个非常热门的话题，它的出现实实在在地解决了很多问题，比如人脸识别、自动驾驶、购物推荐系统、聊天机器人等。</p>
<p>而在安全领域方面，老式的威胁检测系统通过使用启发式的和静态的签名（signature）来检测威胁和异常。例如：杀毒软件会根据病毒程序的特征，生成并维持一个病毒的签名库（保持持续更新），在查杀时通过与库中的签名比对来识别病毒程序。基于签名的威胁检测技术虽然容易理解，但并不健壮，它的最大的问题之一是：在数据规模、数据流速显著增大时，如何保证签名比对过程与数据流入速度匹配。每个包需要与数据库中的每个签名比对，如果不能保持同步，那意味着只能抛弃部分数据包，由此就会产生“漏网之鱼”。</p>
<p>如今，基于签名的系统逐渐被智能网络安全代理（Intelligent cybersecurity agent）所取代。机器学习在识别新型恶意软件、零日漏洞攻击（zero-day attack）、高级可持续威胁（advanced persistent threats，简称 APT）方面取得积极进展。</p>
<p>一般来说，由于攻击的复杂特性，要做到完全预防是很难的，机器学习能做到在攻击的初期识别攻击并防止其扩散到整个系统。许多网络安全公司使用诸如用户行为分析（user behavior analytics）和预测分析（predictive analytics）的高级分析方法，在威胁生命周期的早期阶段识别 APT 攻击，这种方式能够有效预防身份数据泄漏和内部威胁。规范分析（prescriptive analytics）则更具有响应性，能够在网络攻击发生以后分析该采取什么响应措施能将损失降到最小。</p>
<p><img data-src="1.png" alt="48e9cf0bd45e3630c4346d142839c8a1.png"></p>
<h2 id="机器学习中的数据"><a href="#机器学习中的数据" class="headerlink" title="机器学习中的数据"></a>机器学习中的数据</h2><p>数据是机器学习的核心。数据分为结构化数据和非结构化数据，<strong>结构化数据（structured data）</strong>可以被映射为二维表结构，包含表头（Header）和表内元素，传统的关系型数据库（RDBMS）如 MySQL、Oracle 等都是以这种方式存放结构化数据；而<strong>非结构化数据（unstructured data）</strong>数据结构不规则或不完整，没有预定义的数据模型，例如图片、音频/视频等；融合了结构化和非结构化的数据称为<strong>半结构化数据（semi-structured data）</strong>。</p>
<p>根据数据是否被打上标记，数据又被分为<strong>有标注数据（labelled data）</strong>和<strong>无标注数据（unlabelled data）</strong>。例如网络安全中的恶意流量检测，可以将样本中的善意流量（white）和恶意流量（black）手动打标（恶意流量可能是自己模拟生成的），构成训练集训练机器学习模型。</p>
<h3 id="机器学习阶段"><a href="#机器学习阶段" class="headerlink" title="机器学习阶段"></a>机器学习阶段</h3><p>机器学习分为以下四个阶段：</p>
<ul>
<li><strong>分析阶段（The analysis phase）</strong>：在这个阶段，采集到的数据需要被提取明确的<strong>特征（features）</strong>或者参数（parameters），来被用于训练模型。</li>
<li><strong>训练阶段（The training phase）</strong>： 前一阶段的数据将被用来在这个阶段训练机器学习模型（machine learning model），训练阶段是一个<strong>多次迭代</strong>的阶段，目的是为了训练一个更加可信的模型。</li>
<li><strong>测试阶段（The testing phase）</strong>： 在这一阶段，训练阶段产生的机器学习模型将结合更多的数据进行测试并<strong>评估模型</strong>的性能。测试的数据是前面阶段从未被使用的数据。模型的<strong>演化</strong>可能会需要参数训练（调参）。</li>
<li><strong>应用阶段（The application phase）</strong> ：模型被部署到<strong>生产环境</strong>，应用于真实数据。</li>
</ul>
<h3 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h3><p>在训练阶段，由于样本数据的不完备，训练出的机器学习模型可能并不理想（模型的泛化能力不佳），会产生两种现象：过拟合和欠拟合。</p>
<p><strong>过拟合（Overfitting）</strong>，是指系统太过适应于（fit）或者说太过依赖于训练集数据，导致新来的数据都视为不匹配，通常表现为：模型对于训练集表现很好，对于测试集表现很差（容纳度很低）。产生这种现象的常见原因之一是只使用了有标注的数据来训练模型。</p>
<blockquote>
<p>Overfitting: The production of an analysis that corresponds too closely or exactly to a particular set of data, and may therefore fail to fit additional data or predict future observations reliably. – Oxford Dictionary</p>
</blockquote>
<p><strong>欠拟合（Underfitting）</strong>，是模型表现差的另一种场景，通常是由于样本数量较少，模型训练依赖特征过少，学习能力低下造成的。</p>
<p>对于这两种情形，可以通过一些机器学习的常见步骤来消除，比如：数据的交叉验证（cross validation of the data），数据修剪（data pruning）和数据正则化（regularization of the data）。</p>
<p><img data-src="2.png" alt="0574cd5346226da66890df7956671e62.png"></p>
<p>由上图可以看到，当模型层级较低时（模型过于简单），表现为欠拟合，训练集和测试集效果都不好；当模型层级较高时（模型过于复杂），表现为过拟合，训练集效果很好，但由于学习能力过于强大，以至于把训练样本所包含的不太一般的特性都学到了，导致测试集中表现很差。所以我们需要摸索出合适的模型，既不能太简单也不能太复杂，使得在测试集上能有最优表现。</p>
<h2 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h2><p>传统上，基于所提供的学习类型，机器学习系统大体上可以分为两类：有监督学习和无监督学习。强化学习和深度学习是后面引入的新的研究分支。</p>
<p><img data-src="3.png" alt="49c0d215820883fdc0aa834405891742.png"></p>
<h3 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h3><p>有监督学习（Supervised learning）是指使用已标注的数据集推导出预测函数，对测试集进行分类和预测。有监督学习包含一些子分支，比如：</p>
<ul>
<li><strong>半监督学习（Semi-supervised learning）</strong>：训练阶段的数据集即含有有标注的，也含有未标注的。</li>
<li><strong>主动学习（Active learning）</strong>：主动学习是指，通过查询函数，从未标注数据集中查询出信息熵最大（可以简单理解为最复杂）的数据，交给督导者进行标注，循环迭代这个过程直至模型达到最佳。主动学习的“主动”，指的是<strong>主动提出标注请求</strong>，为此需要一个外在的能够对其请求进行标注的实体（通常是相关领域人员）。<br><img data-src="4.png" alt="e834d2167c02ba1908f13760cec58005.png"></li>
</ul>
<p>有监督学习的常见应用包括：人脸识别，需要人为标注新面孔；垃圾邮件检测，需要对邮件内容文本进行分词处理，所以需要提前对一些敏感词汇做人为标注。</p>
<h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>无监督学习算法（Unsupervised learning）是指初始数据集是未标注的，数据视图是在处理过程中由系统自学习构建出来的，没有任何外部干涉。如果说有监督学习是：老师提供对错指示，要求学生能够“对于输入数据X能判断对错”，那么无监督学习就是：在没有老师的情况下，学生自学，要求学生能够“<strong>从数据X中归纳总结出知识点</strong>”。无监督学习算法的具体应用案例包括：用户行为分析（User behavior analysis）、购物篮分析（Market basket analysis）等。</p>
<p><img data-src="5.png" alt="942767e754efb165eb261f9f9692bbc4.png"></p>
<h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>强化学习（Reinforcement learning）是机器学习的又一分支，它强调如何基于<strong>环境</strong>而行动，以取得最大化的<strong>预期利益</strong>。</p>
<p>具有强化学习能力的程序或机器人被称为<strong>代理（Agent）</strong>。代理所解决的问题被抽象为<strong>环境（Environment）</strong>，比如迷宫或者棋盘。代理需要有一个基本的<strong>策略（Policy）</strong>，每次迭代根据这个策略选择一个<strong>动作（Action）</strong>作用于环境，环境接受该动作后<strong>状态（State）</strong>发生变化，同时产生一个<strong>信号（Reward）</strong>，正代表奖励，负代表惩罚。代理会根据这个信号评估之前的策略是否适合。</p>
<p><img data-src="6.png" alt="25df06c2835f3b3d1e7e198431865384.png"></p>
<p>强化学习有一些实际的用例，比如自动驾驶汽车，需要对周围复杂环境作出实施迅速的应对；又比如家喻户晓的 AlphaGo，只需要训练4个小时就可以击败世界知名的象棋AI Stockfish。</p>
<h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>深度学习（Deep learning）是机器学习领域的一个新的研究分支，是一种以人工神经网络为架构，对资料进行表征学习的算法。深度学习并不简单的囊括于传统的有监督/无监督分类中，它本身也会用到有监督和无监督的学习方法来训练深度神经网络。</p>
<p>深度学习的出现，引领了机器学习的又一波热潮，它摧枯拉朽地解决了之前未解决的诸多问题，使得似乎所有的机器辅助功能都变为可能。但它作为目前最热的机器学习方法之一，并不意味着是机器学习的终点，它也具有诸多问题，比如：深度学习需要巨大的数据集做支撑；复杂度较高；深度学习的构想来源于人脑的神经元结构，但人脑的复杂程度要远远超出它所能模拟的范畴。</p>
<h2 id="机器学习解决的问题"><a href="#机器学习解决的问题" class="headerlink" title="机器学习解决的问题"></a>机器学习解决的问题</h2><p>机器学习可以用于解决以下几类问题：分类问题，集群问题，回归问题，降维问题，密度估算问题等等。</p>
<p><img data-src="7.png" alt="53aaf02095bd399d6b16dec0b2332dd7.png"></p>
<h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><p>分类问题（Classification problems）是指基于特征将数据划分到多个类（class）中的问题。因为训练数据是有标注的，所以分类问题属于有监督学习。网络数据分类是一个经典的分类问题，互联网的内容可以根据它们的文本内容比如新闻、社交媒体、广告等划分到它们对应的类别。</p>
<p><img data-src="8.png" alt="d50de17881f0da10019d30b5e4266bef.png"></p>
<h3 id="聚类问题"><a href="#聚类问题" class="headerlink" title="聚类问题"></a>聚类问题</h3><p>聚类问题（Clustering problems）是指将数据分成若干组并将相似数据归为一组。聚类技术常用语信息检索、模式识别、人口统计分析领域。相比于分类问题，聚类问题并不关心某一类是什么，只需要将相似的数据归为一类。因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了，也就是说训练集无需作出预先标注。</p>
<p><img data-src="9.png" alt="c118f41b872bc162fd0f3858d25ec368.png"></p>
<h3 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h3><p>回归问题（Regression problems）指的是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。例如对于图中的二元组数据（x，y），我们可以求出能表示 x，y 关系的线性回归方程，再对接下来的测试数据集进行预测或分类。</p>
<p>回归包括多种类型，比如：线性回归（linear regression），逻辑回归（logistic regression），多项式回归（polynomial regression）等。回归可以用于欺诈检测系统，股票市场分析和预测。</p>
<p><img data-src="10.png" alt="985428a8e920d31726d314abe4af73d0.png"></p>
<h3 id="降维问题"><a href="#降维问题" class="headerlink" title="降维问题"></a>降维问题</h3><p>现实应用中属性维数经常成千上万，且许多学习方法都涉及距离计算，而高维空间会给距离计算带来很大的麻烦，当维数很高时甚至连计算内积都不再容易。事实上，在高维情形下出现的数据样本稀疏、距离计算困难等问题，是所有机器学习方法共同面临的严重障碍，被称为“维数灾难”（curse of dimensionality）。</p>
<p>缓解维数灾难的一个重要途径是<strong>降维（Dimension reduction）</strong>，亦称“维数约简”，即通过某种数学变换将原始高维属性空间转变为一个低维“子空间”（subspace），在这个子空间中样本密度大幅提高，距离计算也变得更为容易。降维将含有多个属性的高维数据，用它的主要属性去表示，并且不丢失重要特征。  降维技术经常用于<strong>特征提取</strong>，比如网络包流数据的处理，为了减少数据规模，通常只提取具有代表性的有用特征进行分析。</p>
<p>下图给出了一个直观的例子，将原始三维空间中的样本点，映射到二维嵌入子空间中。</p>
<p><img data-src="11.jpg" alt="d127776fa637378ffec32cc993ce3c49.png"></p>
<h3 id="密度估算问题"><a href="#密度估算问题" class="headerlink" title="密度估算问题"></a>密度估算问题</h3><p>密度估算问题（Density estimation problems）是用于对密集数据进行机器学习估算的统计学习方法。从技术上讲，它是一种<strong>计算概率密度函数</strong>的技术。在医学分析领域，通常使用这种技术来在庞大的人口中识别疾病相关症状。</p>
<h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><p>支持向量机（Support Vector Machines，SVM）属于有监督的算法，被用于解决线性或非线性的分类问题（linear/non linear classification）。由于优秀的性能，SVM 得到了广泛的应用。</p>
<p>若输入数据所在的特征空间存在作为决策边界（decision boundary）的超平面将样本按正类和负类分开，实际上构造了2个平行的超平面作为间隔边界以判别样本的分类，所有在上间隔边界上方的样本属于正类，在下间隔边界下方的样本属于负类。两个间隔边界的距离被定义为边距（margin），位于间隔边界上的正类和负类样本为支持向量（support vector）。SVM 旨在求解能够划分样本的<strong>最大边距超平面（maximum-margin hyperplane）</strong>。</p>
<p>对于二维平面，超平面可以理解为可以划分样本的一条「直线」，对于高维特征空间，SVM 可以通过<strong>核方法（kernel method）</strong>进行非线性分类。</p>
<p><img data-src="12.png" alt="e44a093db94c73420e3f30d4455b09f1.png"></p>
<h3 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a>贝叶斯网络</h3><p>贝叶斯网（Bayesian network，简称 BN）亦称“信念网”（belief network），它借助有向无环图（Direct Acyclic Graph，简称 DAG）来刻画属性之间的依赖关系，并使条件概率表（Conditional Probability Table，简称 CPT）来描述属性的联合概率分布。</p>
<p><img data-src="13.jpg" alt="fe9d8ceefb48edd4636364d7b7e00a2a.png"></p>
<p>上图给出了西瓜问题的一种贝叶斯网结构和属性“根蒂”的条件概率表。从图中网络结构可看出，“色泽”直接依赖于“好瓜”和“甜度”，而“根蒂”则直接依赖于“甜度”；进一步从条件概率表能得到“根蒂”对“甜度”量化依赖关系，如 $P(根蒂=硬挺|甜度=高)=0.1$ 等。</p>
<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>决策树（decision tree）是一类常见的机器学习方法。以二分类任务为例，我们希望从给定训练数据集学得一个模型用以对新示例进行分类，这个把样本分类的任务，可看作对“当前样本属于正类吗？“这个问题的“决策”或“判定”过程。</p>
<p>顾名思义，决策树是基于树结构来进行决策的，这恰是人类在面临决策问题时一种很自然的处理机制。树中非叶子节点表示需要作出分类判断的属性，每个分支代表可能的属性值。下图给出了西瓜问题的一颗决策树。</p>
<p><img data-src="14.jpg" alt="babb7185999143d2f546dc0d7fc76680.png"></p>
<h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>首先我们介绍一下 <strong>Bagging</strong>。给定包含 m 个样本的数据集，我们先随机取出一个样本放入采样集中，再把该样本放回初始数据集，使得下次采样时该样本仍有可能被选中，这样，经过m次随机采样操作，我们得到含 m 个样本的采样集，初始训练集中有的样本在采样集里多次出现，有的则从未出现。</p>
<p>照这样，我们可采样出 T 个含 m 个训练样本的采样集，然后基于每个采样集训练出一个基学习器，再将这些基学习器进行结合。这就是 Bagging 的基本流程。在对预测输出进行结合时，Bagging 通常对分类任务使用简单投票法，对回归任务使用简单平均法。若分类预测时出现两个类收到同样票数的情形，则最简单的做法是随机选择一个，也可进一步考察学习器投票的置信度来确定最终胜者。</p>
<p>随机森林（Random Forest，简称 RF）是 Bagging 的一个扩展变体。RF 在以决策树为基学习器构建 Bagging 集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。具体来说，传统决策树在选择划分属性时是在当前结点的属性集合（假定有 d 个属性）中选择一个最优属性；而在 RF 中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含 k 个属性的子集，然后再从这个子集中选择一个最优属性用于划分。这样使得随机森林中的决策树都能够彼此不同，提升系统的多样性，从而提升分类性能。</p>
<p>随机森林简单、容易实现、计算开销小，令人惊奇的是，它在很多现实任务中展现出强大的性能，被誉为“代表集成学习技术水平的方法”。</p>
<h3 id="kNN"><a href="#kNN" class="headerlink" title="kNN"></a>kNN</h3><p>k近邻（k-Nearest Neighbor，简称 kNN）学习是一种常用的监督学习方法，其工作机制非常简单：给定测试样本，基于某种距离度量找出训练集中与其最靠近的 k 个训练样本，然后基于这 k 个“邻居”的信息来进行预测。通常，在分类任务中可使用“投票法”，即选择这 k 个样本中出现最多的类别标记作为预测结果；在回归任务中可使用“平均法，即将这 k 个样本的实值输出标记的平均值作为预测结果；还可基于距离远近进行加权平均或加权投票，距离越近的样本权重越大。</p>
<p><img data-src="15.jpg" alt="a5e05733ac1f4912ecc1bd1828535f57.png"></p>
<p>上图是一个k近邻分类器示意图。虚线为等距线，测试样本在 k=1 或 k=5 时被判别为正例，k=3 时被判别为反例。显然，k 是一个重要参数，当 k 取不同值时，分类结果会有显著不同。</p>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。</p>
<p>神经网络中最基本的成分是神经元（neuron）模型，即上述定义中的“简单单元”。在生物神经网络中，每个神经元与其他神经元相连，当它“兴奋”时，就会向相连的神经元发送化学物质，从而改变这些神经元内的电位；如果某神经元的电位超过一个“阈值”（threshold），那么它就会被激活，即“兴奋”起来，向其他神经元发送化学物质。</p>
<p>1943年，McMulloch 和 Pitts 将上述情形抽象为下图所示的简单模型，这就是一直沿用至今的“<strong>M-P神经元模型</strong>”。把许多个这样的神经元按一定的层次结构连接起来，就得到了神经网络。</p>
<p><img data-src="16.jpg" alt="5ba11eb4ebb4f8dddb0b8806dace6347.png"></p>
<p>在这个模型中，神经元接收到来自 n 个其他神经元传递过来的输入信号，这些输入信号通过带权重的连接（connection）进行传递，神经元接收到总输入将与神经元的阈值进行比较，然后通过“激活函数”（activation function）处理以产生神经元的输出。</p>
<h2 id="机器学习架构"><a href="#机器学习架构" class="headerlink" title="机器学习架构"></a>机器学习架构</h2><p><img data-src="17.png" alt="8b49f81f455bb0bb519c3659accc8f7d.png"></p>
<p>注入机器学习系统的数据可能来自不同的源，可以是实时的流数据，也可以是批处理数据或者无交互的定时任务数据。常见的数据源有 Amazon Kinesis、Apache Flume、Apache Kafka 等。注入的数据经过清洗和预处理后被存入数据储存库中，例如 SQL/NoSQL 数据库、数据仓库（data warehouse）、HDFS 分布式系统等等。</p>
<h3 id="模型引擎"><a href="#模型引擎" class="headerlink" title="模型引擎"></a>模型引擎</h3><ul>
<li><strong>数据准备（Data preparation）</strong>：数据准备阶段需要进行数据清洗（data cleansing），检查数据一致性和完整性，对数据进行规范化，对拆分的或是聚合的数据进行转换和重组。</li>
<li><strong>特征生成（Feature generation）</strong>：找到待分析数据的关键特征。特征可以来自原始数据或者聚合后的数据，不同特征通常都是相互独立的。特征提取的首要目标是降低数据维度和提高模型性能。</li>
<li><strong>模型训练（Model training）</strong>：机器学习模型分析数据间的关联，将数据分类到不同的组。为了获得最佳性能，需要对数据特征进行合适的采样。通常 70～80% 的数据会被用于训练阶段。</li>
<li><strong>模型测试（Model testing）</strong>：在测试阶段我们验证模型，模型的性能能够被测试并做出调节。交叉验证能够确定模型的性能。通常 20% 的数据会被用于测试阶段。</li>
</ul>
<h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h3><p>性能调节（Performance tuning）和错误检测（error detection）是机器学习系统最重要的迭代过程，能够帮助提升系统的性能。如果系统的泛化功能能够以较高的概率给出较低的<strong>泛化误差（generalization error）</strong>，我们称这个系统拥有最优性能。事实上这属于 PAC 理论的范畴。</p>
<p>泛化误差与分类的准确度，回归模型预测的精确度直接相关。为了计算泛化误差，我们给出一些评估指标：</p>
<h4 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h4><p>假设现在有一条回归曲线，我们想测量每个点到回归线的距离，而均方误差（Mean squared error，MSE）就能够统计这些偏移量。$P_i$ 为预测值，$A_i$ 为真实值，MSE 对每个点偏移量的平方和求平均：</p>
<p>$$ MSE = \frac{1}{n}\sum_{i=1}^n{(P_i - A_i)^2} $$</p>
<p><img data-src="18.png" alt="d8c5be836a6aff5b4e312f9b7a4a7a8a.png"></p>
<h4 id="平均绝对误差"><a href="#平均绝对误差" class="headerlink" title="平均绝对误差"></a>平均绝对误差</h4><p>平均绝对误差（Mean absolute error，MAE) 计算每个点绝对误差的均值。MAE 是时间序列分析中的预测误差的一个常见指标。相比于 MSE，由于 MSE 使用了平方会放大误差，所以 MSE 对于异常数据更加敏感，而 MAE 对异常点有更好的鲁棒性（抗干扰能力更强），更适合用来做预测分析。但对于学习效率来说，误差较大时 MSE 收敛更快精度更高。</p>
<p>$$ MAE = \frac{1}{n}\sum_{i=1}^n{|P_i - A_i|} $$</p>
<h4 id="精确率、召回率、准确率"><a href="#精确率、召回率、准确率" class="headerlink" title="精确率、召回率、准确率"></a>精确率、召回率、准确率</h4><p>精确率、召回率和准确率是机器学习分类问题（classification problem）模型评估中常见的性能度量指标：</p>
<ul>
<li><strong>精确率（Precision）</strong>，又叫查准率，定义为：$Precision \triangleq \frac{TP}{TP+FP}$</li>
<li><strong>召回率（Recall）</strong>，又叫查全率，定义为：$Recall \triangleq \frac{TP}{TP+FN}$</li>
<li><strong>准确率（Accuracy）</strong>，定义为：$Accuracy \triangleq \frac{TP+TN}{TP+TN+FP+FN}$</li>
</ul>
<p>上述定义式中 T 代表 True，F 代表 False，T/F 表示预测是否正确；P 代表 Positive，N 代表 Negative，P/N 代表本身是正例还是反例。例如：恶意流量检测系统中，P 代表是恶意流量，那么 TP 就代表正确检测出恶意流量，FN 代表本身不是恶意流量却被错误地识别为恶意流量。</p>
<p><img data-src="19.png" alt="385e4f3b305ced036ed00c0098a74855.png"></p>
<p>Precision 从预测结果角度出发，描述了<strong>预测出来的正例结果中有多少是真实正例</strong>，关心的是查出来的准不准；Recall 从真实结果角度出发，描述了<strong>测试集中的真实正例有多少被检测出来</strong>，关心的是查的全不全。Accuracy 则代表所有预测中正确预测所占的比例。</p>
<p>当正负样本分布严重不均匀时，仅仅靠准确率 Accuracy 去评估模型性能是不合适的。就拿恶意流量检测来说，假设恶意流量占总流量的 0.1%，那么考虑一个全部流量都 pass 的检测系统，它的准确率依然能达到 99.9%，但是一条恶意流量都没有检测出来，这显然是不合要求的。所以通常需要结合这三个指标对模型进行整体评估。</p>
<h3 id="性能改善"><a href="#性能改善" class="headerlink" title="性能改善"></a>性能改善</h3><p>那么如何提高模型的性能呢？通常可以通过：</p>
<ul>
<li><strong>改善数据质量</strong>：数据需要清洗、重采样以及规范化，特征提取步骤也可能需要重新审视，缺乏独立性的特征也会导致性能不佳。</li>
<li><strong>更换算法</strong>：模型的性能不佳也可能是因为没有选对合适的算法，在这种情况下，不同算法的基准测试可以帮助我们做出合适的选择。基准测试包括但不限于：K倍交叉验证。</li>
<li>**使用集成学习（Ensemble Learning)**：同时使用多种学习算法来获得比单独使用任何学习算法具有更好的性能。一些最复杂的人工智能系统就是这类集成的副产物。</li>
</ul>
<h2 id="机器学习扩展库"><a href="#机器学习扩展库" class="headerlink" title="机器学习扩展库"></a>机器学习扩展库</h2><p>Python 作为机器学习最常用语言，虽然不是最快的，但因为它的灵活性而被数据科学家们广泛接受。Python 为机器学习专家提供了一系列的工具和扩展库，常用到的有：</p>
<ul>
<li><strong>NumPy</strong>：是统计分析和机器学习方面的重要扩展库，提供了支持线性代数、傅立叶变换和其他数值分析的复杂函数库。</li>
<li><strong>SciPy</strong>：基于 NumPy 的科学计算库，可以处理插值、积分、优化、图像处理、常微分方程数值解的求解、信号处理等问题。</li>
<li><strong>Scikit-learn</strong>：简单高效的机器学习库，提供了解决分类、集群、回归等问题的机器学习算法模型，Scikit-learn 依赖于 NumPy 和 SciPy。</li>
<li><strong>pandas</strong>：非常强力的数据统计分析工具。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。能够很好的读写和呈现表格数据。</li>
<li><strong>Matplotlib</strong>：绘图工具，常常与 NumPy、SciPy 配合使用。</li>
</ul>
<p>下图是 Scikit-learn 在解决不同规模，不同类型问题时推荐使用的算法模型：</p>
<p><img data-src="20.png" alt="92b3401d754315d494e32f9bab97e755.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Halder, S. &amp; Ozdemir, S. <em>Hands-On Machine Learning for Cybersecurity: Safeguard your system by making your machines intelligent using the Python ecosystem[M].</em> Packt Publishing Ltd, 2018.</li>
<li>周志华. 机器学习[M]. 清华大学出版社, 2016.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/09/22/%E4%BB%80%E4%B9%88%E6%98%AFP-NP-NPC%E4%BB%A5%E5%8F%8ANP-Hard%E9%97%AE%E9%A2%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/%E4%BB%80%E4%B9%88%E6%98%AFP-NP-NPC%E4%BB%A5%E5%8F%8ANP-Hard%E9%97%AE%E9%A2%98%EF%BC%9F/" class="post-title-link" itemprop="url">什么是 P, NP, NPC 以及 NP-Hard 问题？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-22 21:17:07" itemprop="dateCreated datePublished" datetime="2020-09-22T21:17:07+08:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Concepts/" itemprop="url" rel="index"><span itemprop="name">Concepts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度并不是表示一个程序解决问题需要花多少时间，而是<strong>当问题规模扩大后，程序需要的时间长度增长得有多快</strong>。</p>
<p>不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序性能很好，具有$O(1)$的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是$O(n)$，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于$O(n^2)$的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是$O(a^n)$的指数级复杂度，甚至$O(n!)$的阶乘级复杂度。</p>
<p>我们将复杂度量级按照数量级递增进行排序得到下图，并将其分为两类：<strong>多项式量级</strong>和<strong>非多项式量级</strong>，后者的复杂度远远大于前者。</p>
<p><img data-src="0.jpg" alt="3723793cc5c810e9d5b06bc95325bf0a.jpeg"></p>
<p>多项式级的复杂度包括$O(1),O(log(n)),O(n^a)$等，它的规模n出现在底数的位置；非多项式级只包含$O(a^n),O(n!)$两种，其复杂度计算机往往不能承受。</p>
<p>自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。举个例子，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。</p>
<p>还有另外一个经典的问题：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE">Hamilton回路</a>。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后回到起点的路径（满足这个条件的路径叫做Hamilton回路）。这个问题目前还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。</p>
<p>由此，我们根据复杂度分级，将问题进行分类。最简单的一类问题被称为P问题，按复杂度依次递增，又有NP问题、NPC问题和NP-Hard问题。先来看看P问题的定义。</p>
<h2 id="P问题"><a href="#P问题" class="headerlink" title="P问题"></a>P问题</h2><blockquote>
<p>定义：在计算复杂度理论中，P（polynomial time class）是在复杂度类问题中可于确定型图灵机以多项式量级（或称多项式时间）求解的决定性问题。</p>
</blockquote>
<p>简单来说，就是<strong>一个P问题可以在多项式（$O(n^k)$）的时间复杂度内被解决</strong>。</p>
<p>P问题比较容易理解，它是复杂度最低的一类问题。事实上，计算机能解决的问题绝大部分都属于P问题，譬如排序、最小树、最短路、最大流、最小费用流、最大匹配等常见问题都是多项式时间可解的P类问题。</p>
<p>然而另一类问题如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TSP">旅行商问题(TSP)</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92">整数线性规划问题(ILP)</a>至今仍未找到多项式时间算法，又往往无法证明多项式算法的不存在性。在这类问题中，又存在一类特殊的问题，即：<strong>我无法在多项式时间内解决该问题，但我可以找到该问题的一个解，然后在多项式时间内验证该解是否正确</strong>。我们将这类问题归类为<strong>NP问题</strong>。举个例子，前面的Hamilton回路问题，虽然它不是P问题，但我可以找到一条路径，并在$O(n)$时间内验证这条路径是否经过每个顶点一次（每个顶点遍历一次）。</p>
<h2 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h2><blockquote>
<p>定义：非确定多项式类（non-deterministic polynomial，缩写：NP）是指在在非确定型图灵机上可以用多项式时间复杂度的算法解决的问题。</p>
</blockquote>
<p>简单来说，NP问题是指<strong>可以在多项式时间内猜出一个解或验证一个解的正确性的问题</strong>。</p>
<p>很显然，前面所说的Hamilton回路属于NP问题。但若是问题变成这样：试问一个图中是否不存在Hamilton回路？该问题就没法在多项式的时间里进行验证了，因为除非你验证过所有的路径，否则你不敢断定它“没有Hamilton回路”。</p>
<p>之所以要定义NP问题，是因为通常<strong>只有NP问题才有可能找到多项式的算法</strong>。若是一个问题连在多项式时间内验证一个解是否正确都做不到，那我们不指望能存在一个解决它的多项式级的算法。事实上信息学中的号称最困难的问题——“NP问题”，其实就是在探讨<strong>NP问题与P问题的关系</strong>。</p>
<p>很显然，所有的P问题都是NP问题，即$P \subset NP$。因为，如果能在多项式时间内解决一个问题，必然能在多项式时间内验证一个问题的解是否正确。那么问题就变成了：<strong>是否所有的NP问题都是P问题，即究竟是否有P=NP?</strong> </p>
<p>目前为止，这个问题还未被证明或推翻。但人们普遍认为，P≠NP，也就是说，多数人相信，<strong>存在至少一个不可能有多项式级复杂度的算法的NP问题</strong>。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，即所谓的NPC问题。正是NPC问题的存在，使人们相信P≠NP。下面我们介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p>
<h2 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h2><blockquote>
<p>定义：如果一个问题满足：</p>
<ol>
<li>它是一个NP问题。</li>
<li>其他属于NP的问题都可在多项式时间内归约成它。</li>
</ol>
<p>我们就将这类问题称为NP-完全问题（NP-Complete，缩写为NP-C或NPC）</p>
</blockquote>
<p>为了说明NPC问题，我们先引入一个概念——<strong>规约(Reducibility)<strong>。简单地说，一个问题A可以规约为问题B的含义是，可以用问题B的解法解决问题A。所以，B的时间复杂度是大于等于A的时间复杂度的。也就是说：</strong>A规约为B，B比A问题要更泛化、更难求解；但一旦B问题解决了，A问题也随之解决了</strong>。</p>
<p>《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以规约为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以找到一个“规则”：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以规约为TSP问题：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。</p>
<p>很显然，规约具有一项重要的性质：<strong>传递性</strong>。如果问题A可规约为问题B，问题B可规约为问题C，则问题A一定可规约为问题C。当然，我们所说的“可规约”是指的可“多项式地”规约(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。规约的过程只有用多项式的时间完成才有意义。</p>
<p>现在我们已经知道，一个问题规约为另一个问题，时间复杂度增加了，问题的应用范围也增大了。<strong>结合规约的传递性，通过对某类问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替原先复杂度较低但应用范围也更小的一类问题的算法</strong>。自然地，我们会想问，如果不断地规约上去，能否找到一个时间复杂度最高，并且能“通吃”所有的NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，<strong>存在这样一个NP问题，所有的NP问题都可以规约成它</strong>。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是所谓的NPC问题，也就是NP-完全问题。到这里你应该可以理解完全（Complete）的含义了。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，<strong>NPC问题是一类NP问题中最复杂的问题，也是在P≠NP假设下最不可能找到多项式时间（化简为P）的问题</strong>。</p>
<p>既然所有的NP问题都能规约为NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p>
<p>那么有没有比NPC问题更复杂的问题呢？答案是有的，就是我们接下来介绍的NP-Hard问题。</p>
<h2 id="NP-Hard问题"><a href="#NP-Hard问题" class="headerlink" title="NP-Hard问题"></a>NP-Hard问题</h2><blockquote>
<p>定义：如果所有NP问题都可以多项式时间归约到某个问题，则称该问题为NP-困难问题（NP-hardness, non-deterministic polynomial-time hardness，缩写为NP-Hard）。</p>
</blockquote>
<p>注意到，一个NP-Hard问题未必可以在多项式时间内验证一个解的正确性，即<strong>NP-Hard问题不一定是NP问题</strong>，也就是NP-Hard问题只满足NPC问题定义的第二个条件。因此我们可以<strong>将NPC问题理解为即是NP问题又是NP-Hard问题的一类问题</strong>。也就是说，NP-Hard问题要比NPC问题的范围更广。从时间复杂性上来考虑，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高更难以解决。换句话说，即使NPC问题有多项式时间的解（P=NP），NP-Hard问题依然可能没有多项式时间的解。</p>
<p>研究生数模竞赛中遇到的基本都是NP-Hard问题，在P≠NP的假设下，只能设计启发式算法或者近似算法，求得令人满意的可行解。<strong>启发式算法</strong>是一个基于直观或经验构造的算法，在可接受的花费(指计算时间和空间)下给出待解决优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。启发式算法以仿自然体算法为主，主要有遗传算法、蚁群算法、模拟退火法、神经网络等；<strong>近似算法</strong>则可以相当快速地找到合理的解决方案，需要证明解决方案的近似性，即所有实例中最坏情况下可以保证近似解的范围，并且运行时间合理。近似算法对于任何实例通常可得到一个有质量保证的解。近似性常用近似比、近似方案来度量。近似算法往往设计方法不难，比如贪心法、动态规划、基于线性规划的方法，但近似性的证明非常难。两者相辅相成。</p>
<h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p>基于P≠NP和P=NP两种猜想，我们得到描述P, NP, NPC，以及NP-Hard之间关系的欧拉图：</p>
<p><img data-src="1.png" alt="4dead7744239cc0042d7f029f3c3875a.png"></p>
<p>可以看到，在P≠NP假设下，P与NPC没有交集，亦即我们之前提到的，NPC问题最不可能化简为P问题。而在P=NP问题下，即使是最复杂的NPC问题也可以化简为P问题，因为从定义来说NPC也是一个NP问题。</p>
<h2 id="确定型与非确定型图灵机"><a href="#确定型与非确定型图灵机" class="headerlink" title="确定型与非确定型图灵机"></a>确定型与非确定型图灵机</h2><p>定义中提及了确定型/非确定型图灵机，虽然对于理解P和NP问题没有太大影响，但还是有必要在这里做一个简要的阐述。</p>
<p>图灵机（Turing machine），又称<strong>确定型图灵机</strong>，是英国数学家艾伦·图灵于1936年提出的一种将人的计算行为抽象化的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。图灵机有以下几个组成部分：</p>
<ol>
<li>一个不限长度的<strong>纸带</strong>。纸带被划分成一个个的小格子，格子中标有符号或者空白。</li>
<li>一个<strong>读写头</strong>。可在纸带上移动，能够读写格子中的符号。</li>
<li>一套<strong>控制规则</strong>。根据当前机器所处状态以及当前读写头所指的格子上的符号，来决定读写头下一步的动作，并改变状态寄存器的值。</li>
<li>一个<strong>状态寄存器</strong>。保存图灵机当前状态。</li>
</ol>
<p>不难看出图灵机本质上就是状态机，我们可以将机器从开始运行到停机的运作过程记录为一串序列：</p>
<p>$$q_0 \rightarrow_{\omega_0} q_1 \rightarrow_{\omega_1} q_2 \rightarrow … \rightarrow_{\omega_{n-1}} q_n$$</p>
<p>开始时，机器处于$q_0$状态，读写头指向0号格子；开始运行后，读入格子中的符号$\omega_0$，根据控制规则，机器进入下一状态$q_1$；重复此过程，直至到达终止状态，机器停机。</p>
<p>终止状态包括两种状态，$q_{accept}$称为接受状态，即机器根据控制规则成功运行至终态；$q_{reject}$称为拒绝状态，如果在运行中遇到下一个操作没有定义的情况，机器将立刻停机并拒绝输入的字符串。由于整个过程只要初始状态、输入、控制规则确定，机器运行的过程就确定，所以我们将其称之为<strong>确定型</strong>图灵机。</p>
<p>如果不加特殊说明，通常所说的图灵机都是确定型图灵机。<strong>非确定型图灵机</strong>和确定型图灵机的不同之处在于，在计算的每一时刻，根据当前状态和读写头所读的符号，<strong>机器存在多种状态转移方案，机器将任意地选择其中一种方案继续运作</strong>，直到最后停机为止。</p>
<p>图灵机是一个计算机的理论模型，我们通常说，现代计算机是基于冯诺依曼体系的，实际是冯诺依曼机就是基于图灵机模型的实现，包括高度复杂化的运算、控制、存储、输入、输出五个部分。比如纸带（用内存/磁盘模拟）、内部状态寄存器（现代计算机有大量的标志位和大量的寄存器甚至寄存器组）、在纸带上移动（各种跳转指令、各种复杂的寻址操作）、控制规则（CPU指令集）等。到目前为止，依然没有能够超越图灵机的模型。关于人工智能、量子计算机是否超越了图灵机也有非常有趣的讨论，感兴趣的读者可以自行查阅资料。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.matrix67.com/blog/archives/105">什么是P问题、NP问题和NPC问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27039635">怎么理解P问题和NP问题？- 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA">图灵机 - WiKi</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">基于 DPDK 的模拟 (D)Dos 攻击实验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 21:02:12" itemprop="dateCreated datePublished" datetime="2020-09-17T21:02:12+08:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Projects/" itemprop="url" rel="index"><span itemprop="name">Projects</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>该实验是我暑期前往导师实验室，与一群东南大学网安三年级的本科生所做。我的工作是帮他们搭建了实验所需运行的服务器环境，实验数据的采集、制图以及结果分析均是他们所做。由于该实验可能在我研究生阶段进行进一步的研究，所以将它摘至我的博客，文档亦摘录了本科生们所做的实验报告，特此申明。</p>
</blockquote>
<p>东大网安本科组员：翟思宇、肖遥、宋昌霖、胡钺琳、赵泽瑞、赵钧陶<br>指导老师：肖卿俊</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本实验搭载高速以太网卡，通过持续的高速数据传输，达到逼近目标服务器链路的传输速率极限，以模拟 (D)Dos 攻击的效果。攻击主机系统采用 Ubuntu Server 版本，受 Linux 系统 I/O 的内核机制的影响，发包速率受到限制。本实验创新性的利用 DPDK 软件平台绕过系统内核，实现高数据吞吐率的效果。</p>
<p><img data-src="0.png" alt="81db04d3b1658e9c254bfbfce6dedde2.png"></p>
<p>如上图，Linux 内核协议栈的实现决定了它内核网络协议的性能不佳，Linux 在内核收包处理时，将网卡收到的报文通过 DMA 放到内存，网卡出发中断通知系统有报文到达，系统分配 sk_buff，将报文拷贝到 sk_buff 中，交由协议栈处理，之后将其送用户态应用程序处理。</p>
<p>这种情况下，报文数量的增多将急剧增加资源的消耗。这包含报文产生 CPU 中断的上下文切换、为报文申请分配 sk_buff 消耗的资源、用户态程序收发包时产生系统调用和上下文切换带来的系统资源消耗。Kernel Bypass（内核旁路）技术应运而生，DPDK 正是采用的上图图由这种类 DMA 机制，直接将数据包从硬件（网卡端口）传输至用户态应用程序，以此来实现低延迟、低消耗的高吞吐网络传输。</p>
<p>TRex 是思科研发的一款成熟的基于 DPDK 的网络测试工具。它运行在标准的 Intel 处理芯片上，同时支持 stateful 和 stateless 两种模式，stateful 可以描述 L4~L7 层的应用场景，而 stateless 主要用于进行定制包的发包。本实验主要利用 TRex 的 DPDK 高线速发包能力，模拟对目标服务器进行 (D)Dos 打击。</p>
<p><img data-src="1.png" alt="7a135e990f639b406cd1cc244d4943f3.png"></p>
<h2 id="实验物理环境"><a href="#实验物理环境" class="headerlink" title="实验物理环境"></a>实验物理环境</h2><p><img data-src="2.JPG" alt="2ffa174d247d24ce9f16ea7332178308.jpeg"></p>
<ol>
<li>DELL Xeon Server，OS: Ubuntu Server 18.04 LTS。原装的系统为 CentOS 6，实验过程中遇到内核版本过低不支持 TRex 发包的问题，所以重装了 Ubuntu 系统。此外服务器还安装了实验室购入的兼容 DPDK 的 INTEL X710 网卡。</li>
<li>NetFPGA-SUME Virtex-7 FPGA Development Board，四个 10Gbps 的端口，实验过程中使用两根光缆连接到服务器构成回环。</li>
<li>DELL 工作站，用于将编译好的 P4 程序烧入 NetFPGA 智能网卡。</li>
</ol>
<h2 id="服务器环境准备"><a href="#服务器环境准备" class="headerlink" title="服务器环境准备"></a>服务器环境准备</h2><h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><ol>
<li>服务器操作系统选择兼容性、稳定性较好的 Ubuntu 18.04.5 LTS 版本，官网下载需要翻墙，也可以选择清华或阿里的开源软件镜像网。<a target="_blank" rel="noopener" href="https://releases.ubuntu.com/bionic/">官网下载地址</a></li>
<li>制作启动 U 盘，使用 Rufus 镜像刻录工具将下载好的 iso 镜像刻录至 U 盘。<a target="_blank" rel="noopener" href="https://ubuntu.com/tutorials/create-a-usb-stick-on-windows#1-overview">官网教程 - Create a bootable USB stick on Windows</a>。</li>
<li>启动服务器，按住 F2 进入 DELL 的 BIOS 界面，将 U 盘调整为启动的第一选项。</li>
<li>重启服务器，按照引导程序安装系统。<a target="_blank" rel="noopener" href="https://ubuntu.com/tutorials/install-ubuntu-server#1-overview">官网教程 - Install Ubuntu Server</a></li>
</ol>
<h3 id="连接外网"><a href="#连接外网" class="headerlink" title="连接外网"></a>连接外网</h3><p><img data-src="3.JPG" alt="8d45ed82634b33c68b4ddacfeef8a6a7.jpeg"></p>
<p>服务器共有四个网口 eno1～eno4，将网线插在左数第一个网口对应 eno1（图中①），并配置 interfaces 文件。图中②位置为 INTEL X710 网卡位置，从 NetFPGA 智能网卡的端口连接至服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vi etc/network/interfaces</span><br><span class="line"></span><br><span class="line">auto eno1</span><br><span class="line">iface eno1 inet dhcp</span><br></pre></td></tr></table></figure>

<p>在<code>/etc/resolv.conf</code>中加入 DNS 配置，此为阿里提供的公共 DNS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 223.6.6.6</span><br></pre></td></tr></table></figure>

<p>要先手动设置 IP 再使用 <code>dhclient</code> 命令启用 DHCP，<strong>每次重启服务器后如需连接外网，需输入这两行命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.102 netmask 255.255.255.0</span><br><span class="line">dhclient eno1</span><br></pre></td></tr></table></figure>

<p>执行完成就可以连通外网了</p>
<h3 id="设置网口"><a href="#设置网口" class="headerlink" title="设置网口"></a>设置网口</h3><p><code>ifconfig -a </code>查看网口信息，列出了 X710 网卡的两个网口信息，默认驱动是 Kernel Driver i40e，先设置 IP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig enp59s0f0 192.168.200.2</span><br><span class="line">sudo ifconfig enp59s0f1 192.168.201.2</span><br></pre></td></tr></table></figure>

<p>在工作站的主机上 ping 一下服务器保证双向联通</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>使用 <code>apt-get</code> 命令安装 DPDK 依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt install -y dpdk dpdk-dev dpdk-doc</span><br></pre></td></tr></table></figure>

<p>安装其他依赖，可以先在本地保存为 <code>install.sh</code>，然后使用 <code>scp</code> 命令传到服务器上 <code>sh install.sh</code>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y cmake gcc g++ git automake llvm llvm-dev llvm-runtime libtool bison flex build-essential vim</span><br><span class="line"></span><br><span class="line"># Install pkg-config here, as it is required for p4lang/PI</span><br><span class="line"># installation to succeed.</span><br><span class="line">sudo apt-get install -y pkg-config</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y wget curl zip unzip rar unrar unar</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y libgc-dev libfl-dev libgmp-dev libevent-dev libssl-dev libjudy-dev libpcap-dev tcpdump</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y libboost-dev libboost-iostreams-dev libboost-graph-dev libboost-test-dev libboost-program-options-dev libboost-system-dev libboost-filesystem-dev libboost-thread-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y libreadline6 libreadline6-dev</span><br><span class="line"># 这里如果提示废弃就执行下面的安装</span><br><span class="line">sudo apt-get install -y libreadline-dev </span><br><span class="line"></span><br><span class="line"># Deps needed to build PI:</span><br><span class="line">sudo apt-get install -y libjudy-dev libreadline-dev valgrind libtool-bin libboost-dev libboost-system-dev libboost-thread-dev</span><br><span class="line"></span><br><span class="line"># Things needed for `cd tutorials/exercises/basic ; make run` to work:</span><br><span class="line">sudo apt-get install -y libgflags-dev net-tools</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y doxygen graphviz texlive-full</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y bridge-utils tcpreplay</span><br><span class="line">sudo apt-get install -y zlib1g-dev pciutils kmod strace  ## needed by cisco trex</span><br></pre></td></tr></table></figure>

<h3 id="安装TRex"><a href="#安装TRex" class="headerlink" title="安装TRex"></a>安装TRex</h3><p>联网下载 TRex</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget --no-cache http://trex-tgn.cisco.com/trex/release/latest</span><br><span class="line">tar -zxvf latest</span><br></pre></td></tr></table></figure>

<p>我们下载的 TRex 最新版本为 v2.82，进入到该目录下并执行 DPDK 端口设置脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd v2.82</span><br><span class="line">./dpdk_setup_ports.py -i</span><br></pre></td></tr></table></figure>

<p>按照下图设置</p>
<p><img data-src="4.jpeg" alt="0b9649d536fbab09908a9df0303c590a.jpeg"></p>
<p>此时可以注意到，X710 网卡的两个网口还是绑定的 i40e 内核驱动。但在运行 TRex 发包命令后会自动绑定到 DPDK 兼容驱动 igb_uio 上。</p>
<h2 id="发包测试"><a href="#发包测试" class="headerlink" title="发包测试"></a>发包测试</h2><p>实验环境准备就绪，进行发包测试。参考 TRex 官方手册 <a target="_blank" rel="noopener" href="https://trex-tgn.cisco.com/trex/doc/trex_manual.html#_running_examples">Running examples
</a>，在 stateful 模式下使用 <code>t-rex-64</code> 命令发送数据包。<code>-f</code> 指定配置 yaml，<code>-m</code> 指定重放次数，<code>-l</code> 指定网络延迟检测速率。更多参数详见官方手册。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./t-rex-64 -f avl/sfr_delay_10_1g.yaml -m 5 -l 1000</span><br></pre></td></tr></table></figure>

<p>测试效果如下：</p>
<p><img data-src="5.jpeg" alt="7402f2999111d19e378f8883aaf3ba34.jpeg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-Per port stats table </span><br><span class="line"></span><br><span class="line">      ports |               0 |               1 </span><br><span class="line"> -----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   opackets |        27882688 |        35434728 </span><br><span class="line">     obytes |      8217921859 |     28586813888 </span><br><span class="line">   ipackets |         5007937 |             709 </span><br><span class="line">     ibytes |      4647534484 |           79608 </span><br><span class="line">    ierrors |               0 |               0 </span><br><span class="line">    oerrors |               0 |               0 </span><br><span class="line">      Tx Bw |       1.18 Gbps |       3.81 Gbps </span><br><span class="line"></span><br><span class="line">-Global stats enabled </span><br><span class="line"> Cpu Utilization : 31.6  %  31.6 Gb/core </span><br><span class="line"> Platform_factor : 1.0  </span><br><span class="line"> Total-Tx        :       5.00 Gbps  </span><br><span class="line"> Total-Rx        :       0.00  bps  </span><br><span class="line"> Total-PPS       :       1.07 Mpps  </span><br><span class="line"> Total-CPS       :      20.51 Kcps  </span><br><span class="line"></span><br><span class="line"> Expected-PPS    :       1.08 Mpps  </span><br><span class="line"> Expected-CPS    :      20.61 Kcps  </span><br><span class="line"> Expected-BPS    :       5.02 Gbps  </span><br><span class="line"></span><br><span class="line"> Active-flows    :    21328  Clients :      511   Socket-util : 0.0775 %    </span><br><span class="line"> Open-flows      :  1342791  Servers :     5621   Socket :    24927 Socket/Clients :  48.8 </span><br><span class="line"> drop-rate       :       5.00 Gbps   </span><br><span class="line"> current time    : 66.5 sec  </span><br><span class="line"> test duration   : 3533.5 sec  </span><br><span class="line"></span><br><span class="line">-Latency stats enabled </span><br><span class="line"> Cpu Utilization : 0.1 %  </span><br><span class="line"> if|   tx_ok , rx_ok  , rx check ,error,       latency (usec) ,    Jitter          max window </span><br><span class="line"></span><br><span class="line">   |         ,        ,          ,     ,   average   ,   max  ,    (usec)                     </span><br><span class="line"> ---------------------------------------------------------------------------------------------------------------- </span><br><span class="line"></span><br><span class="line"> 0 |    65254,   12858,         0,    0,          7  ,      23,       1      |  10  10  15  10  12  11  12  23  10  10  15  18  12 </span><br><span class="line"> 1 |    65254,     136,         0,    0,          3  ,       0,       0      |  0  0  0  0  0  0  0  0  0  0  0  0  0 </span><br><span class="line"></span><br><span class="line">## </span><br></pre></td></tr></table></figure>

<p>主要记录的数据包括：</p>
<ul>
<li><strong>Cpu Utilization</strong>，CPU利用率</li>
<li><strong>Total-Tx</strong>，总计发送速率（Transport）</li>
<li><strong>Total-Rx</strong>，总计接受速率（Receive）</li>
<li><strong>Total-PPS</strong>，总计每秒传输包数量（Packets per second）</li>
</ul>
<h2 id="发包实验"><a href="#发包实验" class="headerlink" title="发包实验"></a>发包实验</h2><p>接下来我们尝试在 stateful 模式下模拟 stateless 发包，使用的是 <code>cap2/</code> 目录下的 <code>imix.yaml</code> 配置文件，根据以太网协议，一个数据包的大小从最小 64Bytes 到最大 1518Bytes，imix 提供了 imix_64、imix_594 和 imix_1518 三类配置文件。</p>
<p><code>-c</code> 指定 CPU 核数，观察并绘制不同包大小、不同核数时 CPU 利用率以及吞吐率的 eps 矢量图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./t-rex-64 -f cap2/imix_1518.yaml -m 823451 -l 1000 -c 2</span><br></pre></td></tr></table></figure>

<p>实验结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">-Per port stats table </span><br><span class="line"></span><br><span class="line">      ports |               0 |               1 </span><br><span class="line"> -----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   opackets |        34232892 |           42080 </span><br><span class="line">     obytes |     51904428378 |         2777280 </span><br><span class="line">   ipackets |               0 |               0 </span><br><span class="line">     ibytes |               0 |               0 </span><br><span class="line">    ierrors |               0 |               0 </span><br><span class="line">    oerrors |               0 |               0 </span><br><span class="line">      Tx Bw |       9.89 Gbps |     527.55 Kbps </span><br><span class="line"></span><br><span class="line">-Global stats enabled </span><br><span class="line"> Cpu Utilization : 100.0  %  9.9 Gb/core </span><br><span class="line"> Platform_factor : 1.0  </span><br><span class="line"> Total-Tx        :       9.89 Gbps  </span><br><span class="line"> Total-Rx        :       0.00  bps  </span><br><span class="line"> Total-PPS       :     816.02 Kpps  </span><br><span class="line"> Total-CPS       :       0.00  cps  </span><br><span class="line"></span><br><span class="line"> Expected-PPS    :       6.59 Gpps  </span><br><span class="line"> Expected-CPS    :       6.59 Gcps  </span><br><span class="line"> Expected-BPS    :      80.00 Tbps  </span><br><span class="line"></span><br><span class="line"> Active-flows    :     1600  Clients :      254   Socket-util : 0.0100 %    </span><br><span class="line"> Open-flows      :     1600  Servers :    65534   Socket :     1600 Socket/Clients :  6.3 </span><br><span class="line"> Total_queue_full : 72264932         </span><br><span class="line"> drop-rate       :       9.89 Gbps   </span><br><span class="line"> current time    : 43.3 sec  </span><br><span class="line"> test duration   : 3556.7 sec  </span><br><span class="line"></span><br><span class="line">-Latency stats enabled </span><br><span class="line"> Cpu Utilization : 0.1 %  </span><br><span class="line"> if|   tx_ok , rx_ok  , rx check ,error,       latency (usec) ,    Jitter          max window </span><br><span class="line"></span><br><span class="line">   |         ,        ,          ,     ,   average   ,   max  ,    (usec)                     </span><br><span class="line"> ---------------------------------------------------------------------------------------------------------------- </span><br><span class="line"></span><br><span class="line"> 0 |    42080,       0,         0,    0,          0  ,       0,       0      |  0  0  0  0  0  0  0  0  0  0  0  0  0 </span><br><span class="line"> 1 |    42081,       0,         0,    0,          0  ,       0,       0      |  0  0  0  0  0  0  0  0  0  0  0  0  0 </span><br><span class="line"></span><br><span class="line">## </span><br></pre></td></tr></table></figure>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h3><p>一个以太网帧的结构包括：</p>
<table>
<thead>
<tr>
<th>PA</th>
<th>SFD</th>
<th>DA</th>
<th>SA</th>
<th>Type</th>
<th>Payload</th>
<th>FCS</th>
<th>IFG</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>1</td>
<td>6</td>
<td>6</td>
<td>2</td>
<td>46 ~ 1500</td>
<td>4</td>
<td>12</td>
</tr>
</tbody></table>
<p>最小帧长：7+1+(6+6+2+46+4)+12 = 84B（最小有效帧长 64B）<br>最大帧长：7+1+(6+6+2+1500+4)+12 = 1538B（最大有效帧长 1518B）</p>
<p>对于最小帧长，最大包传输率 M 和吞吐率 T 为：</p>
<p>$$M = Speed/Size = 100 * 10^9 / (84 * 8) = 148809523 pps$$<br>$$T = M * 64 * 8 = 76.19Gbps$$</p>
<p>对于最大帧长，最大包传输率 M 和吞吐率 T 为：</p>
<p>$$M = Speed/Size = 100 * 10^9 / (1538 * 8) = 8127438 pps$$<br>$$T = M * 1518 * 8 = 98.69Gbps$$</p>
<p>以此类推，我们对于不同的帧长做了理论分析，得到下图：</p>
<p><img data-src="6.png" alt="38021550bd20f375c0c872a80cea41af.png"></p>
<h3 id="吞吐率测试结果"><a href="#吞吐率测试结果" class="headerlink" title="吞吐率测试结果"></a>吞吐率测试结果</h3><p>以下是吞吐率的测试结果：</p>
<p><img data-src="7.png" alt="037b37c99b1bc4c938f887dc1b876ba1.png"><br><img data-src="8.png" alt="ec784c4bc84e984d27170739145d5bfe.png"><br><img data-src="9.png" alt="d9c6568a7c11555a9290d452fbacafe2.png"></p>
<h3 id="包传输率测试结果"><a href="#包传输率测试结果" class="headerlink" title="包传输率测试结果"></a>包传输率测试结果</h3><p>以下是包传输率的测试结果：</p>
<p><img data-src="10.png" alt="0f5b53c8b5544ae9572cebc9168f12cb.png"><br><img data-src="11.png" alt="83c9995318589576075bf3140b4f46fd.png"><br><img data-src="12.png" alt="79d66dcca878a695f31c01cf8e08e2d8.png"></p>
<h3 id="与内核机制发包的对比"><a href="#与内核机制发包的对比" class="headerlink" title="与内核机制发包的对比"></a>与内核机制发包的对比</h3><table>
<thead>
<tr>
<th align="center">包大小(B)</th>
<th align="center">内核机制发包<br>CPU利用率</th>
<th align="center">内核机制发包<br/>PPS(Kpps)</th>
<th align="center">DPDK机制发包<br/>PPS(Mpps)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">64</td>
<td align="center">100%</td>
<td align="center">593.5</td>
<td align="center">14.85</td>
</tr>
<tr>
<td align="center">549</td>
<td align="center">100%</td>
<td align="center">585.29</td>
<td align="center">2.04</td>
</tr>
<tr>
<td align="center">1518</td>
<td align="center">97.70%</td>
<td align="center">537.27</td>
<td align="center">0.82</td>
</tr>
</tbody></table>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>由上述实验结果可知：</p>
<ol>
<li>10Gbps 线速的网络，用 DPDK 跑 4 个核，基本可以实现 64B 最小包较好的发送吞吐率，但是仍达不到 10Gbps 的线速，只有 7.6Gbps 左右。</li>
<li>DPDK 由于采用了绕过内核驱动的技术，使得网络数据包的发送速度大大增加。</li>
<li>此外，随着数据包长度增加，其他条件一定时，吞吐率也随之增加，这与我们的理论分析基本吻合。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><em>Surasak Sanguanpong, Experiences in Building a 100 Gbps (D)DoS Traffic Generator, DIY with a Single  Commodity-off-the-shelf (COTS) Server.</em></li>
<li><a target="_blank" rel="noopener" href="https://trex-tgn.cisco.com/trex/doc/trex_manual.html">TRex official manual</a></li>
<li><a target="_blank" rel="noopener" href="https://trex-tgn.cisco.com/trex/doc/trex_stateless.html#_stateful_vs_stateless">TRex Stateless Support</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/cisco-system-traffic-generator/trex-core">思科TRex Traffic Generator代码仓库</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/" class="post-title-link" itemprop="url">DataCon2020 加密恶意流量检测初赛 Writeup 及总结反思</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-09 23:20:52" itemprop="dateCreated datePublished" datetime="2020-08-09T23:20:52+08:00">2020-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Projects/" itemprop="url" rel="index"><span itemprop="name">Projects</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="初赛题目"><a href="#初赛题目" class="headerlink" title="初赛题目"></a>初赛题目</h2><p>主办方提供了 black/white/test 三个 pcap 文件夹，其中 black 和 white 分别是检测出有/无恶意软件感染的客户端 IP 组，要求选手对 test 数据集进行判定。</p>
<p><img data-src="0.png" alt="09bda35ff290f2e34d88d50e71d98f1a.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题的解题过程应分为以下三个大步骤：</p>
<ol>
<li><strong>特征选择（Feature Selection）</strong>，选取对于区分正常/恶意流量有明显作用的 Features。</li>
<li><strong>特征提取（Feature Extraction）</strong>，从 pcap 文件中提取上述 Features，并转换为模型训练所需要的格式。我们选择的特征提取工具为 <strong>Zeek</strong>。</li>
<li><strong>模型训练（Model Training）</strong>，选择合适的机器学习模型对三类 pcap 文件进行训练和预测。我们选择的 Python 机器学习库为 <strong>scikit-learn</strong>。</li>
</ol>
<h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><h3 id="合并pcap文件"><a href="#合并pcap文件" class="headerlink" title="合并pcap文件"></a>合并pcap文件</h3><p>主办方提供的 pcap 文件，其中 white/black 各有 1500 个 pcap，test 2000 个 pcap</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  tree eta_1 </span><br><span class="line">eta_1</span><br><span class="line">├── black</span><br><span class="line">│   ├── 192.168.10.91.pcap</span><br><span class="line">│   ├── 192.168.44.25.pcap</span><br><span class="line">│   ├── ...</span><br><span class="line">│   └── 192.168.80.115.pcap</span><br><span class="line">├── test</span><br><span class="line">│   ├── 192.168.150.71.pcap</span><br><span class="line">│   ├── 192.168.150.99.pcap</span><br><span class="line">│   ├── ...</span><br><span class="line">│   └── 192.168.210.239.pcap</span><br><span class="line">└── white</span><br><span class="line">    ├── 192.168.119.23.pcap</span><br><span class="line">    ├── 192.168.122.37.pcap</span><br><span class="line">		├── ...</span><br><span class="line">    └── 192.168.96.180.pcap</span><br></pre></td></tr></table></figure>

<p>使用 <code>mergecap</code> 命令将 pcap 文件合并为三个大的 pcap 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  mergecap -w black.pcap ./eta_1/black/*.pcap</span><br><span class="line">➜  tree -s -h .     </span><br><span class="line">.</span><br><span class="line">├── [418M]  black.pcap</span><br><span class="line">├── [1.0G]  test.pcap</span><br><span class="line">└── [1.7G]  white.pcap</span><br></pre></td></tr></table></figure>

<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>参考了多篇加密恶意流量检测的研究论文，我们初步确定了以下四类需要提取的 Features，包括<strong>TLS客户端指纹信息</strong>、<strong>数据包元数据</strong>、<strong>HTTP头部信息</strong>和<strong>DNS响应信息</strong>。</p>
<h4 id="TLS-client-fingerprinting："><a href="#TLS-client-fingerprinting：" class="headerlink" title="TLS client fingerprinting："></a>TLS client fingerprinting：</h4><p>在进行TLS握手时，会进行如下几个步骤：</p>
<ol>
<li><strong>Client Hello</strong>，客户端提供支持的加密套件数组（cipher suites）；</li>
<li><strong>Server Hello</strong>，由服务器端选择一个加密套件，传回服务器端公钥，并进行认证和签名授权（<strong>Certificate</strong> + Signature）；</li>
<li>客户端传回客户端公钥（<strong>Client Key Exchange</strong>），客户端确立连接；</li>
<li>服务器端确立连接，开始 HTTP 通信。</li>
</ol>
<p><img data-src="1.png" alt="5b01483a65bdc17c68873508796bb85e.png"></p>
<p>以上加粗的四种消息类型可以通过 TLS 握手协议的 <strong>Handshake Type</strong> 做区分：</p>
<p><img data-src="2.png" alt="bff6a460bcaa7c442014c3eb89deb26f.png"></p>
<p>基于此，我们选取了以下特征：</p>
<ul>
<li><strong>客户端支持的加密套件数组</strong>（Cipher suites），<strong>服务器端选择的加密套件</strong>。</li>
<li><strong>支持的扩展</strong>（TLS extensions），若分别用向量表示客户端提供的密码套件列表和 TLS 扩展列表，可以从服务器发送的确认包中的信息确定两组向量的值。</li>
<li><strong>客户端公钥长度</strong>（Client public key length），从密钥交换的数据包中，得到密钥的长度。</li>
<li><strong>Client version</strong>，the preferred TLS version for the client</li>
<li><strong>是否非CA自签名</strong>，统计数据表示，恶意流量约70%出现非CA认证服务器且自签名的情况，非恶意流量约占0.1%。此项判断的依据是：未出现 <code>CA: True</code> 字段（默认非 CA 机构）且 <code>signedCertificate</code> 中的 <code>issuer</code> 字段等于 <code>subject</code> 字段。</li>
</ul>
<h4 id="数据包元数据："><a href="#数据包元数据：" class="headerlink" title="数据包元数据："></a>数据包元数据：</h4><ul>
<li><strong>数据包的大小</strong>，数据包的长度受 UDP、TCP 或者 ICMP 协议中数据包的有效载荷大小影响，如果数据包不属于以上协议，则被设置为 IP 数据包的大小。</li>
<li><strong>到达时间序列</strong></li>
<li><strong>字节分布</strong></li>
</ul>
<h4 id="HTTP头部信息："><a href="#HTTP头部信息：" class="headerlink" title="HTTP头部信息："></a>HTTP头部信息：</h4><ul>
<li><strong>Content-Type</strong>，正常流量 HTTP 头部信息汇总值多为 <code>image/*</code>，而恶意流量为 <code>text/*、text/html、charset=UTF-8</code> 或者 <code>text/html;charset=UTF-8</code>。</li>
<li><strong>User-Agent</strong></li>
<li><strong>Accept-Language</strong></li>
<li><strong>Server</strong></li>
<li><strong>HTTP响应码</strong></li>
</ul>
<h4 id="DNS响应信息："><a href="#DNS响应信息：" class="headerlink" title="DNS响应信息："></a>DNS响应信息：</h4><ul>
<li><strong>域名的长度</strong>：正常流量的域名长度分布为均值为6或7的高斯分布（正态分布）；而恶意流量的域名（FQDN全称域名）长度多为6（10）。</li>
<li><strong>数字字符及非字母数字(non-alphanumeric character)的字符占比</strong>：正常流量的DNS响应中全称域名的数字字符的占比和非字母数字字符的占比要大。</li>
<li><strong>DNS解析出的IP数量</strong>：大多数恶意流量和正常流量只返回一个IP地址；其它情况，大部分正常流量返回2-8个IP地址，恶意流量返回4或者11个IP地址。</li>
<li><strong>TTL值</strong>：正常流量的TTL值一般为60、300、20、30；而恶意流量多为300，大约22%的DNS响应汇总TTL为100，而这在正常流量中很罕见。</li>
<li><strong>域名是否收录在Alexa网站</strong>：恶意流量域名信息很少收录在Alexa top-1,000,000中，而正常流量域名多收录在其中。</li>
</ul>
<h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>特征提取我们采用的工具是 <strong>Zeek</strong>，它的前身是 Bro，一款网络安全监视（Network Security Monitoring）工具，它定义了自己的 DSL 语言，支持直接处理 pcap 文件生成各类日志文件，包括 dns、http、smtp 等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ls</span><br><span class="line">conn.log	dhcp.log		 files.log	infected.pcap	  packet_filter.log	  smb_files.log	</span><br><span class="line">smtp.log	lce_rpc.log	 dns.log	  http.log	 kerberos.log	   pe.log		smb_mapping.log	</span><br><span class="line">ssl.log		weird.log		 x5Q9.log</span><br></pre></td></tr></table></figure>



<p>Zeek 网上有一些现成的脚本，我们采用的是 <strong>Zeek FlowMeter</strong>，它基于 OSI 七层协议的网络层和传输层，可以分析并生成一些 Packets 到达时间序列、Packet 字节大小和元数据等新特征。</p>
<p>在使用时，我们需要在 <code>local.zeek</code> 配置文件中加入 <code>@load flowmeter</code>，这样 Zeek 在执行时会加载 <code>flowmeter.zeek</code> 并生成对应的 <code>flowmeter.log</code>，下面列出了 FlowMeter 提取出的一些特征，包括上下行包总数、包负载均值方差等。其他详细的特征请见 <a target="_blank" rel="noopener" href="https://github.com/zeek-flowmeter/zeek-flowmeter">zeek-flowmeter GitHub官方文档</a>。</p>
<table>
<thead>
<tr>
<th>Feature Name</th>
<th>Description</th>
<th>exists in FlowMeter</th>
</tr>
</thead>
<tbody><tr>
<td>uid</td>
<td>The ID of the flow as given by Zeek</td>
<td>No</td>
</tr>
<tr>
<td>flow_duration</td>
<td>The length of the flow in seconds (maximal precision ms). If only on packet was seen the duration is 0.</td>
<td>Yes</td>
</tr>
<tr>
<td>fwd_pkts_tot</td>
<td>The number of packets travelling in the forward direction.</td>
<td>Yes</td>
</tr>
<tr>
<td>bwd_pkts_tot</td>
<td>The number of packets travelling in the backwards direction.</td>
<td>Yes</td>
</tr>
<tr>
<td>fwd_pkts_per_sec</td>
<td>The average number of forward packets transmitted per second during the flow. If the duration is 0 then this feature is also set to 0.</td>
<td>Yes</td>
</tr>
<tr>
<td>fwd_pkts_payload.avg</td>
<td>The average payload size, in bytes, seen in the forward direction.</td>
<td>Yes</td>
</tr>
<tr>
<td>fwd_pkts_payload.std</td>
<td>The standard deviation of the payload size, in bytes, seen in the forward direction.</td>
<td>Yes</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>除 <code>flowmeter.log</code> 之外我们还需要关注 <code>conn.log</code>、<code>ssl.log</code> 和 <code>X509.log</code>。这几个日志共同字段 <code>uid</code> 是 Zeek 根据一次连接的源/目的 IP、源/目的端口四元组生成的唯一 ID。为了方便后续的处理，我们将这几个日志文件统一读入，使用 <code>uid</code> 字段连接后转成 csv 格式输出到文件。<strong>最终我们提取的特征如下：</strong></p>
<p><img data-src="3.jpeg" alt="7d1475ca9c4d88e2c3e078a126fdfd52.jpeg"></p>
<h3 id="特征向量化"><a href="#特征向量化" class="headerlink" title="特征向量化"></a>特征向量化</h3><p>因为模型训练不支持 <code>str</code> 类型的特征，所以需要对 <code>version</code> 和 <code>server_cipher</code> 等字段进行特征向量化。</p>
<table>
<thead>
<tr>
<th>version</th>
<th>cipher</th>
</tr>
</thead>
<tbody><tr>
<td>TLSv10</td>
<td>TLS_RSA_WITH_3DES_EDE_CBC_SHA</td>
</tr>
<tr>
<td>TLSv10</td>
<td>TLS_RSA_WITH_3DES_EDE_CBC_SHA</td>
</tr>
<tr>
<td>TLSv12</td>
<td>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</td>
</tr>
<tr>
<td>TLSv10</td>
<td>TLS_RSA_WITH_RC4_128_MD5</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p><code>DictVectorizer</code> 是 scikit-learn 库中用于将 Python <code>dict</code> 对象表示的特征数组转换为 scikit-learn Estimator 使用的 NumPy/SciPy 表示形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_by_dict</span>(<span class="params">src_file, dest_file</span>):</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line">    vec = DictVectorizer()</span><br><span class="line"></span><br><span class="line">    df = pd.read_csv(src_file)</span><br><span class="line">    vs1 = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: &#123;<span class="string">&#x27;version&#x27;</span>: x&#125;, df[<span class="string">&#x27;version&#x27;</span>]))</span><br><span class="line">    vs2 = vec.fit_transform(vs1).toarray()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(vec.get_feature_names()):</span><br><span class="line">        df[name] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x[index]), vs2))</span><br><span class="line"></span><br><span class="line">    df.to_csv(dest_file, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>向量化后的效果：</p>
<table>
<thead>
<tr>
<th>version=SSLv3</th>
<th>version=TLSv10</th>
<th>version=TLSv12</th>
<th>version=TLSv11</th>
<th>cipher=TLS_RSA_WITH_3DES_EDE_CBC_SHA</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>另外需要注意的是，<strong>需要对特征列进行补全</strong>，否则在进行模型训练时会出现特征个数不匹配的问题。例如：white.pcap 文件中 TLS versions 包含 <code>[&#39;TLSv1.0&#39;, &#39;TLSv1.2&#39;, &#39;SSLv3&#39;]</code> 三个版本，而 black 和 test 的 pcap 文件中除这三个版本外还包含 <code>&#39;TLSv1.1&#39;</code> 版本，所以需要在 white 中加入 <code>version=TLSv1.1</code> 全为 0 的列。</p>
<h3 id="模型选取及参数"><a href="#模型选取及参数" class="headerlink" title="模型选取及参数"></a>模型选取及参数</h3><p>需要注意的是：white 已明确没有被恶意软件感染，所以产生的流量可以全部标注为正常流量，而 black 明确的只是客户端感染了恶意软件，但产生的流量不一定全为恶意流量。所以实际上是<strong>对不平衡样本数据进行训练和预测</strong>。遵循这个思路，可以采用 <strong>Anomaly Detector</strong> + <strong>Misuse Detector</strong> 的联合分类器进行训练。</p>
<p><img data-src="4.png" alt="fe7a1c020a03492fd8b465e8541a410e.png"></p>
<p>基于全正常流量的 white.pcap 文件进行 <strong>one-class classification</strong> 训练异常检测器 Anomaly Detector；再用该分类器对 black.pcap 文件进行推理预测恶意流量；结合 black 中检测的恶意流量和 white 正常流量训练二分类器；最终采用二分类器对 test 中的流量进行检测。</p>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>数据集是我们之前经过 Zeek 特征提取、特征向量化后产生的 <code>white.csv</code>、<code>black.csv</code> 和 <code>test.csv</code> 三个 csv 文件，使用 pandas 读入后定义一个列名数组 <code>data_f</code> 来获取相应特征：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">white_df = pd.read_csv(<span class="string">&quot;white.csv&quot;</span>,index_col=<span class="number">0</span>)</span><br><span class="line">black_df = pd.read_csv(<span class="string">&quot;black.csv&quot;</span>,index_col=<span class="number">0</span>)</span><br><span class="line">test_df = pd.read_csv(<span class="string">&quot;test.csv&quot;</span>,index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">white_flow = white_df[data_f]</span><br><span class="line">black_flow = black_df[data_f]</span><br><span class="line">test_flow = test_df[data_f]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源 IP 用于生成结果 result.txt 文件时使用</span></span><br><span class="line">test_ip = test_df[<span class="string">&#x27;id.oirg_h&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>将 white_flow 和 black_flow 两个数据集合并做归一化处理，得到total_data：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">merge_flow = white_flow.append(black_flow, ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">min_max_scaler = preprocessing.MinMaxScaler()</span><br><span class="line">total_data = min_max_scaler.fit_transform(merge_flow.values)</span><br></pre></td></tr></table></figure>

<p>然后我们从 total_data 中提取 white 的训练集和测试集，同时需要提取 black 的测试集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># white 训练集和测试集(标签1表示正常流量)</span></span><br><span class="line">x_train,x_valid,y_train,y_valid=train_test_split(total_data[<span class="number">0</span>:<span class="number">4834</span>],np.ones(<span class="number">4834</span>,np.<span class="built_in">int</span>),random_state=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># black 测试集</span></span><br><span class="line">black_data = total_data[<span class="number">4834</span>:]</span><br></pre></td></tr></table></figure>

<h4 id="Anomaly-Detector"><a href="#Anomaly-Detector" class="headerlink" title="Anomaly Detector"></a>Anomaly Detector</h4><p>在 black 数据集中同时存在恶意流量和正常流量，没有明确的标注，无法直接用于训练分类器。而 white 数据集中都是正常流量，可以先用 white 数据集来训练一个 Anomaly Detector 分类器。然后用这个分类器在 black 数据集中推理得到哪些是恶意流量。我们的模型选取的隔离森林 <code>IsolationForest</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">clf = IsolationForest(max_samples=<span class="built_in">len</span>(x_train), contamination=<span class="number">0.3</span>)</span><br><span class="line">clf.fit(x_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证集正确率</span></span><br><span class="line">y_pred_valid = clf.predict(x_valid)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;valid_accuracy：&quot;</span> + <span class="built_in">str</span>(np.mean(y_valid == y_pred_valid)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由 black 测试集得到的恶意流量占比</span></span><br><span class="line">y_black_test = clf.predict(black_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;black_anomaly_ratio：&quot;</span> + <span class="built_in">str</span>(<span class="number">1</span> - np.mean(y_black_test==np.ones(<span class="number">3980</span>, np.<span class="built_in">int</span>))))</span><br></pre></td></tr></table></figure>

<h4 id="训练误用检测器-Misuse-Detector"><a href="#训练误用检测器-Misuse-Detector" class="headerlink" title="训练误用检测器 Misuse Detector"></a>训练误用检测器 Misuse Detector</h4><p>假设这些由异常检测器识别的可疑流量是恶意流量，我们就有了恶意流量的标注。接下来我们用这些恶意流量 labels，结合 white 数据集中的正常流量 labels，来训练一个 Misuse Detector。我们选取了 XGBoost 基于树的模型，目标选取为多分类问题（分类数为2）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># XGbooster Model     gbtree    multi:softmax   2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># label标签  1:white  0:black</span></span><br><span class="line">white_flow[<span class="string">&#x27;label&#x27;</span>] = <span class="number">1</span></span><br><span class="line">black_flow[<span class="string">&#x27;label&#x27;</span>] = y_black_test</span><br><span class="line">black_flow[<span class="string">&#x27;label&#x27;</span>] = black_flow[<span class="string">&#x27;label&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留 black 中的恶意流量数据</span></span><br><span class="line">balack_anomaly_flow = black_flow[black_flow[<span class="string">&#x27;label&#x27;</span>] == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到模型训练数据集</span></span><br><span class="line">model_data = white_flow.append(balack_anomaly_flow, ignore_index=<span class="literal">True</span>) </span><br></pre></td></tr></table></figure>

<p>下一步对于数据做 Max/Min 归一化，然后分割出训练集、验证集、测试集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Max/Min 归一化</span></span><br><span class="line">X_flow = model_data[data_f]</span><br><span class="line">label_flow = model_data[<span class="string">&#x27;label&#x27;</span>].values</span><br><span class="line">model_total_flow = X_flow.append(test_flow, ignore_index=<span class="literal">True</span>)</span><br><span class="line">data_normal = preprocessing.scale(model_total_flow.values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分出训练集和测试集</span></span><br><span class="line">model_train = data_normal[:model_data.shape[<span class="number">0</span>]]</span><br><span class="line">model_test = data_normal[model_data.shape[<span class="number">0</span>]:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集中分割出验证集(根据 label_flow 来层次化分割)</span></span><br><span class="line">X_train, X_valid, Y_train, Y_valid = train_test_split(model_train, label_flow, random_state=<span class="number">50</span>,stratify = label_flow)</span><br><span class="line"></span><br><span class="line">xgboost_train = xgb.DMatrix(X_train, label=Y_train)</span><br><span class="line">xgboost_valid = xgb.DMatrix(X_valid, label=Y_valid)</span><br></pre></td></tr></table></figure>

<p>进行 XGBoost 模型训练：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalerror</span>(<span class="params">preds, dtrain</span>):</span>    </span><br><span class="line">    labels = dtrain.get_label()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;error&#x27;</span>, math.sqrt(metrics.mean_squared_error(preds,labels))</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;booster&#x27;</span>: <span class="string">&#x27;gbtree&#x27;</span>,  <span class="comment"># 树模型</span></span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;multi:softmax&#x27;</span>,  <span class="comment"># 多分类</span></span><br><span class="line">    <span class="string">&#x27;num_class&#x27;</span>: <span class="number">2</span>,  <span class="comment"># 类别数</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;gamma&#x27;</span>: <span class="number">0.1</span>,  <span class="comment"># 指定了节点分裂所需的最小损失函数下降值，越大越不易分裂</span></span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">7</span>,  <span class="comment"># 树的深度</span></span><br><span class="line">    <span class="string">&#x27;subsample&#x27;</span>: <span class="number">0.75</span>,  <span class="comment"># 每棵树随机采样的占比（训练集中）</span></span><br><span class="line">    <span class="string">&#x27;colsample_bytree&#x27;</span>: <span class="number">0.75</span>,  <span class="comment"># 每棵树随机采样的列数的占比（每一列是一个特征）</span></span><br><span class="line">    <span class="string">&#x27;min_child_weight&#x27;</span>: <span class="number">0.06</span>, <span class="comment"># 决定最小叶子节点样本权重和</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;eta&#x27;</span>: <span class="number">0.05</span>,  <span class="comment"># 学习率</span></span><br><span class="line">    <span class="string">&#x27;seed&#x27;</span>: <span class="number">100</span>, <span class="comment"># 随机种子</span></span><br><span class="line">    <span class="string">&#x27;nthread&#x27;</span>: <span class="number">6</span>  <span class="comment"># cpu 线程数</span></span><br><span class="line">&#125;</span><br><span class="line">rounds = <span class="number">200</span> <span class="comment"># 迭代次数</span></span><br><span class="line">watchlist = [(xgboost_train, <span class="string">&#x27;train&#x27;</span>), (xgboost_valid, <span class="string">&#x27;valid&#x27;</span>)]</span><br><span class="line">bst = xgb.train(params, xgboost_train, rounds, watchlist,feval=evalerror)</span><br></pre></td></tr></table></figure>

<p>用模型去预测结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test 数据集上使用模型进行预测</span></span><br><span class="line">xgboost_test = xgb.DMatrix(model_test)</span><br><span class="line">y_predicted = bst.predict(xgboost_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_ip.txt 是 test 文件夹中的所有文件名</span></span><br><span class="line">ip = pd.read_table(<span class="string">&#x27;test_ip.txt&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名去掉对应的 .pcap 就是要预测的 IP</span></span><br><span class="line">ip[<span class="number">0</span>] = ip[<span class="number">0</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x.replace(<span class="string">&#x27;.pcap&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">ip_list = <span class="built_in">list</span>(ip[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先将所有客户端 IP 对应的类型标记为 white</span></span><br><span class="line">ip[<span class="number">1</span>] = [<span class="string">&#x27;white&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ip.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历预测结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_predicted)):</span><br><span class="line">    <span class="comment"># 如果第 i 条流量为 black</span></span><br><span class="line">    <span class="keyword">if</span> y_predicted[i] == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 读取第 i 条流量的源 IP</span></span><br><span class="line">        tmp_ip = <span class="built_in">list</span>(test_ip[i:i+<span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历所有要预测的客户端 IP</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ip_list)):</span><br><span class="line">            <span class="comment"># 如果是第 i 条流量（恶意）的源 IP</span></span><br><span class="line">            <span class="keyword">if</span> tmp_ip == ip_list[j]:</span><br><span class="line">            <span class="comment"># 将该客户端 IP 标记为 black</span></span><br><span class="line">                ip.loc[j,<span class="number">1</span>] = <span class="string">&#x27;black&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test 数据集恶意 IP 计数</span></span><br><span class="line">malware_ip_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ip.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">if</span> ip.loc[i,<span class="number">1</span>] == <span class="string">&#x27;black&#x27;</span>:</span><br><span class="line">        malware_ip_count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test数据集恶意ip个数&quot;</span> + <span class="built_in">str</span>(malware_ip_count) )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将最终结果写入 result.txt</span></span><br><span class="line">ip.to_csv(<span class="string">&#x27;result.txt&#x27;</span>,sep=<span class="string">&#x27;,&#x27;</span>,index=<span class="literal">False</span>,header=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h2 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h2><p>这次比赛几次提交点的最好成绩是 72.5 分，距离复赛要求的名次差几名，很遗憾无缘复赛。总结了失利的几点原因：</p>
<ol>
<li>对恶意流量的特征不熟悉，导致花了很多时间去确定需要提取哪些 Features，浪费了前面的检查点。其实我们最后提取的 Features 还有很大的提升空间，比如数据包的时间序列特征，我们只提取了均值、方差等特征，还有字节分布等重要特征未进行有效提取。<br><img data-src="5.png" alt="e67c9834b783a0c2b314e2dd35719671.png"></li>
<li>对模型的选择和参数认识不够，只是盲目的更换模型和调参，一开始发现模型和参数对结果的影响很大，实际上还是特征提取的不够好。当提取了能有效区分正常/恶意流量的特征后，模型的选择和参数对结果影响就较小了，所以最重要的依然是有效特征的提取。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Shekhawat, A. S. (2018). <em>Analysis of Encrypted Malicious Traffic.</em></li>
<li>Jenseg, O. (2019). <em>A machine learning approach to detecting malware in TLS traffic using resilient network features (Master’s thesis, NTNU).</em></li>
<li>Shekhawat, A. S., Di Troia, F., &amp; Stamp, M. (2019). <em>Feature analysis of encrypted malicious traffic. Expert Systems with Applications, 125, 130-141.</em></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@melanijan93/https-medium-com-melanijan93-analysing-pcaps-with-bro-zeek-33340e710012">Analysing PCAPs with Bro/Zeek</a></li>
<li><a target="_blank" rel="noopener" href="https://www.intechopen.com/online-first/machine-learning-applications-in-misuse-and-anomaly-detection">Machine Learning Applications in Misuse and Anomaly Detection</a></li>
<li><a target="_blank" rel="noopener" href="https://machinelearningmastery.com/imbalanced-classification-with-python/">imbalanced-classification-with-python</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/scikit-learn/scikit-learn/blob/master/doc/modules/feature_extraction.rst">scikit-learn GitHub doc: Feature extraction</a></li>
<li><a target="_blank" rel="noopener" href="https://www.secrss.com/articles/18679">基于机器学习的TLS恶意加密流量检测方案</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bonelee/p/9604530.html">利用背景流量数据（contexual flow data）识别TLS加密恶意流量</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="s1mple"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">s1mple</p>
  <div class="site-description" itemprop="description">春光恰与少年同，十里清风慕天青</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/s1mplecc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;s1mplecc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:s1mple951205@gmail.com" title="E-Mail → mailto:s1mple951205@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">s1mple</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 33231,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
