<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"s1mplecc.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="春光恰与少年同，十里清风慕天青">
<meta property="og:type" content="website">
<meta property="og:title" content="s1mple 的博客">
<meta property="og:url" content="https://s1mplecc.github.io/page/5/index.html">
<meta property="og:site_name" content="s1mple 的博客">
<meta property="og:description" content="春光恰与少年同，十里清风慕天青">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="s1mple">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://s1mplecc.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>s1mple 的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">s1mple 的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/s1mplecc" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/07/03/Git%20Flow%20%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s1mple 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/03/Git%20Flow%20%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Git Flow 模型以及工具的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-03 08:11:51" itemprop="dateCreated datePublished" datetime="2018-07-03T08:11:51+08:00">2018-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Concepts/" itemprop="url" rel="index"><span itemprop="name">Concepts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Git-Flow-是什么？"><a href="#Git-Flow-是什么？" class="headerlink" title="Git Flow 是什么？"></a>Git Flow 是什么？</h2><p>2010 年 5 月，在一篇名为 “<a target="_blank" rel="noopener" href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>” 的博文中，Vincent Driessen 介绍了一种构建在 Git 之上的软件开发模型。<strong>通过利用 Git 创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上，实现了软件开发过程不同阶段的相互隔离</strong>。这种软件开发的活动模型被 Vincent 称为 “<strong>Git Flow</strong>”。</p>
<h2 id="Git-Flow-流程图"><a href="#Git-Flow-流程图" class="headerlink" title="Git Flow 流程图"></a>Git Flow 流程图</h2><p>这是 Vincent 博文中的 Git FLow 流程图，该图从右向左，从上到下看：</p>
<p><img data-src="/0.png" alt="git-flow-model"></p>
<h2 id="Git-Flow-Branches"><a href="#Git-Flow-Branches" class="headerlink" title="Git Flow Branches"></a>Git Flow Branches</h2><p>Git Flow 的核心就是<strong>分支（Branch）</strong>，通过在项目的不同阶段对 Branch 的不同操作（包括但不限于 create、merge、rebase 等）来实现一个完整的高效率的工作流程。Git Flow Branches 主要分为两大类：<strong>Main Branches（主分支）</strong> 和 <strong>Supporting branches（辅助分支）</strong>。 其中 Main Branches 中又包含了 <strong>Master</strong> 和 <strong>Develop</strong>，而 Supporting branches 中包含了 <strong>Feature</strong>、<strong>Release</strong>、<strong>Hotfix</strong> 以及其他自定义分支。</p>
<h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><ul>
<li><p><strong>master 分支上存放的是最稳定的正式版本</strong>，并且该分支的代码应该是随时可在生产环境中使用的代码（<strong>Production Ready state</strong>）。当一个版本开发完毕后，产生了一份新的稳定的可供发布的代码时，master 分支上的代码要被更新。同时，每一次更新，都需要在 master 上打上对应的版本号（tag）。</p>
</li>
<li><p><strong>任何人不允许在 master 上进行代码的直接提交，只接受其他分支的合入</strong>。原则上 master 上的代码必须是合并自经过多轮测试且已经发布一段时间且线上稳定的 release 分支（预发分支）。</p>
</li>
</ul>
<h3 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h3><ul>
<li><p><strong>develop 分支是主开发分支，其上更新的代码始终反映着下一个发布版本需要交付的新功能</strong>。当 develop 分支到达一个稳定的点并准备好发布时，应该从该点拉取一个 release 分支并附上发布版本号。也有人称 develop 分支为 “integration branch”，因为会基于该分支和持续集成工具做自动化的 Nightly builds。</p>
</li>
<li><p>develop 分支接受其他 Supporting branches 分支的合入，最常见的就是 feature 分支，开发一个新功能时拉取新的 feature 分支，开发完成后再并入 develop 分支。需要注意的是，<strong>合入 develop 的分支必须保证功能完整，不影响 develop 分支的正常运行</strong>。</p>
</li>
</ul>
<h3 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h3><ul>
<li><p>feature 分支又叫做<strong>功能分支</strong>，一般命名为 feature/xxx，用于<strong>开发即将发布版本或未来版本的新功能或者探索新功能</strong>。该分支通常存在于开发人员的本地代码库而不要求提交到远程代码库上，除非几个人合作在同一个 feature 分支开发。关于这点，ThoughtWorks 洞见上有一篇文章 “<a target="_blank" rel="noopener" href="https://insights.thoughtworks.cn/gitflow-consider-harmful/">Gitflow 有害论</a>” 做了非常有意思的阐述，文章下的评论也异常激烈。也许该文章的名字可能有失偏颇，但文章的本意以及评论传达了一个观点：<strong>feature 分支要求足够细粒度以避免成为 long-lived branch，应当小步小步 merge 而不是一次 merge 大量代码</strong>。</p>
</li>
<li><p>feature 分支只能拉取自 develop 分支，开发完成后要么合并回 develop 分支，要么因为新功能的尝试不如人意而直接丢弃。</p>
</li>
</ul>
<h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><ul>
<li><p>release 分支又叫做<strong>预发分支</strong>，一般命名为 release/1.2（后面接版本号），<strong>该分支专为测试—发布新的版本而开辟，允许做小量级的 Bug 修复和准备发布版本的元数据信息（版本号、编译时间等）</strong>。通过创建 release 分支，使得 develop 分支得以空闲出来接受下一个版本的新的 feature 分支的合入。</p>
</li>
<li><p>release 分支需要提交到服务器上，交由 QA 进行测试，并由 Dev 修复 Bug。同时根据该分支的特性我们可以部署自动化测试以及生产环境代码的自动化更新和部署。</p>
</li>
<li><p>release 分支只能拉取自 develop 分支，合并回 develop 和 master 分支。</p>
</li>
</ul>
<h3 id="Hotfix"><a href="#Hotfix" class="headerlink" title="Hotfix"></a>Hotfix</h3><ul>
<li><p>hotfix 分支又叫<strong>热修复分支</strong>，一般命名为 hotfix/1.2.1（后面接版本号），<strong>当生产环境的代码（master 上代码）遇到了严重到必须立即修复的缺陷时，就需要从 master 分支上指定的 tag 版本（比如 1.2）拉取 hotfix 分支进行代码的紧急修复，并附上版本号（比如 1.2.1）</strong>。这样做的好处是不会打断正在进行的 develop 分支的开发工作，能够让团队中负责 feature 开发的人与负责 hotfix 的人并行、独立的开展工作。</p>
</li>
<li><p>hotfix 分支只能从 master 上拉取，测试通过后合并回 master 分支和 develop 分支。</p>
</li>
</ul>
<h2 id="Git-Flow-工具"><a href="#Git-Flow-工具" class="headerlink" title="Git Flow 工具"></a>Git Flow 工具</h2><p>一旦使用 Git Flow 模型，那么对分支的命令操作必然是频繁且重复的，所幸是有人开发了 Git Flow Script 工具帮助我们简化命令：<a target="_blank" rel="noopener" href="https://github.com/nvie/gitflow">gitflow</a>。</p>
<p>在 Mac 或 Windows 系统上安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// OS X</span><br><span class="line">brew install git-flow</span><br><span class="line"></span><br><span class="line">// Windows</span><br><span class="line">wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash</span><br></pre></td></tr></table></figure>

<p>使用<code>git flow init</code>进行初始化，会询问你分支的命名，使用默认的即可。初始化完成后自动切换到了 develop 分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(master) ✗ git flow init</span><br><span class="line">No branches exist yet. Base branches must be created now.</span><br><span class="line">Branch name for production releases: [master] </span><br><span class="line">Branch name for &quot;next release&quot; development: [develop] </span><br><span class="line"></span><br><span class="line">How to name your supporting branch prefixes?</span><br><span class="line">Feature branches? [feature/] </span><br><span class="line">Release branches? [release/] </span><br><span class="line">Hotfix branches? [hotfix/] </span><br><span class="line">Support branches? [support/] </span><br><span class="line">Version tag prefix? []</span><br><span class="line"></span><br><span class="line">➜  demo git:(develop) ✗ </span><br></pre></td></tr></table></figure>

<p>下面使用 feature 分支演示 Git Flow 功能。<code>git flow feature start my-feature</code>该命令用于新建一个 feature 分支。可以看到，基于 develop 的 feature/my-feature 分支已被创建，并且自动切换到该分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(develop) ✗ git flow feature start my-feature</span><br><span class="line">Switched to a new branch &#x27;feature/my-feature&#x27;</span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- A new branch &#x27;feature/my-feature&#x27; was created, based on &#x27;develop&#x27;</span><br><span class="line">- You are now on branch &#x27;feature/my-feature&#x27;</span><br><span class="line"></span><br><span class="line">Now, start committing on your feature. When done, use:</span><br><span class="line"></span><br><span class="line">     git flow feature finish my-feature</span><br><span class="line"></span><br><span class="line">➜  demo git:(feature/my-feature) ✗ </span><br></pre></td></tr></table></figure>
<p>在该功能分支下我创建了 a.txt 文件并 commit 到本地仓库，下面演示结束 feature 分支。<code>finish</code>命令用于将 feature/my-feature 分支合并入 develop 分支并删除该分支。此时已切换到了 develop 分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(feature/my-feature) git flow feature finish my-feature</span><br><span class="line">Switched to branch &#x27;develop&#x27;</span><br><span class="line">Updating 6c6e4cb..345a380</span><br><span class="line">Fast-forward</span><br><span class="line"> a.txt | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 a.txt</span><br><span class="line">Deleted branch feature/my-feature (was 345a380).</span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- The feature branch &#x27;feature/my-feature&#x27; was merged into &#x27;develop&#x27;</span><br><span class="line">- Feature branch &#x27;feature/my-feature&#x27; has been removed</span><br><span class="line">- You are now on branch &#x27;develop&#x27;</span><br><span class="line"></span><br><span class="line">➜  demo git:(develop) </span><br></pre></td></tr></table></figure>

<p>release 和 hotfix 的命令使用和 feature 一样。需要注意的是它们实际的操作细节会有一些区别，比如 release finish 时会打上版本号，以及合并入 master 和 develop 两个分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(release/1.2) git flow release finish 1.2 </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- Latest objects have been fetched from &#x27;origin&#x27;</span><br><span class="line">- Release branch has been merged into &#x27;master&#x27;</span><br><span class="line">- The release was tagged &#x27;1.2&#x27;</span><br><span class="line">- Release branch has been back-merged into &#x27;develop&#x27;</span><br><span class="line">- Release branch &#x27;release/1.2&#x27; has been deleted</span><br><span class="line"></span><br><span class="line">➜  demo git:(master)</span><br></pre></td></tr></table></figure>

<p>还有将分支 push 到远程代码仓库和拉取远程代码仓库分支的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(release/1.2) git flow release publish 1.2 </span><br><span class="line">➜  demo git:(release/1.2) git flow release pull 1.2 </span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Git Flow 模型通过不同的分支从源代码管理的角度对软件开发活动进行了约束，为我们的软件开发提供了一个可供参考的管理模型。Git Flow 模型让代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。但同时，不同的开发团队存在不同的文化，在不同的项目背景情况下都可能<strong>根据该模型进行适当的精简或扩充</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model —— Vincent Driessen</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5b7fe2745188253010325bf6">Git Flow流程 —— 掘金</a></li>
<li><a target="_blank" rel="noopener" href="http://deshui.wang/%E6%95%8F%E6%8D%B7/2015/10/27/sourcecode-management">敏捷实践系列(四)：代码管理流程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/36292d36e41d">Git Flow的使用 —— 简书</a></li>
<li><a target="_blank" rel="noopener" href="https://insights.thoughtworks.cn/gitflow-consider-harmful/">Git Flow有害论 —— ThoughtWorks洞见</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/06/24/%E8%BF%81%E7%A7%BB%20Ghost%20%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%BD%BF%E7%94%A8%20Docker%20%20%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s1mple 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/24/%E8%BF%81%E7%A7%BB%20Ghost%20%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%BD%BF%E7%94%A8%20Docker%20%20%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">迁移 Ghost 博客并使用 Docker  部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-24 14:30:15" itemprop="dateCreated datePublished" datetime="2018-06-24T14:30:15+08:00">2018-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ops/" itemprop="url" rel="index"><span itemprop="name">Ops</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>因为阿里云服务器在七月初即将过期，以及生活上的一些琐事，博客已经近一个月没有更新了。考虑到十月份域名也将过期，以及阿里云非学生用户太贵，遂考虑国外的云服务器 <a target="_blank" rel="noopener" href="https://www.vultr.com/">Vultr</a>，优点是绑定域名不需要备案，以及按时计费也很方便，缺点是国内访问网速确实比不上阿里云，但同时也跟同学了解到可以使用<strong>锐速</strong>进行优化，这个以后再研究。此外，为将来迁移方便，使用 <strong>Docker</strong> 重新部署 Ghost 博客并制作成镜像上传到云端。这也算我迁移博客后的第一篇文章了。</p>
</blockquote>
<h2 id="Prefaring"><a href="#Prefaring" class="headerlink" title="Prefaring"></a>Prefaring</h2><ul>
<li><p>在 Vultr 的 Servers 界面先新增一个实例，如果能抢到每月 $2.5 的服务器是最好的，然而我没有抢到，所以选择了每月 $5 的服务器，系统为 Ubuntu 16.04，机房在新加坡</p>
</li>
<li><p>在添加实例成功后第一件事是<code>ping</code>一下公网 IP 是否是通的，有些时候分配的 IP 是被大陆给墙了的。<code>ping</code>通后我习惯的首件要事就是添加我的 ssh 公钥以及修改 ssh 的一些策略，比如修改默认端口号、禁用密码登陆之类的，一切都是为安全考虑（吃了第一次的亏，一夜之间异常登陆三十次）</p>
</li>
<li><p>迁移 Ghost 博客之前需要先将原先服务器上的相关文件下载到本地，再上传到新的服务器上。主要包含文章内容，图片以及主题。所幸 Ghost 博客提供了 Export/Import 功能，而且是所有文件导出到一个大 Json 文件中，很方便迁移<br><img data-src="/0.png" alt="14070DA1-C3CD-4A9F-AE52-D4D2DE4A2CDB">主题也很方便，我之前就将代码上传至 <a target="_blank" rel="noopener" href="https://github.com/s1mplecc/ghost-theme-kaldorei">GitHub</a>，克隆下来压缩上传就行。图片稍微麻烦点，需要将 Ghost 目录下的整个<code>content/images</code>文件夹<code>scp</code>到本地，再<code>scp</code>到 Vultr 服务器上，可能要花些时间</p>
</li>
<li><p>接下来去修改你的域名设置，我是在 <a target="_blank" rel="noopener" href="https://sg.godaddy.com/zh">GoDaddy</a> 上购买的域名，所以去狗爹网修改配置如下<br><img data-src="/1.png" alt="64F8A358-E544-4FA3-819C-7F38F5327A5A"></p>
</li>
<li><p>准备工作已经做好，剩下的就是在新服务器上搭建环境和部署博客了。必要的东西也就三个，Nginx 用于做端口映射，Docker 用于运行 Ghost 容器，Certbot 用来配置 Https。Nginx 在 Ubuntu 上安装很简单，使用<code>apt-get</code>命令即可。Certbot 安装在我的另一篇博客<a target="_blank" rel="noopener" href="https://s2mple.xyz/configure-https-with-certbot/">Certbot配置Https</a>中有详细介绍。我们着重介绍一下如何安装 Docker</p>
</li>
</ul>
<h2 id="Installing-Docker"><a href="#Installing-Docker" class="headerlink" title="Installing Docker"></a>Installing Docker</h2><blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Docker官方网站</a>，选择自己的操作系统，我的是 Ubuntu 16.04</p>
</blockquote>
<ul>
<li><p>Update the apt package index, Install packages to allow apt to use a repository over HTTPS</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>
</li>
<li><p>Add Docker’s official GPG key</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
</li>
<li><p>Set up the stable repository</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Install the latest version of Docker CE</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Deploying-Ghost"><a href="#Deploying-Ghost" class="headerlink" title="Deploying Ghost"></a>Deploying Ghost</h2><ul>
<li><p>拉取 Ghost 最新的 Docker 镜像</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull ghost</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行一个容器实例，<code>-d</code>后台运行，<code>-p 2368:2368</code>绑定宿主机 2368 端口至容器内 2368 端口（必须显式的绑定，不然不会自动映射），这也是 Ghost 默认占用的端口号</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 2368:2368 ghost</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行后访问<code>&#123;IP&#125;:2368</code>可以成功进入 Ghost 主页，但是现在还有一些问题，就是点击 Home 键跳转的地址为 localhost:2368，我们需要进入到容器内部修改 Ghost 配置文件</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker exec -it 16 bash</span><br></pre></td></tr></table></figure>
<p>  上述命令表示以交互式终端执行容器的<code>bash</code>命令，其中 16 是刚才启动的容器 ID 前两位，可以使用<code>docker ps</code>查看，通常使用可以唯一标识的前几位即可</p>
</li>
<li><p>进入容器后默认在<code>/var/lib/ghost</code>即 Ghost 安装路径下，修改其下的<code>config.production.json</code>配置文件，其实该文件链接到<code>config.development.json</code>，所以修改哪一个都一样，只需要修改 url 和 server 即可</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://s2mple.xyz/&quot;</span>,</span><br><span class="line"><span class="string">&quot;server&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;port&quot;</span>: <span class="number">2368</span>,</span><br><span class="line">    <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>  退出容器后使用<code>docker restart 16</code>重启容器</p>
</li>
<li><p>主题可以在网页上直接上传。图片还需要我们拷贝到容器中，使用如下命令</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker cp images/ 16:/var/lib/ghost/content</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Nginx-amp-Https"><a href="#Nginx-amp-Https" class="headerlink" title="Nginx &amp; Https"></a>Nginx &amp; Https</h2><blockquote>
<p>至此，我们的博客已经算迁移完毕，接下来还剩下两个步骤：1. 配置 Nginx 80 端口转发到 2368 端口；2. 使用 Certbot 配置 Https。</p>
</blockquote>
<h4 id="Configuring-Nginx"><a href="#Configuring-Nginx" class="headerlink" title="Configuring Nginx"></a>Configuring Nginx</h4><ul>
<li><p>前往 <code>/etc/nginx/conf.d/</code> 目录中创建 ghost.conf 配置文件，配置如下</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;                                                                                  </span><br><span class="line">    server_name s1mple.info www.s1mple.info;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_pass http://127.0.0.1:2368;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ /.well-known &#123;</span><br><span class="line">        allow all;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    client_max_body_size 50m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  保存退出后，<code>service nginx restart</code> 重启 Nginx 服务</p>
</li>
</ul>
<h4 id="Configuring-Https"><a href="#Configuring-Https" class="headerlink" title="Configuring Https"></a>Configuring Https</h4><ul>
<li><p>使用 Certbot 工具配置 Https，如何安装运行可以参考我的另一篇博客<a target="_blank" rel="noopener" href="https://s2mple.xyz/configure-https-with-certbot/"><br>Certbot配置Https</a>。实际上它会读取 Nginx 配置文件并修改它们，可以发现，配置完成后的 ghost.conf 多了如下一些内容，其中就包括重定位到 Https 端口 443</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    # 省略...</span><br><span class="line"></span><br><span class="line">    listen [::]:443 ssl ipv6only=on; # managed by Certbot</span><br><span class="line">    listen 443 ssl; # managed by Certbot</span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/s2mple.xyz/fullchain.pem; # managed by Certbot</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/s2mple.xyz/privkey.pem; # managed by Certbot</span><br><span class="line">    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    if ($host = www.s1mple.info) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ($host = s1mple.info) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line">    listen 80; </span><br><span class="line">    listen [::]:80;</span><br><span class="line"></span><br><span class="line">    server_name s1mple.info www.s1mple.info;</span><br><span class="line">    return 404; # managed by Certbot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  大功告成！现在就可以通过 <a target="_blank" rel="noopener" href="https://s2mple.xyz/">https://s2mple.xyz/</a> 访问我的博客网站了！</p>
</li>
</ul>
<h2 id="Docker-image"><a href="#Docker-image" class="headerlink" title="Docker image"></a>Docker image</h2><blockquote>
<p>接下来我们将经过修改的容器（包含文章、图片、Kaldorei 主题、修改后的配置文件）提交为一个镜像，上传到云端。以后迁移直接<code>pull</code>下来即可。可以参考我之前的博客 <a target="_blank" rel="noopener" href="https://s2mple.xyz/build-docker-images/">构建你的Docker镜像</a></p>
</blockquote>
<ul>
<li><p>首先需要在 <a target="_blank" rel="noopener" href="https://cloud.docker.com/">Docker Cloud官网</a> 注册自己的账号，然后在服务器使用命令登陆</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker login</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">// username</span><br><span class="line">// password</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Docker Cloud 中创建一个新的仓库，命名为 myghost 。将当前容器提交为一个镜像，不加标签默认 latest</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker commit 16 s1mple1995/myghost</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看本地的 Docker 镜像，有两个，一个是原始的 ghost 镜像，一个是刚刚提交的镜像</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">s1mple1995/myghost   latest              e11def1af177        15 seconds ago      613MB</span><br><span class="line">ghost                latest              a375d6b66f06        4 weeks ago         574MB</span><br></pre></td></tr></table></figure>
</li>
<li><p>将镜像<code>push</code>到云端，等待上传完成</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker push s1mple1995/myghost</span><br></pre></td></tr></table></figure></li>
<li><p>现在镜像已经存放在 Docker Cloud 云端了，搜索你的镜像，随时随地可以<code>pull</code>下来</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker search s1mple1995</span><br><span class="line">NAME                      DESCRIPTION                    STARS               OFFICIAL            AUTOMATED</span><br><span class="line">s1mple1995/get-started    学习初步使用                         1                                       </span><br><span class="line">s1mple1995/java-web-env   Java Web程序的运行环境                0                                       </span><br><span class="line">s1mple1995/jpress         jpress blog                    0                                       </span><br><span class="line">s1mple1995/ubuntu         基于官方ubuntu镜像，更改为阿里云软件源，并安…     0                                       </span><br><span class="line">s1mple1995/myghost        我的 Ghost 镜像，包含了文章、图片和主题（ Ka…   0 </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><blockquote>
<p>总的来说，使用 Docker 部署 Ghost 的话可以方便许多。而且制作成镜像上传到云端的话，以后可以直接<code>pull</code>下来，图片、文章、主题都在镜像中了，顶多是更换域名要修改 Ghost 的配置文件。除此之外，更换域名后文章中的域名也需要全量替换，这个我打算以后要换域名的时候写个 Python 脚本来完成。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/05/24/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s1mple 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/24/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">函数式编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-24 06:47:25" itemprop="dateCreated datePublished" datetime="2018-05-24T06:47:25+08:00">2018-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Concepts/" itemprop="url" rel="index"><span itemprop="name">Concepts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>函数式编程是一种编程范式，我们常见的编程范式有<strong>命令式编程（Imperative programming）</strong>，<strong>函数式编程（Functional Programming）</strong>，常见的面向对象编程也是一种命令式编程。相比之下，函数式编程更关心<strong>数据的映射</strong>，命令式编程则关心解决问题的<strong>步骤</strong>。</p>
<p>命令式编程是面向计算机硬件的抽象，有变量（对应着存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令）。简单来说，命令式程序就是一个<strong>冯诺依曼机的指令序列</strong>。以下代码就是典型的命令式编程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sumOfPrices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; prices = Arrays.asList(<span class="number">10</span>, <span class="number">30</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">45</span>, <span class="number">12</span>);</span><br><span class="line">    Double total = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer price : prices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &gt; <span class="number">20</span>) &#123;</span><br><span class="line">            total = total + (price * <span class="number">0.9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而函数式编程是面向数学的抽象，将计算描述为一种表达式求值。函数式编程希望程序员用计算（函数）来表示程序，用<strong>计算（函数）的组合</strong>来表达程序的组合。而非函数式编程则习惯于用命令来表示程序，用命令的顺序执行来表达程序的组合。比如如下的 Scala 代码，通过<code>filter()、map()、reduce()</code>这些函数的组合，完成了从 prices 到 total 的<strong>映射关系</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object Prices &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val prices = Array(10, 30, 17, 20, 15, 18, 45, 12)</span><br><span class="line">    val total = prices.filter(x =&gt; x &gt; 20)</span><br><span class="line">      .map(x =&gt; x * 0.9)</span><br><span class="line">      .reduce((x, y) =&gt; x + y)</span><br><span class="line">    print(&quot;total is: &quot; + total)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>说到底，什么是函数式编程呢？这里借用廖雪峰老师在 <a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317848428125ae6aa24068b4c50a7e71501ab275d52000">Python函数式编程</a> 中的定义。</p>
<p>我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计，函数就是面向过程的程序设计的基本单元。而函数式编程（请注意多了一个“式”字）—— Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。</p>
<p>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。在计算机的层次上，CPU 执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如 C 语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如 Lisp 语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要<strong>输入是确定的，输出就是确定的</strong>，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>在 FP 语言中，<strong>函数作为一等公民</strong>，指的是函数与其他数据类型一样，处于同等地位。函数可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，因此可以对函数进行组合。<strong>高阶函数 (Higher-order Function)</strong> 就是指<strong>接受入参或者返回值为函数</strong>的函数。</p>
<p>用 Python 定义一个简单的高阶函数，接受一个入参函数 f 对 x, y 做操作后相加，使用时我可以使用已经定义好的绝对值函数 <code>abs</code>，或者自定义的匿名函数 <code>lambda x : x * x</code> 取平方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f_add</span>(<span class="params">x, y, f</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> f(x) + f(y)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_add(<span class="number">1</span>, -<span class="number">2</span>, <span class="built_in">abs</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_add(<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">lambda</span> x : x * x)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>有了高阶函数，就可以将复用的粒度降低到函数级别，相对于面向对象语言，复用的粒度更低。</p>
<h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p><strong>柯里化 (Currying)</strong> 是把多个参数的函数转变为只接受一个参数并返回接收剩余参数的函数的过程，这个过程持续多次直到收集到所有所需参数。在 FP 语言中函数（而不是类）被作为参数进行传递，Currying 常常用于转化一个函数的接口以便于其他代码调用。函数的接口就是它的参数，于是 Currying 通常用于减少函数参数的数量</p>
<p>在 JavaScript 中有一个实现函数式编程的库叫作 <strong>Ramda</strong> ，它有一个特性就是：所有方法都支持柯里化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> R = <span class="built_in">require</span>(<span class="string">&#x27;ramda&#x27;</span>)</span><br><span class="line"></span><br><span class="line">R.add(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// R.add(1, 2) =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increment = R.add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> addTen = R.add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">increment(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line">addTen(<span class="number">2</span>) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>这也归功于在 FP 语言中高阶函数的特性，我们来看看<code>add()</code>的实现，返回的是函数，所以不难理解如何实现 <code>increment()</code> 和 <code>addTen()</code> 对 <code>add()</code> 的复用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const add = function(x) &#123;</span><br><span class="line">  return function(y) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const increment = add(1)</span><br><span class="line">const addTen = add(10)</span><br></pre></td></tr></table></figure>
<p>熟悉 JavaScript 的同学可能使用过 Lodash 类库，Ramda 和 Lodash 最大的区别就是<strong>两者的参数位置不同</strong>，在 Ramda 中数据一律放在最后一个参数，理念是： <strong>Function first，Data last</strong> 。而不管是 Lodash 还是 Underscore 都将处理的数据作为第一个参数。事实证明，Ramda 设计更加合理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> R = <span class="built_in">require</span>(<span class="string">&#x27;ramda&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prices = [<span class="number">10</span>, <span class="number">30</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">45</span>, <span class="number">12</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = R.pipe(</span><br><span class="line">  R.filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">20</span>),</span><br><span class="line">  R.map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">0.9</span>),</span><br><span class="line">  R.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">total(prices) <span class="comment">// 67.5</span></span><br><span class="line">totalPrice = _.chain(prices)</span><br><span class="line">  .filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">20</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">0.9</span>)</span><br><span class="line">  .reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)</span><br><span class="line">  .value() <span class="comment">// 67.5</span></span><br></pre></td></tr></table></figure>
<p>显然，将数据放在最后，再利用 Currying 的特性，我们将对 prices 的一系列操作封装成<code>total()</code>函数，要比 Lodash 更具复用性。这种风格也叫做 <strong>Pointfree：不使用所要处理的值，只合成运算过程</strong>。</p>
<h2 id="λ演算"><a href="#λ演算" class="headerlink" title="λ演算"></a>λ演算</h2><p><strong>λ演算 (lambda calculus)<strong>是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。它由数学家阿隆佐·邱奇在20世纪30年代首次发表。Lambda 演算可比拟是最根本的编程语言，它包括了一条变换规则（变量替换）和一条将函数抽象化定义的方式。因此普遍公认是一种</strong>更接近软件而非硬件的方式</strong>。Lambda 演算对函数式编程语言造成很大影响，比如 Lisp、ML 语言和 Haskell 语言。Lambda 演算作为一种广泛用途的计算模型，可以清晰地定义什么是一个可计算函数，而任何可计算函数都能以这种形式表达和求值。Lambda 演算和图灵机已经被证明了是具有同样能力的系统，因此指令式编程能做到的函数式编程也同样可以做到。</p>
<p>编程中提到的 Lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指<strong>匿名函数</strong>，比如 Python 中的<code>lambda</code>关键字，JavaScript 和 Scala 中的箭头函数 <code>=&gt;</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices = [<span class="number">10</span>, <span class="number">30</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">45</span>, <span class="number">12</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(<span class="keyword">lambda</span> x, y : x + y, <span class="built_in">map</span>(<span class="keyword">lambda</span> x : x * <span class="number">0.9</span>, <span class="built_in">filter</span>(<span class="keyword">lambda</span> x : x &gt; <span class="number">20</span>, prices)))</span><br><span class="line"><span class="number">67.5</span></span><br></pre></td></tr></table></figure>

<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>纯函数式编程语言中的变量也不是命令式编程语言中的变量，即存储状态的单元，而是代数中的变量，即一个值的名称。变量的值是<strong>不可变的 (immutable)</strong> ，也就是说不允许像命令式编程语言中那样多次给一个变量赋值。比如说在命令式编程语言我们写<code>x = x + 1</code>，这依赖可变状态的事实，拿给程序员看说是对的，但拿给数学家看，却被认为这个等式为假。<strong>严格意义上的函数式编程意味着不使用可变的变量，赋值，循环和其他命令式控制结构进行编程</strong>。就好比 Java 中所有变量都是<code>final</code>的</p>
<p>事实上函数式程序是可以保存状态的，只不过它们用的不是变量，而是函数。状态保存在函数的参数中，也就是说在栈上。如果你需要保存一个状态一段时间并且时不时的修改它，那么你可以编写一个递归函数。举个例子，试着用 Java 写一个函数用来反转字符串。记住咯，这个程序里的变量都是默认为<code>final</code>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">reverse</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverse(arg.substring(<span class="number">1</span>, arg.length())) + arg.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从理论上说，函数式语言也不是通过冯诺伊曼体系结构的机器上运行的，而是通过λ演算来运行的，就是通过变量替换的方式进行，变量替换为其值或表达式，函数也替换为其表达式，并根据运算符进行计算。λ演算是<strong>图灵完全 (Turing completeness)</strong> 的，但是大多数情况，函数式程序还是被编译成冯诺依曼机的机器语言的指令执行的。</p>
<p>函数式编程的最主要的好处主要是不可变性带来的。没有可变的状态，函数就是<strong>引用透明 (Referential Transparency)</strong> 的和**无副作用 (No Side Effect)**。</p>
<h3 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h3><p>引用透明指的是函数的运行不依赖于外部变量或状态，<strong>值只依赖输入的参数</strong>，任何时候<strong>只要参数相同，引用函数所得的返回值总是相同的</strong>。这样在并发编程中就避免了有外部变量被其它线程调用后导致返回的结果不是期望值，在函数式编程中，纯函数构成的程序是不需要加线程锁的。</p>
<h3 id="无副作用"><a href="#无副作用" class="headerlink" title="无副作用"></a>无副作用</h3><p>所谓<strong>副作用</strong>，指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。在其他类型的语言中，变量往往用来保存<strong>状态 (state)</strong> 。不修改变量，意味着状态不能保存在变量中。<strong>函数式编程使用参数保存状态</strong>，最好的例子就是递归。因为 FP 语言不包含任何赋值语句，变量值一旦被指派就永远不会改变。而且，调用函数只会计算出结果 ── 不会出现其他效果。因此，FP 语言没有副作用。</p>
<h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><p>由于函数是引用透明的，以及函数式编程不像命令式编程那样关注执行步骤，这个系统提供了优化函数式程序的空间，包括<strong>惰性求值 (Lazy evaluation)</strong> 和并性处理。惰性求值的目的是要最小化计算机要做的工作。在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。除可以得到性能的提升外，惰性求值还可以以简单的方式表示无限的概念，这种方式有利于程序的模块化。</p>
<p>比如我们用 Python 的生成器去生成无穷的一个自然数序列，控制台将会一直打印除非你手动中断。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">natural_nums</span>():</span></span><br><span class="line"><span class="meta">... </span>     n = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>         <span class="keyword">yield</span> n</span><br><span class="line"><span class="meta">... </span>         n = n + <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>natural_nums()</span><br><span class="line">&lt;generator <span class="built_in">object</span> f1 at <span class="number">0x1033ed468</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> natural_nums():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>命令式编程主要关心的是 how to do，也就是怎么做，告诉机器每一步的实现过程。而函数式编程主要关心的是 what to do，也就是实体与实体之间的对应关系（<strong>映射</strong>）。函数式编程是给软件开发者提供的另一套工具箱，为我们提供了另外一种抽象和思考的方式。如果你对函数式编程的起源感兴趣，强烈推荐阅读 <a target="_blank" rel="noopener" href="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn/blob/master/FunctionalProgrammingForTheRestOfUs.cn.md">Functional Programming For The Rest of Us</a> 这篇文章，写的很幽默风趣。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn/blob/master/FunctionalProgrammingForTheRestOfUs.cn.md">Functional Programming For The Rest of Us</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28292740/answer/40336090">什么是函数式编程思维 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">JS 函数式编程指南 - GitBook</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97">λ演算 - WiKi百科</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/05/10/Clean%20Code%20--%20%E7%AC%AC%E4%B8%89%E8%8A%82%EF%BC%9APartDB%20%E6%A1%88%E4%BE%8B%E4%B8%8E%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s1mple 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/10/Clean%20Code%20--%20%E7%AC%AC%E4%B8%89%E8%8A%82%EF%BC%9APartDB%20%E6%A1%88%E4%BE%8B%E4%B8%8E%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Clean Code -- 第三节：PartDB 案例与模版方法模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-10 01:24:34" itemprop="dateCreated datePublished" datetime="2018-05-10T01:24:34+08:00">2018-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index"><span itemprop="name">Coding</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该系列源于<a target="_blank" rel="noopener" href="http://zhangyi.xyz/">张逸总监</a>的 Clean Code 培训，包涵了如何写出高质量代码的思想、代码案例以及重构代码的实际演练。<a target="_blank" rel="noopener" href="https://s2mple.xyz/2018/05/07/Clean%20Code%20--%20%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%8A%A5%E8%A1%A8%E5%8F%82%E6%95%B0%E5%A1%AB%E5%85%85%E6%A1%88%E4%BE%8B/">上一篇</a>我们通过报表参数填充案例复习了迪米特法则（最小知识法则）、信息专家模式：数据和行为应该封装在一起。本篇我们将通过 PartDB 案例来见识 IDEA 中 <strong>Extract Superclass</strong> 等强大的重构功能，以及与案例相关的设计模式：<strong>模版方法模式</strong>。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><strong>IntelliJ IDEA</strong>，相比 Eclipse，IDEA 在重构方面十分优秀，结合快捷键，使用起来让人赏心悦目。</li>
<li><strong>示例代码</strong>地址 <a target="_blank" rel="noopener" href="https://github.com/agiledon/cleancode.git">https://github.com/agiledon/cleancode.git</a> ，进行实际操作有助于加深理解和记住快捷键。代码有两个分支，master 分支为重构前的代码，<strong>after-refactoring</strong> 分支为重构后代码，可以使用快捷键 <code>Cmd + D</code> 查看<strong>代码差异</strong>。</li>
<li><strong>活用快捷键</strong>，本人使用的 IDEA 快捷键为 Mac OS X 10.5+ 。Windows 用户将 <code>Cmd</code> 替换成 <code>Ctrl</code>，或者在 IDEA 的 <strong>Refactor</strong> 菜单中查看快捷键。</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + T</td>
<td>重构菜单</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>重命名方法、属性、文件</td>
</tr>
<tr>
<td>Cmd + Alt + M</td>
<td>提取方法（extract method）</td>
</tr>
<tr>
<td>Cmd + Alt + N</td>
<td>内联（Inline），与 extract 相反</td>
</tr>
<tr>
<td>Cmd + Shift + 上下箭头</td>
<td>上下移动声明体（statement）</td>
</tr>
</tbody></table>
<h2 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h2><p>我们定义好了一个汽车零件类 Part，现在要通过 PartDB 去访问数据库执行<code>select * from part</code>，并将返回结果填充成一个 PartList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartDB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER_CLASS = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_SELECT_PARTS = <span class="string">&quot;select * from part&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Part&gt; partList = <span class="keyword">new</span> ArrayList&lt;Part&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(DRIVER_CLASS);</span><br><span class="line">            c = DriverManager.getConnection(DB_URL, USER, PASSWORD);</span><br><span class="line">            Statement stmt = c.createStatement();</span><br><span class="line">            ResultSet rs = stmt.executeQuery(SQL_SELECT_PARTS);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                Part p = <span class="keyword">new</span> Part();</span><br><span class="line">                p.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                p.setBrand(rs.getString(<span class="string">&quot;brand&quot;</span>));</span><br><span class="line">                p.setRetailPrice(rs.getDouble(<span class="string">&quot;retail_price&quot;</span>));</span><br><span class="line">                partList.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            c.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码大概是每一个 Java 程序员都会接触到的：使用 JDBC 访问数据库。加载驱动、创立连接、执行 SQL 返回结果集并且填充到 Java 类中。显然，如果每一步都需要我们手动编写，那若是新增了一个类，比如 CustomerDB 是不是还要去 getConnection 等等，这必然会造成许多<strong>冗余代码</strong>。而现在许多的持久层框架，例如 MyBatis、Hibernate 都是基于 JDBC 进行再封装，避免了重复繁琐的工作。下面我们看看如何重构上述代码。</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>首先一段整洁易读的代码应该层次分明，如果没想到重构，我们可能会使用注释和换行将代码分段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get connection</span></span><br><span class="line">Class.forName(DRIVER_CLASS);</span><br><span class="line">c = DriverManager.getConnection(DB_URL, USER, PASSWORD);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get result set</span></span><br><span class="line">Statement stmt = c.createStatement();</span><br><span class="line">ResultSet rs = stmt.executeQuery(SQL_SELECT_PARTS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// populate parts entity</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，在学会重构之后，我们要习惯使用方法名产生注释的效果，<strong>注释不是越多越好，而要少而精，不必要的注释就不要</strong>。使用 <strong>提取方法（Cmd + Alt + M）</strong> 重构代码，并使用 <strong>Cmd + Shift + ⬆️/ ⬇️</strong> 移动方法顺序。</p>
<p><img data-src="/0.png" alt="25C7F4CD-951E-4B05-8A98-5A0433520EDA"></p>
<p>注意我这里将<code>c</code>重命名（<strong>Shift + F6</strong>）为<code>connection</code>，<strong>命名要遵循在表达清楚业务含义的同时尽可能的短</strong>，<code>rs</code>、<code>err</code>甚至<code>e</code>这种因为频繁使用，基本上可以望文生义，所以可采用业界统一认可的缩写。但<code>c</code>这种命名，一旦代码量增多后，就可能带来阅读上的困扰，应当避免。顺便说一下，应该使用<code>populateParts()</code>而不是<code>populatePartList()</code>这种命名，因为<strong>命名应该站在功能层面，不应该暴露技术实现</strong>，万一哪一天，你改成 Set 了呢？</p>
<p>我们来观察提取出的三个方法。<code>getConnection()</code>创建数据库连接，在抽象层面与业务无关的，实现层面我们暂不考虑用户自定义情况（实际上应该由配置文件读入），所以实现层面也与业务无关。<code>getResultSet()</code>执行 SQL 获取结果集，在抽象层面与业务无关。实现层面上由于<code>SQL_SELECT_PARTS</code>所以与业务强耦合。我们可以使用 <strong>Cmd + Alt + N</strong> ，将<code>select * from part</code> SQL 语句<strong>内联</strong>，再提取<code>getSql()</code>方法（<strong>Cmd + Alt + M</strong>）。</p>
<p><img data-src="/1.png" alt="953ECD52-3430-4BFD-A662-24E78BCAF755"></p>
<p>如此一来，<code>getResultSet()</code>在实现层面也与业务无关了。而<code>getSql()</code>方法在抽象层面与业务无关，在实现层面就与业务有关了。<code>populateParts()</code>这个名字容易让人产生误解，我们将其重命名为<code>populateEntities()</code>，这样，它在抽象层面也与业务无关，而在实现层面与业务有关。为什么我一再强调<strong>抽象层面</strong>和<strong>实现层面</strong>与<strong>业务</strong>的关系，就是为了让方法变得纯粹。这也是软件设计中一种重要的设计思维：<strong>关注点分离</strong>，目的是将<strong>解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过侧面来封装、维护，这样原本分散在在整个应用程序中的变动就可以很好的管理起来</strong>。比方有一个函数叫做<code>CreateNewCustomer()</code>，那么该函数只与客户的数据（属性）打交道，而给新客户自动发优惠券的动作就不能放到这个函数里面。</p>
<p>现在，我们所有的方法都在抽象层面与业务无关，只有<code>getSql()</code>和<code>populateEntities()</code>在实现层面与业务有关。至此，我们拨开重重迷雾，冰山的一角轰然显现！既然大家都在抽象层面与业务无关，我们就应该<strong>抽象出更高阶的抽象类</strong>，这里就用到了 <strong>Extract Superclass</strong> 这个神奇的重构手法。</p>
<p>使用 <strong>Ctrl + T</strong> 调出重构菜单，输入 super 就可以看到 Extract Superclass 的提示，敲击回车<br><img data-src="/2.png" alt="F0675E41-8516-4FC3-96BB-928AB1060D40">注意需要勾选组成父类的成员，这里除了最后一个<code>partList</code>是业务独有的，其他全勾选上，而<code>getSql()</code>和<code>populateEntities()</code>方法因为具体实现与业务相关，就应该是子类去重写，所以应当勾选上 Make abstract。</p>
<p><strong>重构后的 JdbcTemplate 类</strong>：</p>
<p><img data-src="/3.png" alt="68B462DA-CB1F-41FD-A519-6576CF7BD2FE"></p>
<p><strong>重构后的 PartDB 类</strong>：</p>
<p><img data-src="/4.png" alt="CC64100D-FC25-4825-85DD-83AECC318E86"></p>
<p>为什么我在提取父类时直接将父类命名为 JdbcTemplate，大家应该不难想到，我们重构完成的抽象父类，就是一个最简化的 JdbcTemplate。许多框架亦是如此诞生的，使用者使用时让自己的业务实体类去继承这个模版类，重写业务相关方法。这也是软件设计模式中非常著名的<strong>模版方法模式</strong>。</p>
<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><p>模板方法模式说白了就是：<strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</strong>。代表具体逻辑步骤的方法称做**基本方法(primitive method)<strong>；而将基本方法汇总穿成一条线的方法叫做</strong>模板方法(template method)**，这个设计模式的名字也是由此而来。 </p>
<p>在上述的抽象类 JdbcTemplate 中，我们的模版方法就应该是<code>populate()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection = getConnection();</span><br><span class="line">        ResultSet rs = getResultSet(connection);</span><br><span class="line">        populateEntities(rs);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于写信的模版，类似“尊敬的xxx”、“此致，敬礼”这种千篇一律的套话我们可以定义一个模版，而需要差异化书写的只是信的内容。在<code>populate()</code>中，骨架已经搭好：先创建数据库连接，再执行 SQL 返回结果集，最后填充实体类。所以这里能看出，<strong>模版方法展现了框架的生命周期</strong>。为防止恶意操作，一般模板方法都会加上<code>final</code>关键字，不允许用户重写模版方法。</p>
<p>基本方法又可以分为三种：抽象方法、具体方法和钩子方法：</p>
<ul>
<li>**抽象方法(Abstract Method)**：一个抽象方法由抽象类声明，由具体子类实现。在 Java 语言里抽象方法以<code>abstract</code>关键字标识。</li>
<li>**具体方法(Concrete Method)**：一个具体方法由抽象类声明并实现，而子类并不实现或置换。可以添加<code>final</code>关键字做强约束不可重写，比如<code>getResultSet()</code></li>
<li><strong>钩子方法(Hook Method)<strong>：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个</strong>空实现</strong>，作为方法的默认实现。譬如有些框架的<code>init()</code>方法，用户可以实现也可以不实现，定义成<code>abstract</code>就不合适，所以框架会给个空方法</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我在工作当中也使用过 MongoTemplate、RedisTemplate 诸如此类，还从未仔细想过这些类为什么这样命名。直到这次张总通过 IDEA 强大的 <strong>Extract Superclass</strong> 重构手法，给我们展示一个 JdbcTemplate 如何浮出水面的过程，实在是醍醐灌顶，豁然开朗。有兴趣的同学可以看看这些框架的源代码，加深对模版方法模式的理解。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.runoob.com/design-pattern/template-pattern.html">模版方法模式</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html">《JAVA与模式》之模板方法模式</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Separation_of_concerns#Internet_protocol_stack">Separation of concerns - Wiki</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/asis/p/architecture-Soc.html">架构漫谈系列之关注点分离</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/05/07/Clean%20Code%20--%20%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%8A%A5%E8%A1%A8%E5%8F%82%E6%95%B0%E5%A1%AB%E5%85%85%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s1mple 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/07/Clean%20Code%20--%20%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%8A%A5%E8%A1%A8%E5%8F%82%E6%95%B0%E5%A1%AB%E5%85%85%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">Clean Code -- 第二节：报表参数填充案例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-07 13:39:03" itemprop="dateCreated datePublished" datetime="2018-05-07T13:39:03+08:00">2018-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index"><span itemprop="name">Coding</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该系列源于<a target="_blank" rel="noopener" href="http://zhangyi.xyz/">张逸总监</a>的 <strong>Clean Code</strong> 培训，包涵了如何写出高质量代码的思想、代码案例以及重构代码的实际演练。<a target="_blank" rel="noopener" href="https://s2mple.xyz/2018/05/04/Clean%20Code%20--%20%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E4%B8%8E%20Paperboy%20%E6%A1%88%E4%BE%8B/">上一篇</a>我们介绍了迪米特法则（最小知识法则）、信息专家模式：数据和行为应该封装在一起，并且通过 Paperboy 案例实操在 IntelliJ IDEA 中如何重构代码。本篇我们将通过报表参数填充案例来加深理解，并见识 IDEA 中更为强大的重构功能。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><strong>IntelliJ IDEA</strong>，相比 Eclipse，IDEA 在重构方面十分优秀，结合快捷键，使用起来让人赏心悦目。</li>
<li><strong>示例代码</strong>地址 <a target="_blank" rel="noopener" href="https://github.com/agiledon/cleancode.git">https://github.com/agiledon/cleancode.git</a> ，进行实际操作有助于加深理解和记住快捷键。代码有两个分支，master 分支为重构前的代码，<strong>after-refactoring</strong> 分支为重构后代码，可以使用快捷键 <code>Cmd + D</code> 查看<strong>代码差异</strong>。</li>
<li><strong>活用快捷键</strong>，本人使用的 IDEA 快捷键为 Mac OS X 10.5+ 。Windows 用户将 <code>Cmd</code> 替换成 <code>Ctrl</code>，或者在 IDEA 的 <strong>Refactor</strong> 菜单中查看快捷键。</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + T</td>
<td>重构菜单</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>重命名方法、属性、文件</td>
</tr>
<tr>
<td>Cmd + Alt + M</td>
<td>提取方法（extract method）</td>
</tr>
<tr>
<td>Cmd + Alt + N</td>
<td>内联（Inline），与 extract 相反</td>
</tr>
<tr>
<td>Cmd + Shift + 上下箭头</td>
<td>上下移动声明体（statement）</td>
</tr>
</tbody></table>
<h2 id="案例：报表系统之参数处理"><a href="#案例：报表系统之参数处理" class="headerlink" title="案例：报表系统之参数处理"></a>案例：报表系统之参数处理</h2><p>在示例项目中，需要对客户发出的 Web 请求进行处理，获得需要的参数。参数的值放在 Request 中，实现根据配置文件获得了参数的类型信息。根据项目需求，将参数划分为三种：</p>
<ul>
<li>单一参数（SimpleParameter）</li>
<li>元素项参数（ItemParameter）</li>
<li>表参数（TableParameter）</li>
</ul>
<p>因为参数的属性是在配置文件中已经配好，所以定义了 ParameterGraph 对象。它能够读取参数的配置信息，并根据参数的类型创建不同的参数类，这些参数类共同实现了 Parameter 接口。</p>
<p>最初的实现代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterCollector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillParameters</span><span class="params">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (para <span class="keyword">instanceof</span> SimpleParameter) &#123;</span><br><span class="line">                SimpleParameter simplePara = (SimpleParameter) para;</span><br><span class="line">                String[] values = request.getParameterValues(simplePara.getName());</span><br><span class="line">                simplePara.setValue(values);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (para <span class="keyword">instanceof</span> ItemParameter) &#123;</span><br><span class="line">                    ItemParameter itemPara = (ItemParameter) para;</span><br><span class="line">                    <span class="keyword">for</span> (Item item : itemPara.getItems()) &#123;</span><br><span class="line">                        String[] values = request.getParameterValues(item.getName());</span><br><span class="line">                        item.setValues(values);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    TableParameter tablePara = (TableParameter) para;</span><br><span class="line">                    String[] rows =</span><br><span class="line">                            request.getParameterValues(tablePara.getRowName());</span><br><span class="line">                    String[] columns =</span><br><span class="line">                            request.getParameterValues(tablePara.getColumnName());</span><br><span class="line">                    String[] dataCells =</span><br><span class="line">                            request.getParameterValues(tablePara.getDataCellName());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> columnSize = columns.length;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns.length; j++) &#123;</span><br><span class="line">                            TableParameterElement element = <span class="keyword">new</span> TableParameterElement();</span><br><span class="line">                            element.setRow(rows[i]);</span><br><span class="line">                            element.setColumn(columns[j]);</span><br><span class="line">                            element.setDataCell(dataCells[columnSize * i + j]);</span><br><span class="line">                            tablePara.addElement(element);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察代码，<code>if statement</code>中的三段代码块其实做的都是<strong>填充参数</strong>的事，只不过用<code>instanceof</code>判断了参数类型再执行对应的填充操作。结合之前的 Paperboy 案例，与 Wallet 打交道的应该是 Customer 而不是 Paperboy。上述代码明显也违反了迪米特法则，<strong>参数填充的行为应该交由参数类完成而不是 ParameterCollector</strong>。</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>基于代码重用的思想，先将三段代码 <strong>提取方法（Cmd + Alt + M）</strong>，并分别取名为<code>fillSimplePara()</code>、<code>fillItemPara()</code>、<code>fillTablePara()</code>，重构后的方法顺序可能有所差异，可以在方法签名上使用 <strong>Cmd + Shift + ⬆️/ ⬇️</strong> 快捷键移动方法顺序，使之符合正常的阅读习惯。</p>
<p><img data-src="/0.png" alt="A6C5B629-ACC6-458A-8379-852021771E83"></p>
<p>提取了方法后，这一幕是不是似曾相识？之前的 Paperboy 案例中，我们从<code>charge()</code>方法中提取了<code>pay()</code>方法，意识到<code>pay()</code>方法应该归属于 Customer 而不是 Paperboy。这里就要再次强调：<strong>数据和行为应该封装在一起</strong>。显然，ParameterCollector 这个类不应该关注如何填充参数，而是应该收到<code>fillParameters()</code>请求后<strong>委派</strong>给各个 Parameter 类完成填充操作。所以我们采取“<strong>Move Method</strong>”重构手法（<strong>F6</strong>）。</p>
<p><img data-src="/1.png" alt="17C89C7E-DA4F-4914-AA2A-5F6C8DE8845E"></p>
<p>注意，IDEA 通过入参智能提示可以将方法移动到两个类中，显然应该选择 SimpleParameter，同时，方法的访问权限应为 public。接下来分别将<code>fillItemPara()</code>和<code>fillTablePara()</code>方法移动至 ItemParameter 和 TableParameter 中。</p>
<p><img data-src="/2.png" alt="8FB216EF-394B-42F3-B556-6EC576224FE7"></p>
<p>观察上图你会发现，原先的方法有两个参数，但由于我们移动了方法到对应的 Parameter 类中，第二个参数直接变成了用<code>this</code>引用当前对象。<code>ItemParameter itemPara = this;</code>这一步是多余的，直接使用<strong>内联（Cmd + Alt + N</strong>）消除。然后呢，别着急，我们想一想，既然 SimpleParameter、ItemParameter、TableParameter 三个类都有接收一个 request 参数的填充方法，而且他们都实现了 Parameter 接口，那我们为什么不将方法提到接口中，让其他三个类去重写呢？所以接下来先把方法都重命名为<code>fill()</code>，使用 <strong>Shift + F6</strong>进行重命名。</p>
<p><img data-src="/3.png" alt="74F483BA-13C8-4769-9E94-290369E2B41B-1"></p>
<p>接着，不要傻乎乎的去 Parameter 接口中手写<code>fill()</code>抽象方法，还是有快捷键的！那就是 “<strong>Pull Members Up</strong>”重构手法，说真的，当时看张总演示我就震惊了！选中方法，使用 <strong>Ctrl + T</strong> 调出重构菜单，输入一个 pull 你就能看到提示了。<br><img data-src="/4.png" alt="C477A0C4-7E53-4C85-BE02-4A37697680B5"></p>
<p>IDEA 会提示你将<code>pull()</code>方法提升至 Parameter 接口中并 make abstract。<br><img data-src="/5.png" alt="9E0BC21E-0DFB-47AF-8B9E-C99900755E7F"></p>
<p>我们看看重构后的效果，甚至于 ItemParameter 的<code>fill()</code>方法还已经帮你添加了<code>@Override</code>注解，但是剩下的两个 Parameter 类中的<code>fill()</code>方法还需要你手动的添加注解。</p>
<p><img data-src="/6.png" alt="0007121B-DCAA-4629-B1EB-911959D12455"> <img data-src="/7.png" alt="FE508CEB-BABF-4D6F-830E-A6C126BCD693"></p>
<p>最后我们回到 ParameterCollector 类，使用 IDEA 的<strong>智能辅助</strong>快捷键（<strong>Alt + Enter</strong>）去 Cleanup code 删除多余的类型转换。</p>
<p><img data-src="/8.png" alt="5A6909D5-21DC-45BB-B3F0-02ECE946EC10"></p>
<p>然后，你就会发现，<code>if statement</code>也是多余的，删除后，<strong>Cmd + Alt + L</strong> 格式化代码。</p>
<p><img data-src="/9.png" alt="91715C62-8438-4C16-BE77-0C821007877A"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如此，重构过的代码，可谓是层次清晰、一目了然，可比原来一坨堆在 ParameterCollector 中要美观多了。在重构的过程中，我们意识到，<strong>填充参数的行为应该交由它的专家，即各个 Parameter 类管理</strong>，移动方法后，又意识到既然都实现了 Parameter 接口，就应当使用 Java 接口的特性将<code>fill()</code>提升到 Parameter 接口中成为一个抽象方法。至此，<code>if</code>语句和<code>instanceof</code>也都不需要了，交由 JVM 在运行时识别类类型即可。所以说，<strong>重构的过程还可以帮助程序员梳理编码过程，进行合理的抽象和封装</strong>。当然，没有实践的空想理论是不行的，牢记 IDEA 的快捷键，将重构养成习惯，不时来一波亮瞎狗眼的骚操作，岂不美滋滋？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/05/04/Clean%20Code%20--%20%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E4%B8%8E%20Paperboy%20%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s1mple 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/04/Clean%20Code%20--%20%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E4%B8%8E%20Paperboy%20%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">Clean Code -- 第一节：迪米特法则与 Paperboy 案例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-04 05:36:05" itemprop="dateCreated datePublished" datetime="2018-05-04T05:36:05+08:00">2018-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index"><span itemprop="name">Coding</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该系列源于<a target="_blank" rel="noopener" href="http://zhangyi.xyz/">张逸总监</a>的 Clean Code 培训，包涵了如何写出高质量代码的思想、代码案例以及重构代码的实际演练。本篇为该系列的第一篇，主要介绍<strong>迪米特法则</strong>和<strong>信息专家模式</strong>，并结合案例实操在 IntelliJ IDEA 中如何重构代码。本文大部分内容转载自张总博客: <a target="_blank" rel="noopener" href="http://zhangyi.xyz/demeter-law-and-refactoring/#more">迪米特法则与重构</a>。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><strong>IntelliJ IDEA</strong>，相比 Eclipse，IDEA 在重构方面十分优秀，结合快捷键，使用起来让人赏心悦目。</li>
<li><strong>示例代码</strong>地址 <a target="_blank" rel="noopener" href="https://github.com/agiledon/cleancode.git">https://github.com/agiledon/cleancode.git</a> ，进行实际操作有助于加深理解和记住快捷键。代码有两个分支，master 分支为重构前的代码，<strong>after-refactoring</strong> 分支为重构后代码，可以使用快捷键 <code>Cmd + D</code> 查看<strong>代码差异</strong>。</li>
<li><strong>活用快捷键</strong>，本人使用的 IDEA 快捷键为 Mac OS X 10.5+ 。Windows 用户将 <code>Cmd</code> 替换成 <code>Ctrl</code>，或者在 IDEA 的 <strong>Refactor</strong> 菜单中查看快捷键。</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + T</td>
<td>重构菜单</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>重命名方法、属性、文件</td>
</tr>
<tr>
<td>Cmd + Alt + M</td>
<td>提取方法（extract method）</td>
</tr>
<tr>
<td>Cmd + Alt + N</td>
<td>内联（Inline），与 extract 相反</td>
</tr>
<tr>
<td>Cmd + Shift + 上下箭头</td>
<td>上下移动声明体（statement）</td>
</tr>
</tbody></table>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>在面向对象设计的世界里，有一个寻常却又常常为人所忽略的原则——<strong>迪米特法则（Law of Demeter）</strong>。这个原则认为，任何一个对象或者方法，它应该只能调用下列对象：    </p>
<ul>
<li>该对象本身</li>
<li>作为参数传进来的对象（也可以是该对象的字段）</li>
<li>在方法内创建的对象</li>
</ul>
<p>这个原则用以指导正确的<strong>对象协作</strong>，分清楚哪些对象应该产生协作，哪些对象则对于该对象而言，又应该是无知的。</p>
<h2 id="代码案例及分析"><a href="#代码案例及分析" class="headerlink" title="代码案例及分析"></a>代码案例及分析</h2><p>如何理解这个原则？我们可以看看 David Bock 就该原则给出的一个<a target="_blank" rel="noopener" href="https://www2.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/paper-boy/demeter.pdf">绝佳案例</a>。假设一个超市购物的场景，顾客（Customer）到收银台结账，收银员（Paperboy）负责收钱。我们来看看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Wallet myWallet;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wallet <span class="title">getWallet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myWallet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wallet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTotalMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalMoney</span><span class="params">(<span class="keyword">float</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">float</span> deposit)</span> </span>&#123;</span><br><span class="line">        value += deposit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subtractMoney</span><span class="params">(<span class="keyword">float</span> debit)</span> </span>&#123;</span><br><span class="line">        value -= debit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Paperboy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(Customer myCustomer, <span class="keyword">float</span> payment)</span> </span>&#123;</span><br><span class="line">        Wallet theWallet = myCustomer.getWallet();</span><br><span class="line">        <span class="keyword">if</span> (theWallet.getTotalMoney() &gt; payment) &#123;</span><br><span class="line">            theWallet.subtractMoney(payment);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//money not enough</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们将 Paperboy 中<code>charge()</code>方法的代码翻译成这幕小话剧的对白。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“把钱包交出来!”收银员算出顾客要买的商品总价后，“温柔”地对顾客说道。</span><br><span class="line">顾客言听计从，赶紧将钱包掏出来，恭恭敬敬地递给收银员。</span><br><span class="line">接过钱包，收银员毫不客气地打开，检查里面的钱够不够。噢，不错，钱够了。收银员从钱包取出钱，心满意足地笑了。</span><br></pre></td></tr></table></figure>
<p>如果你是顾客，你敢去这样的超市 shopping 吗？</p>
<p>对于 Paperboy 而言，Wallet 不满足迪米特法则三个条件中的任何一个，因此，<strong>不应该让 Paperboy 与 Wallet 对象进行直接交互</strong>。若从<strong>拟人化</strong>的角度思考，则 Wallet 其实属于 Customer 的<strong>隐私</strong>。如此重要的隐私，怎么能直接交给收银员这个陌生人呢？这里所谓的“隐私”，可以视为是“数据”，是“信息”，是“知识”，因此我们往往又将迪米特法则称之为“<strong>最小知识法则</strong>”。</p>
<p>当我们理解“最小知识法则”时，又可以从<strong>职责</strong>的角度去思考以上代码。对于收银员角色，他的职责应该是负责收钱，而不用去管钱包里的钱够不够，如果够了怎么办，如果不够又该怎么办，这些统统都不属于他的职责。设想一下，当超市里人流如织，大家都在购买商品时，如果每一个收银员都要承担这般的职责时，会出现什么样的景象？所以“最小知识法则”乃善法，在对象社区中，我们就应该刻意减少对象之间彼此深入的了解。了解最小的知识，就意味着依赖最小，彼此产生的影响就会最小。这实际上是 <strong>KISS（keep it simple and stupid）</strong> 原则的体现。</p>
<p><strong>信息专家模式</strong>告诉我们：“信息的持有者即为操作该信息的专家”。对于对象，所谓<strong>信息就是该对象内部的字段</strong>。在上述的例子中，Wallet 是 Customer 的字段，那么操作 Wallet 的行为自然就应该分配给 Customer 了。这是题中应有之义。“信息专家模式”其实是面向对象最重要原则“<strong>数据与行为应该封装在一起</strong>”的别名。若在领域建模时能遵循该原则，则可以规避我们设计出贫血模型。</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>如何修改以上代码？注意，<code>charge()</code>行为仍然属于 Paperboy 的职责，因此我们不应该将该方法整体搬迁到 Customer 中，而应该先进行<strong>方法的提取</strong>，选中代码块，使用 <strong>Cmd + Alt + M</strong> 快捷键提取方法。这块代码执行的是支付的步骤，所以命名为<code>pay()</code>。</p>
<p><img data-src="/0.png" alt="781D2706-3961-4C77-ACF8-8BDDCE21B17E"></p>
<p>提取后的<code>charge()</code>在接收方法请求后，转而将请求<strong>委派</strong>给了<code>pay()</code>方法。我们可以这样理解：在抽象层面，收款是收银员的职责；在实现层面，是<code>pay()</code>方法支持了收款行为，该实现归属于顾客。</p>
<p><img data-src="/1.png" alt="1AF2B42F-7B13-4284-AF03-9C1D5C5FE0A1"></p>
<p>观察<code>pay()</code>方法，我们发现该方法操作的数据皆来自 Customer。我们嗅到了一种坏味道，即 Martin Fowler 所谓的“<strong>特性依恋（Feature Envy）</strong>”。对于该坏味道，老马是这样阐释的：“函数对某个类的兴趣高过对自己所处类的兴趣”。不要再嫉妒了，桥归桥，路归路，让方法回到自己最喜欢的地方吧。运用“<strong>Move Method</strong>”重构手法，将<code>pay()</code>方法移动到 Customer 中。</p>
<p>光标在方法签名或方法体中都可，按下 <strong>F6</strong>，IDEA 会根据方法的入参，智能的提示将方法移动到哪个类中，这里只能是 Customer。还要注意方法的访问权限，默认是 Escalate 往上提升一级，这里选择 Public。</p>
<p><img data-src="/2.png" alt="2C6EA6D7-A330-4E90-8B2A-54223072A47A"></p>
<p>操作之后，<code>pay()</code>方法移动到 Customer 中。</p>
<p><img data-src="/3.png" alt="F92C14F0-6693-4154-8A6D-F71AB14BF0E2"></p>
<p>在将方法移到正确的位置后，我们发现暴露的<code>getWallet()</code>方法根本就没有意义。更何况，将钱包裸露出去，难道是想要炫富吗？还是低调一点为好，隐藏自己的“隐私”，总好过被人觊觎而招来飞来横祸之险。于是，<strong>内联（inline）</strong> 之。将光标放在<code>getWallet()</code>上，按下 <strong>Cmd + Alt + N</strong>。</p>
<p><img data-src="/4.png" alt="563C9626-A71E-4DC7-A8DC-BA4DA530EF64"></p>
<p><code>getWallet()</code>方法被删除，并被替换为 Customer 的字段<code>myWallet</code>。那现在声明的<code>theWallet</code>就是多余的，继续内联。<br><img data-src="/5.png" alt="28E463A5-F36A-4250-8611-36BDACF80FCE"></p>
<p>最后，重构过的代码应该是这样的。阅读代码一目了然，Paperboy 进行收银，并委派给顾客进行实际的支付，即掏钱包，数钱，付钱。<br><img data-src="/6.png" alt="3CA41F80-0556-42F3-8E16-5AEEC39332A3"><img data-src="/7.png" alt="E66E7919-9391-4046-8CB4-C46555E561A8"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>判断一段代码是否违背了迪米特法则，有一个小窍门，就是看调用代码是否出现形如<code>a.m1().m2().m3().m4()</code>之类的代码。这种代码在 Martin Fowler《重构》一书中，被名为“**消息链条(Message Chain)**”，有人更加夸张地名其为“火车残骸”。车祸现场啊，真是惨不忍睹。</p>
<p>实际上未重构前的代码即是一种消息链条，在<code>charge()</code>方法中实际执行的是<code>myCustomer.getWallet().subtractMoney(payment)</code>，先获取 Customer 的 Wallet，再执行 Wallet 的扣钱方法。</p>
<p>那么，如下代码是否这样的残骸呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str.split(<span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .map(str -&gt; str.contains(elementName) ? str.replace(elementName + <span class="string">&quot;=&quot;</span>, <span class="string">&quot;&quot;</span>) : <span class="string">&quot;&quot;</span>)</span><br><span class="line">    .filter(str -&gt; !str.isEmpty())</span><br><span class="line">    .reduce(<span class="string">&quot;&quot;</span>, (a, b) -&gt; a + <span class="string">&quot;,&quot;</span> + b);</span><br></pre></td></tr></table></figure>

<p>答案是：不是。这样的代码我们一般称之为“流畅接口或连贯接口（Fluent Interface）”。二者的区别在于<strong>观察形成链条的每个方法返回的是别的对象，还是对象自身。如果返回的是别的对象，就是消息链条</strong>。所谓<code>m1().m2().m3().m4()</code>的调用，其实是调用者不需要也不想知道的“知识”，把这些中间过程的细节暴露出来没有意义，调用者关心的是最终结果；而上述代码中的<code>map()</code>与<code>filter()</code>等方法其实返回的还是 Stream 类。这一调用方式其初衷并非告知中间过程的细节，而是一种声明式的 DSL 表达，调用者可以自由地组合它们。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://zhangyi.xyz/demeter-law-and-refactoring/#more">迪米特法则与重构 – 张逸</a></li>
<li><a target="_blank" rel="noopener" href="https://www2.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/paper-boy/demeter.pdf">The Paperboy, The Wallet, and The Law Of Demeter –  David Bock</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/04/27/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s1mple 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/27/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95/" class="post-title-link" itemprop="url">JavaScript 异步编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-27 02:47:39" itemprop="dateCreated datePublished" datetime="2018-04-27T02:47:39+08:00">2018-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你可能知道，JavaScript 语言的执行环境是<strong>单线程（single thread）</strong>。这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。为了解决这个问题，JavaScript 语言将任务的执行模式分成两种：同步（Synchronous）和 异步（Asynchronous）。</p>
<ul>
<li><strong>同步模式</strong>：后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；</li>
<li><strong>异步模式</strong>则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</li>
</ul>
<p>异步模式非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是 Ajax 操作。在服务器端，Node.js 的异步 I/O 则保证了同一时间可以响应大量的 Http 请求。</p>
<p>本文主要介绍 JavaScript 的异步编程发展：从回调函数到 ES6 的 Promise 对象，再到 ES7 的 async/await 关键字。示例代码已上传至<a target="_blank" rel="noopener" href="https://github.com/s1mplecc/js-asynchronous-programming">GitHub</a>。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调（Callback）函数是异步编程最基本的方法。回调就好比你送女朋友到车站，并让她回家了给你回条短信。回调函数在完成任务后就会被调用，Node.js 就使用了大量的回调函数</p>
<ul>
<li>看看下面的示例代码，你要求女朋友回到家后发一条短信告诉你，然后她在回家的路上愉快的耍起了手机，哈哈哈</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goHome</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    callback()</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am playing a mobile phone&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I have just arrived home.&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goHome(sendMessage)</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// I am playing a mobile phone.</span></span><br><span class="line"><span class="comment">// I have just arrived home.    // after 2000ms</span></span><br></pre></td></tr></table></figure>
<p>注意打印结果的顺序。先打印的是<code>I am playing a mobile phone</code>，而后过了 2s 打印<code>I have just arrived home</code>。这是因为使用了<code>setTimeout()</code>这个函数，表示延时 2000ms 后执行回调函数。</p>
<p>在这个示例中，回调函数即是<code>sendMessage()</code>，回家这个动作是比较耗时的，所以我们使用了<strong>异步</strong>的方式，使得<strong>玩手机的行为不受到阻塞</strong>。是吧，玩手机不一定要回家才能完，路上也能玩嘛。回调使得同步操作变成了异步操作，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。</p>
<p>回调函数的优点是简单、容易理解，缺点是不利于代码的阅读和维护，各个部分之间<strong>高度耦合</strong>，流程会很混乱，而且每个任务只能指定一个回调函数。在 Node.js 的开发中，由于逻辑分层所致，会出现多层回调，易于引发异常处理混乱、闭包过于复杂、代码难以维护等问题。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件，更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。所谓 Promise，简单说就是一个<strong>容器</strong>，里面<strong>保存着某个未来才会结束的事件（通常是一个异步操作）的结果</strong>。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise 对象有以下两个特点：</p>
<ul>
<li><p>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：<strong>Pending</strong>（进行中）、<strong>Resolved</strong>（已成功，又称 Fulfilled）和 <strong>Rejected</strong>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。</p>
</li>
<li><p><strong>一旦状态改变，就不会再变</strong>，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就<strong>凝固</strong>了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
</li>
</ul>
<p>来看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> goHome = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;I have just arrived home.&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am playing a mobile phone.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goHome.then(sendMessage)</span><br></pre></td></tr></table></figure>

<p>这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，<code>goHome.then(sendMessage)</code>显然更符合人的思维方式。</p>
<p>我们可以在<code>Promise</code>中<code>reject</code>错误，在用<code>catch</code>去捕捉，你可能在 axios 发送异步请求的时候见过这种写法。<code>catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> num = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">10</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;num&#x27;</span>, num)</span><br><span class="line">  num % <span class="number">2</span> === <span class="number">0</span> ? resolve(<span class="string">`<span class="subst">$&#123;num&#125;</span> is an even number`</span>) : reject(<span class="string">`<span class="subst">$&#123;num&#125;</span> is not an even number`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">isEven</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// num 6</span></span><br><span class="line"><span class="comment">// 6 is an even number</span></span><br><span class="line"><span class="comment">// num 7</span></span><br><span class="line"><span class="comment">// 7 is not an even number</span></span><br></pre></td></tr></table></figure>
<p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。更多请参考<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/promise">阮老师的教程</a>。</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>最后来看一下异步编程的<strong>终极解决方案</strong>:<code>async/await</code>。<code>async</code>作为 ES7 的一大特性，已经在 Node.js 的框架——<a target="_blank" rel="noopener" href="https://koa.bootcss.com/">Koa2</a> 中被广泛使用。<code>async</code>函数是什么？一句话，<strong>async 函数就是 Generator 函数的语法糖</strong>。<code>async</code>用于申明一个<code>function</code>是异步的，而 <code>await</code>用于等待一个异步函数执行完成。</p>
<p>使用时需要注意：<strong>async 函数返回一个 Promise 对象</strong>；<code>await</code>只能在<code>async</code>内部使用，类似于<code>async function</code>内部的<code>then</code>命令的语法糖。</p>
<p><code>await</code>是个运算符，用于组成表达式，<code>await</code>如果在等待一个 Promise 对象，就会阻塞后面的代码，等着 Promise 对象<code>resolve</code>，然后将得到<code>resolve</code>的值作为 <code>await</code> 表达式的运算结果。</p>
<p>用<code>async/await</code>改写后的代码如下，看起来就像同步代码那样直观：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> goHome = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;I have just arrived home.&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am playing a mobile phone.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> msg = <span class="keyword">await</span> goHome</span><br><span class="line">  <span class="built_in">console</span>.log(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendMessage().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Play together.&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// I am playing a mobile phone.</span></span><br><span class="line"><span class="comment">// I have just arrived home.    // after 2000ms</span></span><br><span class="line"><span class="comment">// Play together.</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从最早的回调函数，到 Promise 对象，再到 Generator 函数，每次都有所改进，但又让人觉得不彻底。<strong>异步编程的语法目标，就是怎样让它更像同步编程</strong>， async 函数就是隧道尽头的亮光，很多人认为它是异步操作的终极解决方案。实际使用起来也更顺手、更容易理解，它必然会被普及，我们应该习惯这种用法。事实上 Koa2 也正是由于此而比拥有复杂的回调嵌套的 Express 更脱颖而出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html">Javascript异步编程的4种方法 - 阮一峰</a></li>
<li><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/promise">Promise 对象 - 阮一峰ES6教程</a></li>
<li><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/async">async 函数 - 阮一峰ES6教程</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007535316">理解 JavaScript 的 async/await</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/04/13/Spring%20Cloud%E9%9B%86%E6%88%90GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E8%AE%A4%E8%AF%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s1mple 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/13/Spring%20Cloud%E9%9B%86%E6%88%90GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E8%AE%A4%E8%AF%81/" class="post-title-link" itemprop="url">Spring Cloud 集成 GitHub 第三方认证</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-13 07:23:14" itemprop="dateCreated datePublished" datetime="2018-04-13T07:23:14+08:00">2018-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index"><span itemprop="name">Coding</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>最近遇到需要在 Spring Cloud 框架中加入<strong>用户认证</strong>的功能，发现 GitHub 有第三方认证功能，遂先写了个 demo 实现通过 GitHub 三方认证完成用户认证，虽然不是最终解决方案，但是有助于理解用户认证的流程</p>
</blockquote>
<ul>
<li><p>代码沿用之前的 <a target="_blank" rel="noopener" href="https://s2mple.xyz/sidecar/">Sidecar – 将Node应用引入Spring Cloud</a> 博客中的代码，用到以下模块</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">─ sidecar-example</span><br><span class="line">   ├── author-service    // 需要认证才能访问的微服务</span><br><span class="line">   ├── eureka-server    // 注册中心</span><br><span class="line">   └── api-gateway    // 网关，一切访问的入口</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>主要修改的是<code>api-gateway</code>，实现效果就是：<strong>用户通过<code>api-gateway</code>访问任何一个微服务，需要先跳转到 GitHub 进行认证，认证通过后才获取访问权限</strong></p>
</blockquote>
<h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><p>在这之前，有一些概念需要先了解</p>
<h3 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h3><blockquote>
<p><strong>SSO</strong>(or <strong>Single Sign On</strong>) <strong>单点登录</strong>，是目前比较流行的企业业务整合的解决方案之一。SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。非常适用于微服务架构，可以实现<strong>在一个微服务应用登录后（通常有专门的认证服务器），即可访问该微服务集群中的所有其他微服务</strong>。</p>
</blockquote>
<h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><blockquote>
<p>大家平时肯定遇到过第三方登录的情况，不知道有没有仔细想过它的流程。假设现在我们用微博账号登录简书</p>
</blockquote>
<ul>
<li><p>最传统的办法是让用户直接在简书的登录页面输微博的账号和密码，简书通过用户的账号和密码去微博那里获取用户数据，但这样做有很多严重的缺点：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">简书需要保存用户的微博账号和密码，这样很不安全。</span><br><span class="line">简书拥有了获取用户在微博所有的权限，包括删除好友、给好友发私信、更改密码、注销账号等危险操作。</span><br><span class="line">用户只有修改微博密码，才能收回赋予简书的权限。但是这样做会使得其他所有通过微博登录的第三方应用程序全部失效。</span><br><span class="line">只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有使用微博登录的网站的数据泄漏。</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了解决以上的问题，OAuth 协议应运而生。我们来看一下它的流程</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简书问新浪微博：我想要获取用户 A 的头像和昵称，请你提供</span><br><span class="line">微博说：我需要经过用户Ａ 本人的许可 =&gt; 然后微博询问用户 A 是否要授权简书访问自己的头像和昵称</span><br><span class="line">用户授权后，微博对简书说：我给你一个临时钥匙（Token），你访问我带了这把钥匙，我就把用户的资料给你</span><br></pre></td></tr></table></figure></li>
<li><p>以上流程可由下图表示<br><img data-src="/0.jpg" alt="291523855245_.pic"></p>
</li>
<li><p>其中最关键的两个部分如下</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">② 用户同意授权给客户端，则认证服务器返回 Code，即授权码</span><br><span class="line">③ 客户端带着 Code，去认证服务器申领 Token</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><blockquote>
<p>以上模式称为授权码模式 (<strong>authorization code</strong>) ，是目前功能最完整、流程最严密的客户端授权模式。它的特点就是通过客户端服务器，与”服务提供商”的认证服务器进行互动</p>
</blockquote>
<ul>
<li><p>步骤如下</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户访问客户端，后者将前者导向认证服务器。</span><br><span class="line">认证服务器询问用户是否给予客户端授权。</span><br><span class="line">若用户给予授权，认证服务器将用户导向客户端事先指定的&quot;重定向URI&quot;（redirection URI），同时附上一个授权码。</span><br><span class="line">客户端收到授权码，附上早先的&quot;重定向URI&quot;，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</span><br><span class="line">认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</span><br></pre></td></tr></table></figure>
<p>  <img data-src="/1.png" alt="bg2014051204"></p>
</li>
</ul>
<h2 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h2><blockquote>
<p>接下来进入正题，如何基于 GitHub 进行第三方认证。首先，我们需要先前往 GitHub 注册一个新的 OAuth App</p>
</blockquote>
<ul>
<li><p>前往<code>https://github.com/settings/developers</code>点击<code>Register a new application</code>，出现如下界面，填写相应信息。注意，主页和回调的 URL 填写的都是<code>api-gateway</code>的地址<br><img data-src="/2.png" alt="B2241479-07A7-4E03-BB62-BCA4CDA5A4A3"></p>
</li>
<li><p>注册成功后生成的<code>Client ID</code>和<code>Client Secret</code>是后续需要填写到配置文件中<br><img data-src="/3.png" alt="C65DDEFD-F282-4F12-A211-938767ECD7DA"></p>
</li>
</ul>
<h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><blockquote>
<p>接下来就是编码<code>api-gateway</code>实现重定位到刚注册的 OAuth App 进行认证</p>
</blockquote>
<ul>
<li><p>添加 Maven 依赖</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在主类上添加<code>@EnableOAuth2Sso</code>注解</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableOAuth2Sso</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了测试过滤情况，我加入了<code>/</code>和<code>/test</code>接口，除此之外，还有<code>/user</code>接口返回 GitHub 个人信息的接口</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;welcome&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">user</span><span class="params">(Principal user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>application.yml</code></p>
  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5555</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:9090/eureka/</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">author-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/author-service/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">author-service</span></span><br><span class="line">    <span class="attr">book-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/book-service/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">node-sidecar</span></span><br><span class="line"></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">ignored:</span> <span class="string">/,/test</span>  <span class="comment"># 认证忽略的接口</span></span><br><span class="line">  <span class="attr">sessions:</span> <span class="string">never</span>   <span class="comment"># session 策略</span></span><br><span class="line">  <span class="attr">oauth2:</span></span><br><span class="line">    <span class="attr">sso:</span></span><br><span class="line">      <span class="attr">loginPath:</span> <span class="string">/login</span>   <span class="comment"># 登录路径</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">      <span class="attr">clientId:</span> <span class="string">554906e366f7861eab21</span></span><br><span class="line">      <span class="attr">clientSecret:</span> <span class="string">e1286e1ac17599c7a8638bb24649e79f5aabddfd</span></span><br><span class="line">      <span class="attr">userAuthorizationUri:</span> <span class="string">https://github.com/login/oauth/authorize</span>   <span class="comment"># 进行用户授权的路径</span></span><br><span class="line">      <span class="attr">accessTokenUri:</span> <span class="string">https://github.com/login/oauth/access_token</span>   <span class="comment"># 获取 token 的路径</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">userInfoUri:</span> <span class="string">https://api.github.com/user</span></span><br><span class="line">      <span class="attr">preferTokenInfo:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><blockquote>
<p>现在就可以进行测试了。陆续启动<code>eureka-server</code>、<code>api-gateway</code>、<code>author-service</code>三个微服务</p>
</blockquote>
<ul>
<li><p>访问<code>localhost:5555/</code>和<code>localhost:5555/test</code>接口，发现均不需要认证，即<code>security.ignored: /,/test</code>配置生效<br><img data-src="/4.png" alt="1C21C2B8-E689-4BBC-94EE-4ED74796994C"></p>
</li>
<li><p>接下来通过网关访问<code>author-service</code>的接口，正常需要通过 GitHub 认证，事实证明确实如此。访问<code>http://localhost:5555/author-service/author/1</code>接口，跳转到<strong>用户授权</strong>界面<br><img data-src="/5.png" alt="D2FCA844-1A95-4907-A350-68A21ACCE38C"></p>
</li>
<li><p>确认授权后重定位到<code>/author-service/author/1</code>接口返回数据<br><img data-src="/6.png" alt="ED7EE656-F376-408D-9DB8-2C6908799A07-1"></p>
</li>
<li><p>还可以访问<code>http://localhost:5555/user</code>来获取 GitHub 账号的信息，这个就不贴图了，自己测试即可</p>
</li>
<li><p>再回到 GitHub 的 OAuth 界面，发现<code>0 user</code>变成<code>1 user</code>了，在此你可以弃用所有的用户 Token 以及重置 Client Secret 密钥<br><img data-src="/7.png" alt="7E65EF94-3B65-4FE3-B814-29C6B8A54ECF"> </p>
</li>
</ul>
<h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote>
<p>以下分析主要是为了看清重定位、URL 的参数和<code>application.yml</code>中的配置有何关联</p>
</blockquote>
<ul>
<li><p>访问<code>http://localhost:5555/author-service/author/1</code>后，重定位到<code>http://localhost:5555/login</code><br><img data-src="/8.png" alt="D33AA927-F963-41C7-BE5F-6AA7C4FF09AF"></p>
</li>
<li><p>访问<code>http://localhost:5555/login</code>重定位<code>https://github.com/login/oauth/authorize</code>即 GitHub 的用户授权路径<br><img data-src="/9.png" alt="E652C938-12A3-4A56-9367-0D07D76B1B66"></p>
</li>
<li><p><code>/login/oauth/authorize</code>这个界面才是用户看到的需要点击授权的页面，我们来看下 URL 携带的参数：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_id: 554906e366f7861eab21</span><br><span class="line">redirect_uri: http://localhost:5555/login</span><br><span class="line">response_type: code</span><br><span class="line">state: z2MaR7</span><br></pre></td></tr></table></figure></li>
<li><p>用户点击确认授权后，注意此 Token 非彼 Token<br><img data-src="/10.png" alt="71F69537-2DE4-49BD-AC22-774211576934"></p>
</li>
<li><p>接下来带着 code 和 state 访问<code>http://localhost:5555/login</code>再重定位到<code>http://localhost:5555/author-service/author/1</code>真正想访问的接口<br><img data-src="/11.png" alt="05DAA887-01B1-42F4-9C20-0820777E7D92"></p>
</li>
</ul>
<blockquote>
<p>事实上，由于申领 Token 这一步是在客户端的后台服务器上完成的，所以对用户不可见。其实客户端在用户点击授权后向<code>https://github.com/login/oauth/access_token</code>发送了一个 POST 请求，并带上<code>client_id</code>、<code>client_secret</code>、上一步获取的<code>code</code>以及<code>redirect_uri</code>等参数，由此来获取<code>access_token</code></p>
</blockquote>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-security/">Spring Cloud Security - 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.github.com/apps/building-oauth-apps/authorization-options-for-oauth-apps/">Authorization options for OAuth Apps</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解 OAuth 2.0 - 阮一峰</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0db71eb445c8">OAuth 认证流程详解</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000011098539">Spring Cloud Security 集成 CAS 对微服务认证</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/04/04/ESLint%20--%20%E4%BB%A3%E7%A0%81%E8%A7%84%E7%BA%A6%E6%8F%92%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s1mple 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/04/ESLint%20--%20%E4%BB%A3%E7%A0%81%E8%A7%84%E7%BA%A6%E6%8F%92%E4%BB%B6/" class="post-title-link" itemprop="url">ESLint —— JavaScript代码规约插件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-04 02:47:12" itemprop="dateCreated datePublished" datetime="2018-04-04T02:47:12+08:00">2018-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ESLint 是一款 JavaScript 的代码规约插件，可以自定义规则，不符合规则的代码可以设置不同级别的报错。方便对于团队内成员的代码质量进行统一管理。之前在 Vue 项目中使用<code>vue-cli</code>时可以自动添加 ESLint 代码规约插件，所以也没去管怎么手动添加 ESLint。但是最近在<code>Koa2</code>项目中，需要手动的去添加并配置 ESLint。本文将介绍如何安装以及配置 ESLint 的规则。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在项目目录下使用<code>npm</code>命令安装 ESLint，并且是开发时依赖需要加上<code>--save-dev</code>。不推荐全局安装，这样可以实现项目规则的<strong>自定义化</strong>以及团队成员的<strong>统一化</strong>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint</span><br></pre></td></tr></table></figure>

<p>初始化，会询问一些问题用于设置 ESLint，比如回答使用 Airbnb 的风格，不同的风格会有一些预定义的规则。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ ./node_modules/.bin/eslint --init</span><br><span class="line"></span><br><span class="line">? How would you like to configure ESLint? Use a popular style guide</span><br><span class="line">? Which style guide <span class="keyword">do</span> you want to follow? Airbnb</span><br><span class="line">? Do you use React? No</span><br><span class="line">? What format <span class="keyword">do</span> you want your config file to be <span class="keyword">in</span>? JavaScript</span><br></pre></td></tr></table></figure>

<p>完成后会在项目目录下生成<code>.eslintrc.js</code>文件，除此之外还可以手动添加<code>.eslintignore</code>，作用和<code>.gitignore</code>一样用于 Eslint 忽略检查的文件。</p>
<p>接着需要在 WebStorm 中启用 Eslint，勾选<code>Enable</code>。</p>
<p><img data-src="/0.png" alt="E9C4D048-BFC5-4D13-A4E8-30CD61BEE953"></p>
<p>现在代码检测已经启动了，比如规则中定义了句尾不加分号，如果加了分号就会报错。</p>
<p><img data-src="/1.png" alt="8EAC31A2-7E35-4016-9D0F-0FB7AD8057A6"></p>
<h2 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h2><p>配置自定义规则，以下是我的规则。参考官方文档 <a target="_blank" rel="noopener" href="https://eslint.org/docs/rules/">Rules</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  extends: &#x27;airbnb-base&#x27;,</span><br><span class="line">  // add your custom rules here</span><br><span class="line">  rules: &#123;</span><br><span class="line">    // allow debugger during development</span><br><span class="line">    &#x27;no-debugger&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;off&#x27;,</span><br><span class="line">    // allow console during development</span><br><span class="line">    &#x27;no-console&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;off&#x27;,</span><br><span class="line">    // allow unused variables during development</span><br><span class="line">    &#x27;no-unused-vars&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;warn&#x27;,</span><br><span class="line">    // disallow trailing commas</span><br><span class="line">    &#x27;comma-dangle&#x27;: [&#x27;error&#x27;, &#x27;never&#x27;],</span><br><span class="line">    // disallow trailing semi</span><br><span class="line">    &#x27;semi&#x27;: [&#x27;error&#x27;, &#x27;never&#x27;],</span><br><span class="line">    // allow the unary operators ++ and --</span><br><span class="line">    &#x27;no-plusplus&#x27;: &#x27;off&#x27;,</span><br><span class="line">    // enforce a maximum line length</span><br><span class="line">    &#x27;max-len&#x27;: [0, 150]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在<code>package.json</code>中添加命令脚本。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;eslint --ext .js .&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以使用<code>npm run lint</code>运行 Eslint 检查程序，结果列出了问题文件所在路径、警告的级别及问题原因。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">➜ npm run lint</span><br><span class="line"></span><br><span class="line">&gt; airbi-metadata@0.1.0 lint /Users/s1mple/Desktop/airbi-metadata</span><br><span class="line">&gt; eslint --ext .js .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /Users/s1mple/Desktop/airbi-metadata/app.js</span><br><span class="line">       3:22  error  Extra semicolon                                                 semi</span><br><span class="line">      22:31  error  Use path.join() or path.resolve() instead of + to create paths  no-path-concat</span><br><span class="line">      22:31  error  Unexpected string concatenation                                 prefer-template</span><br><span class="line">      24:15  error  Use path.join() or path.resolve() instead of + to create paths  no-path-concat</span><br><span class="line">      24:15  error  Unexpected string concatenation                                 prefer-template</span><br><span class="line">    </span><br><span class="line">    /Users/s1mple/Desktop/airbi-metadata/routes/index.js</span><br><span class="line">       3:29  warning  &#x27;next&#x27; is defined but never used  no-unused-vars</span><br><span class="line">       9:35  warning  &#x27;next&#x27; is defined but never used  no-unused-vars</span><br><span class="line">      13:33  warning  &#x27;next&#x27; is defined but never used  no-unused-vars</span><br><span class="line">    </span><br><span class="line">    /Users/s1mple/Desktop/airbi-metadata/routes/users.js</span><br><span class="line">      5:17  error    Unexpected function expression    prefer-arrow-callback</span><br><span class="line">      5:32  warning  &#x27;next&#x27; is defined but never used  no-unused-vars</span><br><span class="line">      9:20  error    Unexpected function expression    prefer-arrow-callback</span><br><span class="line">      9:35  warning  &#x27;next&#x27; is defined but never used  no-unused-vars</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cn.eslint.org/docs/user-guide/getting-started">ESLint 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://eslint.org/docs/rules/">ESLint Rules</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2018/03/31/Sidecar%20--%20%E5%B0%86Node%E5%BA%94%E7%94%A8%E5%BC%95%E5%85%A5Spring%20Cloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s1mple 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/31/Sidecar%20--%20%E5%B0%86Node%E5%BA%94%E7%94%A8%E5%BC%95%E5%85%A5Spring%20Cloud/" class="post-title-link" itemprop="url">Sidecar -- 将 Node 应用引入 Spring Cloud</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-31 02:05:08" itemprop="dateCreated datePublished" datetime="2018-03-31T02:05:08+08:00">2018-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index"><span itemprop="name">Coding</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>Sidecar 起源于 <a target="_blank" rel="noopener" href="https://github.com/Netflix/Prana">Netflix Prana</a>，它的目的是将 <strong>Non-JVM</strong> 语言整合到 Netflix OSS 生态系统中，如今 Spring Cloud 将 Spring Boot 与 Netflix OSS 整合成一套微服务解决框架，大大简化了程序员的开发。而 Sidecar 就是其中的一个衍生物，用于将 Non-JVM 语言，譬如 Node.js、Python 引入至 Spring Cloud 框架中。</p>
</blockquote>
<ul>
<li><p>本文的示例代码已上传至 <a target="_blank" rel="noopener" href="https://github.com/s1mplecc/sidecar-example">Github</a></p>
</li>
<li><p>使用 Maven 构建的多模块项目<code>sidecar-example</code>，并将 Node.js 开发的<code>book-service</code>模块拷贝至一个项目中</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 模块结构如下</span><br><span class="line">─ sidecar-example</span><br><span class="line">   ├── author-service   // Java 开发的微服务，用于测试服务间通信</span><br><span class="line">   ├── eureka-server    // 注册中心</span><br><span class="line">   ├── node-sidecar    // Sidecar，用于将 Node 应用引入 Spring Cloud</span><br><span class="line">   └── book-service    // Node.js 开发的微服务</span><br></pre></td></tr></table></figure></li>
<li><p>使用的 Spring Boot 版本及 Spring Cloud 全家桶版本</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Sidecar"><a href="#Sidecar" class="headerlink" title="Sidecar"></a>Sidecar</h2><blockquote>
<p>先来看看引入 Sidecar 需要做些什么</p>
</blockquote>
<ul>
<li><p><strong>添加 Maven 依赖</strong>，很简单，甚至于不需要<code>eureka-client</code>的依赖，因为它已经整合至 Sidecar 的依赖中</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-sidecar<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来是<strong>注解</strong>，在 Sidecar 主类上添加<code>@EnableSidecar</code>注解，我们来看看这个注解包含些什么</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(SidecarConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableSidecar &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  包含了<strong>网关 Zuul</strong> 以及微服务结构中不可或缺的<strong>熔断器 Hystrix</strong></p>
</li>
<li><p>最后是<strong>配置文件</strong>，在<code>application.yml</code>中添加如下配置</p>
  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9091</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">node-sidecar</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:9090/eureka/</span></span><br><span class="line"><span class="attr">sidecar:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">  <span class="attr">health-uri:</span> <span class="string">http://localhost:$&#123;sidecar.port&#125;/health</span></span><br></pre></td></tr></table></figure>
<p>  声明服务名和注册中心地址都没什么问题，最核心的就是 sidecar 的几个配置，包括</p>
<ul>
<li><code>sidecar.port</code> 监听的 Node 应用的端口号，</li>
<li><code>sidecar.health-uri</code> Node 应用的健康检查接口的 uri</li>
</ul>
</li>
</ul>
<h4 id="健康检查接口"><a href="#健康检查接口" class="headerlink" title="健康检查接口"></a>健康检查接口</h4><blockquote>
<p>Node.js 的微服务应用<code>book-service</code>我采用的 <strong>Koa</strong> 框架，这里不多赘述，需要注意的是：该应用必须实现一个<code>/health</code>健康检查接口，Sidecar 应用会每隔几秒访问一次该接口，并将该服务的健康状态返回给 Eureka</p>
</blockquote>
<ul>
<li><p>只需要返回<code>&#123; status: &#39;UP&#39; &#125;</code>这样一串 Json 即可</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&#x27;koa&#x27;)</span><br><span class="line">const router = require(&#x27;koa-router&#x27;)()</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line"></span><br><span class="line">// log request URL:</span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`)</span><br><span class="line">  await next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// add routes:</span><br><span class="line">router.get(&#x27;/health&#x27;, async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.response.body = &#123;</span><br><span class="line">    status: &#x27;UP&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// add router middleware:</span><br><span class="line">app.use(router.routes())</span><br><span class="line"></span><br><span class="line">app.listen(3000)</span><br><span class="line">console.log(&#x27;app started at port 3000...&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><blockquote>
<p>到目前为止，Sidecar 和 Node 服务已准备就绪，我们按顺序启动 <strong>eureka-server</strong> =&gt; <strong>book-service</strong> =&gt; <strong>node-sidecar</strong></p>
</blockquote>
<ul>
<li><p>访问 Eureka 的 WebUI <code>http://localhost:9090/</code>，Sidecar 已被注册到 Eureka 上，并且状态为 UP<br><img data-src="/0.png" alt="B89413D5-130D-4F5D-BB76-7559B6B0A036">如果我们停掉<code>book-service</code>，则<code>node-sidecar</code>的服务状态会变为 Down，显示服务不可用</p>
</li>
<li><p>访问 Sidecar 的首页<code>http://localhost:9091/</code>，提供了三个接口<br><img data-src="/1.png" alt="A2B5DA24-46A6-40B9-9129-54EC7FA0F329"></p>
</li>
<li><p>访问<code>/health</code>可以得到 Node 应用返回的健康报告</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  访问<code>hosts/node-sidecar</code>可以的到 Sidecar 实例的一些信息</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;port&quot;</span>: <span class="number">3000</span>,</span><br><span class="line">        <span class="attr">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">&quot;instanceInfo&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;instanceId&quot;</span>: <span class="string">&quot;192.168.1.8:node-sidecar:9091&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;app&quot;</span>: <span class="string">&quot;NODE-SIDECAR&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;appGroupName&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;ipAddr&quot;</span>: <span class="string">&quot;192.168.1.8&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;sid&quot;</span>: <span class="string">&quot;na&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;homePageUrl&quot;</span>: <span class="string">&quot;http://localhost:3000/&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;statusPageUrl&quot;</span>: <span class="string">&quot;http://localhost:9091/info&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;healthCheckUrl&quot;</span>: <span class="string">&quot;http://localhost:9091/health&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;secureHealthCheckUrl&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;vipAddress&quot;</span>: <span class="string">&quot;node-sidecar&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;secureVipAddress&quot;</span>: <span class="string">&quot;node-sidecar&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;countryId&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;dataCenterInfo&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;@class&quot;</span>: <span class="string">&quot;com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;MyOwn&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;hostName&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;leaseInfo&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;renewalIntervalInSecs&quot;</span>: <span class="number">30</span>,</span><br><span class="line">                <span class="attr">&quot;durationInSecs&quot;</span>: <span class="number">90</span>,</span><br><span class="line">                <span class="attr">&quot;registrationTimestamp&quot;</span>: <span class="number">1522469074848</span>,</span><br><span class="line">                <span class="attr">&quot;lastRenewalTimestamp&quot;</span>: <span class="number">1522469344919</span>,</span><br><span class="line">                <span class="attr">&quot;evictionTimestamp&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;serviceUpTimestamp&quot;</span>: <span class="number">1522469074848</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;isCoordinatingDiscoveryServer&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">&quot;lastUpdatedTimestamp&quot;</span>: <span class="number">1522469074849</span>,</span><br><span class="line">            <span class="attr">&quot;lastDirtyTimestamp&quot;</span>: <span class="number">1522469044798</span>,</span><br><span class="line">            <span class="attr">&quot;actionType&quot;</span>: <span class="string">&quot;ADDED&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;asgName&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;overriddenStatus&quot;</span>: <span class="string">&quot;UNKNOWN&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;secure&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;uri&quot;</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;serviceId&quot;</span>: <span class="string">&quot;NODE-SIDECAR&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>  可以看到，该实例维护了 Node 应用的访问地址<code>&quot;uri&quot;: &quot;http://localhost:3000&quot;</code>，这也是接下来要说的：其他微服务可以通过 Sidecar 的服务名声明式调用 Node 服务</p>
</li>
</ul>
<h2 id="声明式服务调用"><a href="#声明式服务调用" class="headerlink" title="声明式服务调用"></a>声明式服务调用</h2><blockquote>
<p>以上，我们已经验证了 Eureka 可以通过 Sidecar 间接的管理基于 Node 的微服务。而在微服务体系中，还有非常重要的一点，就是服务间的调用。Spring Cloud 允许我们使用<strong>服务名</strong>进行服务间的调用，摒弃了原先的固定写死的 IP 地址，便于服务集群的横向拓展及维护。那么，Non-JVM 的微服务与其他服务间是否可以通过服务名互相调用呢，答案是可以的。</p>
</blockquote>
<h3 id="被调用"><a href="#被调用" class="headerlink" title="被调用"></a>被调用</h3><blockquote>
<p>我们假设下面一个场景，book-service 提供了根据 bookId 返回对应 book 信息的接口，其中包含 authorId，而 author-service 需要根据该 authorId 获取到对应的作者信息。也就是 author-service 需要访问 book-service 的<code>/book/:bookId</code>接口拿到 authorId</p>
</blockquote>
<ul>
<li><p>先在 book-service 中实现<code>/book/:bookId</code>接口，先固定返回 authorId 为 1</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">&#x27;/book/:bookId&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.response.body = &#123;</span><br><span class="line">    <span class="attr">bookId</span>: ctx.params.bookId,</span><br><span class="line">    <span class="attr">authorId</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">description</span>: <span class="string">&quot;This is a book.&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>而在 author-service 中声明式服务调用使用的是 Spring Cloud 整合的 <strong>Feign</strong>，Maven 依赖如下</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>author-service 作为 book-service 服务的调用者，需要声明 Client 接口，代码如下</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;node-sidecar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookServiceClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/book/&#123;bookId&#125;&quot;)</span></span><br><span class="line">    <span class="function">Book <span class="title">getBook</span><span class="params">(<span class="meta">@PathVariable(&quot;bookId&quot;)</span> String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  注意到<code>@FeignClient</code>注解中调用的服务名填写的是 node-sidecar (大小写不敏感)，因为自始至终 Eureka 中注册的是 Sidecar 的信息，而 Sidecar 实例维护了 book-service 的地址信息，所以它可以将请求转发至 book-service</p>
</li>
<li><p>在 author-service 中提供<code>/book/&#123;bookId&#125;/author</code>接口</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BookServiceClient bookServiceClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/book/&#123;bookId&#125;/author&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Author <span class="title">getAuthor</span><span class="params">(<span class="meta">@PathVariable</span> String bookId)</span></span>&#123;</span><br><span class="line">        Book book = bookServiceClient.getBook(bookId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Author(book.getAuthorId(),<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 author-service ，访问<code>http://localhost:9092/book/1/author</code></p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;authorId&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;authorName&quot;</span>: <span class="string">&quot;Jack&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="调用其他微服务"><a href="#调用其他微服务" class="headerlink" title="调用其他微服务"></a>调用其他微服务</h3><blockquote>
<p>其他微服务可以通过 Sidecar 实例的服务名间接调用基于 Node 的 book-service。同样的，book-service 也可以通过服务名调用其他微服务，这要归功于<code>@EnableZuulProxy</code></p>
</blockquote>
<ul>
<li>访问<code>http://localhost:9091/author-service/book/1/author</code>惊讶的发现，这和我们访问<code>http://localhost:9092/book/1/author</code>结果是一样的，这是由于 Sidecar 引入了 Zuul 网关，它可以获取 Eureka 上注册的服务的地址信息，从而进行路由跳转<br><img data-src="/2.png" alt="A44BC958-7050-4530-8855-7F0042A6C32F"></li>
</ul>
<blockquote>
<p><strong>Tips:</strong> Spring Cloud Zuul 通过与 Eureka 的整合，将自身注册为 Eureka 服务治理下的应用，同时从 Eureka 获取其他所有微服务的示实例信息。对于路由规则的维护，Zuul 默认会将服务名作为 ContextPath 的方式创建路由映射</p>
</blockquote>
<ul>
<li><p>那接下来就简单了，先在 author-service 中添加一个接口返回作者描述</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/author/&#123;authorId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthorDescription</span><span class="params">(<span class="meta">@PathVariable</span> String authorId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;This is an author description of &quot;</span> + authorId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>再在 book-service 中添加 book 的详细信息接口，需要去调用上述的作者描述接口</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> SIDECAR_URI = <span class="string">&#x27;http://localhost:9091&#x27;</span></span><br><span class="line"><span class="keyword">const</span> AUTHOR_SERVICE = <span class="string">&#x27;author-service&#x27;</span></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/book/:bookId/detailed&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> axios.get(<span class="string">`<span class="subst">$&#123;SIDECAR_URI&#125;</span>/<span class="subst">$&#123;AUTHOR_SERVICE&#125;</span>/author/1`</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    ctx.response.body = &#123;</span><br><span class="line">      <span class="attr">bookId</span>: ctx.params.bookId,</span><br><span class="line">      <span class="attr">authorId</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">      <span class="attr">authorDescription</span>: res.data,</span><br><span class="line">      <span class="attr">description</span>: <span class="string">&#x27;This is a book.&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>, error))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>  这里采用的 author-service 服务名去访问的该服务，而不是固定的 IP 地址，格式为<code>$&#123;SIDECAR_URI&#125;/$&#123;AUTHOR_SERVICE&#125;</code></p>
</li>
<li><p>访问<code>http://localhost:3000/book/1/detailed</code></p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;bookId&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;authorId&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;authorDescription&quot;</span>: <span class="string">&quot;This is an author description of 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;This is a book.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Api-Gateway"><a href="#Api-Gateway" class="headerlink" title="Api-Gateway"></a>Api-Gateway</h2><blockquote>
<p>后来我又加入了<code>api-gateway</code>去验证网关能否通过<code>node-sidecar</code>的服务名去将访问 API 的请求转发到<code>book-service</code>，事实证明确实是可以的</p>
</blockquote>
<ul>
<li><p><code>api-gateway</code>的 Maven 依赖</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>需要在主类上加上<code>@EnableZuulProxy</code> Zuul 网关和<code>@EnableDiscoveryClient</code>注解</p>
</li>
<li><p>配置文件</p>
<pre><code class="yml">spring:
  application:
    name: api-gateway
server:
  port: 5555
  context-path: /
eureka:
  instance:
    hostname: localhost
  client:
    serviceUrl:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:9090/eureka/
zuul:
  routes:
    author-service:
      path: /author-service/**
      serviceId: author-service
    book-service:
      path: /book-service/**
      serviceId: node-sidecar
</code></pre>
</li>
<li><p>访问<code>http://localhost:5555/book-service/book/1</code>，在接口层面，<code>node-sidecar</code>其实是不可见的，访问的还是<code>book-service</code>的 API<br><img data-src="/3.png" alt="WX20180403-110158">  </p>
</li>
<li><p>由此，如果<code>book-service</code>需要横向拓展为一个集群，无非是多创建几个对应的 Sidecar 应用，它们的服务名只要是一样的，那就可以通过网关去实现负载均衡，甚至我第二个<code>book-service</code>用 Python 写也没有问题</p>
</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><blockquote>
<p>由此，基于 Non-JVM 语言的微服务，通过 Sidecar ，实现了服务向 Eureka 的注册与健康检查，并且可以通过服务名进行服务间调用。基本上可以说 Non-JVM 应用通过 Sidecar 完美的融入了 Spring Cloud 生态圈。</p>
</blockquote>
<ul>
<li>附上一张架构图<br><img data-src="/4.png" alt="sidecar"></li>
</ul>
<h2 id="Preferences"><a href="#Preferences" class="headerlink" title="Preferences"></a>Preferences</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/marshalYuan/spring-cloud-example/blob/master/docs/sidecar.md">使用 Sidecar 将 Node.js 引入 Spring Cloud</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="s1mple"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">s1mple</p>
  <div class="site-description" itemprop="description">春光恰与少年同，十里清风慕天青</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/s1mplecc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;s1mplecc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:s1mple951205@gmail.com" title="E-Mail → mailto:s1mple951205@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">s1mple</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 33231,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













  

  

  


</body>
</html>
