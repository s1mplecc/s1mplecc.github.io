<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>50 行代码实现一个并发的 Python 爬虫程序</title>
    <url>/2018/12/03/50%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B9%B6%E5%8F%91%E7%9A%84%20Python%20%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>得益于 Python 丰富的库，我们可以不用重复造轮子而是直接拿人家现成的库用，比如爬虫所需的解析 Html 功能都不用自己亲自写。所以，我在用 Python 改写之前的 Java 爬虫时，只用了 50 行代码就实现了原有功能。本文主要介绍编码时用到的库，以及总结了一些 Python 编码的知识点。</p>
<p>案例还是用的之前 <a href="https://s2mple.xyz/2018/11/05/Java%20%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/">Java 网络爬虫</a> 的案例。所需 <code>Python Version &gt;= 3.6</code>，用到的库有：</p>
<ul>
<li><strong>beautifulsoup4</strong> 三方库用于解析 Html，执行 <code>pip install beautifulsoup4</code> 安装</li>
<li>内置的 <strong>urllib</strong> 用于发起网络请求获取响应内容</li>
<li>内置的 <strong>concurrent.futures</strong> 并发库中的 <strong>ProcessPoolExecutor</strong> 用于创建进程池</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>源码已经上传到 <a href="https://gist.github.com/s1mplecc/dfd15f58cbbe5fad2ab13bc2246d49f4">GitHub</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">WWW_BIQUGE_CM = <span class="string">&#x27;http://www.biquge.cm&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__fetch_html</span>(<span class="params">url, decode=<span class="string">&#x27;UTF-8&#x27;</span></span>):</span></span><br><span class="line">    req = request.Request(url)</span><br><span class="line">    req.add_header(<span class="string">&#x27;User-Agent&#x27;</span>, <span class="string">&#x27;Mozilla/5.0&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> request.urlopen(req) <span class="keyword">as</span> res:</span><br><span class="line">        <span class="keyword">return</span> res.read().decode(decode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__parse_title_and_hrefs</span>(<span class="params">index</span>):</span></span><br><span class="line">    html = __fetch_html(<span class="string">f&#x27;<span class="subst">&#123;WWW_BIQUGE_CM&#125;</span>/<span class="subst">&#123;index&#125;</span>/&#x27;</span>, <span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    links = soup.find_all(<span class="string">&#x27;a&#x27;</span>, href=re.<span class="built_in">compile</span>(<span class="string">rf&#x27;/<span class="subst">&#123;index&#125;</span>/&#x27;</span>))</span><br><span class="line">    hrefs = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="string">&#x27;href&#x27;</span>], links))</span><br><span class="line">    title = soup.h1.string</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;title: <span class="subst">&#123;title&#125;</span>\nhrefs: size=<span class="subst">&#123;<span class="built_in">len</span>(hrefs)&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> title, hrefs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__fetch_content</span>(<span class="params">href</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;parsing <span class="subst">&#123;href&#125;</span>&#x27;</span>)</span><br><span class="line">    html = __fetch_html(<span class="string">f&#x27;<span class="subst">&#123;WWW_BIQUGE_CM&#125;</span>/<span class="subst">&#123;href&#125;</span>&#x27;</span>, <span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">r&#x27;&lt;div id=&quot;content&quot;&gt;|&lt;/div&gt;|&lt;br/&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="built_in">str</span>(soup.find(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;content&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__append_contents_to_file</span>(<span class="params">title, hrefs</span>):</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(<span class="number">16</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        contents = executor.<span class="built_in">map</span>(__fetch_content, hrefs)</span><br><span class="line">    os.makedirs(<span class="string">&#x27;downloads&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;./downloads/<span class="subst">&#123;title&#125;</span>.txt&#x27;</span>, <span class="string">&#x27;wt+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">            f.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">index=<span class="string">&#x27;12/12481&#x27;</span></span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    title, hrefs = __parse_title_and_hrefs(index)</span><br><span class="line">    __append_contents_to_file(title, hrefs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;spend time: <span class="subst">&#123;time.time() - start&#125;</span>s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run(<span class="string">&#x27;9/9422&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h3><p>模拟浏览器发起一个 HTTP 请求，我们需要用到 <code>urllib.request</code> 模块。其 <code>urlopen()</code> 方法用于发起请求并获取响应结果，该方法可单独传入一个 <code>urllib.request.Request</code> 对象，并返回一个 <code>http.client.HTTPResponse</code> 对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__fetch_html</span>(<span class="params">url, decode=<span class="string">&#x27;UTF-8&#x27;</span></span>):</span></span><br><span class="line">    req = request.Request(url)</span><br><span class="line">    req.add_header(<span class="string">&#x27;User-Agent&#x27;</span>, <span class="string">&#x27;Mozilla/5.0&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> request.urlopen(req) <span class="keyword">as</span> res:</span><br><span class="line">        <span class="keyword">return</span> res.read().decode(decode)</span><br></pre></td></tr></table></figure>

<p>使用 <code>Request</code> 包装请求头。如果不设置 headers 中的 <strong>User-Agent</strong>，默认的 User-Agent 是 Python-urllib。可能一些网站会将该请求拦截，所以需要伪装成浏览器发起请求。</p>
<h3 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h3><blockquote>
<p>Beautiful Soup is a Python library for pulling data out of HTML and XML files. It works with your favorite parser to provide idiomatic ways of navigating, searching, and modifying the parse tree. It commonly saves programmers hours or days of work.</p>
</blockquote>
<p>Beautiful Soup 用于从 HTML 或 XML 文件中提取数据，提供的功能非常强大。它支持 Python 标准库中的 HTML 解析器：<code>BeautifulSoup(markup, &quot;html.parser&quot;)</code>，还支持一些第三方的解析器（如 html5lib、lxml 等）。</p>
<p>Beautiful Soup 将 HTML 文档转换成一个复杂的树形结构,每个节点都是 Python 对象,所有对象可以归纳为4种: <code>Tag</code>，<code>NavigableString</code>，<code>BeautifulSoup</code>，<code>Comment</code>。<code>Tag</code> 对象与 XML 或 HTML 原生文档中的 tag 相同，所以非常适合用于<strong>定位</strong>。下面列出一些常见用法，感兴趣的同学可以查阅 <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">官方文档</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.title</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;</span></span><br><span class="line"></span><br><span class="line">soup.a</span><br><span class="line"><span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line">soup.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.find(<span class="string">&#x27;a&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;link3&#x27;</span>)</span><br><span class="line"><span class="comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(link.get(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">    <span class="comment"># http://example.com/elsie</span></span><br><span class="line">    <span class="comment"># http://example.com/lacie</span></span><br><span class="line">    <span class="comment"># http://example.com/tillie</span></span><br></pre></td></tr></table></figure>

<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>从 Python3.2 开始 <code>concurrent.futures</code> 被纳入了标准库，这个模块中有2个类：<code>ThreadPoolExecutor</code> 和 <code>ProcessPoolExecutor</code>，分别对 <code>threading</code> 多线程库和 <code>multiprocessing</code> 多进程库的进行了高级别的抽象，封装了统一的接口。</p>
<p>关于是使用多线程还是多进程，大部分人可能有所耳闻，Python 推荐使用多进程而不是多线程。我自己测试的情况也是爬取 3000 章时使用 <code>ProcessPoolExecutor</code> 大约需要 20s，使用 <code>ThreadPoolExecutor</code> 需要大概 40s，性能差了一倍。</p>
<p>其他语言，CPU 是多核时是支持多个线程同时执行的。但在 Python 中，无论是单核还是多核，<strong>同时只能由一个线程在执行</strong>，其根源是 <strong>GIL</strong> 的存在（只存在于 CPython，PyPy 和 Jython 中没有）。</p>
<p>GIL 全称 <strong>Global Interpreter Lock</strong>(全局解释器锁)，是 Python 设计之初为了数据安全所做的决定。某个线程想要执行，必须先拿到 GIL，并且在一个 Python 进程中只有一个 GIL。并且每次释放 GIL 锁时线程会进行锁竞争，切换线程也会消耗资源。这就是为什么在多核 CPU 上 Python 的多线程效率并不高的原因所在，以至于 Python 的专家们精心制作了一个标准答案：<strong>不要使用多线程，请使用多进程</strong>。</p>
<p>此外，Python 可使用 <strong>perf</strong> 库进行性能测试，以下是爬取 50 章时的性能：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(venv) ➜  crawler ✗ python3 -m perf timeit <span class="string">&#x27;import app;app.run(&quot;12/12455&quot;)&#x27;</span></span><br><span class="line">...</span><br><span class="line">* the standard deviation (281 ms) is 24% of the mean (1.16 sec)</span><br><span class="line">* the maximum (2.02 sec) is 73% greater than the mean (1.16 sec)</span><br><span class="line"></span><br><span class="line">Mean +- std dev: 1.16 sec +- 0.28 sec</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h3><p><strong>venv</strong>，全称 <strong>virtualenv</strong> 虚拟环境。用过 JavaScript 的同学都知道，执行 <code>npm install xxx</code> 时会在当前目录生成一个 <code>node_modules</code> 目录，依赖会被安装在这个目录下，除非你加上 <code>-g/--global</code> 全局参数，否则安装的依赖只对当前项目生效（不是全局依赖）。这其实相当于做了一层隔离，将当前项目的环境与全局环境隔离开，有利于版本的管理。</p>
<p>venv 也是这样的作用，用于<strong>为一个应用创建一套隔离的 Python 运行环境</strong>。在这个环境中，你可以管理 Python 版本，pip 版本，以及你所用的三方库的版本，而不会与全局环境冲突。</p>
<p>如果你使用的是 PyCharm，那么创建项目时就可以勾选使用 venv（这也是建议的选择）。效果如下图：<br><img src="/0.png" alt="Screen-Shot-2018-12-03-at-11.01.47-AM">命令行多了 (venv) 前缀：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(venv) ➜  crawler ✗</span><br></pre></td></tr></table></figure>

<p>如果你不是使用的 PyCharm，参考这篇文档：<a href="https://www.kancloud.cn/smilesb101/python3_x/298883">virtualenv</a></p>
<h3 id="风格规范"><a href="#风格规范" class="headerlink" title="风格规范"></a>风格规范</h3><p>Python 风格规范我参考的 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#id16">Google 开源项目风格指南</a>。推荐使用 <strong>PyCharm</strong> IDE，和 IntelliJ IDEA 一样产自 JetBrains 公司，非常良心的软件，会有一些风格提示，并且可以使用快捷键（Ctrl/Cmd + Shift + L）自动格式化。这里主要说说命名吧。</p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p><strong>应该避免的名称</strong></p>
<ol>
<li>单字符名称, 除了计数器和迭代器</li>
<li>包/模块名中的连字符(-)</li>
<li>双下划线开头并结尾的名称( Python 保留, 例如<code>__init__</code>)</li>
</ol>
<p><strong>命名约定</strong></p>
<ol>
<li>用<strong>单下划线(_)开头</strong>表示模块变量或函数是 protected 的(使用 <code>from module import *</code> 时不会包含)。</li>
<li>用<strong>双下划线(__)开头</strong>的实例变量或方法表示类内私有。</li>
<li>对类名使用大写字母开头的单词(如 CapWords，即 Pascal 风格)，但是模块名应该用小写加下划线的方式(如 lower_with_under.py )。尽管已经有很多现存的模块使用类似于CapWords.py 这样的命名，但现在已经不鼓励这样做，因为如果模块名碰巧和类名一致，这会让人困扰。</li>
</ol>
<p><strong>Python之父Guido推荐的规范</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Public</th>
<th>Internal</th>
</tr>
</thead>
<tbody><tr>
<td>Modules</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr>
<td>Packages</td>
<td>lower_with_under</td>
<td></td>
</tr>
<tr>
<td>Classes</td>
<td>CapWords</td>
<td>_CapWords</td>
</tr>
<tr>
<td>Exceptions</td>
<td>CapWords</td>
<td></td>
</tr>
<tr>
<td>Functions</td>
<td>lower_with_under()</td>
<td>_lower_with_under()</td>
</tr>
<tr>
<td>Global/Class Constants</td>
<td>CAPS_WITH_UNDER</td>
<td>_CAPS_WITH_UNDER</td>
</tr>
<tr>
<td>Global/Class Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr>
<td>Instance Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under (protected) or __lower_with_under (private)</td>
</tr>
<tr>
<td>Method Names</td>
<td>lower_with_under()</td>
<td>_lower_with_under() (protected) or __lower_with_under() (private)</td>
</tr>
<tr>
<td>Function/Method Parameters</td>
<td>lower_with_under</td>
<td></td>
</tr>
<tr>
<td>Local Variables</td>
<td>lower_with_under</td>
<td></td>
</tr>
</tbody></table>
<h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><p><strong>所有的顶级代码在模块导入时都会被执行</strong>。即使是一个打算被用作脚本的文件，也应该是可导入的。并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行，这是一种副作用。主功能应该放在一个函数中，并在执行主程序前总是检查 <code>if __name__ == &#39;__main__&#39;</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p><code>__name__</code> 是内置变量，指代<strong>当前模块名</strong>，当模块被直接运行时模块名为 <code>__main__</code>。这句话的意思就是，当模块被直接运行时，下面代码块将被运行，当模块是被导入时，代码块不被运行。</p>
<h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.makedirs(<span class="string">&#x27;downloads&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;./downloads/<span class="subst">&#123;title&#125;</span>.txt&#x27;</span>, <span class="string">&#x27;wt+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">        f.write(content)</span><br></pre></td></tr></table></figure>

<p>第一句用于创建 downloads 文件夹，<code>exist_ok=True</code> 参数允许创建的文件夹已存在，否则会抛出 <code>FileExistsError</code> 异常。</p>
<p>第二句 <code>with ... as ...</code> 的用法和 Java 中的 <code>try with resources</code> 有点类似，这里它会自动关闭打开的文件流。它的核心思想是 with 所求值的对象必须有一个 <code>__enter()__</code> 方法和一个 <code>__exit()__</code> 方法，在 with 代码块开始和结束这两个方法会被执行。如果出现异常则会执行 <code>__exit()__</code>，并传入三个参数 <code>exc_type</code>，<code>exc_value</code>，<code>exc_traceback</code> 用于异常处理。</p>
<p><code>open(&#39;abc.txt&#39;, &#39;a+&#39;)</code> 打开文件时不同的参数有不同的作用，我这里用的 <code>wt+</code> 表示以文本格式打开一个文件用于读写，如果该文件已存在则将其覆盖，如果该文件不存在则创建新文件。还有其他参数，例如 <code>a+</code> 代表 append 追加，<code>r</code> 表示只读等等。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.kancloud.cn/smilesb101/python3_x/295557">廖雪峰的Python3.x教程</a></li>
<li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#id16">Python 风格指南 —— Google 开源项目风格指南</a></li>
<li><a href="https://www.jianshu.com/p/2e190438bd9c">详解 python3 urllib</a></li>
<li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">Beautiful Soup 4 官方文档</a></li>
<li><a href="https://docs.python.org/3/library/concurrent.futures.html">concurrent.futures — Launching parallel tasks 官方文档</a></li>
<li><a href="https://blog.louie.lu/2017/08/01/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-python-%E6%A8%99%E6%BA%96%E5%87%BD%E5%BC%8F%E5%BA%AB%E7%94%A8%E6%B3%95-06-concurrent-futures/">concurrent.futures 性能分析</a></li>
</ul>
]]></content>
      <categories>
        <category>Projects</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>API 设计心得</title>
    <url>/2018/10/10/API%E8%AE%BE%E8%AE%A1%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>最近我在项目中单独编码了加载配置的模块，并提供给团队里的其他开发者使用。在设计 API 时有些心得体会，遂有了此博客记录下来。</p>
</blockquote>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>截取了部分项目结构，大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config module</span></span><br><span class="line"></span><br><span class="line">├── ConfigFactory.java</span><br><span class="line">├── YamlConverter.java</span><br><span class="line">└── core</span><br><span class="line">    ├── AbstractConfig.java</span><br><span class="line">    ├── Config.java</span><br><span class="line">    ├── ConfigFile.java</span><br><span class="line">    ├── ConfigLoader.java</span><br><span class="line">    ├── ...</span><br><span class="line">    └── exceptions</span><br><span class="line">        ├── ConfigFileNotFoundException.java</span><br><span class="line">        ├── UnsupportedFileTypeException.java</span><br><span class="line">        └── ...</span><br></pre></td></tr></table></figure>

<p><code>ConfigFactory</code> 和 <code>YamlConverter</code> 都是对外提供 API 的类，故放在最外层目录下，另外有个 <strong>core</strong> 的文件夹，存放间接使用到的类。类似于操作系统和用户 UI 界面，内核 core 封装你的实现，不暴露给用户，可以非常复杂。外层的 API 提供给用户使用，应该尽量满足<strong>不变</strong>的原则，即<strong>隔离变化</strong>，为了避免升级后用户需要改动代码。</p>
<h2 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h2><p>API 应该保持简单易用，尽量可以<strong>望文知义</strong>。由于现在的 IDE 都有智能感知，会自动提示可调用的方法，一个设计优秀的 API 应该<strong>方法名即能显示用途</strong>，再不济，用户跟进方法阅读注释或者源码也应知道如何使用。<strong>能避免用户必须查阅文档才知道如何使用的应当尽量避免</strong>。</p>
<p>提高易用性可以从如下几各方面：</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><strong>静态方法</strong></h4><p>静态方法不需要实例化，一些工具类就大量运用静态方法，比如 Apache 的 StringUtils 字符串处理工具类，<code>StringUtils.isEmpty()、StringUtils.upperCase()</code> 等几乎所有方法都是 <code>static</code> 的。</p>
<h4 id="Fluent-Interface"><a href="#Fluent-Interface" class="headerlink" title="Fluent Interface"></a><strong>Fluent Interface</strong></h4><p>流畅接口符合人的阅读习惯，比如 jOOQ 数据库映射库，使用流畅接口模拟 SQL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">create.selectFrom(a)</span><br><span class="line">      .where(exists(selectOne()</span><br><span class="line">                 .from(BOOK)</span><br><span class="line">                 .where(BOOK.STATUS.equal(BOOK_STATUS.SOLD_OUT))</span><br><span class="line">                 .and(BOOK.AUTHOR_ID.equal(a.ID))));</span><br></pre></td></tr></table></figure>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a><strong>命名</strong></h4><p>不管是类名、方法名还是参数名，好的命名应该<strong>语义清晰简单</strong>、<strong>符合直觉</strong>、<strong>易于记忆</strong>和<strong>引导用户</strong>，应尽量简单或使用业界常用的命名，比如我在编写 config 模块时借鉴了 Typesafe，它的 API 这样使用：<code>ConfigFactory.load(String resourceBasename)</code>，清晰明了，并且我知道入参是基于 resource 相对路径的文件名。</p>
<p><strong>不要重复局部命名</strong>。在有上下文环境的调用中，减少不必要的描述可以提高 API 的精简和清晰度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="comment">// good</span></span><br><span class="line">  setName() &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// bad</span></span><br><span class="line">  setUserName() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h4><p>使用 Java 的访问控制修饰符 <code>private、default、protected</code> 对方法访问权限进行限定，该隐藏的隐藏，仅暴露对外公开接口。这样在 IDE 智能提示时也方便用户快速定位方法。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>良好的 API 设计利于未来的版本升级——升级带来的用户兼容性成本较低，或者框架开发者的兼容性包袱较轻。</p>
<p>为了将来的兼容性考虑，设计 API 时建议考虑这些因素：</p>
<h4 id="不要提前公开-API"><a href="#不要提前公开-API" class="headerlink" title="不要提前公开 API"></a><strong>不要提前公开 API</strong></h4><p>如果你的某个 API 是为将来预留的，那么不要开放，因为你不清楚未来的设计需求是怎样的，提前公开的 API 在将来改变的可能性非常高。</p>
<h4 id="预留足够的扩展点"><a href="#预留足够的扩展点" class="headerlink" title="预留足够的扩展点"></a><strong>预留足够的扩展点</strong></h4><p>没有良好扩展性的 API 通常会因为频繁的需求变更而导致 API 间接变化，这都是兼容性成本。如果在良好的设计下预留了足够的扩展点，那么这样的 API 能够应对未来一段时间内未知的需求变化，使得 API 变化在可控范围内。</p>
<p>要预留扩展点就意味着通常应该<strong>使用接口或者抽象</strong>的概念来描述 API，建议用清晰定位的接口替代具体的类型。</p>
<h4 id="明确的-API-迁移说明"><a href="#明确的-API-迁移说明" class="headerlink" title="明确的 API 迁移说明"></a><strong>明确的 API 迁移说明</strong></h4><p>如果某个 API 过时了，也不建议删除它；应该标记为过时，Java 中使用 <code>@Deprecated</code> 注解，并告诉使用者新的 API 是什么。当然如果这个 API 会导致出现不可接受的问题，也可以标记它无法通过编译。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://walterlv.com/post/framework-api-design.html#%E4%B8%80%E8%87%B4%E6%80%A7">好的框架需要好的 API 设计 —— API 设计的六个原则
</a></li>
<li><a href="https://www.cnblogs.com/zfc2201/p/3423370.html">接口设计六大原则</a></li>
</ul>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
  </entry>
  <entry>
    <title>Clean Code -- 第一节：迪米特法则与 Paperboy 案例</title>
    <url>/2018/05/04/Clean%20Code%20--%20%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E4%B8%8E%20Paperboy%20%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该系列源于<a href="http://zhangyi.xyz/">张逸总监</a>的 Clean Code 培训，包涵了如何写出高质量代码的思想、代码案例以及重构代码的实际演练。本篇为该系列的第一篇，主要介绍<strong>迪米特法则</strong>和<strong>信息专家模式</strong>，并结合案例实操在 IntelliJ IDEA 中如何重构代码。本文大部分内容转载自张总博客: <a href="http://zhangyi.xyz/demeter-law-and-refactoring/#more">迪米特法则与重构</a>。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><strong>IntelliJ IDEA</strong>，相比 Eclipse，IDEA 在重构方面十分优秀，结合快捷键，使用起来让人赏心悦目。</li>
<li><strong>示例代码</strong>地址 <a href="https://github.com/agiledon/cleancode.git">https://github.com/agiledon/cleancode.git</a> ，进行实际操作有助于加深理解和记住快捷键。代码有两个分支，master 分支为重构前的代码，<strong>after-refactoring</strong> 分支为重构后代码，可以使用快捷键 <code>Cmd + D</code> 查看<strong>代码差异</strong>。</li>
<li><strong>活用快捷键</strong>，本人使用的 IDEA 快捷键为 Mac OS X 10.5+ 。Windows 用户将 <code>Cmd</code> 替换成 <code>Ctrl</code>，或者在 IDEA 的 <strong>Refactor</strong> 菜单中查看快捷键。</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + T</td>
<td>重构菜单</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>重命名方法、属性、文件</td>
</tr>
<tr>
<td>Cmd + Alt + M</td>
<td>提取方法（extract method）</td>
</tr>
<tr>
<td>Cmd + Alt + N</td>
<td>内联（Inline），与 extract 相反</td>
</tr>
<tr>
<td>Cmd + Shift + 上下箭头</td>
<td>上下移动声明体（statement）</td>
</tr>
</tbody></table>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>在面向对象设计的世界里，有一个寻常却又常常为人所忽略的原则——<strong>迪米特法则（Law of Demeter）</strong>。这个原则认为，任何一个对象或者方法，它应该只能调用下列对象：    </p>
<ul>
<li>该对象本身</li>
<li>作为参数传进来的对象（也可以是该对象的字段）</li>
<li>在方法内创建的对象</li>
</ul>
<p>这个原则用以指导正确的<strong>对象协作</strong>，分清楚哪些对象应该产生协作，哪些对象则对于该对象而言，又应该是无知的。</p>
<h2 id="代码案例及分析"><a href="#代码案例及分析" class="headerlink" title="代码案例及分析"></a>代码案例及分析</h2><p>如何理解这个原则？我们可以看看 David Bock 就该原则给出的一个<a href="https://www2.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/paper-boy/demeter.pdf">绝佳案例</a>。假设一个超市购物的场景，顾客（Customer）到收银台结账，收银员（Paperboy）负责收钱。我们来看看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Wallet myWallet;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wallet <span class="title">getWallet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myWallet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wallet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTotalMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalMoney</span><span class="params">(<span class="keyword">float</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">float</span> deposit)</span> </span>&#123;</span><br><span class="line">        value += deposit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subtractMoney</span><span class="params">(<span class="keyword">float</span> debit)</span> </span>&#123;</span><br><span class="line">        value -= debit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Paperboy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(Customer myCustomer, <span class="keyword">float</span> payment)</span> </span>&#123;</span><br><span class="line">        Wallet theWallet = myCustomer.getWallet();</span><br><span class="line">        <span class="keyword">if</span> (theWallet.getTotalMoney() &gt; payment) &#123;</span><br><span class="line">            theWallet.subtractMoney(payment);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//money not enough</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们将 Paperboy 中<code>charge()</code>方法的代码翻译成这幕小话剧的对白。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“把钱包交出来!”收银员算出顾客要买的商品总价后，“温柔”地对顾客说道。</span><br><span class="line">顾客言听计从，赶紧将钱包掏出来，恭恭敬敬地递给收银员。</span><br><span class="line">接过钱包，收银员毫不客气地打开，检查里面的钱够不够。噢，不错，钱够了。收银员从钱包取出钱，心满意足地笑了。</span><br></pre></td></tr></table></figure>
<p>如果你是顾客，你敢去这样的超市 shopping 吗？</p>
<p>对于 Paperboy 而言，Wallet 不满足迪米特法则三个条件中的任何一个，因此，<strong>不应该让 Paperboy 与 Wallet 对象进行直接交互</strong>。若从<strong>拟人化</strong>的角度思考，则 Wallet 其实属于 Customer 的<strong>隐私</strong>。如此重要的隐私，怎么能直接交给收银员这个陌生人呢？这里所谓的“隐私”，可以视为是“数据”，是“信息”，是“知识”，因此我们往往又将迪米特法则称之为“<strong>最小知识法则</strong>”。</p>
<p>当我们理解“最小知识法则”时，又可以从<strong>职责</strong>的角度去思考以上代码。对于收银员角色，他的职责应该是负责收钱，而不用去管钱包里的钱够不够，如果够了怎么办，如果不够又该怎么办，这些统统都不属于他的职责。设想一下，当超市里人流如织，大家都在购买商品时，如果每一个收银员都要承担这般的职责时，会出现什么样的景象？所以“最小知识法则”乃善法，在对象社区中，我们就应该刻意减少对象之间彼此深入的了解。了解最小的知识，就意味着依赖最小，彼此产生的影响就会最小。这实际上是 <strong>KISS（keep it simple and stupid）</strong> 原则的体现。</p>
<p><strong>信息专家模式</strong>告诉我们：“信息的持有者即为操作该信息的专家”。对于对象，所谓<strong>信息就是该对象内部的字段</strong>。在上述的例子中，Wallet 是 Customer 的字段，那么操作 Wallet 的行为自然就应该分配给 Customer 了。这是题中应有之义。“信息专家模式”其实是面向对象最重要原则“<strong>数据与行为应该封装在一起</strong>”的别名。若在领域建模时能遵循该原则，则可以规避我们设计出贫血模型。</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>如何修改以上代码？注意，<code>charge()</code>行为仍然属于 Paperboy 的职责，因此我们不应该将该方法整体搬迁到 Customer 中，而应该先进行<strong>方法的提取</strong>，选中代码块，使用 <strong>Cmd + Alt + M</strong> 快捷键提取方法。这块代码执行的是支付的步骤，所以命名为<code>pay()</code>。</p>
<p><img src="/0.png" alt="781D2706-3961-4C77-ACF8-8BDDCE21B17E"></p>
<p>提取后的<code>charge()</code>在接收方法请求后，转而将请求<strong>委派</strong>给了<code>pay()</code>方法。我们可以这样理解：在抽象层面，收款是收银员的职责；在实现层面，是<code>pay()</code>方法支持了收款行为，该实现归属于顾客。</p>
<p><img src="/1.png" alt="1AF2B42F-7B13-4284-AF03-9C1D5C5FE0A1"></p>
<p>观察<code>pay()</code>方法，我们发现该方法操作的数据皆来自 Customer。我们嗅到了一种坏味道，即 Martin Fowler 所谓的“<strong>特性依恋（Feature Envy）</strong>”。对于该坏味道，老马是这样阐释的：“函数对某个类的兴趣高过对自己所处类的兴趣”。不要再嫉妒了，桥归桥，路归路，让方法回到自己最喜欢的地方吧。运用“<strong>Move Method</strong>”重构手法，将<code>pay()</code>方法移动到 Customer 中。</p>
<p>光标在方法签名或方法体中都可，按下 <strong>F6</strong>，IDEA 会根据方法的入参，智能的提示将方法移动到哪个类中，这里只能是 Customer。还要注意方法的访问权限，默认是 Escalate 往上提升一级，这里选择 Public。</p>
<p><img src="/2.png" alt="2C6EA6D7-A330-4E90-8B2A-54223072A47A"></p>
<p>操作之后，<code>pay()</code>方法移动到 Customer 中。</p>
<p><img src="/3.png" alt="F92C14F0-6693-4154-8A6D-F71AB14BF0E2"></p>
<p>在将方法移到正确的位置后，我们发现暴露的<code>getWallet()</code>方法根本就没有意义。更何况，将钱包裸露出去，难道是想要炫富吗？还是低调一点为好，隐藏自己的“隐私”，总好过被人觊觎而招来飞来横祸之险。于是，<strong>内联（inline）</strong> 之。将光标放在<code>getWallet()</code>上，按下 <strong>Cmd + Alt + N</strong>。</p>
<p><img src="/4.png" alt="563C9626-A71E-4DC7-A8DC-BA4DA530EF64"></p>
<p><code>getWallet()</code>方法被删除，并被替换为 Customer 的字段<code>myWallet</code>。那现在声明的<code>theWallet</code>就是多余的，继续内联。<br><img src="/5.png" alt="28E463A5-F36A-4250-8611-36BDACF80FCE"></p>
<p>最后，重构过的代码应该是这样的。阅读代码一目了然，Paperboy 进行收银，并委派给顾客进行实际的支付，即掏钱包，数钱，付钱。<br><img src="/6.png" alt="3CA41F80-0556-42F3-8E16-5AEEC39332A3"><img src="/7.png" alt="E66E7919-9391-4046-8CB4-C46555E561A8"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>判断一段代码是否违背了迪米特法则，有一个小窍门，就是看调用代码是否出现形如<code>a.m1().m2().m3().m4()</code>之类的代码。这种代码在 Martin Fowler《重构》一书中，被名为“**消息链条(Message Chain)**”，有人更加夸张地名其为“火车残骸”。车祸现场啊，真是惨不忍睹。</p>
<p>实际上未重构前的代码即是一种消息链条，在<code>charge()</code>方法中实际执行的是<code>myCustomer.getWallet().subtractMoney(payment)</code>，先获取 Customer 的 Wallet，再执行 Wallet 的扣钱方法。</p>
<p>那么，如下代码是否这样的残骸呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.split(<span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .map(str -&gt; str.contains(elementName) ? str.replace(elementName + <span class="string">&quot;=&quot;</span>, <span class="string">&quot;&quot;</span>) : <span class="string">&quot;&quot;</span>)</span><br><span class="line">    .filter(str -&gt; !str.isEmpty())</span><br><span class="line">    .reduce(<span class="string">&quot;&quot;</span>, (a, b) -&gt; a + <span class="string">&quot;,&quot;</span> + b);</span><br></pre></td></tr></table></figure>

<p>答案是：不是。这样的代码我们一般称之为“流畅接口或连贯接口（Fluent Interface）”。二者的区别在于<strong>观察形成链条的每个方法返回的是别的对象，还是对象自身。如果返回的是别的对象，就是消息链条</strong>。所谓<code>m1().m2().m3().m4()</code>的调用，其实是调用者不需要也不想知道的“知识”，把这些中间过程的细节暴露出来没有意义，调用者关心的是最终结果；而上述代码中的<code>map()</code>与<code>filter()</code>等方法其实返回的还是 Stream 类。这一调用方式其初衷并非告知中间过程的细节，而是一种声明式的 DSL 表达，调用者可以自由地组合它们。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://zhangyi.xyz/demeter-law-and-refactoring/#more">迪米特法则与重构 – 张逸</a></li>
<li><a href="https://www2.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/paper-boy/demeter.pdf">The Paperboy, The Wallet, and The Law Of Demeter –  David Bock</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>代码重构</tag>
      </tags>
  </entry>
  <entry>
    <title>Clean Code -- 第三节：PartDB 案例与模版方法模式</title>
    <url>/2018/05/10/Clean%20Code%20--%20%E7%AC%AC%E4%B8%89%E8%8A%82%EF%BC%9APartDB%20%E6%A1%88%E4%BE%8B%E4%B8%8E%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该系列源于<a href="http://zhangyi.xyz/">张逸总监</a>的 Clean Code 培训，包涵了如何写出高质量代码的思想、代码案例以及重构代码的实际演练。<a href="https://s2mple.xyz/2018/05/07/Clean%20Code%20--%20%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%8A%A5%E8%A1%A8%E5%8F%82%E6%95%B0%E5%A1%AB%E5%85%85%E6%A1%88%E4%BE%8B/">上一篇</a>我们通过报表参数填充案例复习了迪米特法则（最小知识法则）、信息专家模式：数据和行为应该封装在一起。本篇我们将通过 PartDB 案例来见识 IDEA 中 <strong>Extract Superclass</strong> 等强大的重构功能，以及与案例相关的设计模式：<strong>模版方法模式</strong>。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><strong>IntelliJ IDEA</strong>，相比 Eclipse，IDEA 在重构方面十分优秀，结合快捷键，使用起来让人赏心悦目。</li>
<li><strong>示例代码</strong>地址 <a href="https://github.com/agiledon/cleancode.git">https://github.com/agiledon/cleancode.git</a> ，进行实际操作有助于加深理解和记住快捷键。代码有两个分支，master 分支为重构前的代码，<strong>after-refactoring</strong> 分支为重构后代码，可以使用快捷键 <code>Cmd + D</code> 查看<strong>代码差异</strong>。</li>
<li><strong>活用快捷键</strong>，本人使用的 IDEA 快捷键为 Mac OS X 10.5+ 。Windows 用户将 <code>Cmd</code> 替换成 <code>Ctrl</code>，或者在 IDEA 的 <strong>Refactor</strong> 菜单中查看快捷键。</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + T</td>
<td>重构菜单</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>重命名方法、属性、文件</td>
</tr>
<tr>
<td>Cmd + Alt + M</td>
<td>提取方法（extract method）</td>
</tr>
<tr>
<td>Cmd + Alt + N</td>
<td>内联（Inline），与 extract 相反</td>
</tr>
<tr>
<td>Cmd + Shift + 上下箭头</td>
<td>上下移动声明体（statement）</td>
</tr>
</tbody></table>
<h2 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h2><p>我们定义好了一个汽车零件类 Part，现在要通过 PartDB 去访问数据库执行<code>select * from part</code>，并将返回结果填充成一个 PartList。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartDB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER_CLASS = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_SELECT_PARTS = <span class="string">&quot;select * from part&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Part&gt; partList = <span class="keyword">new</span> ArrayList&lt;Part&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(DRIVER_CLASS);</span><br><span class="line">            c = DriverManager.getConnection(DB_URL, USER, PASSWORD);</span><br><span class="line">            Statement stmt = c.createStatement();</span><br><span class="line">            ResultSet rs = stmt.executeQuery(SQL_SELECT_PARTS);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                Part p = <span class="keyword">new</span> Part();</span><br><span class="line">                p.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                p.setBrand(rs.getString(<span class="string">&quot;brand&quot;</span>));</span><br><span class="line">                p.setRetailPrice(rs.getDouble(<span class="string">&quot;retail_price&quot;</span>));</span><br><span class="line">                partList.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            c.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码大概是每一个 Java 程序员都会接触到的：使用 JDBC 访问数据库。加载驱动、创立连接、执行 SQL 返回结果集并且填充到 Java 类中。显然，如果每一步都需要我们手动编写，那若是新增了一个类，比如 CustomerDB 是不是还要去 getConnection 等等，这必然会造成许多<strong>冗余代码</strong>。而现在许多的持久层框架，例如 MyBatis、Hibernate 都是基于 JDBC 进行再封装，避免了重复繁琐的工作。下面我们看看如何重构上述代码。</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>首先一段整洁易读的代码应该层次分明，如果没想到重构，我们可能会使用注释和换行将代码分段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get connection</span></span><br><span class="line">Class.forName(DRIVER_CLASS);</span><br><span class="line">c = DriverManager.getConnection(DB_URL, USER, PASSWORD);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get result set</span></span><br><span class="line">Statement stmt = c.createStatement();</span><br><span class="line">ResultSet rs = stmt.executeQuery(SQL_SELECT_PARTS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// populate parts entity</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，在学会重构之后，我们要习惯使用方法名产生注释的效果，<strong>注释不是越多越好，而要少而精，不必要的注释就不要</strong>。使用 <strong>提取方法（Cmd + Alt + M）</strong> 重构代码，并使用 <strong>Cmd + Shift + ⬆️/ ⬇️</strong> 移动方法顺序。</p>
<p><img src="/0.png" alt="25C7F4CD-951E-4B05-8A98-5A0433520EDA"></p>
<p>注意我这里将<code>c</code>重命名（<strong>Shift + F6</strong>）为<code>connection</code>，<strong>命名要遵循在表达清楚业务含义的同时尽可能的短</strong>，<code>rs</code>、<code>err</code>甚至<code>e</code>这种因为频繁使用，基本上可以望文生义，所以可采用业界统一认可的缩写。但<code>c</code>这种命名，一旦代码量增多后，就可能带来阅读上的困扰，应当避免。顺便说一下，应该使用<code>populateParts()</code>而不是<code>populatePartList()</code>这种命名，因为<strong>命名应该站在功能层面，不应该暴露技术实现</strong>，万一哪一天，你改成 Set 了呢？</p>
<p>我们来观察提取出的三个方法。<code>getConnection()</code>创建数据库连接，在抽象层面与业务无关的，实现层面我们暂不考虑用户自定义情况（实际上应该由配置文件读入），所以实现层面也与业务无关。<code>getResultSet()</code>执行 SQL 获取结果集，在抽象层面与业务无关。实现层面上由于<code>SQL_SELECT_PARTS</code>所以与业务强耦合。我们可以使用 <strong>Cmd + Alt + N</strong> ，将<code>select * from part</code> SQL 语句<strong>内联</strong>，再提取<code>getSql()</code>方法（<strong>Cmd + Alt + M</strong>）。</p>
<p><img src="/1.png" alt="953ECD52-3430-4BFD-A662-24E78BCAF755"></p>
<p>如此一来，<code>getResultSet()</code>在实现层面也与业务无关了。而<code>getSql()</code>方法在抽象层面与业务无关，在实现层面就与业务有关了。<code>populateParts()</code>这个名字容易让人产生误解，我们将其重命名为<code>populateEntities()</code>，这样，它在抽象层面也与业务无关，而在实现层面与业务有关。为什么我一再强调<strong>抽象层面</strong>和<strong>实现层面</strong>与<strong>业务</strong>的关系，就是为了让方法变得纯粹。这也是软件设计中一种重要的设计思维：<strong>关注点分离</strong>，目的是将<strong>解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过侧面来封装、维护，这样原本分散在在整个应用程序中的变动就可以很好的管理起来</strong>。比方有一个函数叫做<code>CreateNewCustomer()</code>，那么该函数只与客户的数据（属性）打交道，而给新客户自动发优惠券的动作就不能放到这个函数里面。</p>
<p>现在，我们所有的方法都在抽象层面与业务无关，只有<code>getSql()</code>和<code>populateEntities()</code>在实现层面与业务有关。至此，我们拨开重重迷雾，冰山的一角轰然显现！既然大家都在抽象层面与业务无关，我们就应该<strong>抽象出更高阶的抽象类</strong>，这里就用到了 <strong>Extract Superclass</strong> 这个神奇的重构手法。</p>
<p>使用 <strong>Ctrl + T</strong> 调出重构菜单，输入 super 就可以看到 Extract Superclass 的提示，敲击回车<br><img src="/2.png" alt="F0675E41-8516-4FC3-96BB-928AB1060D40">注意需要勾选组成父类的成员，这里除了最后一个<code>partList</code>是业务独有的，其他全勾选上，而<code>getSql()</code>和<code>populateEntities()</code>方法因为具体实现与业务相关，就应该是子类去重写，所以应当勾选上 Make abstract。</p>
<p><strong>重构后的 JdbcTemplate 类</strong>：</p>
<p><img src="/3.png" alt="68B462DA-CB1F-41FD-A519-6576CF7BD2FE"></p>
<p><strong>重构后的 PartDB 类</strong>：</p>
<p><img src="/4.png" alt="CC64100D-FC25-4825-85DD-83AECC318E86"></p>
<p>为什么我在提取父类时直接将父类命名为 JdbcTemplate，大家应该不难想到，我们重构完成的抽象父类，就是一个最简化的 JdbcTemplate。许多框架亦是如此诞生的，使用者使用时让自己的业务实体类去继承这个模版类，重写业务相关方法。这也是软件设计模式中非常著名的<strong>模版方法模式</strong>。</p>
<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><p>模板方法模式说白了就是：<strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</strong>。代表具体逻辑步骤的方法称做**基本方法(primitive method)<strong>；而将基本方法汇总穿成一条线的方法叫做</strong>模板方法(template method)**，这个设计模式的名字也是由此而来。 </p>
<p>在上述的抽象类 JdbcTemplate 中，我们的模版方法就应该是<code>populate()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection = getConnection();</span><br><span class="line">        ResultSet rs = getResultSet(connection);</span><br><span class="line">        populateEntities(rs);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于写信的模版，类似“尊敬的xxx”、“此致，敬礼”这种千篇一律的套话我们可以定义一个模版，而需要差异化书写的只是信的内容。在<code>populate()</code>中，骨架已经搭好：先创建数据库连接，再执行 SQL 返回结果集，最后填充实体类。所以这里能看出，<strong>模版方法展现了框架的生命周期</strong>。为防止恶意操作，一般模板方法都会加上<code>final</code>关键字，不允许用户重写模版方法。</p>
<p>基本方法又可以分为三种：抽象方法、具体方法和钩子方法：</p>
<ul>
<li>**抽象方法(Abstract Method)**：一个抽象方法由抽象类声明，由具体子类实现。在 Java 语言里抽象方法以<code>abstract</code>关键字标识。</li>
<li>**具体方法(Concrete Method)**：一个具体方法由抽象类声明并实现，而子类并不实现或置换。可以添加<code>final</code>关键字做强约束不可重写，比如<code>getResultSet()</code></li>
<li><strong>钩子方法(Hook Method)<strong>：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个</strong>空实现</strong>，作为方法的默认实现。譬如有些框架的<code>init()</code>方法，用户可以实现也可以不实现，定义成<code>abstract</code>就不合适，所以框架会给个空方法</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我在工作当中也使用过 MongoTemplate、RedisTemplate 诸如此类，还从未仔细想过这些类为什么这样命名。直到这次张总通过 IDEA 强大的 <strong>Extract Superclass</strong> 重构手法，给我们展示一个 JdbcTemplate 如何浮出水面的过程，实在是醍醐灌顶，豁然开朗。有兴趣的同学可以看看这些框架的源代码，加深对模版方法模式的理解。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.runoob.com/design-pattern/template-pattern.html">模版方法模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html">《JAVA与模式》之模板方法模式</a></li>
<li><a href="https://en.wikipedia.org/wiki/Separation_of_concerns#Internet_protocol_stack">Separation of concerns - Wiki</a></li>
<li><a href="http://www.cnblogs.com/asis/p/architecture-Soc.html">架构漫谈系列之关注点分离</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>代码重构</tag>
      </tags>
  </entry>
  <entry>
    <title>Clean Code -- 第二节：报表参数填充案例</title>
    <url>/2018/05/07/Clean%20Code%20--%20%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%8A%A5%E8%A1%A8%E5%8F%82%E6%95%B0%E5%A1%AB%E5%85%85%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该系列源于<a href="http://zhangyi.xyz/">张逸总监</a>的 <strong>Clean Code</strong> 培训，包涵了如何写出高质量代码的思想、代码案例以及重构代码的实际演练。<a href="https://s2mple.xyz/2018/05/04/Clean%20Code%20--%20%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E4%B8%8E%20Paperboy%20%E6%A1%88%E4%BE%8B/">上一篇</a>我们介绍了迪米特法则（最小知识法则）、信息专家模式：数据和行为应该封装在一起，并且通过 Paperboy 案例实操在 IntelliJ IDEA 中如何重构代码。本篇我们将通过报表参数填充案例来加深理解，并见识 IDEA 中更为强大的重构功能。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><strong>IntelliJ IDEA</strong>，相比 Eclipse，IDEA 在重构方面十分优秀，结合快捷键，使用起来让人赏心悦目。</li>
<li><strong>示例代码</strong>地址 <a href="https://github.com/agiledon/cleancode.git">https://github.com/agiledon/cleancode.git</a> ，进行实际操作有助于加深理解和记住快捷键。代码有两个分支，master 分支为重构前的代码，<strong>after-refactoring</strong> 分支为重构后代码，可以使用快捷键 <code>Cmd + D</code> 查看<strong>代码差异</strong>。</li>
<li><strong>活用快捷键</strong>，本人使用的 IDEA 快捷键为 Mac OS X 10.5+ 。Windows 用户将 <code>Cmd</code> 替换成 <code>Ctrl</code>，或者在 IDEA 的 <strong>Refactor</strong> 菜单中查看快捷键。</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + T</td>
<td>重构菜单</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>重命名方法、属性、文件</td>
</tr>
<tr>
<td>Cmd + Alt + M</td>
<td>提取方法（extract method）</td>
</tr>
<tr>
<td>Cmd + Alt + N</td>
<td>内联（Inline），与 extract 相反</td>
</tr>
<tr>
<td>Cmd + Shift + 上下箭头</td>
<td>上下移动声明体（statement）</td>
</tr>
</tbody></table>
<h2 id="案例：报表系统之参数处理"><a href="#案例：报表系统之参数处理" class="headerlink" title="案例：报表系统之参数处理"></a>案例：报表系统之参数处理</h2><p>在示例项目中，需要对客户发出的 Web 请求进行处理，获得需要的参数。参数的值放在 Request 中，实现根据配置文件获得了参数的类型信息。根据项目需求，将参数划分为三种：</p>
<ul>
<li>单一参数（SimpleParameter）</li>
<li>元素项参数（ItemParameter）</li>
<li>表参数（TableParameter）</li>
</ul>
<p>因为参数的属性是在配置文件中已经配好，所以定义了 ParameterGraph 对象。它能够读取参数的配置信息，并根据参数的类型创建不同的参数类，这些参数类共同实现了 Parameter 接口。</p>
<p>最初的实现代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterCollector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillParameters</span><span class="params">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (para <span class="keyword">instanceof</span> SimpleParameter) &#123;</span><br><span class="line">                SimpleParameter simplePara = (SimpleParameter) para;</span><br><span class="line">                String[] values = request.getParameterValues(simplePara.getName());</span><br><span class="line">                simplePara.setValue(values);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (para <span class="keyword">instanceof</span> ItemParameter) &#123;</span><br><span class="line">                    ItemParameter itemPara = (ItemParameter) para;</span><br><span class="line">                    <span class="keyword">for</span> (Item item : itemPara.getItems()) &#123;</span><br><span class="line">                        String[] values = request.getParameterValues(item.getName());</span><br><span class="line">                        item.setValues(values);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    TableParameter tablePara = (TableParameter) para;</span><br><span class="line">                    String[] rows =</span><br><span class="line">                            request.getParameterValues(tablePara.getRowName());</span><br><span class="line">                    String[] columns =</span><br><span class="line">                            request.getParameterValues(tablePara.getColumnName());</span><br><span class="line">                    String[] dataCells =</span><br><span class="line">                            request.getParameterValues(tablePara.getDataCellName());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> columnSize = columns.length;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns.length; j++) &#123;</span><br><span class="line">                            TableParameterElement element = <span class="keyword">new</span> TableParameterElement();</span><br><span class="line">                            element.setRow(rows[i]);</span><br><span class="line">                            element.setColumn(columns[j]);</span><br><span class="line">                            element.setDataCell(dataCells[columnSize * i + j]);</span><br><span class="line">                            tablePara.addElement(element);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察代码，<code>if statement</code>中的三段代码块其实做的都是<strong>填充参数</strong>的事，只不过用<code>instanceof</code>判断了参数类型再执行对应的填充操作。结合之前的 Paperboy 案例，与 Wallet 打交道的应该是 Customer 而不是 Paperboy。上述代码明显也违反了迪米特法则，<strong>参数填充的行为应该交由参数类完成而不是 ParameterCollector</strong>。</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>基于代码重用的思想，先将三段代码 <strong>提取方法（Cmd + Alt + M）</strong>，并分别取名为<code>fillSimplePara()</code>、<code>fillItemPara()</code>、<code>fillTablePara()</code>，重构后的方法顺序可能有所差异，可以在方法签名上使用 <strong>Cmd + Shift + ⬆️/ ⬇️</strong> 快捷键移动方法顺序，使之符合正常的阅读习惯。</p>
<p><img src="/0.png" alt="A6C5B629-ACC6-458A-8379-852021771E83"></p>
<p>提取了方法后，这一幕是不是似曾相识？之前的 Paperboy 案例中，我们从<code>charge()</code>方法中提取了<code>pay()</code>方法，意识到<code>pay()</code>方法应该归属于 Customer 而不是 Paperboy。这里就要再次强调：<strong>数据和行为应该封装在一起</strong>。显然，ParameterCollector 这个类不应该关注如何填充参数，而是应该收到<code>fillParameters()</code>请求后<strong>委派</strong>给各个 Parameter 类完成填充操作。所以我们采取“<strong>Move Method</strong>”重构手法（<strong>F6</strong>）。</p>
<p><img src="/1.png" alt="17C89C7E-DA4F-4914-AA2A-5F6C8DE8845E"></p>
<p>注意，IDEA 通过入参智能提示可以将方法移动到两个类中，显然应该选择 SimpleParameter，同时，方法的访问权限应为 public。接下来分别将<code>fillItemPara()</code>和<code>fillTablePara()</code>方法移动至 ItemParameter 和 TableParameter 中。</p>
<p><img src="/2.png" alt="8FB216EF-394B-42F3-B556-6EC576224FE7"></p>
<p>观察上图你会发现，原先的方法有两个参数，但由于我们移动了方法到对应的 Parameter 类中，第二个参数直接变成了用<code>this</code>引用当前对象。<code>ItemParameter itemPara = this;</code>这一步是多余的，直接使用<strong>内联（Cmd + Alt + N</strong>）消除。然后呢，别着急，我们想一想，既然 SimpleParameter、ItemParameter、TableParameter 三个类都有接收一个 request 参数的填充方法，而且他们都实现了 Parameter 接口，那我们为什么不将方法提到接口中，让其他三个类去重写呢？所以接下来先把方法都重命名为<code>fill()</code>，使用 <strong>Shift + F6</strong>进行重命名。</p>
<p><img src="/3.png" alt="74F483BA-13C8-4769-9E94-290369E2B41B-1"></p>
<p>接着，不要傻乎乎的去 Parameter 接口中手写<code>fill()</code>抽象方法，还是有快捷键的！那就是 “<strong>Pull Members Up</strong>”重构手法，说真的，当时看张总演示我就震惊了！选中方法，使用 <strong>Ctrl + T</strong> 调出重构菜单，输入一个 pull 你就能看到提示了。<br><img src="/4.png" alt="C477A0C4-7E53-4C85-BE02-4A37697680B5"></p>
<p>IDEA 会提示你将<code>pull()</code>方法提升至 Parameter 接口中并 make abstract。<br><img src="/5.png" alt="9E0BC21E-0DFB-47AF-8B9E-C99900755E7F"></p>
<p>我们看看重构后的效果，甚至于 ItemParameter 的<code>fill()</code>方法还已经帮你添加了<code>@Override</code>注解，但是剩下的两个 Parameter 类中的<code>fill()</code>方法还需要你手动的添加注解。</p>
<p><img src="/6.png" alt="0007121B-DCAA-4629-B1EB-911959D12455"> <img src="/7.png" alt="FE508CEB-BABF-4D6F-830E-A6C126BCD693"></p>
<p>最后我们回到 ParameterCollector 类，使用 IDEA 的<strong>智能辅助</strong>快捷键（<strong>Alt + Enter</strong>）去 Cleanup code 删除多余的类型转换。</p>
<p><img src="/8.png" alt="5A6909D5-21DC-45BB-B3F0-02ECE946EC10"></p>
<p>然后，你就会发现，<code>if statement</code>也是多余的，删除后，<strong>Cmd + Alt + L</strong> 格式化代码。</p>
<p><img src="/9.png" alt="91715C62-8438-4C16-BE77-0C821007877A"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如此，重构过的代码，可谓是层次清晰、一目了然，可比原来一坨堆在 ParameterCollector 中要美观多了。在重构的过程中，我们意识到，<strong>填充参数的行为应该交由它的专家，即各个 Parameter 类管理</strong>，移动方法后，又意识到既然都实现了 Parameter 接口，就应当使用 Java 接口的特性将<code>fill()</code>提升到 Parameter 接口中成为一个抽象方法。至此，<code>if</code>语句和<code>instanceof</code>也都不需要了，交由 JVM 在运行时识别类类型即可。所以说，<strong>重构的过程还可以帮助程序员梳理编码过程，进行合理的抽象和封装</strong>。当然，没有实践的空想理论是不行的，牢记 IDEA 的快捷键，将重构养成习惯，不时来一波亮瞎狗眼的骚操作，岂不美滋滋？</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>代码重构</tag>
      </tags>
  </entry>
  <entry>
    <title>DataCon2020 加密恶意流量检测初赛 Writeup 及总结反思</title>
    <url>/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<h2 id="初赛题目"><a href="#初赛题目" class="headerlink" title="初赛题目"></a>初赛题目</h2><p>主办方提供了 black/white/test 三个 pcap 文件夹，其中 black 和 white 分别是检测出有/无恶意软件感染的客户端 IP 组，要求选手对 test 数据集进行判定。</p>
<p><img src="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/0.png" alt="09bda35ff290f2e34d88d50e71d98f1a.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题的解题过程应分为以下三个大步骤：</p>
<ol>
<li><strong>特征选择（Feature Selection）</strong>，选取对于区分正常/恶意流量有明显作用的 Features。</li>
<li><strong>特征提取（Feature Extraction）</strong>，从 pcap 文件中提取上述 Features，并转换为模型训练所需要的格式。我们选择的特征提取工具为 <strong>Zeek</strong>。</li>
<li><strong>模型训练（Model Training）</strong>，选择合适的机器学习模型对三类 pcap 文件进行训练和预测。我们选择的 Python 机器学习库为 <strong>scikit-learn</strong>。</li>
</ol>
<h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><h3 id="合并pcap文件"><a href="#合并pcap文件" class="headerlink" title="合并pcap文件"></a>合并pcap文件</h3><p>主办方提供的 pcap 文件，其中 white/black 各有 1500 个 pcap，test 2000 个 pcap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  tree eta_1 </span><br><span class="line">eta_1</span><br><span class="line">├── black</span><br><span class="line">│   ├── 192.168.10.91.pcap</span><br><span class="line">│   ├── 192.168.44.25.pcap</span><br><span class="line">│   ├── ...</span><br><span class="line">│   └── 192.168.80.115.pcap</span><br><span class="line">├── test</span><br><span class="line">│   ├── 192.168.150.71.pcap</span><br><span class="line">│   ├── 192.168.150.99.pcap</span><br><span class="line">│   ├── ...</span><br><span class="line">│   └── 192.168.210.239.pcap</span><br><span class="line">└── white</span><br><span class="line">    ├── 192.168.119.23.pcap</span><br><span class="line">    ├── 192.168.122.37.pcap</span><br><span class="line">		├── ...</span><br><span class="line">    └── 192.168.96.180.pcap</span><br></pre></td></tr></table></figure>

<p>使用 <code>mergecap</code> 命令将 pcap 文件合并为三个大的 pcap 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  mergecap -w black.pcap ./eta_1/black/*.pcap</span><br><span class="line">➜  tree -s -h .     </span><br><span class="line">.</span><br><span class="line">├── [418M]  black.pcap</span><br><span class="line">├── [1.0G]  test.pcap</span><br><span class="line">└── [1.7G]  white.pcap</span><br></pre></td></tr></table></figure>

<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>参考了多篇加密恶意流量检测的研究论文，我们初步确定了以下四类需要提取的 Features，包括<strong>TLS客户端指纹信息</strong>、<strong>数据包元数据</strong>、<strong>HTTP头部信息</strong>和<strong>DNS响应信息</strong>。</p>
<h4 id="TLS-client-fingerprinting："><a href="#TLS-client-fingerprinting：" class="headerlink" title="TLS client fingerprinting："></a>TLS client fingerprinting：</h4><p>在进行TLS握手时，会进行如下几个步骤：</p>
<ol>
<li><strong>Client Hello</strong>，客户端提供支持的加密套件数组（cipher suites）；</li>
<li><strong>Server Hello</strong>，由服务器端选择一个加密套件，传回服务器端公钥，并进行认证和签名授权（<strong>Certificate</strong> + Signature）；</li>
<li>客户端传回客户端公钥（<strong>Client Key Exchange</strong>），客户端确立连接；</li>
<li>服务器端确立连接，开始 HTTP 通信。</li>
</ol>
<p><img src="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/1.png" alt="5b01483a65bdc17c68873508796bb85e.png"></p>
<p>以上加粗的四种消息类型可以通过 TLS 握手协议的 <strong>Handshake Type</strong> 做区分：</p>
<p><img src="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/2.png" alt="bff6a460bcaa7c442014c3eb89deb26f.png"></p>
<p>基于此，我们选取了以下特征：</p>
<ul>
<li><strong>客户端支持的加密套件数组</strong>（Cipher suites），<strong>服务器端选择的加密套件</strong>。</li>
<li><strong>支持的扩展</strong>（TLS extensions），若分别用向量表示客户端提供的密码套件列表和 TLS 扩展列表，可以从服务器发送的确认包中的信息确定两组向量的值。</li>
<li><strong>客户端公钥长度</strong>（Client public key length），从密钥交换的数据包中，得到密钥的长度。</li>
<li><strong>Client version</strong>，the preferred TLS version for the client</li>
<li><strong>是否非CA自签名</strong>，统计数据表示，恶意流量约70%出现非CA认证服务器且自签名的情况，非恶意流量约占0.1%。此项判断的依据是：未出现 <code>CA: True</code> 字段（默认非 CA 机构）且 <code>signedCertificate</code> 中的 <code>issuer</code> 字段等于 <code>subject</code> 字段。</li>
</ul>
<h4 id="数据包元数据："><a href="#数据包元数据：" class="headerlink" title="数据包元数据："></a>数据包元数据：</h4><ul>
<li><strong>数据包的大小</strong>，数据包的长度受 UDP、TCP 或者 ICMP 协议中数据包的有效载荷大小影响，如果数据包不属于以上协议，则被设置为 IP 数据包的大小。</li>
<li><strong>到达时间序列</strong></li>
<li><strong>字节分布</strong></li>
</ul>
<h4 id="HTTP头部信息："><a href="#HTTP头部信息：" class="headerlink" title="HTTP头部信息："></a>HTTP头部信息：</h4><ul>
<li><strong>Content-Type</strong>，正常流量 HTTP 头部信息汇总值多为 <code>image/*</code>，而恶意流量为 <code>text/*、text/html、charset=UTF-8</code> 或者 <code>text/html;charset=UTF-8</code>。</li>
<li><strong>User-Agent</strong></li>
<li><strong>Accept-Language</strong></li>
<li><strong>Server</strong></li>
<li><strong>HTTP响应码</strong></li>
</ul>
<h4 id="DNS响应信息："><a href="#DNS响应信息：" class="headerlink" title="DNS响应信息："></a>DNS响应信息：</h4><ul>
<li><strong>域名的长度</strong>：正常流量的域名长度分布为均值为6或7的高斯分布（正态分布）；而恶意流量的域名（FQDN全称域名）长度多为6（10）。</li>
<li><strong>数字字符及非字母数字(non-alphanumeric character)的字符占比</strong>：正常流量的DNS响应中全称域名的数字字符的占比和非字母数字字符的占比要大。</li>
<li><strong>DNS解析出的IP数量</strong>：大多数恶意流量和正常流量只返回一个IP地址；其它情况，大部分正常流量返回2-8个IP地址，恶意流量返回4或者11个IP地址。</li>
<li><strong>TTL值</strong>：正常流量的TTL值一般为60、300、20、30；而恶意流量多为300，大约22%的DNS响应汇总TTL为100，而这在正常流量中很罕见。</li>
<li><strong>域名是否收录在Alexa网站</strong>：恶意流量域名信息很少收录在Alexa top-1,000,000中，而正常流量域名多收录在其中。</li>
</ul>
<h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>特征提取我们采用的工具是 <strong>Zeek</strong>，它的前身是 Bro，一款网络安全监视（Network Security Monitoring）工具，它定义了自己的 DSL 语言，支持直接处理 pcap 文件生成各类日志文件，包括 dns、http、smtp 等：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ls</span><br><span class="line">conn.log	dhcp.log		 files.log	infected.pcap	  packet_filter.log	  smb_files.log	</span><br><span class="line">smtp.log	lce_rpc.log	 dns.log	  http.log	 kerberos.log	   pe.log		smb_mapping.log	</span><br><span class="line">ssl.log		weird.log		 x5Q9.log</span><br></pre></td></tr></table></figure>



<p>Zeek 网上有一些现成的脚本，我们采用的是 <strong>Zeek FlowMeter</strong>，它基于 OSI 七层协议的网络层和传输层，可以分析并生成一些 Packets 到达时间序列、Packet 字节大小和元数据等新特征。</p>
<p>在使用时，我们需要在 <code>local.zeek</code> 配置文件中加入 <code>@load flowmeter</code>，这样 Zeek 在执行时会加载 <code>flowmeter.zeek</code> 并生成对应的 <code>flowmeter.log</code>，下面列出了 FlowMeter 提取出的一些特征，包括上下行包总数、包负载均值方差等。其他详细的特征请见 <a href="https://github.com/zeek-flowmeter/zeek-flowmeter">zeek-flowmeter GitHub官方文档</a>。</p>
<table>
<thead>
<tr>
<th>Feature Name</th>
<th>Description</th>
<th>exists in FlowMeter</th>
</tr>
</thead>
<tbody><tr>
<td>uid</td>
<td>The ID of the flow as given by Zeek</td>
<td>No</td>
</tr>
<tr>
<td>flow_duration</td>
<td>The length of the flow in seconds (maximal precision ms). If only on packet was seen the duration is 0.</td>
<td>Yes</td>
</tr>
<tr>
<td>fwd_pkts_tot</td>
<td>The number of packets travelling in the forward direction.</td>
<td>Yes</td>
</tr>
<tr>
<td>bwd_pkts_tot</td>
<td>The number of packets travelling in the backwards direction.</td>
<td>Yes</td>
</tr>
<tr>
<td>fwd_pkts_per_sec</td>
<td>The average number of forward packets transmitted per second during the flow. If the duration is 0 then this feature is also set to 0.</td>
<td>Yes</td>
</tr>
<tr>
<td>fwd_pkts_payload.avg</td>
<td>The average payload size, in bytes, seen in the forward direction.</td>
<td>Yes</td>
</tr>
<tr>
<td>fwd_pkts_payload.std</td>
<td>The standard deviation of the payload size, in bytes, seen in the forward direction.</td>
<td>Yes</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>除 <code>flowmeter.log</code> 之外我们还需要关注 <code>conn.log</code>、<code>ssl.log</code> 和 <code>X509.log</code>。这几个日志共同字段 <code>uid</code> 是 Zeek 根据一次连接的源/目的 IP、源/目的端口四元组生成的唯一 ID。为了方便后续的处理，我们将这几个日志文件统一读入，使用 <code>uid</code> 字段连接后转成 csv 格式输出到文件。<strong>最终我们提取的特征如下：</strong></p>
<p><img src="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/3.jpeg" alt="7d1475ca9c4d88e2c3e078a126fdfd52.jpeg"></p>
<h3 id="特征向量化"><a href="#特征向量化" class="headerlink" title="特征向量化"></a>特征向量化</h3><p>因为模型训练不支持 <code>str</code> 类型的特征，所以需要对 <code>version</code> 和 <code>server_cipher</code> 等字段进行特征向量化。</p>
<table>
<thead>
<tr>
<th>version</th>
<th>cipher</th>
</tr>
</thead>
<tbody><tr>
<td>TLSv10</td>
<td>TLS_RSA_WITH_3DES_EDE_CBC_SHA</td>
</tr>
<tr>
<td>TLSv10</td>
<td>TLS_RSA_WITH_3DES_EDE_CBC_SHA</td>
</tr>
<tr>
<td>TLSv12</td>
<td>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</td>
</tr>
<tr>
<td>TLSv10</td>
<td>TLS_RSA_WITH_RC4_128_MD5</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p><code>DictVectorizer</code> 是 scikit-learn 库中用于将 Python <code>dict</code> 对象表示的特征数组转换为 scikit-learn Estimator 使用的 NumPy/SciPy 表示形式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_by_dict</span>(<span class="params">src_file, dest_file</span>):</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line">    vec = DictVectorizer()</span><br><span class="line"></span><br><span class="line">    df = pd.read_csv(src_file)</span><br><span class="line">    vs1 = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: &#123;<span class="string">&#x27;version&#x27;</span>: x&#125;, df[<span class="string">&#x27;version&#x27;</span>]))</span><br><span class="line">    vs2 = vec.fit_transform(vs1).toarray()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(vec.get_feature_names()):</span><br><span class="line">        df[name] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x[index]), vs2))</span><br><span class="line"></span><br><span class="line">    df.to_csv(dest_file, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>向量化后的效果：</p>
<table>
<thead>
<tr>
<th>version=SSLv3</th>
<th>version=TLSv10</th>
<th>version=TLSv12</th>
<th>version=TLSv11</th>
<th>cipher=TLS_RSA_WITH_3DES_EDE_CBC_SHA</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>另外需要注意的是，<strong>需要对特征列进行补全</strong>，否则在进行模型训练时会出现特征个数不匹配的问题。例如：white.pcap 文件中 TLS versions 包含 <code>[&#39;TLSv1.0&#39;, &#39;TLSv1.2&#39;, &#39;SSLv3&#39;]</code> 三个版本，而 black 和 test 的 pcap 文件中除这三个版本外还包含 <code>&#39;TLSv1.1&#39;</code> 版本，所以需要在 white 中加入 <code>version=TLSv1.1</code> 全为 0 的列。</p>
<h3 id="模型选取及参数"><a href="#模型选取及参数" class="headerlink" title="模型选取及参数"></a>模型选取及参数</h3><p>需要注意的是：white 已明确没有被恶意软件感染，所以产生的流量可以全部标注为正常流量，而 black 明确的只是客户端感染了恶意软件，但产生的流量不一定全为恶意流量。所以实际上是<strong>对不平衡样本数据进行训练和预测</strong>。遵循这个思路，可以采用 <strong>Anomaly Detector</strong> + <strong>Misuse Detector</strong> 的联合分类器进行训练。</p>
<p><img src="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/4.png" alt="fe7a1c020a03492fd8b465e8541a410e.png"></p>
<p>基于全正常流量的 white.pcap 文件进行 <strong>one-class classification</strong> 训练异常检测器 Anomaly Detector；再用该分类器对 black.pcap 文件进行推理预测恶意流量；结合 black 中检测的恶意流量和 white 正常流量训练二分类器；最终采用二分类器对 test 中的流量进行检测。</p>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>数据集是我们之前经过 Zeek 特征提取、特征向量化后产生的 <code>white.csv</code>、<code>black.csv</code> 和 <code>test.csv</code> 三个 csv 文件，使用 pandas 读入后定义一个列名数组 <code>data_f</code> 来获取相应特征：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">white_df = pd.read_csv(<span class="string">&quot;white.csv&quot;</span>,index_col=<span class="number">0</span>)</span><br><span class="line">black_df = pd.read_csv(<span class="string">&quot;black.csv&quot;</span>,index_col=<span class="number">0</span>)</span><br><span class="line">test_df = pd.read_csv(<span class="string">&quot;test.csv&quot;</span>,index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">white_flow = white_df[data_f]</span><br><span class="line">black_flow = black_df[data_f]</span><br><span class="line">test_flow = test_df[data_f]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源 IP 用于生成结果 result.txt 文件时使用</span></span><br><span class="line">test_ip = test_df[<span class="string">&#x27;id.oirg_h&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>将 white_flow 和 black_flow 两个数据集合并做归一化处理，得到total_data：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">merge_flow = white_flow.append(black_flow, ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">min_max_scaler = preprocessing.MinMaxScaler()</span><br><span class="line">total_data = min_max_scaler.fit_transform(merge_flow.values)</span><br></pre></td></tr></table></figure>

<p>然后我们从 total_data 中提取 white 的训练集和测试集，同时需要提取 black 的测试集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># white 训练集和测试集(标签1表示正常流量)</span></span><br><span class="line">x_train,x_valid,y_train,y_valid=train_test_split(total_data[<span class="number">0</span>:<span class="number">4834</span>],np.ones(<span class="number">4834</span>,np.<span class="built_in">int</span>),random_state=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># black 测试集</span></span><br><span class="line">black_data = total_data[<span class="number">4834</span>:]</span><br></pre></td></tr></table></figure>

<h4 id="Anomaly-Detector"><a href="#Anomaly-Detector" class="headerlink" title="Anomaly Detector"></a>Anomaly Detector</h4><p>在 black 数据集中同时存在恶意流量和正常流量，没有明确的标注，无法直接用于训练分类器。而 white 数据集中都是正常流量，可以先用 white 数据集来训练一个 Anomaly Detector 分类器。然后用这个分类器在 black 数据集中推理得到哪些是恶意流量。我们的模型选取的隔离森林 <code>IsolationForest</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = IsolationForest(max_samples=<span class="built_in">len</span>(x_train), contamination=<span class="number">0.3</span>)</span><br><span class="line">clf.fit(x_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证集正确率</span></span><br><span class="line">y_pred_valid = clf.predict(x_valid)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;valid_accuracy：&quot;</span> + <span class="built_in">str</span>(np.mean(y_valid == y_pred_valid)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由 black 测试集得到的恶意流量占比</span></span><br><span class="line">y_black_test = clf.predict(black_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;black_anomaly_ratio：&quot;</span> + <span class="built_in">str</span>(<span class="number">1</span> - np.mean(y_black_test==np.ones(<span class="number">3980</span>, np.<span class="built_in">int</span>))))</span><br></pre></td></tr></table></figure>

<h4 id="训练误用检测器-Misuse-Detector"><a href="#训练误用检测器-Misuse-Detector" class="headerlink" title="训练误用检测器 Misuse Detector"></a>训练误用检测器 Misuse Detector</h4><p>假设这些由异常检测器识别的可疑流量是恶意流量，我们就有了恶意流量的标注。接下来我们用这些恶意流量 labels，结合 white 数据集中的正常流量 labels，来训练一个 Misuse Detector。我们选取了 XGBoost 基于树的模型，目标选取为多分类问题（分类数为2）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># XGbooster Model     gbtree    multi:softmax   2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># label标签  1:white  0:black</span></span><br><span class="line">white_flow[<span class="string">&#x27;label&#x27;</span>] = <span class="number">1</span></span><br><span class="line">black_flow[<span class="string">&#x27;label&#x27;</span>] = y_black_test</span><br><span class="line">black_flow[<span class="string">&#x27;label&#x27;</span>] = black_flow[<span class="string">&#x27;label&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留 black 中的恶意流量数据</span></span><br><span class="line">balack_anomaly_flow = black_flow[black_flow[<span class="string">&#x27;label&#x27;</span>] == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到模型训练数据集</span></span><br><span class="line">model_data = white_flow.append(balack_anomaly_flow, ignore_index=<span class="literal">True</span>) </span><br></pre></td></tr></table></figure>

<p>下一步对于数据做 Max/Min 归一化，然后分割出训练集、验证集、测试集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Max/Min 归一化</span></span><br><span class="line">X_flow = model_data[data_f]</span><br><span class="line">label_flow = model_data[<span class="string">&#x27;label&#x27;</span>].values</span><br><span class="line">model_total_flow = X_flow.append(test_flow, ignore_index=<span class="literal">True</span>)</span><br><span class="line">data_normal = preprocessing.scale(model_total_flow.values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分出训练集和测试集</span></span><br><span class="line">model_train = data_normal[:model_data.shape[<span class="number">0</span>]]</span><br><span class="line">model_test = data_normal[model_data.shape[<span class="number">0</span>]:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集中分割出验证集(根据 label_flow 来层次化分割)</span></span><br><span class="line">X_train, X_valid, Y_train, Y_valid = train_test_split(model_train, label_flow, random_state=<span class="number">50</span>,stratify = label_flow)</span><br><span class="line"></span><br><span class="line">xgboost_train = xgb.DMatrix(X_train, label=Y_train)</span><br><span class="line">xgboost_valid = xgb.DMatrix(X_valid, label=Y_valid)</span><br></pre></td></tr></table></figure>

<p>进行 XGBoost 模型训练：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalerror</span>(<span class="params">preds, dtrain</span>):</span>    </span><br><span class="line">    labels = dtrain.get_label()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;error&#x27;</span>, math.sqrt(metrics.mean_squared_error(preds,labels))</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;booster&#x27;</span>: <span class="string">&#x27;gbtree&#x27;</span>,  <span class="comment"># 树模型</span></span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;multi:softmax&#x27;</span>,  <span class="comment"># 多分类</span></span><br><span class="line">    <span class="string">&#x27;num_class&#x27;</span>: <span class="number">2</span>,  <span class="comment"># 类别数</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;gamma&#x27;</span>: <span class="number">0.1</span>,  <span class="comment"># 指定了节点分裂所需的最小损失函数下降值，越大越不易分裂</span></span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">7</span>,  <span class="comment"># 树的深度</span></span><br><span class="line">    <span class="string">&#x27;subsample&#x27;</span>: <span class="number">0.75</span>,  <span class="comment"># 每棵树随机采样的占比（训练集中）</span></span><br><span class="line">    <span class="string">&#x27;colsample_bytree&#x27;</span>: <span class="number">0.75</span>,  <span class="comment"># 每棵树随机采样的列数的占比（每一列是一个特征）</span></span><br><span class="line">    <span class="string">&#x27;min_child_weight&#x27;</span>: <span class="number">0.06</span>, <span class="comment"># 决定最小叶子节点样本权重和</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;eta&#x27;</span>: <span class="number">0.05</span>,  <span class="comment"># 学习率</span></span><br><span class="line">    <span class="string">&#x27;seed&#x27;</span>: <span class="number">100</span>, <span class="comment"># 随机种子</span></span><br><span class="line">    <span class="string">&#x27;nthread&#x27;</span>: <span class="number">6</span>  <span class="comment"># cpu 线程数</span></span><br><span class="line">&#125;</span><br><span class="line">rounds = <span class="number">200</span> <span class="comment"># 迭代次数</span></span><br><span class="line">watchlist = [(xgboost_train, <span class="string">&#x27;train&#x27;</span>), (xgboost_valid, <span class="string">&#x27;valid&#x27;</span>)]</span><br><span class="line">bst = xgb.train(params, xgboost_train, rounds, watchlist,feval=evalerror)</span><br></pre></td></tr></table></figure>

<p>用模型去预测结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test 数据集上使用模型进行预测</span></span><br><span class="line">xgboost_test = xgb.DMatrix(model_test)</span><br><span class="line">y_predicted = bst.predict(xgboost_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_ip.txt 是 test 文件夹中的所有文件名</span></span><br><span class="line">ip = pd.read_table(<span class="string">&#x27;test_ip.txt&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名去掉对应的 .pcap 就是要预测的 IP</span></span><br><span class="line">ip[<span class="number">0</span>] = ip[<span class="number">0</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x.replace(<span class="string">&#x27;.pcap&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">ip_list = <span class="built_in">list</span>(ip[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先将所有客户端 IP 对应的类型标记为 white</span></span><br><span class="line">ip[<span class="number">1</span>] = [<span class="string">&#x27;white&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ip.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历预测结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_predicted)):</span><br><span class="line">    <span class="comment"># 如果第 i 条流量为 black</span></span><br><span class="line">    <span class="keyword">if</span> y_predicted[i] == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 读取第 i 条流量的源 IP</span></span><br><span class="line">        tmp_ip = <span class="built_in">list</span>(test_ip[i:i+<span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历所有要预测的客户端 IP</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ip_list)):</span><br><span class="line">            <span class="comment"># 如果是第 i 条流量（恶意）的源 IP</span></span><br><span class="line">            <span class="keyword">if</span> tmp_ip == ip_list[j]:</span><br><span class="line">            <span class="comment"># 将该客户端 IP 标记为 black</span></span><br><span class="line">                ip.loc[j,<span class="number">1</span>] = <span class="string">&#x27;black&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test 数据集恶意 IP 计数</span></span><br><span class="line">malware_ip_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ip.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">if</span> ip.loc[i,<span class="number">1</span>] == <span class="string">&#x27;black&#x27;</span>:</span><br><span class="line">        malware_ip_count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test数据集恶意ip个数&quot;</span> + <span class="built_in">str</span>(malware_ip_count) )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将最终结果写入 result.txt</span></span><br><span class="line">ip.to_csv(<span class="string">&#x27;result.txt&#x27;</span>,sep=<span class="string">&#x27;,&#x27;</span>,index=<span class="literal">False</span>,header=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h2 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h2><p>这次比赛几次提交点的最好成绩是 72.5 分，距离复赛要求的名次差几名，很遗憾无缘复赛。总结了失利的几点原因：</p>
<ol>
<li>对恶意流量的特征不熟悉，导致花了很多时间去确定需要提取哪些 Features，浪费了前面的检查点。其实我们最后提取的 Features 还有很大的提升空间，比如数据包的时间序列特征，我们只提取了均值、方差等特征，还有字节分布等重要特征未进行有效提取。<br><img src="/2020/08/09/DataCon2020%20%E5%8A%A0%E5%AF%86%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%88%9D%E8%B5%9B%20Writeup%20%E5%8F%8A%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/5.png" alt="e67c9834b783a0c2b314e2dd35719671.png"></li>
<li>对模型的选择和参数认识不够，只是盲目的更换模型和调参，一开始发现模型和参数对结果的影响很大，实际上还是特征提取的不够好。当提取了能有效区分正常/恶意流量的特征后，模型的选择和参数对结果影响就较小了，所以最重要的依然是有效特征的提取。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Shekhawat, A. S. (2018). <em>Analysis of Encrypted Malicious Traffic.</em></li>
<li>Jenseg, O. (2019). <em>A machine learning approach to detecting malware in TLS traffic using resilient network features (Master’s thesis, NTNU).</em></li>
<li>Shekhawat, A. S., Di Troia, F., &amp; Stamp, M. (2019). <em>Feature analysis of encrypted malicious traffic. Expert Systems with Applications, 125, 130-141.</em></li>
<li><a href="https://medium.com/@melanijan93/https-medium-com-melanijan93-analysing-pcaps-with-bro-zeek-33340e710012">Analysing PCAPs with Bro/Zeek</a></li>
<li><a href="https://www.intechopen.com/online-first/machine-learning-applications-in-misuse-and-anomaly-detection">Machine Learning Applications in Misuse and Anomaly Detection</a></li>
<li><a href="https://machinelearningmastery.com/imbalanced-classification-with-python/">imbalanced-classification-with-python</a></li>
<li><a href="https://github.com/scikit-learn/scikit-learn/blob/master/doc/modules/feature_extraction.rst">scikit-learn GitHub doc: Feature extraction</a></li>
<li><a href="https://www.secrss.com/articles/18679">基于机器学习的TLS恶意加密流量检测方案</a></li>
<li><a href="https://www.cnblogs.com/bonelee/p/9604530.html">利用背景流量数据（contexual flow data）识别TLS加密恶意流量</a></li>
</ul>
]]></content>
      <categories>
        <category>Projects</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 新特性</title>
    <url>/2017/12/29/ES6%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>ES6</strong>（or <strong>ECMAScript 6</strong>）规定了新一代的 <strong>JavaScript</strong> 语法，其中含有许多必要且实用的新特性。尤其是加入了一些<strong>语法糖</strong>使我们代码更简洁明了。本文所有代码都在浏览器的 <strong>JavaScript</strong> 控制台或者 <strong>Node</strong> 环境下运行过，输出结果在<code>// result:</code>注释后。</p>
<h2 id="Arrows"><a href="#Arrows" class="headerlink" title="Arrows"></a>Arrows</h2><blockquote>
<p><strong>箭头函数</strong>是使用 <strong>=&gt;</strong> 语法缩写的一个函数（相当于<strong>匿名函数</strong>），左边是参数，右边可以是表达式（<strong>expression</strong>）或者声明体（<strong>statement bodies</strong>）。</p>
</blockquote>
<p><code>=&gt;</code>右边接表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>].map(<span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">1</span>))</span><br><span class="line"><span class="comment">// result: [ 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure>

<p><code>=&gt;</code>右边接声明体：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>].forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(v &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br><span class="line"><span class="comment">// result: 4</span></span><br></pre></td></tr></table></figure>

<p>箭头函数可以和<strong>不定参数</strong>配合使用，下面代码定义了一个求和方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">...nums</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sumValue = <span class="number">0</span></span><br><span class="line">    nums.forEach(<span class="function"><span class="params">num</span> =&gt;</span> sumValue += num)</span><br><span class="line">    <span class="built_in">console</span>.log(sumValue)</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">// result: 7</span></span><br></pre></td></tr></table></figure>

<p>需要特别注意的是，箭头函数<strong>绑定this</strong>，这是和 <strong>function</strong> 定义是不同的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> std = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() _this.birth：</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">std.getAge()</span><br><span class="line"><span class="comment">// result: 28</span></span><br></pre></td></tr></table></figure>

<p>传统的写法我需要特地定义个<code>_this</code>让它指向当前这个 <strong>std</strong> 对象，而箭头函数绑定了上下文的 <strong>this</strong>，即调用该 <strong>function</strong> 的对象 <strong>std</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">std = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() <span class="built_in">this</span>.birth <span class="comment">// this指向std对象：</span></span><br><span class="line">        <span class="keyword">return</span> fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">std.getAge()</span><br><span class="line"><span class="comment">// result: 28</span></span><br></pre></td></tr></table></figure>

<h2 id="Let-Const"><a href="#Let-Const" class="headerlink" title="Let + Const"></a>Let + Const</h2><blockquote>
<p>ES6 新增了两个绑定了<strong>块作用域</strong>的声明变量的关键字 <strong>let</strong> 和 <strong>const</strong>。</p>
</blockquote>
<p><code>let</code>用法和<code>var</code>一样，但是限定了作用域。因为在 <strong>JavaScript</strong> 中，<code>var</code>定义全局变量，所以能不用<code>var</code>的地方就不用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">print(a) <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">print(b) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><code>const</code>声明一个只读的常量，并且必须<strong>初始化</strong>。一旦声明，常量的值就不能改变：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="comment">// Error: Missing initializer in const declaration</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">a = <span class="number">2</span> <span class="comment">// Error: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>阮一峰老师的<strong>ES6编程风格</strong>中明确指出在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在<strong>全局环境</strong>，不应该设置变量，只应设置常量。<strong>const优于let原因如下:</strong></p>
<ul>
<li><strong>const</strong>可以提醒阅读程序的人，这个变量不应该改变。</li>
<li><strong>const</strong>比较符合<strong>函数式编程思想</strong>，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算。</li>
<li><strong>JavaScript</strong> 编译器会对<strong>const</strong>进行优化，所以多使用<strong>const</strong>，有利于<strong>提高程序的运行效率</strong>，也就是说<strong>let</strong>和<strong>const</strong>的本质区别，其实是编译器内部的处理不同。<strong>所有的函数都应该设置为常量</strong>。</li>
</ul>
<h2 id="Template-Strings"><a href="#Template-Strings" class="headerlink" title="Template Strings"></a>Template Strings</h2><blockquote>
<p>ES6 引入了构造字符串的语法糖：<strong>模版字符串 `…`<strong>，使用</strong>反引号</strong>表示。它有两个作用，一是表示<strong>多行字符串</strong>，二是<strong>替换为绑定的变量值</strong>。</p>
</blockquote>
<p>多行字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行`</span>)</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// 第一行</span></span><br><span class="line"><span class="comment">// 第二行</span></span><br></pre></td></tr></table></figure>

<p>在模版字符串中使用<code>$&#123;property&#125;</code>替换为属性的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Bob&#x27;</span>, time = <span class="string">&#x27;today&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span>)</span><br><span class="line"><span class="comment">// result: Hello Bob, how are you today?</span></span><br></pre></td></tr></table></figure>

<h2 id="Default-Rest-Spread"><a href="#Default-Rest-Spread" class="headerlink" title="Default + Rest + Spread"></a>Default + Rest + Spread</h2><blockquote>
<p>参数的默认值、不定参数以及参数数组的展开。</p>
</blockquote>
<p>函数的参数可以<strong>指定默认值</strong>，调用时如果未指定将使用默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">12</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// f(3) -&gt; 15 </span></span><br><span class="line"><span class="comment">// f(3,4) -&gt; 7</span></span><br></pre></td></tr></table></figure>

<p><strong>不定参数</strong>使用<code>...</code>表示，它取代了之前的 <strong>arguments</strong>，适用于更常见的需求。如下例中 <strong>y</strong> 是一个参数数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, ...y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y.length</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// f(3,&#x27;abc&#x27;,10) -&gt; 6</span></span><br><span class="line"><span class="comment">// f(3,&#x27;abc&#x27;,10,&#x27;xyz&#x27;) -&gt; 9</span></span><br></pre></td></tr></table></figure>

<p>同时<code>...</code>还可以在函数调用时将数组转换成连续的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line">f(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">// result: 6</span></span><br></pre></td></tr></table></figure>

<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><blockquote>
<p><strong>for…of</strong> 是 ES6 新加入的遍历循环的操作，而传统的 <strong>for…in</strong> 循环由于历史遗留问题，它遍历的实际上是对象的<strong>属性名</strong>。</p>
</blockquote>
<p>我们用<code>for...in</code>遍历对象的<strong>属性名</strong>，需要用<code>o[prop]</code>来获取属性的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="attr">age</span>: <span class="number">11</span>&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> o) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;prop&#125;</span> is <span class="subst">$&#123;o[prop]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// name is Jack</span></span><br><span class="line"><span class="comment">// age is 11</span></span><br></pre></td></tr></table></figure>

<p>同样的，<strong>Array</strong> 实际上也是一个对象，它的每个元素的索引被视为一个属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>]</span><br><span class="line">arr.name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="comment">// actually arr is an object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* (3) [1, 4, 9, name: &quot;Jack&quot;]</span></span><br><span class="line"><span class="comment">0: 1</span></span><br><span class="line"><span class="comment">1: 4</span></span><br><span class="line"><span class="comment">2: 9</span></span><br><span class="line"><span class="comment">name: &quot;Jack&quot;</span></span><br><span class="line"><span class="comment">length: 3</span></span><br><span class="line"><span class="comment">__proto__: Array(0) */</span></span><br></pre></td></tr></table></figure>

<p>我们使用<code>for...in</code>去遍历数组，实际上<code>for...in</code>遍历的是数组的<strong>下标索引</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> arr) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`数组第<span class="subst">$&#123;index&#125;</span>个是<span class="subst">$&#123;arr[index]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// 数组第0个是1</span></span><br><span class="line"><span class="comment">// 数组第1个是4</span></span><br><span class="line"><span class="comment">// 数组第2个是9</span></span><br><span class="line"><span class="comment">// 数组第name个是Jack</span></span><br></pre></td></tr></table></figure>

<p>ES6 引入<code>for...of</code>循环，遍历的是集合本身的元素，可以用于遍历 <strong>Array、Set、Map</strong> 等：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> arr) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>name: &quot;Jack&quot;</code>被舍弃了，实际上也不推荐这种向数组添加属性的操作。</p>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.forEach(<span class="function">(<span class="params">value,index</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;index&#125;</span> : <span class="subst">$&#123;value&#125;</span>`</span>))</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// 0 : 1</span></span><br><span class="line"><span class="comment">// 1 : 4</span></span><br><span class="line"><span class="comment">// 2 : 9</span></span><br></pre></td></tr></table></figure>

<p>遍历一个 <strong>Map</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;Jack&#x27;</span>, <span class="number">11</span>], [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">13</span>], [<span class="string">&#x27;John&#x27;</span>, <span class="number">10</span>]])</span><br><span class="line">m.forEach(<span class="function">(<span class="params">value, key, map</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> is <span class="subst">$&#123;value&#125;</span> years old.`</span>))</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// Jack is 11 years old.</span></span><br><span class="line"><span class="comment">// Tom is 13 years old.</span></span><br><span class="line"><span class="comment">// John is 10 years old.</span></span><br></pre></td></tr></table></figure>

<h2 id="Destructuring"><a href="#Destructuring" class="headerlink" title="Destructuring"></a>Destructuring</h2><blockquote>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为**解构(Destructuring)**。</p>
</blockquote>
<p>可以利用数组和解构，一次性给多个变量赋值。同时可以很方便的<strong>交换</strong>两个变量值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换a、b的值</span></span><br><span class="line">[a, b] = [b, a]</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// a = 2</span></span><br><span class="line"><span class="comment">// b = 1</span></span><br></pre></td></tr></table></figure>

<p>也可以使用嵌套数组进行解构，左右两边的模版应该相同，不对应则变量值为<code>undefined</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, [[y], z]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]]</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// x = 1</span></span><br><span class="line"><span class="comment">// y = 2</span></span><br><span class="line"><span class="comment">// z = 3</span></span><br></pre></td></tr></table></figure>

<p>语法糖 <code>...</code> 被解构成一个数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,...rest] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// rest = [2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>解构还可以用于对象，<strong>需要注意:</strong> 数组的解构是按次序排列的，而对象的属性没有次序，所以<strong>变量必须与属性同名</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// foo = &quot;aaa&quot;</span></span><br><span class="line"><span class="comment">// bar = &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure>

<p>当不知道参数传入顺序时，可以将一组参数与变量名对应起来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> x + y - z</span><br><span class="line">&#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">// result: 0</span></span><br></pre></td></tr></table></figure>

<p>非常适合提取 <strong>JSON</strong> 对象中的属性值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, data &#125; = jsonData</span><br><span class="line"><span class="built_in">console</span>.log(id, status, data)</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br></pre></td></tr></table></figure>

<p>以及加载模块时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getTable, postLoginForm &#125; <span class="keyword">from</span> <span class="string">&#x27;api&#x27;</span></span><br></pre></td></tr></table></figure>


<h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><blockquote>
<p>ES6 引入 <strong>class</strong> 关键字，是的原先对象原型(<strong>prototype</strong>)的写法变得更加直观、更像<strong>面向对象编程</strong>的语法，用法类似于 <strong>Java</strong> 中的 <strong>class</strong>。</p>
</blockquote>
<p>定义一个 <strong>Point</strong> 类，其中有个构造函数<code>constructor</code>，需要注意类中的函数不需要<code>function</code>关键字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="built_in">this</span>.x&#125;</span>,<span class="subst">$&#123;<span class="built_in">this</span>.y&#125;</span>)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 生成实例</span></span><br><span class="line">p.toString()</span><br><span class="line"><span class="comment">// result: &quot;(1,2)&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><blockquote>
<p><strong>模块</strong>的引入是 ES6 的一大重要特性，我们可以将一个大程序拆成几个小文件，需要的时候再导入。ES6 之前是没有模块加载的功能的，社区制定了一些方案，比如 <strong>CommonJS</strong>的 <strong>require、module.exports</strong>。而 ES6 规定了模块加载的标准语法，并且 ES6 可以在<strong>编译时就完成模块加载</strong>，效率要比 <strong>CommonJS</strong> 模块的加载方式高。</p>
</blockquote>
<p>下面代码我在<code>b.js</code>中导出了一个常量和一个函数，在<code>a.js</code>中导入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">pi</span>: <span class="number">3.14</span>,</span><br><span class="line">    <span class="attr">plusOne</span>: <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; pi, plusOne &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pi)</span><br><span class="line"><span class="built_in">console</span>.log(plusOne(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 node a.js 输出结果:</span></span><br><span class="line"><span class="comment">// 3.14</span></span><br><span class="line"><span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>在 ES6 中规定了模块导入导出的关键字<code>import、export</code>，使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> plusOne = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; pi, plusOne &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; pi, plusOne &#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>import</code>大括号中变量名，必须与导出时声明的对外接口的<strong>名称相同</strong>。</p>
<p><code>export default</code>命令用于指定模块的<strong>默认输出</strong>，一个模块只能有一个默认输出，因此<code>export default</code>只能出现一次，所以<code>import</code>导入时可以不加大括号，名称也可以随意取。其实就想当于导出了一个 <strong>default</strong> 变量，将开平方的箭头函数<strong>赋值</strong>给它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> v =&gt; v * v</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> square <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: 100</span></span><br></pre></td></tr></table></figure>

<p>因此我们才可以这样引入第三方库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import _ from &#x27;lodash&#x27;</span><br></pre></td></tr></table></figure>

<p>需要<strong>特别注意</strong>的是，目前 <strong>Node</strong> 和浏览器还未对 <strong>import、export</strong> 做支持，因为<strong>V8引擎</strong>暂不支持，但是不久的将来肯定会加入该语法。<a href="https://nodejs.org/dist/latest-v9.x/docs/api/esm.html#esm_unsupported">Node官方文档</a> 也明确说明了不建议 <strong>require</strong> 而推荐使用标准的 <strong>import</strong> 并且等待最新的<strong>V8引擎</strong>的支持。可以使用 <strong>Babel</strong> 进行转码。</p>
<p><img src="/0.png" alt="512494CE-D620-4262-B2A2-CC5B351E6A3C"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://babeljs.io/learn-es2015/">Babel官网 —— Learn ES2015</a></li>
<li><a href="http://es6.ruanyifeng.com/">阮一峰 —— ES6入门</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000">廖雪峰 —— JavaScript教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ESLint —— JavaScript代码规约插件</title>
    <url>/2018/04/04/ESLint%20--%20%E4%BB%A3%E7%A0%81%E8%A7%84%E7%BA%A6%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ESLint 是一款 JavaScript 的代码规约插件，可以自定义规则，不符合规则的代码可以设置不同级别的报错。方便对于团队内成员的代码质量进行统一管理。之前在 Vue 项目中使用<code>vue-cli</code>时可以自动添加 ESLint 代码规约插件，所以也没去管怎么手动添加 ESLint。但是最近在<code>Koa2</code>项目中，需要手动的去添加并配置 ESLint。本文将介绍如何安装以及配置 ESLint 的规则。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在项目目录下使用<code>npm</code>命令安装 ESLint，并且是开发时依赖需要加上<code>--save-dev</code>。不推荐全局安装，这样可以实现项目规则的<strong>自定义化</strong>以及团队成员的<strong>统一化</strong>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev eslint</span><br></pre></td></tr></table></figure>

<p>初始化，会询问一些问题用于设置 ESLint，比如回答使用 Airbnb 的风格，不同的风格会有一些预定义的规则。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ ./node_modules/.bin/eslint --init</span><br><span class="line"></span><br><span class="line">? How would you like to configure ESLint? Use a popular style guide</span><br><span class="line">? Which style guide <span class="keyword">do</span> you want to follow? Airbnb</span><br><span class="line">? Do you use React? No</span><br><span class="line">? What format <span class="keyword">do</span> you want your config file to be <span class="keyword">in</span>? JavaScript</span><br></pre></td></tr></table></figure>

<p>完成后会在项目目录下生成<code>.eslintrc.js</code>文件，除此之外还可以手动添加<code>.eslintignore</code>，作用和<code>.gitignore</code>一样用于 Eslint 忽略检查的文件。</p>
<p>接着需要在 WebStorm 中启用 Eslint，勾选<code>Enable</code>。</p>
<p><img src="/0.png" alt="E9C4D048-BFC5-4D13-A4E8-30CD61BEE953"></p>
<p>现在代码检测已经启动了，比如规则中定义了句尾不加分号，如果加了分号就会报错。</p>
<p><img src="/1.png" alt="8EAC31A2-7E35-4016-9D0F-0FB7AD8057A6"></p>
<h2 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h2><p>配置自定义规则，以下是我的规则。参考官方文档 <a href="https://eslint.org/docs/rules/">Rules</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  extends: &#x27;airbnb-base&#x27;,</span><br><span class="line">  // add your custom rules here</span><br><span class="line">  rules: &#123;</span><br><span class="line">    // allow debugger during development</span><br><span class="line">    &#x27;no-debugger&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;off&#x27;,</span><br><span class="line">    // allow console during development</span><br><span class="line">    &#x27;no-console&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;off&#x27;,</span><br><span class="line">    // allow unused variables during development</span><br><span class="line">    &#x27;no-unused-vars&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;warn&#x27;,</span><br><span class="line">    // disallow trailing commas</span><br><span class="line">    &#x27;comma-dangle&#x27;: [&#x27;error&#x27;, &#x27;never&#x27;],</span><br><span class="line">    // disallow trailing semi</span><br><span class="line">    &#x27;semi&#x27;: [&#x27;error&#x27;, &#x27;never&#x27;],</span><br><span class="line">    // allow the unary operators ++ and --</span><br><span class="line">    &#x27;no-plusplus&#x27;: &#x27;off&#x27;,</span><br><span class="line">    // enforce a maximum line length</span><br><span class="line">    &#x27;max-len&#x27;: [0, 150]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在<code>package.json</code>中添加命令脚本。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;eslint --ext .js .&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以使用<code>npm run lint</code>运行 Eslint 检查程序，结果列出了问题文件所在路径、警告的级别及问题原因。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ npm run lint</span><br><span class="line"></span><br><span class="line">&gt; airbi-metadata@0.1.0 lint /Users/s1mple/Desktop/airbi-metadata</span><br><span class="line">&gt; eslint --ext .js .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /Users/s1mple/Desktop/airbi-metadata/app.js</span><br><span class="line">       3:22  error  Extra semicolon                                                 semi</span><br><span class="line">      22:31  error  Use path.join() or path.resolve() instead of + to create paths  no-path-concat</span><br><span class="line">      22:31  error  Unexpected string concatenation                                 prefer-template</span><br><span class="line">      24:15  error  Use path.join() or path.resolve() instead of + to create paths  no-path-concat</span><br><span class="line">      24:15  error  Unexpected string concatenation                                 prefer-template</span><br><span class="line">    </span><br><span class="line">    /Users/s1mple/Desktop/airbi-metadata/routes/index.js</span><br><span class="line">       3:29  warning  &#x27;next&#x27; is defined but never used  no-unused-vars</span><br><span class="line">       9:35  warning  &#x27;next&#x27; is defined but never used  no-unused-vars</span><br><span class="line">      13:33  warning  &#x27;next&#x27; is defined but never used  no-unused-vars</span><br><span class="line">    </span><br><span class="line">    /Users/s1mple/Desktop/airbi-metadata/routes/users.js</span><br><span class="line">      5:17  error    Unexpected function expression    prefer-arrow-callback</span><br><span class="line">      5:32  warning  &#x27;next&#x27; is defined but never used  no-unused-vars</span><br><span class="line">      9:20  error    Unexpected function expression    prefer-arrow-callback</span><br><span class="line">      9:35  warning  &#x27;next&#x27; is defined but never used  no-unused-vars</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://cn.eslint.org/docs/user-guide/getting-started">ESLint 官方文档</a></li>
<li><a href="https://eslint.org/docs/rules/">ESLint Rules</a></li>
</ul>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Fluent Interface —— Martin Fowler 博客译文</title>
    <url>/2019/01/23/Fluent%20Interface%20--%20Martin%20Fowler%20%E5%8D%9A%E5%AE%A2%E8%AF%91%E6%96%87/</url>
    <content><![CDATA[<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://www.martinfowler.com/bliki/FluentInterface.html">Fluent Interface</a>，Matrin Fowler 博客，发表于 2005 年 12 月 20 日。</p>
<h2 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h2><p>几个月前我和 Eric Evans 进行了一次讨论会，他谈到一种接口的设计风格，我们称之为流畅接口（Fluent Interface）。它不是一种常见的风格，但我们觉得应该广为人知。描述它的最直观的方式就是例子。</p>
<p>最简单的例子可能就来自 Eric 编写的 <a href="http://timeandmoney.sourceforge.net/">TimeAndMoney Library</a>。为了指定一段时间间隔，我们通常这么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimePoint fiveOClock, sixOClock;</span><br><span class="line">...</span><br><span class="line">TimeInterval meetingTime = <span class="keyword">new</span> TimeInterval(fiveOClock, sixOClock);</span><br></pre></td></tr></table></figure>

<p>但是 TimeAndMoney 库的使用者会这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimeInterval meetingTime = fiveOClock.until(sixOClock);</span><br></pre></td></tr></table></figure>

<p>下面我继续演示“客户下订单”这个例子。一个订单包含多个订单项，每个订单项包含商品项和购买的数量。在提交订单时一个订单项应当是可跳过的，这意味着我更希望在没有此订单项（缺货）的情况下提交订单，而不是推迟提交整个订单。所以这里可以给整个订单一个“急促（rush）”的状态标识。</p>
<p>要实现上述功能，最常见的编码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeNormal</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">    Order o1 = <span class="keyword">new</span> Order();</span><br><span class="line">    customer.addOrder(o1);</span><br><span class="line">    OrderLine line1 = <span class="keyword">new</span> OrderLine(<span class="number">6</span>, Product.find(<span class="string">&quot;TAL&quot;</span>));</span><br><span class="line">    o1.addLine(line1);</span><br><span class="line">    OrderLine line2 = <span class="keyword">new</span> OrderLine(<span class="number">5</span>, Product.find(<span class="string">&quot;HPK&quot;</span>));</span><br><span class="line">    o1.addLine(line2);</span><br><span class="line">    OrderLine line3 = <span class="keyword">new</span> OrderLine(<span class="number">3</span>, Product.find(<span class="string">&quot;LGV&quot;</span>));</span><br><span class="line">    o1.addLine(line3);</span><br><span class="line">    line2.setSkippable(<span class="keyword">true</span>);</span><br><span class="line">    o1.setRush(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上我们创建了多个对象然后将它们组装在一起。如果无法在构造函数中设置所有内容，那么就需要创建临时变量来帮助我们完成组装 —— 尤其是将集合项添加到集合中。</p>
<p>下面是使用流畅接口实现相同的组装：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeFluent</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">    customer.newOrder()</span><br><span class="line">            .with(<span class="number">6</span>, <span class="string">&quot;TAL&quot;</span>)</span><br><span class="line">            .with(<span class="number">5</span>, <span class="string">&quot;HPK&quot;</span>).skippable()</span><br><span class="line">            .with(<span class="number">3</span>, <span class="string">&quot;LGV&quot;</span>)</span><br><span class="line">            .priorityRush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这种风格最重要的一点就是，基于 Internal DomainSpecificLanguage 将要做的事沿着一条线进行编码（译者注：Domain Specific Language，DSL，领域专用语言）。实际上这也是为什么我们选择用 “Fluent” 一词来描述它，在很多方面这两个术语是同义词。<strong>这种 API 被设计为可读的和流式的，这种流畅性的代价是在设计和构建 API 时需要花更多的功夫</strong>。构造函数、setter 和 add 方法的 API 简单且容易编写，但要想提供一个漂亮的流畅接口则需要更多的思考。</p>
<p>事实上，刚才我想用在 Calgary 咖啡店吃早餐的时间完成这个小例子的编码，但是我搞砸了，看来好的流畅接口需要花费一些时间去实现。如果你想找一个比较成熟的例子，可以看看 <a href="http://jmock.org/">JMock</a>。与任何 mocking 库一样，JMock 需要创建复杂的行为规范。在过去几年中已经构建了许多 mocking 库，而 JMock 的这个则包含了非常漂亮的流畅接口，使用体验非常好。这是它的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mock.expects(once())</span><br><span class="line">    .method(<span class="string">&quot;m&quot;</span>)</span><br><span class="line">    .with(or(stringContains(<span class="string">&quot;hello&quot;</span>), stringContains(<span class="string">&quot;howdy&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>我看到 Steve Freeman 和 Nat Price 在 <a href="https://www.martinfowler.com/bliki/JAOO2005.html">JAOO2005</a> 上就 JMock API 的演变发表了精彩的演讲，演讲相关的内容他们已经发表到一篇 <a href="http://www.mockobjects.com/files/evolving_an_edsl.ooplsa2006.pdf">OOPSLA论文</a> 上。</p>
<p>到目前为止，我们看到用于创建对象配置的流畅接口通常会涉及到 <a href="https://en.wikipedia.org/wiki/Value_object">值对象</a>。我不确定这是否属于流畅接口的一个定义特征，虽然我怀疑它们出现在声明性上下文中有某种关联。对我们而言，<strong>流畅性的关键考验在于领域特定语言的质量</strong>。API 使用起来越像流式的语言，它就越流畅。</p>
<p>像这样构建一个流畅接口会导致一些不符合使用习惯的 API。其中最明显的一个就是 setter 会有返回值（在订单示例中，<code>with</code> 方法为订单添加一个订单项并返回整个订单），而惯例是修改性质的方法返回 <code>void</code>，因为这样遵循 <a href="https://martinfowler.com/bliki/CommandQuerySeparation.html">CommandQuerySeparation</a> 原则（译者注：CQS，命令查询分离原则）。这个约定确实妨碍了流畅接口，所以我倾向于暂不遵循这个惯例。</p>
<p>你应该<strong>根据流畅接口的下一个行为（fluent action）去选择返回类型</strong>。JMock 提出了一个重点：根据接下来的需要改变其返回类型。<strong>这种风格的一个很好的优点是方法补完后（intellisense）有助于告诉你接下来要键入什么 —— 有点像 IDE 中的智能提示</strong>。总的来说，我发现动态语言对于 DSL 来说效果更好，因为它们的语法往往更简洁。但是，使用方法补完是静态语言的一个优点。</p>
<p>流畅接口定义的方法的一个问题是它们可能名不符实。举个例子，你去查看 <code>with</code> 方法的文档可能并没有什么意义，因为这个方法的实现和 <code>with</code> 并没有什么关联。我承认光就方法的命名来说这不是一个好的命名，因为它根本不能表达该方法实际做了什么。只有在流畅行为的上下文中这种命名才能显示出它的优势（译者注：这点我在编码时也深有体会，流畅接口的方法实现与方法命名常常做的是两回事，比如说把值对象传递下去）。解决此问题的一种可能的方法是只在此上下文中使用 builder 对象（译者注：可以参考 Builder Pattern，比如 <code>new BankAccount.Builder(4567L).withOwner(&quot;Homer&quot;).atBranch(&quot;Springfield&quot;).build();</code>，只在最后一步 <code>build()</code> 中进行构建）。</p>
<p>Eric 提到的一点是，到目前为止，他使用并看到了流畅的接口大多是关于值对象的配置。值对象不具有领域意义的标识（Identity），因此你可以轻松创建并丢弃它们。所以接口的流畅度取决于使用旧值构造新值。从这个意义上讲，订单案例并不典型，因为它属于 <a href="https://www.martinfowler.com/bliki/EvansClassification.html">EvansClassification</a> 中的实体对象（Entity）。（译者注：Evans Classification，Evans 关于领域对象的分类 Entity、Value Object 和 Service）</p>
<p>目前为止我还没有看到很多的流畅接口，可以得出结论，我们对它们的优缺点了解还不够。所以任何使用它们的劝告都只能是初步的 —— 但我认为它们已经成熟，可以进行更多的尝试。</p>
<p><a href="https://bofh.org.uk/2005/12/21/fluent-interfaces/">Piers Cawley</a> 对本文有一个很好的跟进。</p>
<p><strong>更新</strong>（2008年6月23日）。自从我写这篇文章以来，这个术语被广泛使用，这给了我一种令人愉快的满足感。在我一直在研究的书中，我已经提炼了关于流畅接口和内部 DSLs 的想法。我也注意到了一个常见的误解 —— 很多人似乎将流畅接口与方法链（Method Chaining）等同起来。当然链式接口是使用了流畅接口的一种常用的技术，但真正的流畅接口远不止于此。</p>
<p>我上面展示的 JMock 示例使用了方法链，但同时也使用嵌套函数和对象作用域。</p>
]]></content>
      <categories>
        <category>Translations</category>
      </categories>
      <tags>
        <tag>流畅接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Flow 模型以及工具的使用</title>
    <url>/2018/07/03/Git%20Flow%20%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Git-Flow-是什么？"><a href="#Git-Flow-是什么？" class="headerlink" title="Git Flow 是什么？"></a>Git Flow 是什么？</h2><p>2010 年 5 月，在一篇名为 “<a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>” 的博文中，Vincent Driessen 介绍了一种构建在 Git 之上的软件开发模型。<strong>通过利用 Git 创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上，实现了软件开发过程不同阶段的相互隔离</strong>。这种软件开发的活动模型被 Vincent 称为 “<strong>Git Flow</strong>”。</p>
<h2 id="Git-Flow-流程图"><a href="#Git-Flow-流程图" class="headerlink" title="Git Flow 流程图"></a>Git Flow 流程图</h2><p>这是 Vincent 博文中的 Git FLow 流程图，该图从右向左，从上到下看：</p>
<p><img src="/0.png" alt="git-flow-model"></p>
<h2 id="Git-Flow-Branches"><a href="#Git-Flow-Branches" class="headerlink" title="Git Flow Branches"></a>Git Flow Branches</h2><p>Git Flow 的核心就是<strong>分支（Branch）</strong>，通过在项目的不同阶段对 Branch 的不同操作（包括但不限于 create、merge、rebase 等）来实现一个完整的高效率的工作流程。Git Flow Branches 主要分为两大类：<strong>Main Branches（主分支）</strong> 和 <strong>Supporting branches（辅助分支）</strong>。 其中 Main Branches 中又包含了 <strong>Master</strong> 和 <strong>Develop</strong>，而 Supporting branches 中包含了 <strong>Feature</strong>、<strong>Release</strong>、<strong>Hotfix</strong> 以及其他自定义分支。</p>
<h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><ul>
<li><p><strong>master 分支上存放的是最稳定的正式版本</strong>，并且该分支的代码应该是随时可在生产环境中使用的代码（<strong>Production Ready state</strong>）。当一个版本开发完毕后，产生了一份新的稳定的可供发布的代码时，master 分支上的代码要被更新。同时，每一次更新，都需要在 master 上打上对应的版本号（tag）。</p>
</li>
<li><p><strong>任何人不允许在 master 上进行代码的直接提交，只接受其他分支的合入</strong>。原则上 master 上的代码必须是合并自经过多轮测试且已经发布一段时间且线上稳定的 release 分支（预发分支）。</p>
</li>
</ul>
<h3 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h3><ul>
<li><p><strong>develop 分支是主开发分支，其上更新的代码始终反映着下一个发布版本需要交付的新功能</strong>。当 develop 分支到达一个稳定的点并准备好发布时，应该从该点拉取一个 release 分支并附上发布版本号。也有人称 develop 分支为 “integration branch”，因为会基于该分支和持续集成工具做自动化的 Nightly builds。</p>
</li>
<li><p>develop 分支接受其他 Supporting branches 分支的合入，最常见的就是 feature 分支，开发一个新功能时拉取新的 feature 分支，开发完成后再并入 develop 分支。需要注意的是，<strong>合入 develop 的分支必须保证功能完整，不影响 develop 分支的正常运行</strong>。</p>
</li>
</ul>
<h3 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h3><ul>
<li><p>feature 分支又叫做<strong>功能分支</strong>，一般命名为 feature/xxx，用于<strong>开发即将发布版本或未来版本的新功能或者探索新功能</strong>。该分支通常存在于开发人员的本地代码库而不要求提交到远程代码库上，除非几个人合作在同一个 feature 分支开发。关于这点，ThoughtWorks 洞见上有一篇文章 “<a href="https://insights.thoughtworks.cn/gitflow-consider-harmful/">Gitflow 有害论</a>” 做了非常有意思的阐述，文章下的评论也异常激烈。也许该文章的名字可能有失偏颇，但文章的本意以及评论传达了一个观点：<strong>feature 分支要求足够细粒度以避免成为 long-lived branch，应当小步小步 merge 而不是一次 merge 大量代码</strong>。</p>
</li>
<li><p>feature 分支只能拉取自 develop 分支，开发完成后要么合并回 develop 分支，要么因为新功能的尝试不如人意而直接丢弃。</p>
</li>
</ul>
<h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><ul>
<li><p>release 分支又叫做<strong>预发分支</strong>，一般命名为 release/1.2（后面接版本号），<strong>该分支专为测试—发布新的版本而开辟，允许做小量级的 Bug 修复和准备发布版本的元数据信息（版本号、编译时间等）</strong>。通过创建 release 分支，使得 develop 分支得以空闲出来接受下一个版本的新的 feature 分支的合入。</p>
</li>
<li><p>release 分支需要提交到服务器上，交由 QA 进行测试，并由 Dev 修复 Bug。同时根据该分支的特性我们可以部署自动化测试以及生产环境代码的自动化更新和部署。</p>
</li>
<li><p>release 分支只能拉取自 develop 分支，合并回 develop 和 master 分支。</p>
</li>
</ul>
<h3 id="Hotfix"><a href="#Hotfix" class="headerlink" title="Hotfix"></a>Hotfix</h3><ul>
<li><p>hotfix 分支又叫<strong>热修复分支</strong>，一般命名为 hotfix/1.2.1（后面接版本号），<strong>当生产环境的代码（master 上代码）遇到了严重到必须立即修复的缺陷时，就需要从 master 分支上指定的 tag 版本（比如 1.2）拉取 hotfix 分支进行代码的紧急修复，并附上版本号（比如 1.2.1）</strong>。这样做的好处是不会打断正在进行的 develop 分支的开发工作，能够让团队中负责 feature 开发的人与负责 hotfix 的人并行、独立的开展工作。</p>
</li>
<li><p>hotfix 分支只能从 master 上拉取，测试通过后合并回 master 分支和 develop 分支。</p>
</li>
</ul>
<h2 id="Git-Flow-工具"><a href="#Git-Flow-工具" class="headerlink" title="Git Flow 工具"></a>Git Flow 工具</h2><p>一旦使用 Git Flow 模型，那么对分支的命令操作必然是频繁且重复的，所幸是有人开发了 Git Flow Script 工具帮助我们简化命令：<a href="https://github.com/nvie/gitflow">gitflow</a>。</p>
<p>在 Mac 或 Windows 系统上安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// OS X</span><br><span class="line">brew install git-flow</span><br><span class="line"></span><br><span class="line">// Windows</span><br><span class="line">wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash</span><br></pre></td></tr></table></figure>

<p>使用<code>git flow init</code>进行初始化，会询问你分支的命名，使用默认的即可。初始化完成后自动切换到了 develop 分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  demo git:(master) ✗ git flow init</span><br><span class="line">No branches exist yet. Base branches must be created now.</span><br><span class="line">Branch name for production releases: [master] </span><br><span class="line">Branch name for &quot;next release&quot; development: [develop] </span><br><span class="line"></span><br><span class="line">How to name your supporting branch prefixes?</span><br><span class="line">Feature branches? [feature/] </span><br><span class="line">Release branches? [release/] </span><br><span class="line">Hotfix branches? [hotfix/] </span><br><span class="line">Support branches? [support/] </span><br><span class="line">Version tag prefix? []</span><br><span class="line"></span><br><span class="line">➜  demo git:(develop) ✗ </span><br></pre></td></tr></table></figure>

<p>下面使用 feature 分支演示 Git Flow 功能。<code>git flow feature start my-feature</code>该命令用于新建一个 feature 分支。可以看到，基于 develop 的 feature/my-feature 分支已被创建，并且自动切换到该分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  demo git:(develop) ✗ git flow feature start my-feature</span><br><span class="line">Switched to a new branch &#x27;feature/my-feature&#x27;</span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- A new branch &#x27;feature/my-feature&#x27; was created, based on &#x27;develop&#x27;</span><br><span class="line">- You are now on branch &#x27;feature/my-feature&#x27;</span><br><span class="line"></span><br><span class="line">Now, start committing on your feature. When done, use:</span><br><span class="line"></span><br><span class="line">     git flow feature finish my-feature</span><br><span class="line"></span><br><span class="line">➜  demo git:(feature/my-feature) ✗ </span><br></pre></td></tr></table></figure>
<p>在该功能分支下我创建了 a.txt 文件并 commit 到本地仓库，下面演示结束 feature 分支。<code>finish</code>命令用于将 feature/my-feature 分支合并入 develop 分支并删除该分支。此时已切换到了 develop 分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  demo git:(feature/my-feature) git flow feature finish my-feature</span><br><span class="line">Switched to branch &#x27;develop&#x27;</span><br><span class="line">Updating 6c6e4cb..345a380</span><br><span class="line">Fast-forward</span><br><span class="line"> a.txt | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 a.txt</span><br><span class="line">Deleted branch feature/my-feature (was 345a380).</span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- The feature branch &#x27;feature/my-feature&#x27; was merged into &#x27;develop&#x27;</span><br><span class="line">- Feature branch &#x27;feature/my-feature&#x27; has been removed</span><br><span class="line">- You are now on branch &#x27;develop&#x27;</span><br><span class="line"></span><br><span class="line">➜  demo git:(develop) </span><br></pre></td></tr></table></figure>

<p>release 和 hotfix 的命令使用和 feature 一样。需要注意的是它们实际的操作细节会有一些区别，比如 release finish 时会打上版本号，以及合并入 master 和 develop 两个分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  demo git:(release/1.2) git flow release finish 1.2 </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- Latest objects have been fetched from &#x27;origin&#x27;</span><br><span class="line">- Release branch has been merged into &#x27;master&#x27;</span><br><span class="line">- The release was tagged &#x27;1.2&#x27;</span><br><span class="line">- Release branch has been back-merged into &#x27;develop&#x27;</span><br><span class="line">- Release branch &#x27;release/1.2&#x27; has been deleted</span><br><span class="line"></span><br><span class="line">➜  demo git:(master)</span><br></pre></td></tr></table></figure>

<p>还有将分支 push 到远程代码仓库和拉取远程代码仓库分支的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  demo git:(release/1.2) git flow release publish 1.2 </span><br><span class="line">➜  demo git:(release/1.2) git flow release pull 1.2 </span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Git Flow 模型通过不同的分支从源代码管理的角度对软件开发活动进行了约束，为我们的软件开发提供了一个可供参考的管理模型。Git Flow 模型让代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。但同时，不同的开发团队存在不同的文化，在不同的项目背景情况下都可能<strong>根据该模型进行适当的精简或扩充</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model —— Vincent Driessen</a></li>
<li><a href="https://juejin.im/entry/5b7fe2745188253010325bf6">Git Flow流程 —— 掘金</a></li>
<li><a href="http://deshui.wang/%E6%95%8F%E6%8D%B7/2015/10/27/sourcecode-management">敏捷实践系列(四)：代码管理流程</a></li>
<li><a href="https://www.jianshu.com/p/36292d36e41d">Git Flow的使用 —— 简书</a></li>
<li><a href="https://insights.thoughtworks.cn/gitflow-consider-harmful/">Git Flow有害论 —— ThoughtWorks洞见</a></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 基础教程</title>
    <url>/2017/11/28/Git%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Git 是目前世界上最先进的分布式版本控制系统。相比较CVS及SVN这种老式的集中式版本控制系统，要更加灵活方便，也更安全稳定。<strong>集中式</strong>是指版本库是放在中央服务器中，需要联网才能工作。<strong>分布式</strong>是指没有中央服务器，每个人电脑上有个完整的版本仓库，可以本地修改代码再联网提交到Git服务器上，Git服务器作用仅仅“交换”大家的修改即代码同步。此外，Git还拥有极其强大的分支管理功能。</p>
<h2 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h2><p>本文主要介绍基础的 Git 命令，更加复杂的 Git 命令可以查看：<a href="https://s2mple.xyz/2018/09/18/Git%20%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">Git 进阶教程</a>。另外 Git 的常用命令文档可以参考：<a href="https://education.github.com/git-cheat-sheet-education.pdf">git-cheatsheet</a>。</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>始终要记住你的<strong>本地和Git服务器上都存在版本仓库（repository）</strong>，Git实现代码同步实际上是同步你的本地仓库和远程仓库。有两种方式创建仓库：1. 从服务器上克隆一个仓库；2. 初始化一个本地仓库。</p>
<p>从Git服务器上<strong>克隆（clone）</strong>一个仓库下来，可以通过<strong>ssh</strong>或<strong>http</strong>的方式。ssh需要将你的公钥存放在Git服务器上，而http不需要但是速度相较ssh要慢。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:s1mplecc/MyHashMap.git</span><br><span class="line">git clone https://github.com/s1mplecc/MyHashMap.git</span><br></pre></td></tr></table></figure>

<p>从远程库克隆下来的是完整的版本库，含有<code>.git</code>文件夹，其下的<code>config</code>文件夹包括了本仓库的配置信息。包含了url、远程库的名字以及分支等：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ cat .git/config</span><br><span class="line"></span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:s1mplecc/MyHashMap.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br></pre></td></tr></table></figure>

<p>第二种方式，<code>git init</code>是将当前目录初始化为Git可以管理的仓库。会在当前目录下生成了<code>.git</code>文件夹。</p>
<p>如果要将本地仓库推到服务器上，需要现在服务器上创建一个repository，然后在本地目录下绑定服务器上的repository，origin是版本库默认的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:s1mplecc/MyHashMap.git</span><br></pre></td></tr></table></figure>
<h3 id="提交变更"><a href="#提交变更" class="headerlink" title="提交变更"></a>提交变更</h3><p>当你对版本库中的文件做了变更（增删改），可以使用<code>git status</code>命令查看当前版本库的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  github.io git:(hexo) ✗ git status</span><br><span class="line">On branch hexo</span><br><span class="line">Your branch is ahead of &#x27;origin/hexo&#x27; by 9 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   &quot;source/_posts/ES6\346\226\260\347\211\271\346\200\247.md&quot;</span><br><span class="line">    modified:   &quot;source/_posts/Git Flow \346\250\241\345\236\213\344\273\245\345\217\212\345\267\245\345\205\267\347\232\204\344\275\277\347\224\250.md&quot;</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p><code>git add .</code>或者<code>git add all</code>将所有修改提交到暂存区。<code>.</code>表示当前目录下所有修改了的文件，当然也可以指定某个文件。</p>
<p>将暂存区的所有内容提交到当前分支，默认分支即Git为我们自动创建的<strong>master</strong>分支。<code>-m</code>参数后面接提交的message：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;balabala&quot;</span><br></pre></td></tr></table></figure>

<p>将当前分支提交到远程库中，<code>-u</code>第一次使用时将本地的master分支绑定到远程库的master分支，以后可以省略不加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>从远程库拉取修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<p>在开发过程中会有频繁的提交，所以日常中我们用到最多的就是上述命令了。本质上本地与远程版本库的同步就是记录下每次的<strong>修改信息</strong>。Git会帮我们记录下每次提交的修改，方便我们进行同步、回退以及合并。</p>
<h4 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h4><p>说到<code>add</code>不得不提<code>.gitignore</code>这个文件，它的作用是忽略一些文件的提交，比如IntelliJ IDEA生成的<code>.idea</code>文件、编译生成的<code>target</code>文件等等。这类文件不需要提交到服务器污染大家的环境。关于<code>.gitignore</code>的编写github上都有现成的模版。另外IDE也可以安装相应的gitignore插件。</p>
<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>正是Git帮我们记录了每次提交的修改，我们可以通过命令查看历史信息，以及每次做了什么修改。</p>
<p><code>git log</code>查看提交历史，每条记录有一个唯一的id用于标识，使用时可以使用可以唯一表示的前几位。添加参数<code>-p &lt;file&gt;/&lt;commit id&gt;</code>查看指定文件或某次commit的历史信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 24345a1a74184f99eb32202bfcc1cd0fd6ac945d (HEAD -&gt; master)</span><br><span class="line">Author: s1mple &lt;s1mple@macpro.local&gt;</span><br><span class="line">Date:   Wed Nov 29 11:33:56 2017 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line">commit b90b6da1573d55ef59a900d435d903e41667f61e</span><br><span class="line">Author: s1mple &lt;s1mple@macpro.local&gt;</span><br><span class="line">Date:   Wed Nov 29 11:31:43 2017 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>

<p><code>git diff b90b6da</code>查看某次提交后与当前版本的区别，可以看到我在文本中添加了一行second：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> first</span><br><span class="line">+second</span><br></pre></td></tr></table></figure>
<p><code>git reflog</code>查看命令操作历史。</p>
<h3 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h3><p>如果你在提交了某次变更后又想撤销这次变更，Git也提供了撤销和回退的功能。Git将提交记录（节点）串成一条线，<strong>HEAD</strong>就是一指向当前版本的指针，做回退操作其实就是这个指针在这条线上的节点间移动。牢记：<strong>Git跟踪并管理的是修改，而非文件</strong>。</p>
<p><code>reset</code>命令回退到指定的某个版本，<code>HEAD</code>表示当前版本，<code>HEAD^</code>表示上一个版本。也可以用具体的 commit id：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<p>如果你修改了某个文件，但还没有<code>add</code>，可以直接舍弃这次修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>如果你已经<code>commit</code>了，也可以还原回去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert &lt;commit id&gt;</span><br></pre></td></tr></table></figure>
<p>revert与reset的区别在于，revert会生成一次新的提交去移除某些提交（相当于反向操作），在节点线上还是向前走的。而reset是把HEAD指针后移到指定节点，直接从这个节点走出新的一条线。可以参考<a href="http://www.cnblogs.com/houpeiyong/p/5890748.html">代码回滚：git reset、git checkout和git revert区别和联系</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://education.github.com/git-cheat-sheet-education.pdf">git-cheatsheet</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000">Git教程 —— 廖雪峰</a></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 进阶教程</title>
    <url>/2018/09/18/Git%20%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>你的本地仓库由 Git 维护的三棵「树」组成。第一个是你的<strong>工作目录（Working dir）</strong>，它持有实际文件，即你所见的；第二个是<strong>缓存区（Stage or Index）</strong>，它像个缓存区域，临时保存你的改动；第三个是<strong>提交历史（Commit history）</strong>，包含的 HEAD 指针指向你最近一次 commit 的引用。关于工作区和缓存区概念可参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000">廖雪峰的Git教程</a>。</p>
<p><img src="/0.svg" alt="687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f62617369632d75736167652e737667-1"></p>
<p>上面的四条命令在工作目录、stage 缓存（也叫做索引）和 commit 历史之间复制文件。</p>
<ul>
<li><code>git add files</code> 把工作目录中的文件加入 stage 缓存。</li>
<li><code>git commit</code> 把 stage 缓存生成一次 commit，并加入 commit 历史。</li>
<li><code>git reset -- files</code> 撤销最后一次 git add files，你也可以用 git reset 撤销所有 stage 缓存文件。</li>
<li><code>git checkout -- files</code> 把文件从 stage 缓存复制到工作目录，用来丢弃本地修改。</li>
</ul>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p><code>git merge</code> 命令把不同分支合并起来。合并前，索引必须和当前提交相同。**<code>git merge other</code> 用于将 other 分支上的提交合并到当前分支**。</p>
<p>如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。另一种情况是如果当前提交是另一个分支的祖父节点，就导致 <strong>fast-forward</strong> 合并，HEAD 指针只是简单的移动。</p>
<p><img src="/1.svg" alt="687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f6d657267652d66662e737667"></p>
<p>否则就是一次真正的合并。默认把当前提交（<em>ed489</em> 如下所示）和另一个提交（_33104_）以及他们的共同祖父节点（_b325c_）进行一次<strong>三方合并</strong>。结果是先保存当前目录和索引，然后和父节点 <em>33104</em> 一起做一次<strong>新提交</strong>。</p>
<p><img src="/2.svg" alt="687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f6d657267652e737667"></p>
<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p><code>git cherry-pick</code> 命令「复制」一个提交节点并在当前分支做一次完全一样的新提交。</p>
<p><img src="/3.svg" alt="687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f6368657272792d7069636b2e737667"></p>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p><code>git rebase</code> 是合并命令的另一种选择。merge 把两个分支合并进行一次新提交，提交历史不是线性的。rebase 在当前分支上重演另一个分支的历史，<strong>提交历史是线性的</strong>。</p>
<p><img src="/4.svg" alt="687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f7265626173652e737667"></p>
<p>上面的命令都在 <em>topic</em> 分支中进行，执行 <code>git rebase master</code> 意味着将 <em>topic</em> 分支基于  <em>master</em> 分支进行重演，在 <em>da985</em> 后附加对应于 <em>169a6</em> 和 <em>2c33a</em> 的两次新提交，所以提交历史是线性的。</p>
<h3 id="rebase-和-merge-的区别"><a href="#rebase-和-merge-的区别" class="headerlink" title="rebase 和 merge 的区别"></a>rebase 和 merge 的区别</h3><p>在 <em>topic</em> 分支中执行 <code>git rebase master</code> 后的分支树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      A---B topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              A&#x27;--B&#x27; topic</span><br><span class="line">             /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<p>在 <em>topic</em> 分支中执行 <code>git merge master</code> 后的分支树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      A---B topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      A---B---H topic</span><br><span class="line">     /       / </span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<p>rebase 最大的好处是你的项目历史会是非常整洁的线性，不像 merge 那样引入多余的合并提交。但同时，rebase 也会带来两个后果：安全性和可跟踪性。使用时要遵守 <strong>rebase 的黄金法则：绝不要在公共的分支上使用它</strong>。可跟踪性是指 rebase 不会有合并提交中附带的信息，你看不到 <em>topic</em> 分支中并入了 <em>master</em> 的哪些更改。</p>
<h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p><code>git reset</code> 命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。如果<strong>你的更改还没有共享给别人</strong>，reset 是撤销这些更改的简单方法。当你开发一个功能的时候发现「糟糕，我做了什么？我应该重新来过！」时，reset 就像是 <code>go-to</code> 命令一样。</p>
<p><img src="/5.svg" alt="687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f72657365742d636f6d6d69742e737667"></p>
<p>还可以通过传入参数来修改你的缓存区或工作目录：</p>
<ul>
<li><code>--soft</code> 缓存区和工作目录都不会被改变。</li>
<li><code>--mixed</code> 默认选项。缓存区同步到你指定的提交，但工作目录不受影响。</li>
<li><code>--hard</code> 缓存区和工作目录都同步到你指定的提交。</li>
</ul>
<p>把这些参数想成定义 <code>git reset</code> 操作的<strong>作用域</strong>就容易理解多了。拿上图举例来说，如果执行 <code>git reset --soft HEAD~3</code>，那么文件不会被修改，后三次提交被 <code>git add</code> 添加到暂存区，相当于只撤销了 <code>git commit</code>；<code>git reset --mixed HEAD~3</code> 则文件不会被修改，但后三次提交没有添加到暂存区；<code>git reset --hard HEAD~3</code> 则文件会被回退到 <em>b325c</em> 时的状态。</p>
<h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><p><strong>revert 撤销一个提交的同时会创建一个新的提交</strong>。这是一个安全的方法，因为它不会重写提交历史。比如，下图执行 <code>git revert HEAD~2</code> 会创建一个新的提交来撤销前两个提交的更改，然后把新的提交加入提交历史。</p>
<p><img src="/6.svg" alt="06"></p>
<p>相比 <code>git reset</code>，它不会改变现在的提交历史。因此，**<code>git revert</code> 可以用在公共分支上，<code>git reset</code> 应该用在私有分支上**。你也可以把 <code>git revert</code> 用作撤销已经 push 的更改，而 <code>git reset</code> 用来撤销已经 commit 但没有 push 的更改，或者 <code>git reset HEAD</code> 撤销没有 commit 的更改。</p>
<h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><p><strong>checkout 命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支</strong>。</p>
<p>当给出一个（本地）分支时，那么 <em>HEAD</em> 指针将指向那个分支，也就是说，我们「切换」到那个分支了。<strong>stage 缓存和工作目录中的内容会和 <em>HEAD</em> 对应的提交节点一致</strong>。</p>
<p><img src="/7.svg" alt="a"></p>
<p>当指定的是一个标签、远程分支、SHA-1 值或者是像 master~3 类似的东西，就会得到一个<strong>匿名分支</strong>，又称作 <strong>detached HEAD（被分离的 HEAD 标识）</strong>。这样可以很方便地在历史版本之间互相切换。比如说你想要编译 1.2.1 版本，你可以运行 <code>git checkout v1.2.1</code>（这是一个标签 tag，而非分支名），编译，安装，然后切换回原先分支。</p>
<p><img src="/8.svg" alt="b"></p>
<p>当提交操作涉及到 detached HEAD 时，其行为会略有不同。<em>HEAD</em> 处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。你可以认为这是在更新一个匿名分支。</p>
<p><img src="/9.svg" alt="c"></p>
<p>一旦此后你切换到别的分支，比如说 _master_，那么这个提交节点（可能）再也不会被引用到，将会被丢弃掉。</p>
<p><img src="/10.svg" alt="d"></p>
<p>但是，如果你想保存这个状态，可以用命令 <code>git checkout -b name</code> 来创建一个新的分支。</p>
<p><img src="/11.svg" alt="e"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/geeeeeeeeek/git-recipes">git-recipes —— GitHub 8k star 的高质量教程</a></li>
<li><a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing">Merging vs. Rebasing</a></li>
<li><a href="https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting">Resetting, Checking Out &amp; Reverting</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000">Git教程 —— 廖雪峰</a></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 异常处理</title>
    <url>/2018/07/16/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直以来，Java 的异常处理可能是每个 Java 程序员都需要面对和经历的难题之一。何时该抛出异常，该抛出何种异常，需不需要自定义异常类，何时又该捕获异常并处理，相信每一个 Java 程序员或多或少都有这样的疑问。最近也是觉得项目需要统一规范的异常处理，所以花了些时间研读 <em>Thinking in Java</em>、《阿里巴巴 Java 开发手册》以及前辈们总结的优质文章，归纳了一些自认为比较关键的部分，希望有助于大家更好的设计如何处理异常。关键还是需要大量优秀源码的阅读经验。</p>
<blockquote>
<p>异常的设计初衷是将<strong>运行时产生的错误信息通过某种方式传递给某个接收者 —— 该接收者将知道如何正确的处理这个问题</strong>。Java 使用异常来提供一致的错误报告模型，使得构件能够与客户端代码可靠地沟通问题。实际上，<strong>异常处理的一个重要目标就是把错误处理的代码同错误发生的地点分离</strong>，使得你在某处专注于要完成的事，而在另一处处理错误。既分离了主干代码和错误处理逻辑，又可以重用错误处理代码。—— <em>Thinking in Java</em></p>
</blockquote>
<p>上面所说的接受者其实分为两类，一类是开发人员，另一类是使用用户。所以，实际上异常设计出来：</p>
<ol>
<li>帮助开发人员定位错误，修复代码漏洞。</li>
<li>反馈给客户端用户，比如表单的输入值非法，让他得以更正错误。</li>
</ol>
<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>Java 将异常分为两个大类：<strong>非检查型异常（Unchecked Exception）</strong>，也称非受控异常。以及<strong>检查型异常（Checked Exception）</strong>，也称受控异常。这两者的区别在于：</p>
<ol>
<li>Check Exception 编译器会做强制检查，必须使用<code>try...catch</code>捕获或者<code>throws</code>在方法签名处申明，否则编译不通过。</li>
<li>Unchecked Exception 发生在运行期，具有不确定性，通常是由于程序的<strong>逻辑问题</strong>所引起的，所以在程序设计中我们需要考虑周全，尽量通过<strong>提前预检</strong>避免这类异常。</li>
</ol>
<p>Java 中异常的继承结构如下图所示：</p>
<p><img src="/2018/07/16/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/0.jpg" alt="v2-2cb1558f17876f329804fcced62661ef_1200x500"></p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Error 表示<strong>系统级别的错误</strong>，应用程序本身无法克服和恢复的一种严重问题，例如 JVM 栈溢出<code>StackOverFlowError</code>、内存溢出<code>OutOfMemoryError</code>等。<strong>在编码中不应该主动抛出 Error 类型的异常</strong>。</p>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>运行时异常<code>RuntimeException</code>是<code>Exception</code>衍生子类中的非检查型异常，即编译器不会强制要求捕获或者声明抛出。<code>RuntimeException</code>发生的时候，表示程序中出现了编程错误（即 Bug），所以应该找出错误修改程序，而不是去捕获。比如空指针异常<code>NullPointerException</code>、数组下标越界<code>ArrayIndexOutOfBoundsException</code>，程序员可以通过提前预检去避免该类错误。</p>
<h3 id="受控异常"><a href="#受控异常" class="headerlink" title="受控异常"></a>受控异常</h3><p>绝大多数受控异常（Checked Exception）位于<code>java.io</code>包内，这是合乎情理的，因为在你请求了不存在的系统资源的时候，一段健壮的程序必须能够优雅的处理这种情况，而不应该挂掉。比如<code>FileNotFoundException</code>可能是用户删除了文件，或者<code>ConnectException</code>网络中断导致的连接异常，这类问题可以通过用户恢复文件或检查网络及时矫正。</p>
<h2 id="异常处理的最佳实践"><a href="#异常处理的最佳实践" class="headerlink" title="异常处理的最佳实践"></a>异常处理的最佳实践</h2><p>异常堆栈信息提供了导致异常出现的方法调用链的精确顺序，包括每个方法调用的类名，方法名，代码文件名以及行数，以此来精确定位异常出现的现场。在有效使用异常的情况下，异常类型回答了<strong>什么</strong>异常被抛出，异常堆栈跟踪回答了<strong>在哪</strong>抛出，异常信息回答了<strong>为什么</strong>会抛出，如果你的异常没有回答以上全部问题，那么可能你没有很好地使用它们。本文主要介绍异常使用的两大原则：<strong>提早抛出</strong>和<strong>延迟捕获</strong>。更多请参考博客最后的参考文章，推荐研读《阿里巴巴 Java 开发手册》。</p>
<h3 id="提早抛出"><a href="#提早抛出" class="headerlink" title="提早抛出"></a>提早抛出</h3><p>来看以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    InputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read file...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readFile(<span class="keyword">null</span>); <span class="comment">// throw exception</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:130)</span></span><br><span class="line"><span class="comment">at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93)</span></span><br><span class="line"><span class="comment">at info.s1mple.exceptiondemo.ExceptionDemo.readFile(ExceptionDemo.java:15)</span></span><br><span class="line"><span class="comment">at info.s1mple.exceptiondemo.ExceptionDemo.main(ExceptionDemo.java:10) */</span></span><br></pre></td></tr></table></figure>

<p>以上代码展示了<code>FileInputStream</code>类的构造函数传入<code>null</code>值导致的<code>NullPointerException</code>异常。不幸的是，<code>NullPointerException</code>是 Java 中信息量最少的（却也是最常遭遇且让人崩溃的）异常。它压根不提我们最关心的事情：到底哪里是<code>null</code>。所以我们不得不回退几步去找哪里出了错。</p>
<p>通过跟踪堆栈打印信息，我们可以确定错误原因是向<code>readFile()</code>传入了一个空文件名参数。既然<code>readFile()</code>不能处理空文件名，所以马上检查该条件，如果文件名为空则抛出非法参数异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filename == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;filename is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read file...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readFile(<span class="keyword">null</span>); <span class="comment">// throw exception</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: filename is null</span></span><br><span class="line"><span class="comment">    at info.s1mple.exceptiondemo.ExceptionDemo.readFile(ExceptionDemo.java:15)</span></span><br><span class="line"><span class="comment">    at info.s1mple.exceptiondemo.ExceptionDemo.main(ExceptionDemo.java:10) */</span></span><br></pre></td></tr></table></figure>

<p>这里使用<code>IllegalArgumentException</code>继承自<code>RuntimeException</code>的非受控异常，所以不强制要求在方法签名处声明。实际开发中根据业务要求，假如文件名是由用户输入，那可以自定义类似<code>RequestArgsIllegalException</code>的受控异常类将错误信息返回给前端并呈现给用户。在命名自定义异常类时要清晰准确。</p>
<p>类似上述代码中的<code>if statement</code>被称为<strong>卫语句（guard clauses）</strong>，原则是将可能出错的每个分支做<strong>单独检查</strong>，要么抛出异常要么立即返回，将正常的实现代码放在卫语句之后保证运行到此处时所有条件都已通过。如此既避免了嵌套层次过多的<code>if...else</code>条件分支，又使得实现代码被剥离出来放在最后集中处理。</p>
<p>通过提早抛出异常（又称<strong>迅速失败</strong>），异常得以清晰又准确。堆栈信息立即反映出什么出了错（提供了非法参数值），为什么出错（文件名不能为空值），以及哪里出的错。另外，其中包含的异常信息<code>&quot;filename is null&quot;</code>使得异常提供的信息更加丰富，而这是我们之前代码中抛出的<code>NullPointerException</code>所无法提供的。</p>
<h3 id="延迟捕获"><a href="#延迟捕获" class="headerlink" title="延迟捕获"></a>延迟捕获</h3><p>编写异常的程序员最可能犯的一个错误是，在程序有能力处理异常之前就捕获它。问题在于，捕获之后该拿异常怎么办？最不该的就是什么都不做。空的<code>catch</code>块等于把整个异常丢进黑洞，能够说明何时何处为何出错的所有信息都会丢失。把异常写到日志中还稍微好点，至少有迹可循。但我们总不能指望用户去阅读或者理解日志文件和异常信息。阿里开发手册中说道：<strong>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容</strong>。</p>
<p>在有条件处理异常之前过早捕获它，通常会导致更严重的错误和其他异常。例如，如果上文的<code>readFile()</code>方法在调用<code>FileInputStream</code>构造方法时立即捕获和记录可能抛出的<code>FileNotFoundException</code>，代码会变成下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;file not found: &#123;&#125;&quot;</span>, filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.read(); <span class="comment">// may produce NullPointerException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readFile(<span class="string">&quot;xxx&quot;</span>); <span class="comment">// throw exception</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">13:10:27.439 [main] ERROR info.s1mple.exceptiondemo.ExceptionDemo - file not found: xxx</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">    at info.s1mple.exceptiondemo.ExceptionDemo.readFile(ExceptionDemo.java:32)</span></span><br><span class="line"><span class="comment">    at info.s1mple.exceptiondemo.ExceptionDemo.main(ExceptionDemo.java:16) */</span></span><br></pre></td></tr></table></figure>

<p>上面的代码在完全没有能力从<code>FileNotFoundException</code>中恢复过来的情况下就捕获了它。如果文件无法找到，那么<code>in.read()</code>就不应该执行。尽管我们捕获了<code>FileNotFoundException</code>异常并打印了日志，但是一个更让人头疼的<code>NullPointerException</code>将被抛出。错误信息不仅误导了我们出了什么错（真正的错误是文件找不到而不是空指针），还误导了错误的出处，不应该在<code>in.read()</code>而应该在<code>new FileInputStream(filename)</code>。</p>
<p>所以<code>readFile()</code>真正应该做的事情不是捕获这些异常，那应该是什么？看起来有点有悖常理，通常最合适的做法其实是什么都不做，不要马上捕获异常。把责任交给<code>readFile()</code>的调用者，让它来决定文件缺失的处理方法，有可能会提示用户指定其他文件，或者使用默认值，实在不行的话警告用户并退出程序。</p>
<p>当然，最终你的程序需要捕获异常，否则会意外终止。但这里的技巧是<strong>在合适的层面捕获异常</strong>，以便你的程序要么可以从异常中有意义地恢复并继续下去，而不导致更深入的错误；要么能够为用户提供明确的信息，引导他们修正错误。如果当前所在方法无法胜任，那么就不要处理异常，而将它抛出直至具备处理这个异常的能力的作用域来处理。</p>
<h2 id="该抛出何种异常"><a href="#该抛出何种异常" class="headerlink" title="该抛出何种异常"></a>该抛出何种异常</h2><p>那么抛出异常时该抛出何种异常，是 Checked Exception 还是 Unchecked Exception ？我在网上查阅资料时发现不同的人对此有不同的观点，不管是开发人员还是项目的 Leader。有的认为该全部抛出 Unchecked Exception 类型的异常，并在某一层面做统一捕获处理，这样做的优点是保证了方法的纯粹性。另一种观点则不支持抛出<code>RuntimeException</code>。通过阅读《Thinking in Java》和<a href="https://www.ibm.com/developerworks/cn/java/j-jtp05254/">关于异常的争论：要检查，还是不要检查？– IBM developerWorks</a>（这是一篇非常优质的文章）发现很多资深的专家甚至是语言的设计者对此持有不同观点。</p>
<h3 id="传统的观点"><a href="#传统的观点" class="headerlink" title="传统的观点"></a>传统的观点</h3><blockquote>
<p>“If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception.” —— <em>The Java Tutorial</em></p>
</blockquote>
<p>Sun 公司的 <em>The Java Tutorial</em> 摘录中，总结了关于将一个异常声明为检查型还是非检查型的传统观点。</p>
<p>因为 Java 语言并不要求方法捕获或者指定运行时异常，因此编写只抛出运行时异常的代码或者使得他们的所有异常子类都继承自<code>RuntimeException</code>，对于程序员来说是有吸引力的。这些编程捷径允许程序员编写 Java 代码不会受到来自编译器的所有挑剔性错误的干扰。尽管对于程序员来说这似乎比较方便，但是它回避了 Java 的捕获或者指定要求的意图，并且对于那些使用您提供的类的程序员可能会导致问题。 </p>
<p>如果您仅仅是因此而抛出一个<code>RuntimeException</code>或者它的子类，那么您换取到了什么呢？您只是获得了抛出一个异常而不用您指定这样做的能力。换句话说，这是一种用于避免文档化方法所能抛出的异常的方式。在什么时候这是有益的？也就是说，在什么时候避免注明一个方法的行为是有益的？答案是“几乎从不”。</p>
<p><strong>换句话说，Sun 告诉我们检查型异常应该是准则。</strong> 该教程通过多种方式继续说明，通常应该抛出检查型异常，而不是<code>RuntimeException</code> —— 除非您是 JVM。</p>
<p>在 <em>Effective Java: Programming Language Guide</em> 一书中，Josh Bloch 提供了下列关于检查型和非检查型异常的知识点，这些与 <em>The Java Tutorial</em> 中的建议相一致（但是并不完全严格一致）：</p>
<ul>
<li><strong>第 39 条：只为异常条件使用异常。</strong> 也就是说，不要为控制流程而使用异常，比如应当使用<code>Iterator.hasNext()</code>去判断迭代边界，而不是在调用<code>Iterator.next()</code>捕获<code>NoSuchElementException</code>。</li>
<li><strong>第 40 条：为可恢复的条件使用检查型异常，为编程错误使用运行时异常。</strong> 这里，Bloch 回应传统的 Sun 观点 —— 运行时异常应该只是用于指示编程错误，例如违反前置条件。</li>
<li><strong>第 41 条：避免不必要的使用检查型异常。</strong> 换句话说，对于调用者不可能从其中恢复的情形，或者惟一可以预见的响应将是程序退出，则不要使用检查型异常。</li>
<li><strong>第 43 条：抛出与抽象相适应的异常。</strong> 换句话说，一个方法所抛出的异常应该在一个抽象层次上定义，该抽象层次与该方法做什么相一致，而不一定与方法的底层实现细节相一致。例如，一个从文件、数据库装载资源的方法在不能找到资源时，应该抛出某种<code>ResourceNotFound</code>异常（通常使用异常链来保存隐含的原因），而不是更底层的<code>IOException</code>、<code>SQLException</code>。</li>
</ul>
<h3 id="重新考察检查型异常"><a href="#重新考察检查型异常" class="headerlink" title="重新考察检查型异常"></a>重新考察检查型异常</h3><p>最近，几位受尊敬的专家，包括 <em>Thinking in Java</em> 作者 Bruce Eckel 和 <em>J2EE Design and Development</em> 作者 Rod Johnson，已经公开声明尽管他们最初完全同意检查型异常的正统观点，但是他们已经认定<strong>排他性</strong>使用检查型异常的想法并没有最初看起来那样好，并且<strong>对于许多大型项目，检查型异常已经成为一个重要的问题来源</strong>。Eckel 提出了一个更为极端的观点，建议所有的异常应该是非检查型的；Johnson 的观点要保守一些，但是仍然暗示传统的优先选择检查型异常是过分的。Martin Fowler 也说过：“总的来说，我觉得异常很不错，但是 Java 的‘被检查的异常’带来的麻烦比好处要多。”</p>
<p>不恰当的使用检查型异常会导致许多问题：</p>
<ul>
<li><strong>检查型异常不适当地暴露实现细节</strong>。如果选择不处理而将异常逐层向上抛出，势必会导致方法与底层实现所抛异常相耦合。举个例子，一个<code>loadUserProfile()</code>方法可能会去调用加载数据库或者加载文件系统的代码，而在该方法层面抛出<code>SQLException</code>或是<code>FileNotFoundException</code>，这实际上违反了 Bloch 的 第 43 条 —— 被抛出的异常所位于的抽象层次与抛出它们的方法不一致。所以你可能需要重新包装一个<code>NoSuchUserException</code>并抛出。</li>
<li><strong>不稳定的方法签名</strong>。你可能对因为实现的改变而修改方法签名声明的异常感到厌烦，事实上这也是由于业务方法与具体实现相耦合所导致的。本质上还是没遵循第 43 条，方法在遇到失败时应该抛出一个异常，并且该异常应该反映该方法做什么（就像<code>NoSuchUserException</code>反应出该方法是去查询用户），而不是它具体如何做（像<code>SQLException</code>反应出需要连接数据库）。</li>
<li><strong>难以理解的代码</strong>。因为许多方法都抛出一定数目的不同异常，错误处理的代码相对于实际的功能代码的比率可能会偏高，使得难以找到一个方法中实际完成功能的代码。异常通过集中错误处理来设想减少代码的，但是一个具有三行代码和六个 catch 块（其中每个块只是记录异常或者包装并重新抛出异常）的方法看起来比较膨胀并且会使得本来简单的代码变得模糊。这与异常设计的初衷相违背。</li>
</ul>
<p>基于以上种种原因，Bruce Eckel 声称在使用 Java 语言多年后，他已经得出这样的结论，认为检查型异常是一个失败的发明。Eckel 提倡将所有的异常都作为非检查型的。如果查看 Eckel 的 Web 站点上的讨论，您将会发现回应者是严重分裂的。一些人认为他的提议是荒谬的；一些人认为这是一个重要的思想。</p>
<p>Rod Johnson 采取一个不太激进的方法。他提出，<strong>一些异常本质上是次要的返回代码</strong>（它通常指示违反业务规则），该类异常的作用通常在于中断违反业务规则的操作，抛出至处理错误的层面被捕获（指示如何修正）。Johnson 提倡对于该类异常使用检查型异常。</p>
<h3 id="该使用何种异常"><a href="#该使用何种异常" class="headerlink" title="该使用何种异常"></a>该使用何种异常</h3><p>关于是否使用检查型异常的决定是复杂的，并且很显然没有明显的答案。Sun 的建议是对于任何情况使用它们，而 C# 方法（也就是 Eckel 和其他人所赞同的）是对于任何情况都不使用它们。其他人表示可以折中考虑。个人认为并没有绝对的对与错，<strong>选择何种异常在于团队的统一规范</strong>。非检查型异常的最大风险之一就是它并没有按照检查型异常采用的方式那样自我<strong>文档化</strong>。阅读 Java 源码发现，不管是检查型异常还是非检查型异常，都在文档中标明了该方法会抛出何种异常。在决定使用非检查型异常更需如此，不管是提示自己还是使用你提供的类库的其他人员。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Thinking in Java》</li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-jtp05254/">关于异常的争论：要检查，还是不要检查？– IBM developerWorks</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28302269">Java异常的深入研究与分析 – 知乎</a></li>
<li><a href="https://www.zhihu.com/question/28254987">如何优雅的处理异常？– 知乎</a></li>
<li><a href="https://www.cnblogs.com/skywang12345/p/3544287.html">《Effective Java》中关于异常处理的几条建议</a></li>
</ul>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 异常处理之 Web 案例</title>
    <url>/2018/07/19/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B9%8B%20Web%20%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于我的上一篇博客：<a href="https://s2mple.xyz/2018/07/16/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">Java 异常处理</a>中的观点，我编写了一个简单的 Web 案例，包括自定义异常类，在合适的层面处理，以及遇到的由于代码 Bug 抛出运行时异常的情形。示例代码已经上传至 <a href="https://github.com/s1mplecc/exception-demo">GitHub</a>，包含基于 Spring Boot 的 Java 后端代码以及基于 Vue.js 的前端代码两个部分。</p>
<p>我们的演示案例有两个功能，获取用户列表以及注册新用户，界面如下所示：</p>
<p><img src="/0.png" alt="102BDB82-6CAD-4C3F-A5EC-5F1052F3A337"></p>
<h2 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h2><p>先看一下我们领域模型 User，为简化代码未使用数据库，而是模拟数据库的自增主键自动生成 userId。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> userIdGenerateKey = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    User(String username, String phone, Integer age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = User.userIdGenerateKey++;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    User(User userWithoutId) &#123;</span><br><span class="line">        <span class="keyword">this</span>(userWithoutId.username, userWithoutId.phone, userWithoutId.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在资源库<code>UserRepository</code>一层使用<code>List</code>直接在内存中存储用户，并初始化了两条用户信息。对外提供<code>users()</code>返回所有用户以及<code>addUser()</code>添加一个新用户两个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        users.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;13500000000&quot;</span>, <span class="number">18</span>));</span><br><span class="line">        users.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;13500000001&quot;</span>, <span class="number">19</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">users</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到在业务功能为获取用户列表和注册新用户，而注册功能还可能包括发送验证邮件等之类的功能，所以有必要将其提取至 Service 层提供一个<code>register()</code>接口。目前只是单纯的调用资源库的<code>addUser()</code>添加一个新的用户。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userRepository.addUser(<span class="keyword">new</span> User(user));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller 层代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">users</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.users();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        userService.register(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加业务规则进行校验"><a href="#添加业务规则进行校验" class="headerlink" title="添加业务规则进行校验"></a>添加业务规则进行校验</h3><p>上述案例还是未抛出任何异常的情况，实际业务必然会对用户输入做一定约束。假设注册新用户有如下业务规则：1. 用户名是必填项，不能为空；2. 年龄和电话号码为可选项，如果填入年龄，必须是大于零的合法数字。</p>
<p>那么根据 DDD 的思想以及信息专家模式，检查用户名和年龄是否合法应该属于领域对象 User。如下所示，这里先埋个坑，也是我未思考全面所留下的隐患，一会儿会提及。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkAgeIsLegal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age &gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUsernameIsNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(username.trim());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>如果客户输入的值不符合要求，我们应当抛出一个异常提醒用户及时修正。自定义<code>RequestArgsIllegalException</code>异常类，意为请求参数非法，重写<code>getMessage()</code>方法。异常类的命名要清晰准确反应问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestArgsIllegalException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestArgsIllegalException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestArgsIllegalException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Illegal request arguments: &quot;</span> + <span class="keyword">super</span>.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务层的<code>register()</code>接口，我们使用<strong>卫语句</strong>检查参数，如果非法则抛出包含了异常信息的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserService</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(User user)</span> <span class="keyword">throws</span> RequestArgsIllegalException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!user.checkAgeIsLegal()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RequestArgsIllegalException(<span class="string">&quot;age cannot be less than zero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!user.checkUsernameIsNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RequestArgsIllegalException(<span class="string">&quot;username can not be empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    userRepository.addUser(<span class="keyword">new</span> User(user));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Controller 层捕获异常并将异常信息返回给前端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserController</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="meta">@RequestBody</span> User user, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userService.register(user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RequestArgsIllegalException e) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;&#123;&#125;. &#123;&#125;&quot;</span>, e.getMessage(), user);</span><br><span class="line">        response.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口调试"><a href="#接口调试" class="headerlink" title="接口调试"></a>接口调试</h2><p>使用 Postman 测试后端<code>register()</code>接口，请求体如下，其中年龄违反了业务规则。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;Halen&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="attr">&quot;phone&quot;</span>: <span class="string">&quot;13500000002&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Postman 返回的错误信息，状态吗<code>status</code>为 400，错误信息<code>message</code>为 “Illegal request arguments: age cannot be less than zero” 都已经被包装在返回的消息体中。同理，用户名为空也是一样就不贴出来了。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="number">1532055599002</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;Bad Request&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Illegal request arguments: age cannot be less than zero&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/users&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又要提到我之前说到的那个坑了，也是我在使用 Postman 测试接口时发现的 Bug。根据业务规则允许用户不填入年龄和电话号码。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求消息体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;Halen&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应消息体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="number">1532056232417</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;Internal Server Error&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;No message available&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/users&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常可怕的 500 服务器内部错误出现了！根据响应消息完全无法定位错误出处。一般来说，这种情况是后端代码出了 Bug，所幸我们还能查看控制台输出或者日志。果不其然，一个空指针异常被抛出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.NullPointerException: null</span><br><span class="line">    at info.s1mple.exceptiondemo.domian.model.user.User.checkAgeIsLegal(User.java:30)</span><br></pre></td></tr></table></figure>

<p>原来是<code>checkAgeIsLegal()</code>方法出了问题，赶紧去及时修复 Bug，根据业务规则，添加<code>this.age == null</code>认为年龄为空合法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkAgeIsLegal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age == <span class="keyword">null</span> || <span class="keyword">this</span>.age &gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h2><p>前端实现就很简单了，捕获到错误直接 alert 出来。前端使用 axios 发送异步请求，请求后端的注册用户接口，<code>this.user</code>是绑定了用户输入表单值的 User 对象。如果参数符合要求提示成功，如果参数非法则会走入<code>catch</code>分支将错误原因提醒给用户。注意到 Error 对象是做了封装的，我们要获取可以在<code>err.response.data</code>中获取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">register</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    axios.post(<span class="string">&#x27;http://localhost:8080/users&#x27;</span>, <span class="built_in">this</span>.user)</span><br><span class="line">      .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;Success!&#x27;</span>)</span><br><span class="line">        <span class="built_in">this</span>.loadUsers()</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        alert(err.response.data.message)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>前端捕获了异常将异常出错信息弹框显示：</p>
<p><img src="/1.png" alt="06A6A59C-1FDF-4BA6-9DDB-6D29BDD489A9"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由此我们整个的前后端异常处理的过程就贯通了，在这个案例中我使用的是受控异常（Checked Exception）并且自定义了异常类。可以看到，相较于运行时异常（RuntimeException），它的好处在于能够很好的将异常分门别类，并且捕获异常返回相应的异常码给前端，也方便前端的报错呈现。最后我们总结一下：<strong>对于由用户操作引起的异常，在我们的控制范围之内，应当使用合适的受控异常对其进行捕获并反馈给前端</strong>。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 网络爬虫</title>
    <url>/2018/11/05/Java%20%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>编写一个 Java 的爬虫程序，并行爬取小说网站上的小说。代码已上传至 <a href="https://github.com/s1mplecc/web-crawler">GitHub</a>。Python 编写的爬虫请见<a href="https://s2mple.xyz/2018/12/03/50%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B9%B6%E5%8F%91%E7%9A%84%20Python%20%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F/">50 行代码实现一个并发的 Python 爬虫程序</a>。本文主要关注：</p>
<ul>
<li>爬虫程序思路</li>
<li>使用 <strong>Gradle</strong> 构建项目时遇到的问题以及解决办法</li>
<li>使用 JDK8 的特性如何简便地进行<strong>并行化开发</strong></li>
</ul>
<h2 id="爬虫思路"><a href="#爬虫思路" class="headerlink" title="爬虫思路"></a>爬虫思路</h2><p>先说一说自己写这个爬虫时的思路，也算是解决问题的入手点。主要的解析类为 HtmlParser ，负责解析 Html。其实这个程序就是通过 Html 源码解析小说名 Title、小说所含所有章节的 Url、小说每一章的内容，最后将内容按顺序写入文件。</p>
<h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>解析小说章节目录网址 Html 源码的 <code>&lt;h1&gt;...&lt;/h1&gt;</code> 标签中的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 章节目录网址</span><br><span class="line">http://www.biquge.cm/9/9422/</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;h1&gt;大道朝天&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">// after parse</span><br><span class="line">大道朝天</span><br></pre></td></tr></table></figure>

<h3 id="Chapter-URIs"><a href="#Chapter-URIs" class="headerlink" title="Chapter URIs"></a>Chapter URIs</h3><p>解析小说章节目录网址 Html 源码的 <code>&lt;div id=&quot;list&quot;&gt;...&lt;/div&gt;</code> 中包含的 <code>&lt;a href=&quot;...&quot;&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 章节目录网址</span><br><span class="line">http://www.biquge.cm/9/9422/</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;div id=&quot;list&quot;&gt;</span><br><span class="line">&lt;dl&gt;&lt;dd&gt;&lt;a href=&quot;/9/9422/6927857.html&quot;&gt;第一章 三千里禁&lt;/a&gt;&lt;/dd&gt;</span><br><span class="line">&lt;dd&gt;&lt;a href=&quot;/9/9422/6927858.html&quot;&gt;第二章 斩天一剑&lt;/a&gt;&lt;/dd&gt;</span><br><span class="line">&lt;dd&gt;&lt;a href=&quot;/9/9422/6927859.html&quot;&gt;第三章 再次踏进那条河的白衣少年&lt;/a&gt;&lt;/dd&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/dl&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// after parse</span><br><span class="line">[&quot;/9/9422/6927859.html&quot;, &quot;/9/9422/6927858.html&quot;, &quot;/9/9422/6927857.html&quot; ...]</span><br></pre></td></tr></table></figure>

<h3 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h3><p>根据 Chapter URIs 解析每一章的内容，最后拼接在一起写入文件。根据 <code>&lt;div id=&quot;content&quot;&gt;...&lt;/div&gt;</code> 解析，<code>&amp;nbsp;</code> 替换为空格，<code>&lt;br /&gt;</code> 替换为换行符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 某一章的网址</span><br><span class="line">http://www.biquge.cm/9/9422/6927857.html</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;div id=&quot;content&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;朝天大陆南方，一片青山绵延数千里，数百秀峰终年隐在云雾中。&lt;br /&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;天下第一修行大派青山宗便在此间，普通人极难一睹真容。&lt;br /&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// after parse</span><br><span class="line"></span><br><span class="line">    朝天大陆南方，一片青山绵延数千里，数百秀峰终年隐在云雾中。</span><br><span class="line">    </span><br><span class="line">    天下第一修行大派青山宗便在此间，普通人极难一睹真容。</span><br></pre></td></tr></table></figure>

<h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p>不得不说，Gradle 让我眼前一亮，相比 Maven，它抛弃了冗余繁琐的 XML 格式，使用语法精炼的 <strong>Groovy</strong>，以下就是我的项目构建文件 <strong>build.gradle</strong> 的全部内容，相当于 Maven 的 pom.xml，清爽简短但重要的信息一点不少。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">&#x27;xyz.s1mple.crawler&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.3.1&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.3.1&#x27;</span></span><br><span class="line">    testCompile <span class="string">&#x27;org.assertj:assertj-core:3.11.1&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;org.slf4j:slf4j-api:1.7.25&#x27;</span></span><br><span class="line">    runtime <span class="string">&#x27;org.slf4j:slf4j-simple:1.7.25&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line"></span><br><span class="line">    testLogging &#123;</span><br><span class="line">        events <span class="string">&quot;passed&quot;</span>, <span class="string">&quot;skipped&quot;</span>, <span class="string">&quot;failed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的配置文件中我们可以发现，Gradle 沿用了 Maven 的中央仓库，同时还可以设置 Maven 本地仓库，同时 Gradle 项目生成的构件也可以发布到 Maven 仓库供他人使用，这一点也是支撑 Gradle 快速发展的重要一点。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>关于安装，我使用的 IDE 是 IntelliJ IDEA，使用内置的 Gradle 也可，但最好是下载安装全局的 Gradle，这样可以随时随地跑 Gradle 命令。Mac 下安装十分方便。其他系统如何安装可以在 <a href="https://gradle.org/install/#with-a-package-manager">Gradle官网</a> 上找到。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install gradle</span><br></pre></td></tr></table></figure>

<h3 id="JUnit5"><a href="#JUnit5" class="headerlink" title="JUnit5"></a>JUnit5</h3><p>在使用 Gradle 的时候我遇到了一个问题：明明添加了 JUnit5 也就是 jupiter 的依赖，为什么使用 <code>gradle test</code> 命令没用任何输出。这个问题在我将依赖换回 Junit4 时得到解决，也就是说果然是配置的问题。在 build.gradle 中添加如下配置即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.3.1&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.3.1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以添加 <code>testLogging</code>。再运行命令有如下输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  web-crawler git:(master) ✗ gradle clean test</span><br><span class="line"></span><br><span class="line">&gt; Task :test</span><br><span class="line"></span><br><span class="line">xyz.s1mple.crawler.HtmlParserTest &gt; should_parse_novel_content_from_html() PASSED</span><br><span class="line"></span><br><span class="line">xyz.s1mple.crawler.HtmlParserTest &gt; should_parse_novel_title_from_html() PASSED</span><br><span class="line"></span><br><span class="line">xyz.s1mple.crawler.HtmlParserTest &gt; should_parse_chapter_uris_from_html() PASSED</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 1s</span><br></pre></td></tr></table></figure>

<h2 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h2><p>Java 多线程编程是越来越容易了，从最早的 Thread，Runnable 到 JDK5 的ExecutorService 到 JDK7 的 ForkJoin 框架。现在 JDK8 又提供了<strong>并行流</strong>（<strong>parallelStream</strong>）来简化这一过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; cost = Lists.newArrayList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">34</span>);</span><br><span class="line"><span class="keyword">long</span> total = cost.parallelStream()</span><br><span class="line">                    .map(x -&gt; x += <span class="number">1</span>)</span><br><span class="line">                    .reduce((y, z) -&gt; y + z)</span><br><span class="line">                    .get();</span><br></pre></td></tr></table></figure>

<p>在 parallelStream 中默认线程池大小是机器的 CPU 核数。<strong>默认情况下，所有的 Fork/Join 任务都会共用同一个线程池，线程的数量等于CPU的核数</strong>。所以在未手动设置线程池数量的情况下我的电脑会启动 4 个线程，而爬虫的瓶颈在于网络 I/O 不在 CPU，所以果断自定义线程数。效果也十分显著，爬取两千多章的时间从原先的两分多钟变为 20s。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool(PARALLELISM_LEVEL);</span><br><span class="line">pool.submit(() -&gt; urls.parallelStream()</span><br><span class="line">        .map(url -&gt; htmlParser.parseContent(urlReader.read(url)))</span><br><span class="line">        .reduce((x, y) -&gt; x + y)</span><br><span class="line">        .orElse(<span class="string">&quot;&quot;</span>))</span><br><span class="line">        .get();</span><br></pre></td></tr></table></figure>

<p>需要注意两点：</p>
<ul>
<li><code>pool.submit()</code> 该方法为<strong>懒加载</strong>，如果<strong>不调用它的结果则实际不会执行</strong>，最后 <code>.get()</code> 获取执行结果。</li>
<li><code>.reduce((x, y) -&gt; x + y)</code> 这一步貌似会有很多字符串拼接影响效率，实则底层会使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 帮你做了性能优化。</li>
</ul>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>关于并行数对爬虫程序的性能影响，实际测试时受网络波动的影响，测试数据可能波动较大，连接每个 Url 的耗时在 50ms ～ 1000ms 波动区间。为减少网络不稳定带来的影响，以下测试分为 100 章、1000 章两个数量级，进行不同并行等级的循环测试，测试 3 轮，时间单位为秒。</p>
<p><strong>数量级：103 章</strong></p>
<table>
<thead>
<tr>
<th align="center">PARALLELISM_LEVEL</th>
<th align="center">1</th>
<th align="center">4</th>
<th align="center">16</th>
<th align="center">64</th>
<th align="center">256</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第1次测试</td>
<td align="center">9</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">第2次测试</td>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">第3次测试</td>
<td align="center">9</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p><strong>数量级：1180 章</strong></p>
<table>
<thead>
<tr>
<th align="center">PARALLELISM_LEVEL</th>
<th align="center">4</th>
<th align="center">8</th>
<th align="center">16</th>
<th align="center">32</th>
<th align="center">64</th>
<th align="center">128</th>
<th align="center">256</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第1次测试</td>
<td align="center">28</td>
<td align="center">16</td>
<td align="center">10</td>
<td align="center">13</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">11</td>
</tr>
<tr>
<td align="center">第2次测试</td>
<td align="center">23</td>
<td align="center">16</td>
<td align="center">14</td>
<td align="center">11</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">14</td>
</tr>
<tr>
<td align="center">第3次测试</td>
<td align="center">25</td>
<td align="center">29</td>
<td align="center">14</td>
<td align="center">13</td>
<td align="center">29</td>
<td align="center">20</td>
<td align="center">20</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.infoq.com/cn/news/2011/04/xxb-maven-6-gradle">Gradle，构建工具的未来？</a></li>
<li><a href="https://medium.com/@jonashavers/how-to-use-junit-5-with-gradle-fb7c5c3286cc">How to use JUnit 5 with Gradle</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 日志二三事</title>
    <url>/2019/01/13/Java-%E6%97%A5%E5%BF%97%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 拥有功能和性能都非常强大的日志库，但另一方面，Java 日志库依赖看起来丰富的让人眼花缭乱。相信大家或多或少都有这样的疑问，Log4j，SLF4J，Logback，Log4j2 这些日志框架我该如何选择？它们彼此间又有什么关系？本篇文章将介绍这些日志库的历史演进和之间的关系，方便你选择最适合的日志库。文章最后还有日志库使用的最佳实践。</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p><strong>Log4j</strong> (Log For Java) 可以当之无愧地说是 Java 日志框架的元老，1999 年发布首个版本，2012 年发布最后一个版本，2015 年正式宣布终止，至今还有无数的系统在使用 Log4j，甚至很多新系统的日志框架选型仍在选择 Log4j。</p>
<p>然而老的不等于好的，在 IT 技术层面更是如此。尽管 Log4j 有着出色的历史战绩，但早已不是 Java 日志框架的最优选择。</p>
<p>在 Log4j 被 Apache Foundation 收入门下之后，由于理念不合， Log4j 的作者 Ceki Gülcü 离开并开发了 SLF4J 和 Logback。</p>
<p><strong>SLF4J</strong> (Simple Log Facade For Java) 因其优秀的性能和理念很快受到了广泛欢迎，2016 年的统计显示，GitHub 上的热门 Java 项目中，SLF4J 是使用率第二名的类库（第一名是 Junit）。</p>
<p><strong>Logback</strong> 则吸取了 Log4j 的经验，实现了很多强大的新功能，再加上它和 SLF4J 能够无缝集成，也受到了欢迎。</p>
<p>在这期间，Apache Logging 则一直在关门憋大招，<strong>Log4j2</strong> 在 beta 版鼓捣了几年，终于在 2014 年发布了 GA 版，不仅吸收了 Logback 的先进功能，更通过优秀的锁机制、LMAX Disruptor、”无垃圾”机制等先进特性，在性能上全面超越了 Log4j 和 Logback。</p>
<h3 id="Log4j-1-x"><a href="#Log4j-1-x" class="headerlink" title="Log4j 1.x"></a>Log4j 1.x</h3><p>Log4j (Log For Java) 是在 Logback 出现之前被广泛使用的日志库，由 Gülcü 于 2001 年发布，后来成为 Apache 基金会的顶级项目。Log4j 在设计上非常优秀，对后续的 Java Log 框架有长久而深远的影响，也产生了 Log4c、Log4s、Log4perl 等到其他语言的移植。Log4j 的短板在于性能，在Logback 和 Log4j2 出来之后，Log4j 的使用也减少了。</p>
<h3 id="Commons-Logging"><a href="#Commons-Logging" class="headerlink" title="Commons Logging"></a>Commons Logging</h3><p>Commons Logging，简称 JCL，是 Apache 下属项目。JCL 是一个 <strong>Log Facade，只提供 Log API，不提供实现</strong>，然后有 Adapter 来使用 Log4j 或者 JDK 中自带的 JUL（Java Util Logging）作为 <strong>Log Implementation</strong>。</p>
<p>不同的项目可能各自使用了不同的日志库，如果你的项目依赖的其他项目各自使用了不同的日志库，你想控制日志行为，就需要针对每个日志库都写一个配置文件，那岂不是很麻烦?所以这个时候 JCL 就出现了。</p>
<p>在程序中日志创建和记录都是用 JCL 中的接口，而真正运行时会搜索当前 ClassPath 中有什么实现，如果有 Log4j 就是用 Log4j，如果啥都没有则使用 JDK 的 JUL。这样，在你的项目中，还有第三方的项目中，大家记录日志都使用 JCL 的接口，然后最终运行程序时，可以按照自己的需求(或者喜好)来选择使用合适的 Log Implementation。比如你想使用 Log4j，就添加 Log4j 的依赖并编写一个 Log4j 的配置文件（通常命名为 <code>log4j.properties</code>）。</p>
<h3 id="SLF4J-Logback"><a href="#SLF4J-Logback" class="headerlink" title="SLF4J/Logback"></a>SLF4J/Logback</h3><p>SLF4J (Simple Logging <strong>Facade</strong> for Java) 和 Logback 也是 Gülcü 创立的项目，其创立主要是为了提供更高性能的实现。其中，SLF4j 是类似于 JCL 的 Log Facade，Logback 是类似于 Log4j 的 Log Implementation。</p>
<p>SLF4J 出现的缘由是 Gülcü 认为 JCL 的 API 设计得不好，容易让使用者写出性能有问题的代码。比如在用 JCL 输出一个 debug 级别的 log：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;start process request, url: &quot;</span> + url);</span><br></pre></td></tr></table></figure>

<p>这个有什么问题呢？一般生产环境 log 级别都会设到 info 或者以上，那这条 log 是不会被输出的。然而不管会不会输出，这其中都会做一个字符串连接操作，然后生产一个新的字符串。如果这条语句在循环或者被调用很多次的函数中，就会多做很多无用的字符串连接，影响性能。所以 JCL 的最佳实践推荐这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;start process request, url: &quot;</span> + url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然作为 API 来说这太为繁琐，所以 SLF4J 提供了新的 API，方便开发者使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;start process request, url: &#123;&#125;&quot;</span>, url);</span><br></pre></td></tr></table></figure>

<p>这样的话，在不输出 log 的时候避免了字符串拼接的开销；在输出的时候需要做一个字符串 format，代价比手工拼接字符串大一些，但是可以接受。</p>
<p>而 Logback 则是作为 Log4j 的取缔者来开发的，提供了性能更好的实现，以及异步 logger，Filter 等更多的特性。</p>
<h3 id="Log4j2"><a href="#Log4j2" class="headerlink" title="Log4j2"></a>Log4j2</h3><p>现在有了更好的 SLF4J 和 Logback 正慢慢取代 JCL 和 Log4j，然而维护 Log4j 的人不想坐视用户一点点被 SLF4J /Logback 蚕食，所以 Log4j2 诞生了。Log4j2 和 Log4j1.x 并不兼容，设计上很大程度上模仿了 SLF4J/Logback，性能上也获得了很大的提升。Log4j2 也做了 Facade/Implementation 分离的设计，分成了 log4j-api 和 log4j-core。</p>
<h2 id="Facade-amp-Implementation"><a href="#Facade-amp-Implementation" class="headerlink" title="Facade &amp; Implementation"></a>Facade &amp; Implementation</h2><p>JCL、SLF4J 和 Log4j2 日志框架都使用了 GoF 设计模式中的门面模式（<strong>Facade Pattern</strong>），将接口和实现分离，定义统一的接口，而实现可以由用户自由选择。现在我们有了三个流行的 Log Facade，以及多个 Log Implementation，那么该如何配合使用呢？</p>
<h3 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h3><p>Gülcü 是个追求完美的人，他决定让 SLF4J 和这些 Log 之间都能够方便的互相替换，所以做了各种 <strong>Adapter</strong> 和 <strong>Bridge</strong> 来连接:</p>
<p><img src="/2019/01/13/Java-%E6%97%A5%E5%BF%97%E4%BA%8C%E4%B8%89%E4%BA%8B/0.jpg" alt="0a9ca27a6fcb038fca91153b1147e5cc.jpeg"></p>
<p>有趣的是，唯独没有 slf4j-over-log4j2 的桥接库，而且 log4j-to-slf4j 和 log4j-slf4j-impl 也是由 Apache 自己开发的。</p>
<p>slf4j-api 只是 Log Facade 的依赖，添加了该依赖意味着在编码时你能够使用 <code>Logger log = LoggerFactory.getLogger(Main.class);</code> 和 <code>log.info(&quot;hello, &#123;&#125;&quot;, &quot;world&quot;);</code> 这种方式。除此之外，还需要添加 Log Implementation 的依赖。</p>
<p>下图是 <a href="https://www.slf4j.org/manual.html">SLF4J官网</a> 介绍可以绑定的日志实现框架。其中 slf4j-simple 是为小项目提供的简单实现；logback-classic 是官方的原生实现，不需要额外的适配器。而 <code>slf4j-log4j12</code> 和 <code>slf4j-jdk14</code> 分别是适配到 Log4j 和 JUL 的依赖，JUL 由于是 JDK 自带所以不需要额外依赖，而 Log4j 则还需要添加自己的底层实现依赖。</p>
<p><img src="/2019/01/13/Java-%E6%97%A5%E5%BF%97%E4%BA%8C%E4%B8%89%E4%BA%8B/1.png" alt="b7d8f119aca4c91e4d72283f7198148f.png"></p>
<p>下面这张图展示了 SLF4J 绑定不同日志实现框架需要的依赖：</p>
<p><img src="/2019/01/13/Java-%E6%97%A5%E5%BF%97%E4%BA%8C%E4%B8%89%E4%BA%8B/2.png" alt="d8261ab119309917e25180ef0ae42abe.png"></p>
<h3 id="Log4j2-1"><a href="#Log4j2-1" class="headerlink" title="Log4j2"></a>Log4j2</h3><p>关于 Log Facade 选择 SLF4J 还是 Log4j2，个人觉得要看项目需求。总的来说 SLF4J 的兼容性更好，日志实现可以随意搭配使用；虽然 Log4j2 可以通过 log4j-to-slf4j 桥接到 SLF4J 再使用其他的 Log Implementation，但这必然带来多余的性能消耗。</p>
<p>而 Log4j2 的优点则在于性能，在 <a href="https://stackoverflow.com/questions/41498021/is-it-worth-to-use-slf4j-with-log4j2">Is it worth to use slf4j with log4j2</a> 这个问题中推荐直接面向 Log4j2 API 编程，理由如下：</p>
<ul>
<li>Message API</li>
<li>Lambdas for lazy logging</li>
<li>Log any Object instead of just Strings</li>
<li>Garbage-free: avoid creating varargs or creating Strings where possible</li>
<li>CloseableThreadContext automatically removes items from the MDC when you’re finished with them</li>
</ul>
<p>Logback 和 Log4j2 都宣称自己是 Log4j 的后代，一个是出自同一作者，另一个则是在名字上根正苗红。撇开血统不谈，比较一下 Log4j2 和 Logback：</p>
<ul>
<li>Log4j2 比 Logback 更新。Log4j2 的 GA 版在 2014 年底才推出，比 Logback 晚了好几年，这期间 Log4j2 确实吸收了 SLF4J 和 Logback 的一些优点（比如日志模板），同时应用了不少的新技术</li>
<li>由于采用了更先进的锁机制和 LMAX Disruptor 库，Log4j2 的性能优于 Logback，尤其是在多线程环境下和使用异步日志的环境下</li>
<li>二者都支持 Filter（应该说是 Log4j2 借鉴了 Logback 的 Filter），能够实现灵活的日志记录规则（例如仅对一部分用户记录 DEBUG 级别的日志）</li>
<li>二者都支持对配置文件的动态更新</li>
<li>二者都能够适配 SLF4J， Logback 与 SLF4J 的适配应该会更好一些，毕竟省掉了一层适配库</li>
<li>Logback 能够自动压缩/删除旧日志</li>
<li>Logback 提供了对日志的 HTTP 访问功能</li>
<li>Log4j2 实现了“无垃圾”和“低垃圾”模式。简单地说，Log4j2 在记录日志时，能够重用对象（如String等），尽可能避免实例化新的临时对象，减少因日志记录产生的垃圾对象，减少垃圾回收带来的性能下降</li>
</ul>
<p>这是 Apache 官方提供的同步和异步写日志时的性能对比图：</p>
<p><img src="/2019/01/13/Java-%E6%97%A5%E5%BF%97%E4%BA%8C%E4%B8%89%E4%BA%8B/3.png" alt="900a0952b7540882925dd50699dc3e29.png"></p>
<p><img src="/2019/01/13/Java-%E6%97%A5%E5%BF%97%E4%BA%8C%E4%B8%89%E4%BA%8B/4.png" alt="c5b42a899b63e265a3e2f4300d443ecb.png"></p>
<p>所以综上所诉，个人的看法是：<strong>如果对性能有要求，且 Log Implementation 想选用 Log4j2 的话，推荐 Log Facade 直接使用 Log4j2 API</strong>。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="总是使用-Log-Facade，而不是具体-Log-Implementation"><a href="#总是使用-Log-Facade，而不是具体-Log-Implementation" class="headerlink" title="总是使用 Log Facade，而不是具体 Log Implementation"></a>总是使用 Log Facade，而不是具体 Log Implementation</h3><p>正如之前所说的，使用 Log Facade 可以方便的切换具体的日志实现。而且，如果依赖多个项目，使用了不同的 Log Facade，还可以方便的通过 Adapter 转接到同一个实现上。如果依赖项目使用了多个不同的日志实现，就麻烦的多了。</p>
<p>具体来说，现在<strong>推荐使用 Log4j2 API 或者 SLF4j</strong>，不推荐继续使用 JCL。</p>
<h3 id="只添加一个-Log-Implementation-依赖"><a href="#只添加一个-Log-Implementation-依赖" class="headerlink" title="只添加一个 Log Implementation 依赖"></a>只添加一个 Log Implementation 依赖</h3><p>毫无疑问，项目中应该只使用一个具体的 Log Implementation，<strong>建议使用 Logback 或者 Log4j2</strong>。如果有依赖的项目中，使用的 Log Facade 不支持直接使用当前的 Log Implementation，就添加合适的桥接器依赖。</p>
<h3 id="总是为-Log-Implementation-依赖设置-optional-和-runtime-scope"><a href="#总是为-Log-Implementation-依赖设置-optional-和-runtime-scope" class="headerlink" title="总是为 Log Implementation 依赖设置 optional 和 runtime scope"></a>总是为 Log Implementation 依赖设置 optional 和 runtime scope</h3><p>在项目中，Log Implementation 的依赖强烈建议设置为 runtime scope，并且设置为 optional。例如项目中使用了 SLF4J 作为 Log Facade，然后想使用 Logback 作为 Implementation，那么使用 POM 文件应该这么写：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;logback.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设为 optional，<strong>依赖不会传递</strong>，这样如果你的项目被别的项目依赖，它就不会引入不想要的 Log Implementation 依赖，即<strong>使用你提供的库的用户可以自定义 Log Implementation</strong>；</p>
<p>Scope 设置为 runtime，是为了防止开发人员在项目中直接使用 Log Implementation 中的类，而不适用 Log Facade 中的类，即<strong>编码时程序员只可见 Log Facade 层面而不必关注实现层面</strong>。</p>
<h3 id="如果有必要，排除依赖的第三方库中的-Log-Impementation-依赖"><a href="#如果有必要，排除依赖的第三方库中的-Log-Impementation-依赖" class="headerlink" title="如果有必要，排除依赖的第三方库中的 Log Impementation 依赖"></a>如果有必要，排除依赖的第三方库中的 Log Impementation 依赖</h3><p>这是很常见的一个问题，第三方库的开发者未必会把具体的日志实现或者桥接器的依赖设置为 optional，然后你的项目继承了这些依赖。然而具体的日志实现未必是你想使用的，比如他依赖了 Log4j，你想使用 Logback，这样程序在运行时会检测到有多个日志实现类，如下图。另外，如果不同的第三方依赖使用了不同的桥接器和 Log 实现，也容易形成环。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/Users/s1mple/.m2/repository/org/slf4j/slf4j-log4j12/1.7.5/slf4j-log4j12-1.7.5.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/Users/s1mple/.m2/repository/com/caacitc/slf4j-jdk14-1.6.1.jar/1.0.2/slf4j-jdk14-1.6.1.jar-1.0.2.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br></pre></td></tr></table></figure>

<p>这种情况下，推荐的处理方法，是<strong>使用 exclude 来排除所有的这些 Log 实现和桥接器的依赖，只保留第三方库里面对 Log Facade 的依赖</strong>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.jstorm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstorm-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外，在 IntelliJ IDEA 中，可以使用 <strong>Show Maven Dependencies</strong> 查看依赖关系图，可以方便的搜索依赖并 exclude 掉。</p>
<h3 id="避免为不会输出的-log-付出代价"><a href="#避免为不会输出的-log-付出代价" class="headerlink" title="避免为不会输出的 log 付出代价"></a>避免为不会输出的 log 付出代价</h3><p>Log 库都可以灵活的设置输出界别，所以每一条程序中的 log，都是有可能不会被输出的。这时候要注意不要额外的付出代价。</p>
<p>先看两个有问题的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;start process request, url: &quot;</span> + url);</span><br><span class="line">logger.debug(<span class="string">&quot;receive request: &#123;&#125;&quot;</span>, toJson(request));</span><br></pre></td></tr></table></figure>

<p>第一条是直接做了字符串拼接，所以即使日志级别高于 debug 也会做一个字符串连接操作；第二条虽然用了 SLF4J/Log4j2 中的懒求值方式来避免不必要的字符串拼接开销，但是 <code>toJson()</code> 这个函数却是都会被调用并且开销更大。</p>
<p>推荐的写法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;start process request, url:&#123;&#125;&quot;</span>, url); <span class="comment">// SLF4J/LOG4J2</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123; <span class="comment">// SLF4J/LOG4J2</span></span><br><span class="line">    logger.debug(<span class="string">&quot;receive request: &quot;</span> + toJson(request)); </span><br><span class="line">&#125;</span><br><span class="line">logger.debug(<span class="string">&quot;receive request: &#123;&#125;&quot;</span>, () -&gt; toJson(request)); <span class="comment">// LOG4J2</span></span><br><span class="line">logger.debug(() -&gt; <span class="string">&quot;receive request: &quot;</span> + toJson(request)); <span class="comment">// LOG4J2</span></span><br></pre></td></tr></table></figure>

<h3 id="日志中尽量避免输出行号，函数名等字段"><a href="#日志中尽量避免输出行号，函数名等字段" class="headerlink" title="日志中尽量避免输出行号，函数名等字段"></a>日志中尽量避免输出行号，函数名等字段</h3><p>原因是，为了获取语句所在的函数名，或者行号，log 库的实现都是获取当前的 stacktrace，然后分析取出这些信息，而获取 stacktrace 的代价是很昂贵的。如果有很多的日志输出，就会占用大量的 CPU。在没有特殊需要的情况下，建议不要在日志中输出这些这些字段。</p>
<p>正确做法是使用日志打印的类名和内容定位到代码位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Main.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16:08:14.913 [main] INFO com.github.s1mplecc.log.Main - hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/24272450">Java 日志框架解析(上) - 历史演进</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24275518">Java 日志框架解析(下) - 最佳实践</a></li>
<li><a href="http://codepub.cn/2017/03/08/Programming-to-the-log4j2-API-instead-of-slf4j/">面向log4j2 API编程而不是slf4j</a></li>
<li><a href="https://www.slf4j.org/manual.html">SLF4J 官方文档</a></li>
<li><a href="https://logging.apache.org/log4j/2.x/performance.html">Apache Log4j2 官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Optional 源码阅读</title>
    <url>/2018/11/27/Java8%20Optional%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Optional 是 Java8 引入的一个重要特性，它是一个容器，里面装着一个可能为空可能不为空的对象。在它出现之前，为避免空指针异常我们可能会这样编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLastFour</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(employee != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Address address = employee.getPrimaryAddress();</span><br><span class="line">        <span class="keyword">if</span>(address != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ZipCode zip = address.getZipCode();</span><br><span class="line">            <span class="keyword">if</span>(zip != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> zip.getLastFour()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> FMLException(<span class="string">&quot;Missing data&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然代码嵌套层次很深不够整洁。而用 Optional 将值包裹起来后，我们可以不再关注于值会不会为 <code>null</code>，会不会抛空指针，而将注意力集中在<strong>对数据的操作</strong>。并且 Optional 提供了 <code>map</code>、<code>flatMap</code>、<code>filter</code> 等方法让我们可以进行<strong>函数式风格</strong>的编码。那么上诉代码可以如此改写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLastFour</span><span class="params">(Optional&lt;Employee&gt; employee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> employee.flatMap(employee -&gt; employee.getPrimaryAddress())</span><br><span class="line">                   .flatMap(address -&gt; address.getZipCode())</span><br><span class="line">                   .flatMap(zip -&gt; zip.getLastFour())</span><br><span class="line">                   .orElseThrow(() -&gt; <span class="keyword">new</span> FMLException(<span class="string">&quot;Missing data&quot;</span>));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>更确切的说，Optional 是一个 <strong>Monad</strong> 容器。那什么是 Monad 呢？可以参考下面这段话：<code> Think of monads as an object that wraps a value and allows us to apply a set of transformations on that value and get it back out with all the transformations applied.</code> 简单的说，Monad 是一个包裹了一个值的容器（值可以是单个对象也可以是集合），允许我们对该值进行一系列的转换（函数操作）后返回给m我们期望的值。也就是说，Monad 封装了接收函数作为入参的一些方法（filter、map、flatMap 等）。</p>
<p>那么现在，让我们从源码开始一步一步揭开它的神秘面纱。</p>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>Optional 使用私有化的构造函数和单例模式提供了<strong>值为空的单例</strong>，暴露的静态工厂方法为 <code>Optional.empty()</code>。该种设计感觉和 Java 设计模式中的<strong>空对象模式</strong>有异曲同工之妙，也是避免空指针的核心所在，后面我们将会提到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Common instance for &#123;<span class="doctag">@code</span> empty()&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时提供 <code>Optional.of(value)</code> 和 <code>Optional.ofNullable(value)</code> 两个工厂方法用于将 value 装入 Optional 容器中。注意 <code>of()</code> 方法在值为空时会抛出<strong>空指针异常</strong>。所以在允许入参值为空时使用 <code>ofNullable()</code>，它在值为空时调用 <code>Optional.empty()</code> 返回 <code>EMPTY</code> 单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if value is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isPresent-和-get"><a href="#isPresent-和-get" class="headerlink" title="isPresent 和 get"></a>isPresent 和 get</h2><p>Optional 提供的 <code>isPresent()</code> 用于判断容器中的值是否为空，<code>get()</code> 方法用来获取容器中的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法通常会组合起来使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; optString = Optional.of(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optString.isPresent()) &#123;</span><br><span class="line">    System.out.println(optString.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但我想说的是，Optional 的初衷不是为了让我们仅仅使用这两个方法，事实上也应当尽量避免使用这两个方法，而是多使用 <code>ifPresent()</code> 和 <code>orElse()</code> 等方法代替。因为一旦你这样用，就和使用 <code>if(xxx != null)&#123;&#125;</code> 没什么区别了。</p>
<p>Optional 真正的核心就在于下面这些方法。</p>
<h2 id="Optional-与函数接口"><a href="#Optional-与函数接口" class="headerlink" title="Optional 与函数接口"></a>Optional 与函数接口</h2><p>Optional 对于 Java8 提供的四种<strong>函数接口</strong>：<code>Function</code>、<code>Predicate</code>、<code>Consumer</code>、<code>Supplier</code> 都包装了相应的方法，以满足我们可以进行<strong>函数式</strong>风格的编码。本部分介绍这些方法的实现和使用，为了直观，部分代码使用匿名内部类的方式。</p>
<p>关于函数接口（<strong>Functional Interfaces</strong>），我的上一篇博客 <a href="https://s2mple.xyz/2018/11/16/Java8%20%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/">Java8 函数接口</a>中有详细介绍。</p>
<h3 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a>ifPresent</h3><p><code>ifPresent(consumer)</code> 方法接受一个<strong>消费者函数</strong> <code>Consumer</code> 入参，如果 Optional 容器中的值不为空，则调用 <code>Consumer</code> 的 <code>accept(value)</code> 方法消费容器中的值。若值为空则什么都不做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下代码会打印容器中的值 “abc”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">        .ifPresent(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// print abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda</span></span><br><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>).ifPresent(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter(predicate)</code> 方法接受一个<strong>谓词函数</strong> <code>Predicate</code> 入参，调用谓词的 <code>test(value)</code> 判断容器中的值是否满足谓词条件，<strong>满足则返回该容器本身</strong>，不满足或值为空时返回 <code>Optional.empty()</code> 单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> predicate.test(value) ? <span class="keyword">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码分别展示了 <code>filter</code> 通过和不通过的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">        .filter(<span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s.length() &gt; <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .ifPresent(System.out::println); <span class="comment">// do nothing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda</span></span><br><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">        .filter(s -&gt; s.length() == <span class="number">3</span>)</span><br><span class="line">        .ifPresent(System.out::println); <span class="comment">// print abc</span></span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map(mapper)</code> 方法接受一个<strong>函数</strong> <code>Function</code> 入参，将容器中的值执行 <code>apply(value)</code> 操作后返回，返回的依然是 <code>Optional</code> 包裹的值，值的类型为 <code>apply()</code>  方法的返回类型，即 <code>map</code> 可能<strong>改变容器中值的类型</strong>。同样，值为空或 <code>apply()</code> 为空则返回 <code>empty()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码展示了 <code>map</code> 的用法，通过 <code>.map(s -&gt; s.length())</code> 返回类型已经从 <code>Optional&lt;String&gt;</code> 变为 <code>Optional&lt;Integer&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">        .map(<span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .ifPresent(System.out::println); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda</span></span><br><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>).map(s -&gt; s.length()); <span class="comment">// Optional&lt;Integer&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p><code>flatMap</code> 可以视作一种特殊的 <code>map</code> 操作，可以视为 map + flatten 操作。仔细观察，它的入参接受的 Function 函数的输出泛型为 <code>Optional&lt;U&gt;</code>，所以不需要像 <code>map</code> 方法中再用 <code>ofNullable()</code> 包装成 Optional 容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map</code> 与 <code>flatMap</code> 的区别如下。自定义的 <code>optionalLength(string)</code> 返回 <code>Optional&lt;Integer&gt;</code> 类型，所以 <code>map</code> 会返回 <code>Optional&lt;Optional&lt;Integer&gt;&gt;</code> 类型，只有调用 <code>flatMap</code> 才返回 <code>Optional&lt;Integer&gt;</code> 类型，相当于多做了一步 flatten 操作将其拍平为一维纬度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Optional&lt;Integer&gt; <span class="title">optionalLength</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(s.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>).map(s -&gt; optionalLength(s)); <span class="comment">// Optional&lt;Optional&lt;Integer&gt;&gt;</span></span><br><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>).flatMap(s -&gt; optionalLength(s)); <span class="comment">// Optional&lt;Integer&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="orElseGet-和-orElseThrow"><a href="#orElseGet-和-orElseThrow" class="headerlink" title="orElseGet 和 orElseThrow"></a>orElseGet 和 orElseThrow</h3><p><code>orElseGet(other)</code> 接受<strong>提供者函数</strong> <code>Supplier</code> 作为入参，当容器中的值为空时调用 <code>Supplier</code> 的 <code>get()</code> 方法获取值。<code>orElseThrow(supplier)</code> 则是值为空时抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时如下，若当前容器中的值为空则返回 <code>anotherString()</code> 的值。注意这一步已经跳出了 Optional 容器，返回的类型为容器中值的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">anotherString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;anotherString&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">        .filter(s -&gt; s.startsWith(<span class="string">&quot;zzz&quot;</span>)) <span class="comment">// Optional.empty()</span></span><br><span class="line">        .orElseGet(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> anotherString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// &quot;anotherString&quot;</span></span><br><span class="line">        </span><br><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">        .filter(s -&gt; s.length() == <span class="number">3</span>) <span class="comment">// Optional[&quot;abc&quot;]</span></span><br><span class="line">        .orElseGet(() -&gt; anotherString()); <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">        .filter(s -&gt; s.startsWith(<span class="string">&quot;zzz&quot;</span>)) <span class="comment">// Optional.empty()</span></span><br><span class="line">        .orElseThrow(() -&gt; <span class="keyword">new</span> RuntimeException(<span class="string">&quot;no eligible values&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Optional 提供的这些方法让我们不再关注于是否会抛出空指针异常，而是通过函数的自由组合专注于对数据的操作，比如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(people)</span><br><span class="line">        .flatMap(people -&gt; people.getName())</span><br><span class="line">        .map(name -&gt; name.toUpperCase())</span><br><span class="line">        .filter(name -&gt; name.startsWith(<span class="string">&quot;T&quot;</span>))</span><br><span class="line">        .orElse(<span class="string">&quot;TONY&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其实 Optional 的核心在于提供的 <code>empty()</code> 单例，使得如上代码整条链路不会在某一步中断抛出空指针异常，而是只要其中一步值为空后，<code>Optional.empty()</code> <strong>将在这条链路上继续向下传播</strong>，直到最后 <code>orElse()</code> 等方法指名默认处理并跳出容器。</p>
<p>Optional 源码时有诸多值得我们借鉴取经的地方，诸如：</p>
<ul>
<li>Monad 容器的思想。容器接收一个值，进行函数操作后依然返回该容器，比如 <code>map</code>、<code>flatMap</code>、<code>filter</code>。这就使得我们可以随意组合以上方法，编写函数式风格的代码。类似的还有 Java 8 的 <code>Stream</code> 接口。</li>
<li>提供 <code>Optional.empty()</code> 类似空对象模式的空值单例。</li>
<li>严谨的编码，源码中有许多 <code>Objects.requireNonNull()</code> 对极端情况进行验证，比如 <code>flatMap</code> 方法中的 <code>Objects.requireNonNull(mapper);</code> 和 <code>Optional.ofNullable(mapper.apply(value));</code> 对于入参函数不为空和调用 <code>apply()</code> 后返回值不为空的验证。</li>
<li>API 的全面性，当容器中没有你期待的值时提供 <code>orElse</code>、<code>orElseGet</code>、<code>orElseThrow</code> 等其他处理手段，不管是设置默认值还是抛出异常，API 都考虑到了。</li>
</ul>
<p>目前在一些 ORM 框架中也加入了 Optional 的支持，比如 Hibernate 从 5.2 版本后提供 <code>loadOptional()</code> 方法返回 <code>Optional&lt;T&gt;</code> 类型。有兴趣的可以自己去研究。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a></li>
<li><a href="https://medium.com/coding-with-clarity/understanding-the-optional-monad-in-java-8-e3000d85ffd2">Understanding the Optional Monad in Java 8</a></li>
</ul>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 函数接口</title>
    <url>/2018/11/16/Java8%20%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><p>在函数式编程中，<strong>纯函数</strong>的定义是：</p>
<ol>
<li>此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由 I/O 设备产生的外部输出无关。</li>
<li>该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。</li>
</ol>
<p>为使 Java 支持函数式编程，<strong>函数接口</strong>（<strong>Functional Interfaces</strong>）正是 Java 8 引入的一个核心概念。函数接口要求接口中只能定义个<strong>唯一一个抽象方法</strong>。同时，引入一个新的注解： <code>@FunctionalInterface</code>，作为函数接口的标记。</p>
<p>Java 8 提供了四大类函数接口：<strong>谓词</strong> <code>Predicate</code>，<strong>函数</strong> <code>Function</code>，<strong>提供者</strong> <code>Supplier</code>，<strong>消费者</strong> <code>Consumer</code>。以及衍生的函数接口，比如 <code>BiFunction&lt;T, U, R&gt;</code> 支持两个入参的函数等等，它们都定义在 <code>java.util.function</code> 包下。</p>
<h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>函数式接口的重要属性是：<strong>我们能够使用 Lambda 实例化它们</strong>。Lambda 表达式的引入给开发者带来了不少优点：在 Java 8 之前，匿名内部类，监听器和事件处理器的使用都显得很冗长，代码可读性很差，Lambda 表达式的应用则使代码变得更加紧凑，可读性增强；Lambda 表达式使<strong>并行操作大集合</strong>变得很方便，可以充分发挥多核 CPU 的优势，更易于为多核处理器编写代码。</p>
<p>Lambda 表达式由三个部分组成：第一部分为一个括号内用逗号分隔的函数入参；第二部分为箭头符号 <code>-&gt;</code>；第三部分为方法体，可以是表达式和代码块。语法如下：</p>
<ul>
<li><p><code>(parameters) ‑&gt; expression</code> 方法体为表达式，该表达式的值作为返回值返回。</p>
</li>
<li><p><code>(parameters) ‑&gt; &#123; statements; &#125;</code> 方法体为代码块，必须用 <code>&#123;&#125;</code> 包裹起来，若该函数需要返回值则需要 <code>return</code>。</p>
</li>
</ul>
<p>用 Lambda 表达式替换匿名内部类的写法如下。再进一步，可以使用<strong>方法引用</strong>（<strong>Method Reference</strong>）简写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Anonymous inner class</span></span><br><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>).map(<span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda</span></span><br><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>).map(s -&gt; s.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method reference</span></span><br><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>).map(String::length);</span><br></pre></td></tr></table></figure>

<p>使用 <code>parallelStream()</code> 和 Lambda 表达式并行操作集合，默认线程数为 CPU 核数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">urls.parallelStream()</span><br><span class="line">        .filter(url -&gt; url.endsWith(<span class="string">&quot;.html&quot;</span>))</span><br><span class="line">        .map(url -&gt; htmlParser.contentFrom(url))</span><br><span class="line">        .reduce((x, y) -&gt; x + y)</span><br><span class="line">        .orElse(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="谓词-Predicate"><a href="#谓词-Predicate" class="headerlink" title="谓词 Predicate"></a>谓词 Predicate</h2><p>在计算机语言的环境下，谓词是指条件表达式的求值返回真或假的过程。在 Java 中就是进行逻辑判断后返回值为 <code>boolean</code> 的函数，对应函数接口为 <code>Predicate&lt;T&gt;</code>。在针对集合进行筛选时，通常会使用谓词对集合元素进行条件判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Predicate&lt;T&gt;</code> 接口定义的唯一抽象方法 <code>test(T t)</code> 用以验证输入参数是否满足谓词条件。同时，它还提供了默认方法用以支持<strong>组合的与、或、非逻辑运算</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; p1 = p ‑&gt; p.getColor() == Color.RED;</span><br><span class="line">Predicate&lt;Apple&gt; p2 = p ‑&gt; p.getSize() == Size.Medium;</span><br><span class="line"></span><br><span class="line">apples.stream().filter(p1.and(p2));</span><br></pre></td></tr></table></figure>

<h2 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 Function"></a>函数 Function</h2><p><code>Function&lt;T, R&gt;</code> 接口代表一个函数，准确地说，代表了具有输入输出的函数，这也是最常见的函数定义。具有两个入参的函数对应接口为 <code>BiFunction&lt;T, U, R&gt;</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the type of the result of the function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数也可以进行组合，组合后返回的结果也是一个函数，这就是所谓的<strong>组合子</strong>。组合子方法分别为：</p>
<ul>
<li><code>compose(before)</code>，组合前一个函数，相当于 <code>V -&gt; T -&gt; R</code> </li>
<li><code>andThen(after)</code>，组合后一个函数，相当于 <code>T -&gt; R -&gt; V</code></li>
</ul>
<h2 id="提供者-Supplier"><a href="#提供者-Supplier" class="headerlink" title="提供者 Supplier"></a>提供者 Supplier</h2><p>当一个函数仅仅用于返回结果时，我们可以将这种函数称为<strong>提供者</strong>，接口定义为 <code>Supplier&lt;T&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只提供一个 <code>get()</code> 方法，我们可以将这种提供者代表的函数看做是一种 Query 操作。</p>
<h2 id="消费者-Consumer"><a href="#消费者-Consumer" class="headerlink" title="消费者 Consumer"></a>消费者 Consumer</h2><p>与提供者对应的接口则被称之为<strong>消费者</strong>，用以接收一个输入，但却并不关心返回结果，即返回值为 <code>void</code>。消费者的对应接口为 <code>Consumer&lt;T&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents an operation that accepts a single input argument and returns no</span></span><br><span class="line"><span class="comment"> * result. Unlike most other functional interfaces, &#123;<span class="doctag">@code</span> Consumer&#125; is expected</span></span><br><span class="line"><span class="comment"> * to operate via side-effects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不像其他函数接口，<code>Consumer</code> 通常是<strong>有副作用的</strong>。这也不难理解，该函数只有输入没有输出，那数据通常是被外部系统消费了。同时 <code>Consumer</code> 支持 <code>andThen(after)</code> 组合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; c1 = s -&gt; System.out.println(s);</span><br><span class="line">Consumer&lt;String&gt; c2 = s -&gt; storeToDB(s);</span><br><span class="line"></span><br><span class="line">Optional.of(<span class="string">&quot;abc&quot;</span>).ifPresent(c1.andThen(c2));</span><br></pre></td></tr></table></figure>

<p>这种消费者代表的函数相当于是一个 Command 操作。软件设计的一条原则就是 <strong>CQS</strong>（Command-Query Separation）命令-查询分离原则，即保证一个方法体内只有 Query 和 Command 的一种，就是因为查询无副作用而命令可能会改变数据状态。</p>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 异步编程</title>
    <url>/2018/04/27/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你可能知道，JavaScript 语言的执行环境是<strong>单线程（single thread）</strong>。这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。为了解决这个问题，JavaScript 语言将任务的执行模式分成两种：同步（Synchronous）和 异步（Asynchronous）。</p>
<ul>
<li><strong>同步模式</strong>：后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；</li>
<li><strong>异步模式</strong>则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</li>
</ul>
<p>异步模式非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是 Ajax 操作。在服务器端，Node.js 的异步 I/O 则保证了同一时间可以响应大量的 Http 请求。</p>
<p>本文主要介绍 JavaScript 的异步编程发展：从回调函数到 ES6 的 Promise 对象，再到 ES7 的 async/await 关键字。示例代码已上传至<a href="https://github.com/s1mplecc/js-asynchronous-programming">GitHub</a>。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调（Callback）函数是异步编程最基本的方法。回调就好比你送女朋友到车站，并让她回家了给你回条短信。回调函数在完成任务后就会被调用，Node.js 就使用了大量的回调函数</p>
<ul>
<li>看看下面的示例代码，你要求女朋友回到家后发一条短信告诉你，然后她在回家的路上愉快的耍起了手机，哈哈哈</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goHome</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    callback()</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am playing a mobile phone&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I have just arrived home.&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goHome(sendMessage)</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// I am playing a mobile phone.</span></span><br><span class="line"><span class="comment">// I have just arrived home.    // after 2000ms</span></span><br></pre></td></tr></table></figure>
<p>注意打印结果的顺序。先打印的是<code>I am playing a mobile phone</code>，而后过了 2s 打印<code>I have just arrived home</code>。这是因为使用了<code>setTimeout()</code>这个函数，表示延时 2000ms 后执行回调函数。</p>
<p>在这个示例中，回调函数即是<code>sendMessage()</code>，回家这个动作是比较耗时的，所以我们使用了<strong>异步</strong>的方式，使得<strong>玩手机的行为不受到阻塞</strong>。是吧，玩手机不一定要回家才能完，路上也能玩嘛。回调使得同步操作变成了异步操作，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。</p>
<p>回调函数的优点是简单、容易理解，缺点是不利于代码的阅读和维护，各个部分之间<strong>高度耦合</strong>，流程会很混乱，而且每个任务只能指定一个回调函数。在 Node.js 的开发中，由于逻辑分层所致，会出现多层回调，易于引发异常处理混乱、闭包过于复杂、代码难以维护等问题。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件，更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。所谓 Promise，简单说就是一个<strong>容器</strong>，里面<strong>保存着某个未来才会结束的事件（通常是一个异步操作）的结果</strong>。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise 对象有以下两个特点：</p>
<ul>
<li><p>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：<strong>Pending</strong>（进行中）、<strong>Resolved</strong>（已成功，又称 Fulfilled）和 <strong>Rejected</strong>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。</p>
</li>
<li><p><strong>一旦状态改变，就不会再变</strong>，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就<strong>凝固</strong>了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
</li>
</ul>
<p>来看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> goHome = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;I have just arrived home.&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am playing a mobile phone.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goHome.then(sendMessage)</span><br></pre></td></tr></table></figure>

<p>这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，<code>goHome.then(sendMessage)</code>显然更符合人的思维方式。</p>
<p>我们可以在<code>Promise</code>中<code>reject</code>错误，在用<code>catch</code>去捕捉，你可能在 axios 发送异步请求的时候见过这种写法。<code>catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> num = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">10</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;num&#x27;</span>, num)</span><br><span class="line">  num % <span class="number">2</span> === <span class="number">0</span> ? resolve(<span class="string">`<span class="subst">$&#123;num&#125;</span> is an even number`</span>) : reject(<span class="string">`<span class="subst">$&#123;num&#125;</span> is not an even number`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">isEven</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// num 6</span></span><br><span class="line"><span class="comment">// 6 is an even number</span></span><br><span class="line"><span class="comment">// num 7</span></span><br><span class="line"><span class="comment">// 7 is not an even number</span></span><br></pre></td></tr></table></figure>
<p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。更多请参考<a href="http://es6.ruanyifeng.com/#docs/promise">阮老师的教程</a>。</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>最后来看一下异步编程的<strong>终极解决方案</strong>:<code>async/await</code>。<code>async</code>作为 ES7 的一大特性，已经在 Node.js 的框架——<a href="https://koa.bootcss.com/">Koa2</a> 中被广泛使用。<code>async</code>函数是什么？一句话，<strong>async 函数就是 Generator 函数的语法糖</strong>。<code>async</code>用于申明一个<code>function</code>是异步的，而 <code>await</code>用于等待一个异步函数执行完成。</p>
<p>使用时需要注意：<strong>async 函数返回一个 Promise 对象</strong>；<code>await</code>只能在<code>async</code>内部使用，类似于<code>async function</code>内部的<code>then</code>命令的语法糖。</p>
<p><code>await</code>是个运算符，用于组成表达式，<code>await</code>如果在等待一个 Promise 对象，就会阻塞后面的代码，等着 Promise 对象<code>resolve</code>，然后将得到<code>resolve</code>的值作为 <code>await</code> 表达式的运算结果。</p>
<p>用<code>async/await</code>改写后的代码如下，看起来就像同步代码那样直观：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> goHome = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;I have just arrived home.&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am playing a mobile phone.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> msg = <span class="keyword">await</span> goHome</span><br><span class="line">  <span class="built_in">console</span>.log(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendMessage().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Play together.&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// I am playing a mobile phone.</span></span><br><span class="line"><span class="comment">// I have just arrived home.    // after 2000ms</span></span><br><span class="line"><span class="comment">// Play together.</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从最早的回调函数，到 Promise 对象，再到 Generator 函数，每次都有所改进，但又让人觉得不彻底。<strong>异步编程的语法目标，就是怎样让它更像同步编程</strong>， async 函数就是隧道尽头的亮光，很多人认为它是异步操作的终极解决方案。实际使用起来也更顺手、更容易理解，它必然会被普及，我们应该习惯这种用法。事实上 Koa2 也正是由于此而比拥有复杂的回调嵌套的 Express 更脱颖而出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html">Javascript异步编程的4种方法 - 阮一峰</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/promise">Promise 对象 - 阮一峰ES6教程</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/async">async 函数 - 阮一峰ES6教程</a></li>
<li><a href="https://segmentfault.com/a/1190000007535316">理解 JavaScript 的 async/await</a></li>
</ul>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 简介</title>
    <url>/2017/12/26/JavaScript%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>JavaScript</strong>是目前前端开发中最流行的语言，在学习的过程中会遇到各种<strong>JS</strong>有关的名词。本文章的主要目的是介绍<strong>ECMAScript</strong>(or <strong>ES</strong>)、<strong>CommonJS</strong>、<strong>Node.js</strong>、<strong>Vue.js</strong>或<strong>AngularJS</strong>等与<strong>JavaScript</strong>之间的联系。</p>
<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p><strong>ECMAScript</strong>和<strong>JavaScript</strong>的关系是，前者是后者的<strong>规范</strong>，后者是前者的一种<strong>实现</strong>（另外的实现还有<strong>Jscript</strong> 和<strong>ActionScript</strong>等）。</p>
<p><strong>JavaScript</strong>的创造者<strong>Netscape</strong>公司，将<strong>JavaScript</strong>提交给国际标准化组织<strong>ECMA</strong>，希望这种语言能够成为国际标准，标准委员会最终决定，标准在每年的6月份正式发布一次，作为当年的正式版本。</p>
<p>目前的几乎所有的浏览器（不包括低版本的IE），都已经支持<strong>ES5</strong>了，而写代码时最好采用<strong>ES6</strong>语法（毕竟语法糖写起来更舒服，还添加了很多必要的新特性，而且浏览器全面支持<strong>ES6</strong>是迟早的事）。不用担心浏览器不能识别新语法，<strong>Bable</strong>就是用来解决这种问题的工具。</p>
<p><strong>Babel</strong>是一个广泛使用的<strong>ES6</strong>转码器，可以将<strong>ES6</strong>代码转为<strong>ES5</strong>代码，从而在浏览器环境运行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转码前</span></span><br><span class="line">input.map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转码后</span></span><br><span class="line">input.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>在介绍<strong>CommonJS</strong>之前有必要先介绍一下<strong>Node.js</strong>。首先明确一点，<strong>JavaScript</strong>和<strong>Python</strong>一样，是一种脚本语言，或者是<strong>解释型语言</strong>，和<strong>C、C++</strong> 这种需要编译成可执行文件再运行的语言不同，它的运行只需要解释器能够解释执行即可，而不需要编译器。<strong>浏览器</strong>就包含了解释执行网页中的<strong>JavaScript</strong>代码的功能。</p>
<p>伴随着互联网和<strong>JavaScript</strong>语言的快速发展，人们不仅仅局限于拿JS来做前端开发，所以<strong>Node.js</strong>随之应运而生。<strong>Node.js</strong>作为一个后端的<strong>Javascrip</strong>t运行环境（解释器），这意味着你可以编写系统级或者服务器端的<strong>Javascript</strong>代码，交给<strong>Node.js</strong>来解释执行。</p>
<p><strong>Node.js</strong>采用了<strong>Google Chrome</strong>浏览器的V8引擎（<strong>C++编写</strong>），性能很好，同时还提供了很多系统级的API，如文件操作、网络编程等。浏览器端的<strong>Javascript</strong>代码在运行时会受到各种安全性的限制，对客户系统的操作有限。相比之下，<strong>Node.js</strong>则是一个全面的后台运行时，基于<strong>Javascript</strong>提供了其他语言能够实现的许多功能。</p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>可以说<strong>CommonJS</strong>和<strong>Node.js</strong>的关系是，前者是后者的<strong>规范</strong>，后者是前者的一种<strong>实现</strong>。</p>
<p><strong>ECMAScript</strong>提供核心语言功能，浏览器端的<strong>JavaScript实现</strong>包括了<strong>ES核心</strong>、<strong>DOM</strong>(or <strong>Document Object Model</strong>)和<strong>BOM</strong>(or <strong>Browser Object Model</strong>)，所以你在浏览器的<strong>JS</strong>控制台可以使用<code>document、window、alert...</code>等有关<strong>DOM</strong>和<strong>BOM</strong>的操作。</p>
<p>而<strong>CommonJS</strong>主要为<strong>非浏览器的应用</strong>定义一套API（比如<strong>Node</strong>应用），从而填补了空白。它的终极目标是提供一个类似<strong>Python、Ruby</strong>和<strong>Java</strong>的<strong>标准库</strong>。</p>
<p>可以看到在<strong>Node</strong>环境中没有定义<code>alert</code>和<code>document</code>，因为<strong>Node</strong>不关心<strong>DOM</strong>和<strong>BOM</strong>操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ node</span><br><span class="line">&gt; alert(&#x27;!!!&#x27;)</span><br><span class="line">ReferenceError: alert is not defined</span><br><span class="line">&gt; document</span><br><span class="line">ReferenceError: document is not defined</span><br></pre></td></tr></table></figure>

<p>但是它可以调用读取文件的函数，读取出了<code>a.txt</code>中的<code>Hello!</code>并打印，这是浏览器做不到也不应该去做的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ node</span><br><span class="line">&gt; const fs = require(&#x27;fs&#x27;);                 </span><br><span class="line">&gt; const content = fs.readFileSync(&#x27;./a.txt&#x27;,&#x27;utf-8&#x27;);</span><br><span class="line">&gt; console.log(content);</span><br><span class="line">hello!</span><br></pre></td></tr></table></figure>

<h2 id="Vue-js、AngularJS…"><a href="#Vue-js、AngularJS…" class="headerlink" title="Vue.js、AngularJS…"></a>Vue.js、AngularJS…</h2><p>这些没什么好说的，之所以带上<strong>JS</strong>就是因为它们是用<strong>JavaScript</strong>语言开发的框架，实际上就是个<strong>JS库</strong>，用于简化我们前端代码的编写。</p>
<p>至于为什么使用<strong>Vue.js</strong>这些框架需要安装<strong>Node.js</strong>，原因也很简单，因为很多工具（比如<strong>Babel、webpack</strong>）都是用<strong>Node</strong>开发出来的，这也是你为什么可以用<code>npm</code>安装的原因。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://es6.ruanyifeng.com/#docs/intro">ECMAScript6简介 - 阮一峰</a></li>
<li><a href="http://www.commonjs.org/">CommonJS官网</a></li>
<li><a href="https://nodejs.org/en/">Node.js官网</a></li>
</ul>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 泛型</title>
    <url>/2018/02/28/Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我的上一篇博客<a href="https://s2mple.xyz/2018/02/27/Java%E6%B3%9B%E5%9E%8B%E4%B9%8B%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/">Java 泛型之类型擦除</a>只是对于 Java 泛型和类型擦除做了一个简要的介绍，本文主要是针对 Java 泛型做一些更深入的补充说明。</p>
<h2 id="泛型的引入"><a href="#泛型的引入" class="headerlink" title="泛型的引入"></a>泛型的引入</h2><p>在没有泛型之前，我们如果想向一个 Box 类中装入一个不知道类型的对象，只能使用 <strong>Object</strong> 这个顶级父类来操作盒子中的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object object)</span> </span>&#123; <span class="keyword">this</span>.object = object; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> object; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而引入了泛型之后，代码修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generic version of the Box class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the value being boxed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// T stands for &quot;Type&quot;</span></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个装有 T 类型的 Box 类。在使用时可以随心所欲，既可创建一个专门装 String 的 Box ，也可创建一个装 Integer 的 Box。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;String&gt; bs = <span class="keyword">new</span> Box&lt;String&gt;();</span><br><span class="line">Box&lt;Integer&gt; bi = <span class="keyword">new</span> Box&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<p>甚至于我们在定义 Box 时可以更加苛刻，只允许这个盒子装入一个数字类型的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如果你想在创建一个装 String 的 Box 就得报错了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Error: Type Parameter &#x27;String&#x27; is not within its bound; should extend &#x27;Number&#x27;</span></span><br><span class="line"><span class="comment">// Box&lt;String&gt; bs = new Box&lt;String&gt;();</span></span><br></pre></td></tr></table></figure>

<p><strong>Tips</strong>：在 Java SE 7之后，允许我们使用如下更简洁的语法 <code>Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();</code>，因为编译器能够推断出上下文的类型参数，所以没必要做冗余的声明。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型方法是声明了自己的类型参数的方法。泛型方法的类型参数的<strong>作用域</strong>仅限于声明它的方法内部。允许静态和非静态的泛型方法，即可以用 <strong>static</strong> 修饰。泛型方法的语法是<strong>在方法的返回类型之前包含一个尖括号列出的类型参数列表</strong>。</p>
<p>示范代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericsMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printClassName</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestGenericsMethod test = <span class="keyword">new</span> TestGenericsMethod();</span><br><span class="line">        test.printClassName(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        test.printClassName(<span class="number">10</span>);</span><br><span class="line">        test.printClassName(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        test.printClassName(test);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="comment">// Integer</span></span><br><span class="line"><span class="comment">// Character</span></span><br><span class="line"><span class="comment">// TestGenerics</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型的类型变量"><a href="#泛型的类型变量" class="headerlink" title="泛型的类型变量"></a>泛型的类型变量</h2><p><strong>类型变量</strong>( or <strong>Type Variable</strong>) ,即上述代码的 T，用于代表一类类型，声明之后可以在 class 中使用。</p>
<h3 id="命名惯例"><a href="#命名惯例" class="headerlink" title="命名惯例"></a>命名惯例</h3><p>按照惯例，类型参数使用<strong>单个大写字母</strong>表示，虽然这个字母命名并不强求，比如上述代码中的<code>&lt;T&gt;</code>，你可以使用<code>&lt;U&gt;</code>等等代替，但是如下是<strong>类型参数的命名惯例</strong>：</p>
<table>
<thead>
<tr>
<th align="center">命名简写</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T</td>
<td>Type</td>
</tr>
<tr>
<td align="center">S,U,V etc.</td>
<td>2nd, 3rd, 4th types</td>
</tr>
<tr>
<td align="center">E</td>
<td>Element (被广泛适用于 Java 的集合类中，表示集合中的元素类型)</td>
</tr>
<tr>
<td align="center">K</td>
<td>Key</td>
</tr>
<tr>
<td align="center">V</td>
<td>Value</td>
</tr>
<tr>
<td align="center">N</td>
<td>Number</td>
</tr>
</tbody></table>
<h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><p>定义泛型类或接口时可以使用多个类型参数，一个典型案例就是 Map，它存储一对键值对，我截取了一段 Map.Entry 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">setValue</span><span class="params">(V value)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道 HashMap 是继承了 Map 的，所以在使用时可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="通配符与-T-的区别"><a href="#通配符与-T-的区别" class="headerlink" title="通配符与 T 的区别"></a>通配符与 T 的区别</h3><p>在接触泛型之初，我一直好奇 <strong>类型参数</strong>(<strong>type parameters</strong>，即 T, E, etc.) 和 <strong>通配符</strong>(<strong>wildcard</strong>) 之间有什么区别，因为它们的功能看上去有的重叠。以下是我总结自 Java 的官方文档以及 StackOverFlow 上面的解答。</p>
<p><strong>类型参数与通配符的区别：</strong></p>
<p>在定义泛型类或接口时，只能使用类型参数，并可以在类内部引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不可以使用通配符，因为<code>?</code>不能代表一种具体类型，而<code>T</code>代表一种具体类型，只是暂时未定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;?&gt; </span>&#123; <span class="comment">// Error!!!</span></span><br><span class="line">    <span class="keyword">private</span> ? t; <span class="comment">// Error!!!</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通配符可以使用 <strong>super</strong> 关键字定义<strong>下界</strong>，而类型参数不可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(List&lt;? <span class="keyword">super</span> Number&gt; list)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要在泛型类内部定义一个与当前参数类型无关的方法，可以使用<code>&lt;?&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;<span class="comment">// Used type &#x27;T&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printListSize</span><span class="params">(List&lt;?&gt; list)</span></span>&#123; <span class="comment">// Not associated with type &#x27;T&#x27;</span></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box&lt;String&gt; box = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        box.printListSize(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;aa&quot;</span>,<span class="string">&#x27;s&#x27;</span>))); <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，查看 Java 的 <strong>Class</strong> 类的源码，可以看到<code>&lt;?&gt;</code>有被广泛的使用，是因为<code>Class&lt;T&gt;</code>中的大多数的方法都不依赖于 T。</p>
<p>有些人认为，如果你不需要使用声明的参数类型，那就可以使用<code>?</code>使得代码更简单更具可读性。所以，如果你需要定义一种可变的类型，并且在限定范围内使用到这种类型，请使用<code>&lt;T&gt;</code>，否则就可以使用<code>&lt;?&gt;</code>。</p>
<h2 id="泛型示例之-LinkedStack"><a href="#泛型示例之-LinkedStack" class="headerlink" title="泛型示例之 LinkedStack"></a>泛型示例之 LinkedStack</h2><p>下面是一个使用 Java 泛型编写的 LinkedStack 的实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T item;</span><br><span class="line">        Node&lt;T&gt; next; <span class="comment">//下一个节点的引用，类似于C中的指针</span></span><br><span class="line"></span><br><span class="line">        Node() &#123; <span class="comment">//没有参数的Constructor，用于初始化时生成栈顶</span></span><br><span class="line">            item = <span class="keyword">null</span>;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(T item, Node&lt;T&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="comment">//栈空标记</span></span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top = <span class="keyword">new</span> Node&lt;&gt;(); <span class="comment">//初始化栈顶</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;&gt;(item, top); <span class="comment">//与上一节点链接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span> (!top.isEmpty()) &#123;</span><br><span class="line">            top = top.next; <span class="comment">//指针后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/types.html">官方文档</a></li>
<li><a href="https://stackoverflow.com/questions/6008241/what-is-the-difference-between-e-and-t-for-java-generics">What is the difference between ‘?’, ‘E’, and ‘T’ for Java generics?</a></li>
</ul>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 泛型之类型擦除</title>
    <url>/2018/02/27/Java%E6%B3%9B%E5%9E%8B%E4%B9%8B%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java SE5 的重大变化之一就是加入了<strong>泛型</strong>，实现了参数化类型，使得代码可以适用于多种类型。但由于兼容旧版本的考虑，不得不作出了一些牺牲，比如<strong>擦除</strong>，使得泛型使用受到一定局限。本文简要介绍了 Java 泛型以及类型擦除的概念和使用</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>Java泛型</strong> (<strong>Generics</strong>) 是 JDK5 引入的新特性，允许在定义类和接口的时候使用<strong>类型参数</strong> (<strong>Type Parameter</strong>)。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在 JDK5 中的新<strong>集合类</strong>框架中。</p>
<p>通过泛型，大大提升了集合类的<strong>可复用性</strong>，你可以定义一个装字符串的 ArrayList，也可以定义一个装整型的 ArrayList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Stringals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">als.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integerali = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ali.add(<span class="number">1</span>); </span><br><span class="line">ali.add(<span class="string">&quot;aaa&quot;</span>);  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>自定义泛型类可以参考我的上一篇博客，<a href="https://s2mple.xyz/java-generics-linkedstack/">Java泛型之LinkedStack</a></p>
<h3 id="使用泛型需要注意"><a href="#使用泛型需要注意" class="headerlink" title="使用泛型需要注意"></a>使用泛型需要注意</h3><p>泛型的引入可以解决之前的集合类框架在使用过程中经常出现的运行时类型错误，因为编译器可以在编译时就发现很多明显的错误。但无奈的是，为了保证与旧版本的<strong>兼容性</strong>，Java 泛型的实现上存在着一些不够优雅的地方。</p>
<p>开发人员在使用泛型的时候，很容易根据自己的直觉而犯一些错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGenerics</span><span class="params">(ArrayList&lt;Objectlist)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法接收<code>ArrayList&lt;Object&gt;</code>作为形参，但是如果尝试传入一个<code>ArrayList&lt;String&gt;</code>对象，却发现无法通过编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    testGenerics(<span class="keyword">new</span> ArrayList&lt;String&gt;()); <span class="comment">// 编译错误!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然从直觉上来说，Object 是 String 的父类，这种类型转换应该是合理的。但是实际上这会产生<strong>隐含的类型转换</strong>问题，因此编译器直接就禁止这样的行为</p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>使用泛型的时候加上的类型参数，会被编译器在<strong>编译时</strong>去掉(擦除)。这个过程就称为<strong>类型擦除</strong> (<strong>Type Erasure</strong>) 。如在代码中定义的<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译之后都会变成 List 。</p>
<p>可以说，类型擦除这个令人困惑的 Java 特性，完全是历史遗留问题导致的。因为 JDK5 之前没有泛型，为了旧代码能够正常运行，Java 泛型必须要在编译器层次将类型擦除，所导致的严酷事实就是：<strong>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</strong></p>
<p>很多泛型的特性都与类型擦除的存在有关，包括：</p>
<p><strong>泛型类并没有自己独有的 Class 类对象。</strong> 比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code></p>
<p><strong>静态变量是被泛型类的所有实例所共享的。</strong> 对于声明为<code>MyClass&lt;T&gt;</code>的类，访问其中的静态变量的方法仍然是<code>MyClass.myStaticVar</code>。不管是通过<code>new MyClass&lt;String&gt;</code>还是<code>new MyClass&lt;Integer&gt;</code>创建的对象，都是共享一个静态变量</p>
<p><strong>泛型的参数类型不能用于 Java异常处理的<code>catch</code>语句中。</strong> 因为异常处理是由 JVM 在运行时刻来进行的。由于类型信息被擦除，JVM 是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的。对于 JVM 来说，它们都是<code>MyException</code>类型的。也就无法执行与异常对应的<code>catch</code>语句</p>
<p>简单来说就是：<strong>泛型的类型信息在编译阶段被擦除，运行时刻任何获取泛型参数类型信息的行为都是非法的。</strong> </p>
<h3 id="编译器的类型检查"><a href="#编译器的类型检查" class="headerlink" title="编译器的类型检查"></a>编译器的类型检查</h3><p>了解了类型擦除机制之后，就会明白<strong>编译器承担了全部的类型检查工作</strong>。编译器禁止某些泛型的使用方式，正是为了确保类型的安全性。</p>
<p>继续用上例代码来做演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGenerics</span><span class="params">(ArrayList&lt;Objectlist)</span> </span>&#123;</span><br><span class="line">    list.add(<span class="number">1</span>); <span class="comment">// 合法</span></span><br><span class="line">    list.add(<span class="string">&quot;aaa&quot;</span>); <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    testGenerics(<span class="keyword">new</span> ArrayList&lt;String&gt;()); <span class="comment">// 编译错误!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难理解，为了避免<code>ArrayList&lt;String&gt;</code>中添加一个 Integer 类型的对象，编译器干脆禁止了这样的行为。编译器会尽可能的检查可能存在的类型安全问题。对于确定是违反相关原则的地方，会给出编译错误。当编译器无法判断类型的使用是否正确的时候，会给出警告信息。</p>
<h3 id="通配符与上下界"><a href="#通配符与上下界" class="headerlink" title="通配符与上下界"></a>通配符与上下界</h3><p>在使用泛型类的时候，既可以指定一个具体的类型，如<code>List&lt;String&gt;</code>就声明了具体的类型是 String，也可以用 <strong>通配符<code>?</code></strong> 来表示未知类型，比如<code>List&lt;?&gt;</code>。通配符所代表的其实是<strong>一组类型</strong>，但具体的类型<strong>暂时未知</strong>，而是在<strong>使用时再确定</strong>。</p>
<p><code>List&lt;?&gt;</code>不同于<code>List&lt;Object&gt;</code>的地方是，<code>List&lt;Object&gt;</code>实际上确定了参数类型是 Object 及其子类。而<code>List&lt;?&gt;</code>则其中所包含的元素类型是不确定。使用时可以用<code>List&lt;String&gt;</code>或<code>List&lt;Integer&gt;</code>替换。如果它包含了 String 的话，往里面添加 Integer 类型的元素就是错误的</p>
<p>请看如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGenerics</span><span class="params">(ArrayList&lt;?list)</span> </span>&#123;</span><br><span class="line">    list.add(<span class="string">&quot;aaa&quot;</span>); <span class="comment">// 编译错误!!!</span></span><br><span class="line">    </span><br><span class="line">    Object obj = list.get(<span class="number">0</span>); <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Stringlist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    testGenerics(list); <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码有如下几点要注意：</p>
<ol>
<li>因为通配符<code>?</code>类型未知，所以为了避免运行时类型错误，<code>list.add(&quot;aaa&quot;)</code>编译不会通过</li>
<li>虽然类型未知，但肯定是 Object 及其子类，所以<strong>通配符代表的元素可以用 Object 来引用。</strong></li>
<li>向<code>testGenerics()</code>方法传入的是<code>ArrayList&lt;String&gt;</code>类型的，并且编译通过。即使用时声明具体类型</li>
</ol>
<p>由于<code>List&lt;?&gt;</code>中的元素只能用 Object 来引用，显然在需要更精细的类型时并不适用。在这些情况下，可以使用<strong>上下界</strong>来限制未知类型的范围。</p>
<p><code>List&lt;? extends Number&gt;</code>说明 List 中可能包含的元素类型是 Number 及其<strong>子类</strong>。</p>
<p><code>List&lt;? super Number&gt;</code>则说明 List 中包含的是 Number 及其<strong>父类</strong>。</p>
<p>当使用<code>extends</code>引入了上界之后，在使用类型的时候就可以<strong>使用上界类中定义的方法</strong>。查看如下的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGenerics</span><span class="params">(ArrayList&lt;? extends Numberlist)</span> </span>&#123;</span><br><span class="line">    Number number = list.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(number.intValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Doubledoubles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    doubles.add(<span class="number">2.33333</span>);</span><br><span class="line">    testGenerics(doubles); <span class="comment">// 运行输出结果：2 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参改为<code>&lt;? extends Number&gt;</code>后，可以看到如下两个性质：</p>
<ul>
<li>可以使用 Number 引用</li>
<li>在<code>testGenerics()</code>方法中可以调用 Number 类的<code>intValue()</code>方法</li>
</ul>
<p>上述代码中，我们为了调用<code>intValue()</code>方法，必须给定泛型类的边界，以告诉编译器只能接受遵循这个边界的类型。这里重用了 <strong>extends</strong> 关键字。这样在编译时， <strong>泛型类型参数将擦除到它的第一个边界</strong>，即 Number，这样就可以调用<code>intValue()</code>方法了。</p>
<h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>引入泛型之后的类型系统增加了<strong>两个维度</strong>：一个是<strong>类型参数自身</strong>的继承体系结构，另外一个是<strong>泛型类或接口自身</strong>的继承体系结构。第一个指的是对于<code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>这样的情况，类型参数 String 继承自 Object 。而第二种指的是<code>List&lt;String&gt;</code>和<code>Collection&lt;String&gt;</code>这种情况。对于这个类型系统，有如下的一些规则：</p>
<p>相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code>的子类型，<code>List&lt;String&gt;</code>可以替换<code>Collection&lt;String&gt;</code>。这种情况也适用于带有上下界的类型声明。</p>
<p>当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对<code>Collection&lt;? extends Number&gt;</code>来说，其子类型可以在 Collection 这个维度上展开，即<code>List&lt;? extends Number&gt;</code>和<code>Set&lt;? extends Number&gt;</code>等；也可以在 Number 这个层次上展开，即<code>Collection&lt;Double&gt;</code>和<code>Collection&lt;Integer&gt;</code>等。如此循环下去，<code>ArrayList&lt;Long&gt;</code>和<code>HashSet&lt;Double&gt;</code>等也都算是<code>Collection&lt;? extends Number&gt;</code>的子类型。</p>
<p>如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java泛型确实有些让人困惑的特性，这也是任何有历史的编程语言所需要承担的历史包袱，后续的版本更新会被早期的设计缺陷所拖累。正是这样，如果一门语言长久的停留在过去，必然会被新的语言取代。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Java 编程思想》</li>
<li><a href="http://www.infoq.com/cn/articles/cf-java-generics">Java深度历险——Java泛型</a></li>
</ul>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 管道与重定向</title>
    <url>/2017/12/27/Linux%20%E7%AE%A1%E9%81%93%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<h2 id="标准-I-O-流"><a href="#标准-I-O-流" class="headerlink" title="标准 I/O 流"></a>标准 I/O 流</h2><p>Linux shell 可以接收和发送字符序列或字符流形式的输入和输出。无论实际的字符流是来自还是来自文件，键盘，显示器上的窗口或其他IO设备，字符流都可以通过<strong>文件IO</strong>技术进行访问。Linux shell 使用3种<strong>标准的I/O流</strong>，每种流都与一个<strong>文件描述符</strong>。Linux 内核采用文件描述符（file descriptor）来访问文件。文件描述符是<strong>非负整数</strong>。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stdout   //标准输出流，它显示命令运行的输出，文件描述符为 1</span><br><span class="line">stderr   //标准错误流，它显示命令运行的错误输出，文件描述符为 2</span><br><span class="line">stdin    //标准输入流，它为命令提供输入，文件描述符为 0</span><br></pre></td></tr></table></figure>

<p>输入流通常通过终端敲击键盘为程序提供输入。输出流通常向终端输出显示文本字符。</p>
<p><img src="/0.png" alt="linuxcom"></p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>在Linux命令行模式中，如果命令所需的输入不是来自键盘，而是来自指定的文件，这就是输入重定向。同理，命令的输出也可以不显示在屏幕上，而是写入到指定文件中，这就是输出重定向。</p>
<h3 id="gt-符号"><a href="#gt-符号" class="headerlink" title="&gt; 符号"></a>&gt; 符号</h3><p>格式 <code>&#123;stdout|stderr&#125; &gt; filename</code>，使用 <code>&gt;</code> 符号将左侧输出重定向到一个文件中。需要注意的是：如果<strong>文件名不存在则创建它，如果存在则覆盖</strong>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; a.txt</span><br><span class="line">➜ cat a.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>还可以这样：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ ls | grep <span class="string">&quot;**.png&quot;</span> &gt; a.txt</span><br><span class="line">➜ cat a.txt </span><br><span class="line">arguments.png</span><br><span class="line">mvvm.png</span><br><span class="line">nrm-test.png</span><br><span class="line">require.png</span><br></pre></td></tr></table></figure>

<p>该命令将左侧命令的标准输出重定向到<code>a.txt</code>文件中。</p>
<p>特别的，使用 <code>/dev/null</code> 可以清空文件。<code>/dev/null</code>相当于Linux的黑洞文件，永远为空。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /dev/null &gt; a.txt</span><br></pre></td></tr></table></figure>

<h3 id="gt-gt-符号"><a href="#gt-gt-符号" class="headerlink" title="&gt;&gt; 符号"></a>&gt;&gt; 符号</h3><p>格式 <code>&#123;stdout|stderr&#125; &gt;&gt; filename</code>，<code>&gt;&gt;</code>符号和<code>&gt;</code>符号作用差不多，如果文件不存在则创建，存在则<strong>追加</strong>内容到文件尾，不会覆盖。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ cat a.txt</span><br><span class="line">hello</span><br><span class="line">➜ <span class="built_in">echo</span> <span class="string">&quot;world&quot;</span> &gt;&gt; a.txt</span><br><span class="line">➜ cat a.txt</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<h3 id="lt-符号"><a href="#lt-符号" class="headerlink" title="&lt; 符号"></a>&lt; 符号</h3><p>格式 <code>&#123;command&#125; &lt; filename</code>，将文件的内容作为标准输入，传给左边的命令处理。</p>
<p>如下，将字符 <code>o</code> 替换为 <code>x</code>，但是源文件并不会改动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ tr <span class="string">&#x27;o&#x27;</span> <span class="string">&#x27;x&#x27;</span> &lt; a.txt</span><br><span class="line">hellx</span><br><span class="line">wxrld</span><br><span class="line">➜ cat a.txt </span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<p>又比如使用 <code>nc</code> 命令传输文件，发送端将文件作为标准输入传输给接受端，再由接收端写入文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nc -l &#123;port&#125; &gt; filename // 接收端</span><br><span class="line">nc &#123;接受者IP&#125; &#123;port&#125; &lt; filename // 发送端</span><br></pre></td></tr></table></figure>

<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道命令操作符：<code>|</code> ，它能将前面一个命令传出的标准输出(stdout)，作为标准输入(stdin)传给下一条命令。相比于重定向，管道符号两边都是<strong>可独立执行</strong>的命令，通常用于命令间<strong>传递参数</strong>，而重定位符号的右侧必须是文件名。</p>
<p><img src="/1.png" alt="pipe"></p>
<p>如下这条命令 <code>ls</code> 列出当前目录下所有非隐藏文件，作为标准输入传给 <code>grep</code>去过滤出以 <code>.png</code> 结尾的文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ ls | grep <span class="string">&quot;**.png&quot;</span></span><br><span class="line">arguments.png</span><br><span class="line">mvvm.png</span><br><span class="line">nrm-test.png</span><br><span class="line">require.png</span><br></pre></td></tr></table></figure>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>假设现在我启动了一个 Java 进程。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ ps -ef | grep java</span><br><span class="line">  501  6292  6030   0 11:00PM ttys000    0:11.42 /usr/bin/java -jar /Users/s1mple/Library/Mobile Documents/com~apple~CloudDocs/Works/testvue/target/testvue-0.0.1-SNAPSHOT.jar</span><br><span class="line">  501  6324  6224   0 11:05PM ttys001    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn java</span><br></pre></td></tr></table></figure>

<p>执行这条命令后终端打印出 Java 进程信息，进程号 6292。接下来我想结合管道命令 <code>kill</code> 掉这个 Java 进程。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ ps -ef | grep java | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9   </span><br><span class="line">➜ ps -ef | grep java</span><br><span class="line">  501  6352  6224   0 11:11PM ttys001    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn java</span><br></pre></td></tr></table></figure>

<p>这个命令看上去很长其实无非是多个命令组合在一起。我之所以想说这个是因为在<strong>Tomcat</strong>的运行脚本<code>catalina.sh</code>中看到了用于停止<strong>Tomcat</strong>的类似的命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ ps -ef | grep java | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9 </span><br></pre></td></tr></table></figure>

<p><code>ps -ef</code>列出所有进程传递给<code>grep java</code>过滤出包含 Java 关键字的进程，再传递给<code>grep -v grep</code>剔除包含<strong>grep</strong>关键字的进程，<code>awk &#39;&#123;print $2&#125;&#39;</code> 6292，再将参数传递给<code>xargs kill -9</code>最终杀掉进程。实际上等同于执行了 <code>kill -9 6292</code>。</p>
<p>很多时候比如说再写<strong>shell</strong>脚本时确实这样用，因为进程号是动态分配的，不能写死，只能通过一些手段动态获取进程号再进行<strong>参数传递</strong>。</p>
<h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><blockquote>
<p>另外简单提一下<strong>命令替换</strong>。在Linux命令行模式下，当遇到一对 <strong>``</strong> 时，将首先执行 <strong>`</strong> 中间包含的命令，然后将其输出结果作为参数代入命令行中，这就是命令替换了。它<strong>将一个命令的输出作为另外一个命令的参数</strong></p>
</blockquote>
<p>过滤出<code>.*rc</code>的文件，将文件中的内容统一输出到<code>rc.txt</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ cat `ls -a | grep &quot;.*rc&quot;` &gt; ./Desktop/rc.txt</span><br></pre></td></tr></table></figure>

<p>上诉命令和下面这条起一个作用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ ls -a | grep &quot;.*rc&quot; | xargs cat &gt; ./Desktop/rc.txt</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.ibm.com/developerworks/linux/library/l-lpic1-103-4/index.html">Streams, pipes, and redirects</a></li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX 数学公式语法</title>
    <url>/2020/10/11/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="特殊格式"><a href="#特殊格式" class="headerlink" title="特殊格式"></a>特殊格式</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$x^n$</td>
<td align="center"><code>x^n</code></td>
<td align="center">上标符号</td>
</tr>
<tr>
<td align="center">$x_1$</td>
<td align="center"><code>x_1</code></td>
<td align="center">下标符号</td>
</tr>
<tr>
<td align="center">$v_{\mbox{初始}}$</td>
<td align="center"><code>V_&#123;\mbox&#123;初始&#125;&#125;</code></td>
<td align="center">汉字形式</td>
</tr>
<tr>
<td align="center">$\displaystyle \frac{x+y}{y+z}$</td>
<td align="center"><code>\displaystyle \frac&#123;x+y&#125;&#123;y+z&#125;</code></td>
<td align="center">字体控制</td>
</tr>
<tr>
<td align="center">$\underline{x+y}$</td>
<td align="center"><code>\underline&#123;x+y&#125;</code></td>
<td align="center">下划线符号</td>
</tr>
<tr>
<td align="center">$\overbrace{a+b+c+d}^{2.0}$</td>
<td align="center"><code>\overbrace&#123;a+b+c+d&#125;^&#123;2.0&#125;</code></td>
<td align="center">上大括号</td>
</tr>
<tr>
<td align="center">$a+\underbrace{b+c}_{1.0}+d$</td>
<td align="center"><code>a+\underbrace&#123;b+c&#125;_&#123;1.0&#125;+d</code></td>
<td align="center">下大括号</td>
</tr>
<tr>
<td align="center">$x \stackrel{f} \rightarrow y$</td>
<td align="center"><code>x \stackrel&#123;f&#125; \rightarrow y</code></td>
<td align="center">上位符号</td>
</tr>
<tr>
<td align="center">${n+1 \choose k}={n \choose k}+{n \choose k-1}$</td>
<td align="center"><code>&#123;n+1 \choose k&#125;=&#123;n \choose k&#125;+&#123;n \choose k-1&#125;</code></td>
<td align="center">组合公式</td>
</tr>
</tbody></table>
<h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\pm$</td>
<td align="center"><code>\pm</code></td>
<td align="center">加减运算</td>
</tr>
<tr>
<td align="center">$\mp$</td>
<td align="center"><code>\mp</code></td>
<td align="center">减甲运算</td>
</tr>
<tr>
<td align="center">$\times$</td>
<td align="center"><code>\times</code></td>
<td align="center">乘法运算</td>
</tr>
<tr>
<td align="center">$\cdot$</td>
<td align="center"><code>\cdot</code></td>
<td align="center">点乘运算</td>
</tr>
<tr>
<td align="center">$\ast$</td>
<td align="center"><code>\ast</code></td>
<td align="center">星乘运算</td>
</tr>
<tr>
<td align="center">$\div$</td>
<td align="center"><code>\div</code></td>
<td align="center">除法运算</td>
</tr>
<tr>
<td align="center">$\frac{x+y}{y+z}$</td>
<td align="center"><code>\frac&#123;x+y&#125;&#123;y+z&#125;</code> 或 <code>&#123;x+y&#125; \over &#123;y+z&#125;</code></td>
<td align="center">分式运算</td>
</tr>
<tr>
<td align="center">$\overline{x}$</td>
<td align="center"><code>\overline&#123;x&#125;</code></td>
<td align="center">平均数运算</td>
</tr>
<tr>
<td align="center">$\sqrt x$</td>
<td align="center"><code>\sqrt x</code></td>
<td align="center">开根号运算</td>
</tr>
<tr>
<td align="center">$\sqrt[n]{x+y}$</td>
<td align="center"><code>\sqrt[n]&#123;x+y&#125;</code></td>
<td align="center">开方运算</td>
</tr>
<tr>
<td align="center">$\log_2 x$</td>
<td align="center"><code>\log_2 x</code></td>
<td align="center">对数运算</td>
</tr>
<tr>
<td align="center">$\lim \limits_{n \to \infty}x_n$</td>
<td align="center"><code>\lim \limits_&#123;n \to \infty&#125;x_n</code></td>
<td align="center">极限运算</td>
</tr>
<tr>
<td align="center">$\sum \limits_{i=1}^n{x_i}$</td>
<td align="center"><code>\sum \limits_&#123;i=1&#125;^n&#123;x_i&#125;</code></td>
<td align="center">求和运算</td>
</tr>
<tr>
<td align="center">$\prod \limits_{i=1}^n{x_i}$</td>
<td align="center"><code>\prod \limits_&#123;i=1&#125;^n&#123;x_i&#125;</code></td>
<td align="center">连乘运算</td>
</tr>
<tr>
<td align="center">$\int_{a}^{b} e^x, dx$</td>
<td align="center"><code>\int_&#123;a&#125;^&#123;b&#125; e^x\, dx</code></td>
<td align="center">积分运算</td>
</tr>
<tr>
<td align="center">$\iint \limits_D, dx,dy$</td>
<td align="center"><code>\iint \limits_D\, dx\,dy</code></td>
<td align="center">双重积分</td>
</tr>
<tr>
<td align="center">$\oint_{L} x+y, dx,dy$</td>
<td align="center"><code>\oint_&#123;L&#125; x+y\, dx\,dy</code></td>
<td align="center">闭合曲线积分</td>
</tr>
<tr>
<td align="center">$\partial x$</td>
<td align="center"><code>\partial x</code></td>
<td align="center">微分运算</td>
</tr>
</tbody></table>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\geq$</td>
<td align="center"><code>\geq</code></td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">$\leq$</td>
<td align="center"><code>\leq</code></td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">$\neq$</td>
<td align="center"><code>\neq</code></td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">$\ngeq$</td>
<td align="center"><code>\ngeq</code></td>
<td align="center">不大于等于</td>
</tr>
<tr>
<td align="center">$\not\geq$</td>
<td align="center"><code>\not\geq</code></td>
<td align="center">不大于等于</td>
</tr>
<tr>
<td align="center">$\nleq$</td>
<td align="center"><code>\nleq</code></td>
<td align="center">不小于等于</td>
</tr>
<tr>
<td align="center">$\not\leq$</td>
<td align="center"><code>\not\leq</code></td>
<td align="center">不小于等于</td>
</tr>
<tr>
<td align="center">$\approx$</td>
<td align="center"><code>\approx</code></td>
<td align="center">约等于</td>
</tr>
<tr>
<td align="center">$\equiv$</td>
<td align="center"><code>\equiv</code></td>
<td align="center">恒定等于</td>
</tr>
<tr>
<td align="center">$\bigodot$</td>
<td align="center"><code>\bigodot</code></td>
<td align="center">同或</td>
</tr>
<tr>
<td align="center">$\bigotimes$</td>
<td align="center"><code>\bigotimes</code></td>
<td align="center">同与</td>
</tr>
<tr>
<td align="center">$\bigoplus$</td>
<td align="center"><code>\bigoplus</code></td>
<td align="center">异或</td>
</tr>
</tbody></table>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\in$</td>
<td align="center"><code>\in</code></td>
<td align="center">属于</td>
</tr>
<tr>
<td align="center">$\notin$</td>
<td align="center"><code>\notin</code></td>
<td align="center">不属于</td>
</tr>
<tr>
<td align="center">$\subset$</td>
<td align="center"><code>\subset</code></td>
<td align="center">子集</td>
</tr>
<tr>
<td align="center">$\supset$</td>
<td align="center"><code>\supset</code></td>
<td align="center">子集</td>
</tr>
<tr>
<td align="center">$\subseteq$</td>
<td align="center"><code>\subseteq</code></td>
<td align="center">真子集</td>
</tr>
<tr>
<td align="center">$\subsetneq$</td>
<td align="center"><code>\subsetneq</code></td>
<td align="center">非真子集</td>
</tr>
<tr>
<td align="center">$\supseteq$</td>
<td align="center"><code>\supseteq</code></td>
<td align="center">真子集</td>
</tr>
<tr>
<td align="center">$\supsetneq$</td>
<td align="center"><code>\supsetneq</code></td>
<td align="center">非真子集</td>
</tr>
<tr>
<td align="center">$\not\subset$</td>
<td align="center"><code>\not\subset</code></td>
<td align="center">非子集</td>
</tr>
<tr>
<td align="center">$\not\supset$</td>
<td align="center"><code>\not\supset</code></td>
<td align="center">非子集</td>
</tr>
<tr>
<td align="center">$\cup$</td>
<td align="center"><code>\cup</code></td>
<td align="center">并集</td>
</tr>
<tr>
<td align="center">$\cap$</td>
<td align="center"><code>\cap</code></td>
<td align="center">交集</td>
</tr>
<tr>
<td align="center">$\setminus$</td>
<td align="center"><code>\setminus</code></td>
<td align="center">差集</td>
</tr>
<tr>
<td align="center">$\mathbb{R}$</td>
<td align="center"><code>\mathbb&#123;R&#125;</code></td>
<td align="center">实数集合</td>
</tr>
<tr>
<td align="center">$\mathbb{Z}$</td>
<td align="center"><code>\mathbb&#123;Z&#125;</code></td>
<td align="center">自然数集合</td>
</tr>
<tr>
<td align="center">$\emptyset$</td>
<td align="center"><code>\emptyset</code></td>
<td align="center">空集</td>
</tr>
</tbody></table>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\infty$</td>
<td align="center"><code>\infty</code></td>
<td align="center">无穷</td>
</tr>
<tr>
<td align="center">$\imath$</td>
<td align="center"><code>\imath</code></td>
<td align="center">虚数</td>
</tr>
<tr>
<td align="center">$\jmath$</td>
<td align="center"><code>\jmath</code></td>
<td align="center">虚数</td>
</tr>
<tr>
<td align="center">$\hat{a}$</td>
<td align="center"><code>\hat&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\check{a}$</td>
<td align="center"><code>\check&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\breve{a}$</td>
<td align="center"><code>\breve&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\tilde{a}$</td>
<td align="center"><code>\tilde&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\bar{a}$</td>
<td align="center"><code>\bar&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\vec{a}$</td>
<td align="center"><code>\vec&#123;a&#125;</code></td>
<td align="center">矢量符号</td>
</tr>
<tr>
<td align="center">$\acute{a}$</td>
<td align="center"><code>\acute&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\grave{a}$</td>
<td align="center"><code>\grave&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\mathring{a}$</td>
<td align="center"><code>\mathring&#123;a&#125;</code></td>
<td align="center">数学符号</td>
</tr>
<tr>
<td align="center">$\dot{a}$</td>
<td align="center"><code>\dot&#123;a&#125;</code></td>
<td align="center">一阶导数符号</td>
</tr>
<tr>
<td align="center">$\ddot{a}$</td>
<td align="center"><code>\ddot&#123;a&#125;</code></td>
<td align="center">二阶导数符号</td>
</tr>
<tr>
<td align="center">$\uparrow$</td>
<td align="center"><code>\uparrow</code></td>
<td align="center">上箭头</td>
</tr>
<tr>
<td align="center">$\Uparrow$</td>
<td align="center"><code>\Uparrow</code></td>
<td align="center">上箭头</td>
</tr>
<tr>
<td align="center">$\downarrow$</td>
<td align="center"><code>\downarrow</code></td>
<td align="center">下箭头</td>
</tr>
<tr>
<td align="center">$\Downarrow$</td>
<td align="center"><code>\Downarrow</code></td>
<td align="center">下箭头</td>
</tr>
<tr>
<td align="center">$\leftarrow$</td>
<td align="center"><code>\leftarrow</code></td>
<td align="center">左箭头</td>
</tr>
<tr>
<td align="center">$\Leftarrow$</td>
<td align="center"><code>\Leftarrow</code></td>
<td align="center">左箭头</td>
</tr>
<tr>
<td align="center">$\rightarrow$</td>
<td align="center"><code>\rightarrow</code></td>
<td align="center">右箭头</td>
</tr>
<tr>
<td align="center">$\Rightarrow$</td>
<td align="center"><code>\Rightarrow</code></td>
<td align="center">右箭头</td>
</tr>
<tr>
<td align="center">$\longrightarrow$</td>
<td align="center"><code>\longrightarrow</code></td>
<td align="center">向右长箭头</td>
</tr>
<tr>
<td align="center">$\Longrightarrow$</td>
<td align="center"><code>\Longrightarrow</code></td>
<td align="center">向右长箭头</td>
</tr>
<tr>
<td align="center">$A \xleftarrow{n=0} B \xrightarrow[T]{n&gt;0} C$</td>
<td align="center"><code>A \xleftarrow&#123;n=0&#125; B \xrightarrow[T]&#123;n&gt;0&#125; C</code></td>
<td align="center">上下方可输入公式的箭头</td>
</tr>
<tr>
<td align="center">$\triangleq$</td>
<td align="center"><code>\triangleq</code></td>
<td align="center">定义为</td>
</tr>
<tr>
<td align="center">$\because$</td>
<td align="center"><code>\because</code></td>
<td align="center">因为</td>
</tr>
<tr>
<td align="center">$\therefore$</td>
<td align="center"><code>\therefore</code></td>
<td align="center">所以</td>
</tr>
<tr>
<td align="center">$\forall$</td>
<td align="center"><code>\forall</code></td>
<td align="center">任意</td>
</tr>
<tr>
<td align="center">$\exists$</td>
<td align="center"><code>\exists</code></td>
<td align="center">存在</td>
</tr>
<tr>
<td align="center">$\ldots$</td>
<td align="center"><code>\ldots</code></td>
<td align="center">底端对齐的省略号</td>
</tr>
<tr>
<td align="center">$\cdots$</td>
<td align="center"><code>\cdots</code></td>
<td align="center">中线对齐的省略号</td>
</tr>
<tr>
<td align="center">$\vdots$</td>
<td align="center"><code>\vdots</code></td>
<td align="center">竖直对齐的省略号</td>
</tr>
<tr>
<td align="center">$\ddots$</td>
<td align="center"><code>\ddots</code></td>
<td align="center">斜对齐的省略号</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>矩阵表示</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\left[ \begin&#123;matrix&#125; 1 &amp;2 &amp;\cdots &amp;4\\5 &amp;6 &amp;\cdots &amp;8 \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ 13 &amp;14 &amp;\cdots &amp;16\end&#123;matrix&#125; \right]</span><br></pre></td></tr></table></figure>

<p>$$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8 \ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \ 13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]$$</p>
<p><strong>大括号公式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(n)= \begin&#123;cases&#125; 1 &amp; \text&#123;n = 0 或 1&#125;\\ F(n-1)+F(n-2) &amp; \text&#123;n &gt; 1&#125; \end&#123;cases&#125;</span><br></pre></td></tr></table></figure>

<p>$$F(n)= \begin{cases} 1 &amp; \text{n = 0 或 1}\ F(n-1)+F(n-2) &amp; \text{n &gt; 1} \end{cases}$$</p>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table>
<thead>
<tr>
<th align="center">大写</th>
<th align="center">代码</th>
<th align="center">小写</th>
<th align="center">代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center"><code>A</code></td>
<td align="center">α</td>
<td align="center"><code>\alhpa</code></td>
</tr>
<tr>
<td align="center">B</td>
<td align="center"><code>B</code></td>
<td align="center">β</td>
<td align="center"><code>\beta</code></td>
</tr>
<tr>
<td align="center">Γ</td>
<td align="center"><code>\Gamma</code></td>
<td align="center">γ</td>
<td align="center"><code>\gamma</code></td>
</tr>
<tr>
<td align="center">Δ</td>
<td align="center"><code>\Delta</code></td>
<td align="center">δ</td>
<td align="center"><code>\delta</code></td>
</tr>
<tr>
<td align="center">E</td>
<td align="center"><code>E</code></td>
<td align="center">ϵ</td>
<td align="center"><code>\epsilon</code></td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center"><code>Z</code></td>
<td align="center">ζ</td>
<td align="center"><code>\zeta</code></td>
</tr>
<tr>
<td align="center">H</td>
<td align="center"><code>H</code></td>
<td align="center">η</td>
<td align="center"><code>\eta</code></td>
</tr>
<tr>
<td align="center">Θ</td>
<td align="center"><code>\Theta</code></td>
<td align="center">θ</td>
<td align="center"><code>\theta</code></td>
</tr>
<tr>
<td align="center">I</td>
<td align="center"><code>I</code></td>
<td align="center">ι</td>
<td align="center"><code>\iota</code></td>
</tr>
<tr>
<td align="center">K</td>
<td align="center"><code>K</code></td>
<td align="center">κ</td>
<td align="center"><code>\kappa</code></td>
</tr>
<tr>
<td align="center">Λ</td>
<td align="center"><code>\Lambda</code></td>
<td align="center">λ</td>
<td align="center"><code>\lambda</code></td>
</tr>
<tr>
<td align="center">M</td>
<td align="center"><code>M</code></td>
<td align="center">μ</td>
<td align="center"><code>\mu</code></td>
</tr>
<tr>
<td align="center">N</td>
<td align="center"><code>N</code></td>
<td align="center">ν</td>
<td align="center"><code>\nu</code></td>
</tr>
<tr>
<td align="center">Ξ</td>
<td align="center"><code>\Xi</code></td>
<td align="center">ξ</td>
<td align="center"><code>\xi</code></td>
</tr>
<tr>
<td align="center">O</td>
<td align="center"><code>O</code></td>
<td align="center">ο</td>
<td align="center"><code>\omicron</code></td>
</tr>
<tr>
<td align="center">Π</td>
<td align="center"><code>\Pi</code></td>
<td align="center">π</td>
<td align="center"><code>\pi</code></td>
</tr>
<tr>
<td align="center">P</td>
<td align="center"><code>P</code></td>
<td align="center">ρ</td>
<td align="center"><code>\rho</code></td>
</tr>
<tr>
<td align="center">Σ</td>
<td align="center"><code>\Sigma</code></td>
<td align="center">σ</td>
<td align="center"><code>\sigma</code></td>
</tr>
<tr>
<td align="center">T</td>
<td align="center"><code>T</code></td>
<td align="center">τ</td>
<td align="center"><code>\tau</code></td>
</tr>
<tr>
<td align="center">Υ</td>
<td align="center"><code>\Upsilon</code></td>
<td align="center">υ</td>
<td align="center"><code>\upsilon</code></td>
</tr>
<tr>
<td align="center">Φ</td>
<td align="center"><code>\Phi</code></td>
<td align="center">ϕ</td>
<td align="center"><code>\phi</code></td>
</tr>
<tr>
<td align="center">X</td>
<td align="center"><code>X</code></td>
<td align="center">χ</td>
<td align="center"><code>\chi</code></td>
</tr>
<tr>
<td align="center">Ψ</td>
<td align="center"><code>\Psi</code></td>
<td align="center">ψ</td>
<td align="center"><code>\psi</code></td>
</tr>
<tr>
<td align="center">Ω</td>
<td align="center"><code>\v</code></td>
<td align="center">ω</td>
<td align="center"><code>\omega</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 文件结构</title>
    <url>/2018/01/30/Linux%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初学 Linux 总是好奇 Linux 系统下各个文件夹为什么这么命名，它们的用途是什么。本文主要介绍 Linux 下各文件夹的结构和用途说明。</p>
<h2 id="文件颜色"><a href="#文件颜色" class="headerlink" title="文件颜色"></a>文件颜色</h2><p>一般人性化点的 Shell 都会有文件的不同颜色显示。下图为 Linux 下不同颜色的文件代表的含义。比如可执行文件显示绿色，目录显示蓝色，链接文件显示浅蓝色等<br><img src="/0.png" alt="linuxfilecolor"></p>
<h2 id="FHS"><a href="#FHS" class="headerlink" title="FHS"></a>FHS</h2><p>Linux 有专门的指导文件系统的标准，叫做 FHS(全称 Filesystem Hierarchy Standard)。Linux 所依赖的文件系统，有两个基本的概念：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shareable / unshareable （共享性）</span><br><span class="line">static / variable （稳定性）</span><br></pre></td></tr></table></figure>

<p>对于可分享（shareable）的文件系统，FHS 规定：可分享文件能够被存放在一台将被多个用户同时访问的主机上，通常情况下，当一个系统所需的所有文件都存放在一台外部主机上时，可以方便的挂载一个或很少几个目录来使这些文件可用。但是，并不是在文件系统架构中的所有文件都是可分享的，所以每个系统都至少需要一处能够存放不可共享文件的本地空间。</p>
<p>对于静态（static）文件系统，FHS 规定：静态文件需要与动态文件隔离，因为，不同于动态文件，静态文件可以存放在只读介质上（而动态文件不可以），并且不需要和动态文件一起备份。</p>
<p>FHS 中关于特定文件夹用途和所需包含内容的规定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin: Essential user command binaries (for use by all users)</span><br><span class="line">/sbin: System binaries</span><br><span class="line">/usr: shareable static</span><br><span class="line">    /usr/bin: Most user commands</span><br><span class="line">    /usr/sbin: Non-essential standard system binaries</span><br><span class="line">    /usr/local: Local hierarchy</span><br></pre></td></tr></table></figure>

<h3 id="bin"><a href="#bin" class="headerlink" title="/bin"></a>/bin</h3><p><code>/bin</code>，binary 的简称。该目录下为二进制的可执行文件，显示为绿色。包含了引导启动所需的命令或普通用户可使用的命令。多是系统中重要的系统文件</p>
<p>比如说根目录<code>/bin</code>下都是些常用命令的执行文件，再比如说 Tomcat 的<code>bin</code>目录下有一些运行脚本，有 Linux Shell 执行的<code>.sh</code>结尾的文件，也有 Windows 执行的<code>.bat</code>结尾的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /bin/</span><br><span class="line">cat    tar    cp      ls     rm   ...</span><br><span class="line"></span><br><span class="line">$ ls /usr/local/tomcat9/bin/</span><br><span class="line">shutdown.bat    catalina.bat     shutdown.sh</span><br><span class="line">catalina.sh     startup.bat      startup.sh    ...</span><br></pre></td></tr></table></figure>

<h3 id="sbin"><a href="#sbin" class="headerlink" title="/sbin"></a>/sbin</h3><p><code>/sbin</code>，System binaries 的简称。存放系统管理员以及其他需要root权限来运行的工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /sbin/</span><br><span class="line">reboot    shutdown    poweroff    route    sysctl     ...  </span><br></pre></td></tr></table></figure>

<h3 id="usr"><a href="#usr" class="headerlink" title="/usr"></a>/usr</h3><p><code>/usr</code>是文件系统中第二大主要部分，其中存放了可分享的、只读的数据（即可分享性，静态性数据）。这说明<code>/usr</code>文件系统需要能够在各种不同的兼容 FHS 系统的之间可共享，并且不可被修改。任何依赖于平台或者需要改写的数据，都应该存放在其它位置</p>
<p><code>/usr/bin</code>集中了几乎所有用户命令，比如<code>man、info</code>系统自带或者<code>git、docker</code>这种后来安装的三方软件的命令</p>
<p><code>/usr/sbin</code>包括了多数服务程序需要管理员权限的命令，比如<code>mysqld、sshd</code></p>
<p><code>/usr/local</code>，本地安装的软件和其他文件都可以放在这里</p>
<h3 id="lib"><a href="#lib" class="headerlink" title="/lib"></a>/lib</h3><p><code>/lib</code>，Libraries 的简称。库文件，存储文件运行需要的依赖库。不如 Tomcat 是基于 Java 的，它的<code>lib</code>目录下包含了一些依赖 Jar 包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /usr/local/tomcat9/lib</span><br><span class="line">annotations-api.jar       el-api.jar       tomcat-coyote.jar   tomcat-util-scan.jar</span><br><span class="line">catalina-ant.jar          jasper-el.jar </span><br></pre></td></tr></table></figure>

<h3 id="etc"><a href="#etc" class="headerlink" title="/etc"></a>/etc</h3><p><code>/etc</code>这个文件夹很有意思，也是最开始困扰我很久的，因为它里头什么都有…其实它取名就是取自”等等”的缩写词 etc. 存放着系统以及各种程序的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -F /etc</span><br><span class="line">hosts    hostname    passwd    nginx/    ssh/    ...</span><br></pre></td></tr></table></figure>

<p>早期 UNIX 系统中，对于<code>/etc</code>，贝尔实验室的解释是：etcetra directory(or etc.) 。表示其他、等等什么的，其实就是用来放不能归类到其他目录中的内容，所以比较杂乱。后来 FHS 规定用来放配置文件，就解释为：Editable Text Configuration 或者 Extended Tool Chest</p>
<h3 id="var"><a href="#var" class="headerlink" title="/var"></a>/var</h3><p><code>/var</code>，Variable 的简称，多用于存放动态变化的文件。也用于某些大文件的溢出区，比如各种服务的日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /var/backups</span><br><span class="line">group.bak    passwd.bak    ....</span><br><span class="line"></span><br><span class="line">$ ls /var/log</span><br><span class="line">syslog    dpkg.log    auth.log     ...</span><br><span class="line"></span><br><span class="line">$ ls -F /var/run</span><br><span class="line">nginx.pid    docker.pid    sshd.pid     resolvconf/    ...</span><br></pre></td></tr></table></figure>

<p><code>/var/run</code>中包含了进程的ID以及动态生成的配置文件等，比如连接网络时自动生成的<code>/var/run/resolvconf/resolv.conf</code>域名解析服务器的配置信息，其实<code>/etc/resolv.conf</code>文件就是链接到此文件</p>
<h3 id="root"><a href="#root" class="headerlink" title="/root"></a>/root</h3><p><code>/root</code>目录是<code>root</code>用户的用户目录，<code>~</code>代表当前用户的用户目录，普通用户的目录在<code>/home</code>下，比如我通过<code>su s1mple</code>切换到 s1mple 用户，用户目录为<code>/home/s1mple</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu-server:~# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">s1mple@ubuntu-server:~$ pwd</span><br><span class="line">/home/s1mple</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>/opt</code>，Optional application software packages 代表你可以在该目录下安装第三方软件，和<code>/usr/local</code>的作用相似</p>
<p><code>/dev</code>，device 的简称，该目录存放设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用户可 以通过访问<code>/dev/mouse</code>来访问鼠标的输入，就像访问其他文件一样</p>
<p><code>/tmp</code>，temporary 的简称，目录存放程序在运行时产生的临时数据，注意：<code>/var/tmp</code>比<code>/tmp</code>允许更大的或需要存在较长时间的临时文件</p>
<p><code>/proc</code>，虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息，比如<code>/proc/cpuinfo</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://mp.weixin.qq.com/s/yUwUawPlIjPThe3v1Ppcug">Linux 下各文件夹的结构说明及用途介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 的终极 Shell -- ZSH</title>
    <url>/2018/07/30/Mac%20%E7%9A%84%E7%BB%88%E6%9E%81%20Shell%20--%20ZSH/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外某位大牛开源出一个能够让你快速上手的 zsh 项目，叫做『oh my zsh』，使得 zsh 逐渐流行起来。</p>
<h2 id="ZSH"><a href="#ZSH" class="headerlink" title="ZSH"></a>ZSH</h2><p>安装 zsh。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install zsh</span><br></pre></td></tr></table></figure>

<p>安装完后在 Terminal 的设置中设置默认使用 zsh。</p>
<p><img src="/0.png" alt="8F9622E7-901E-46F0-94D7-B5E7AEE04C08"></p>
<h2 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h2><p>oh-my-zsh 是最为流行的 zsh 配置文件，提供了完善的插件体系，相关的文件在<code>~/.oh-my-zsh/plugins</code>目录下。<a href="https://github.com/robbyrussell/oh-my-zsh">GitHub 链接</a>。</p>
<p>安装 oh-my-zsh：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>安装完成后<code>source ~/.zshrc</code>使之生效。</p>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>在<code>.zshrc</code>中添加配置，其中可以自定义<code>alias</code>用于简化命令，这里贴出我的配置。<code>alias -s</code>意为 define suffix aliases，譬如命令行输入<code>xxx.gz</code>就相当于<code>tar -xzvf xxx.gz</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># compress relatived</span></span><br><span class="line"><span class="built_in">alias</span> -s gz=<span class="string">&#x27;tar -xzvf&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> -s tgz=<span class="string">&#x27;tar -xzvf&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> -s zip=<span class="string">&#x27;unzip&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> -s bz2=<span class="string">&#x27;tar -xjvf&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sublime text</span></span><br><span class="line"><span class="built_in">alias</span> subl=<span class="string">&quot;open -a &#x27;Sublime Text&#x27;&quot;</span></span><br><span class="line"><span class="built_in">alias</span> -s php=subl</span><br><span class="line"><span class="built_in">alias</span> -s rb=subl</span><br><span class="line"><span class="built_in">alias</span> -s html=crm</span><br><span class="line"><span class="built_in">alias</span> -s xml=subl</span><br><span class="line"><span class="built_in">alias</span> -s txt=subl</span><br><span class="line"><span class="built_in">alias</span> -s hbs=subl</span><br><span class="line"></span><br><span class="line"><span class="comment"># macdown</span></span><br><span class="line"><span class="built_in">alias</span> macdown=<span class="string">&quot;open -a MacDown&quot;</span></span><br><span class="line"><span class="built_in">alias</span> -s md=macdown</span><br><span class="line"></span><br><span class="line"><span class="comment"># git relatived</span></span><br><span class="line"><span class="built_in">alias</span> gpom=<span class="string">&#x27;git push -u origin master&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> grao=<span class="string">&#x27;git remote add origin&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># others</span></span><br><span class="line"><span class="built_in">alias</span> his=<span class="string">&#x27;history&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -a&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alh&#x27;</span></span><br></pre></td></tr></table></figure>

<p>添加如下配置后，可以使用<code>subl a.txt</code>或者直接输入<code>a.txt</code>通过 Sublime 打开文本文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias subl=&quot;open -a &#x27;Sublime Text&#x27;&quot;</span><br><span class="line">alias -s txt=subl</span><br></pre></td></tr></table></figure>

<p>另外，添加了两个常用 Git 命令的缩写，其实 Oh My Zsh 已经包含了许多 Git 的简写命令，比如常用的<code>gst</code>即<code>git status</code>的简写。可以使用命令<code>alias</code>查看还有哪些简写命令。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>oh-my-zsh 有很多提升命令行效率的实用工具，我目前使用了如下四个插件，确实在使用过程中体验到效率的提升。安装完成后在<code>.zshrc</code>中打开插件，其中 git 是默认安装并开启的插件，前面也提到有许多简写命令，这里不多赘述，请自行查阅。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  Z</span><br><span class="line">  zsh-syntax-highlighting</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h3><p><a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/z">Z 插件</a>，功能和 autojump 类似，使用<code>z &#123;path&#125;</code>实现目录间快速跳转，并且作为 oh-my-zsh 的内置组件，只需要在<code>.zshrc</code>中打开即可。</p>
<p>如图，Z 插件会记录你前往的目录，并根据进入次数计算权重（<code>z -r</code>查看权重），以后再进入该目录只用<code>z ddd</code>，会进行<strong>模糊匹配</strong>，前往<strong>权重最高</strong>的目录。</p>
<p><img src="/1.png" alt="678A0E3A-EDE9-4D9B-AA39-A6E14DC6E2EC"></p>
<h3 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h3><p><a href="https://github.com/zsh-users/zsh-syntax-highlighting">Zsh 语法高亮插件</a>。安装后终端输入的命令正确会<strong>绿色高亮</strong>显示，输入错误会显示红色，用于在执行命令前检查是否有语法错误。</p>
<p><img src="/2.png" alt="82881CCA-A343-45D1-9A1D-4DD8E77E1B78"></p>
<p>安装 zsh-syntax-highlighting，完成后在<code>.zshrc</code>中添加。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<h3 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h3><p><a href="https://github.com/zsh-users/zsh-autosuggestions">Zsh 命令自动补全插件</a>，效率神器。如图输入命令时，会给出建议的命令（灰色部分）按键盘 <code>→</code> 补全。</p>
<p><img src="/3.png" alt="8B1B4FDE-F810-4E90-B20A-37274ABDDFDE"></p>
<p>安装 zsh-autosuggestions，完成后在<code>.zshrc</code>中添加。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/zsh-users/zsh-autosuggestions <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/19556676">终极 Shell——ZSH - 知乎专栏</a></li>
<li><a href="http://wulfric.me/2015/08/zsh/">一些命令行效率工具</a></li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中的可迭代类型</title>
    <url>/2021/04/01/Python-%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%BF%AD%E4%BB%A3%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>之前我们已经讨论过，Python 的“序列协议”是指：任何类，只要使用标准的签名和语义实现了 <code>__getitem__</code> 和 <code>__len__</code> 方法，就能用在任何期待序列的地方，解释器会为这些类做特殊的支持，比如支持迭代和 in 运算符。序列协议的接口定义可以查阅官方的 CPython API 接口文档：<a href="https://docs.python.org/3.8/c-api/sequence.html">Python/C API Reference Manual – Sequence Protocol</a>，其中有这样一个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PySequence_Check</span><span class="params">(PyObject *o)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* Return 1 if the object provides sequence protocol, and 0 otherwise. Note that it returns 1 for Python classes with a __getitem__() method unless they are dict subclasses since in general case it is impossible to determine what the type of keys it supports. This function always succeeds. */</span></span></span><br></pre></td></tr></table></figure>

<p>这个函数的作用是检查并返回对象是否支持序列协议 —— 只在实现了 <code>__getitem__</code> 方法且不是字典子类时才返回 1。这也符合我们之前所说的，协议是非正式的，没有强制力，只要你知道类的具体使用场景，可以只实现协议的一部分。比如，仅为了支持迭代，甚至不需要提供 <code>__len__</code> 方法。</p>
<p>Python 常用的内置序列类型包括：字符串 str、列表 list、元组 tuple 和范围 range。尽管字典 dict 和集合 set 实现了序列协议中的 <code>__getitem__</code> 和 <code>__len__</code> 方法，但它们并不算序列类型，因为它们的特征与序列有本质差异，比如这两个类型不支持通过整数下标索引访问元素，不支持切片，并且字典和集合内的元素是无序的。</p>
<p>序列类 Sequence，定义在标准库 <code>collections.abc</code> 模块中，继承自 Reversible 和 Collection 类，而 Collection 又继承自 Sized、Iterable 和 Container，体现了序列类可反转、具有规模、可迭代和是一个容器的语义。</p>
<p>从 <code>collections.abc</code> 模块的源码中，我们还能了解到序列类包含哪些子类。除了显示继承了 Sequence 的子类，如 ByteString 和 MutableSequence，还有通过 register 关键字绑定为 Sequence 虚拟子类的一些内置类型，在绑定虚拟子类一节中也提到过这一点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> <span class="type">Sequence</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="built_in">issubclass</span>(i, <span class="type">Sequence</span>) <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="built_in">str</span>, <span class="built_in">list</span>, <span class="built_in">tuple</span>, <span class="built_in">range</span>, <span class="built_in">bytes</span>, <span class="built_in">bytearray</span>, <span class="built_in">memoryview</span>)])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>([<span class="built_in">issubclass</span>(i, <span class="type">Sequence</span>) <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="built_in">dict</span>, <span class="built_in">set</span>)])</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>上面列表推导表达式中的所有类型都是定义在 builtsin 模块中的内置类型，可以看到，除了 dict 和 set 之外，第二行的所有内置类型都是序列类型。除此之外，标准库中还定义了其他序列类型，比如 array 模块的 array 数组类型，collections 模块中的 deque 双端队列类型。</p>
<p>对于这些序列类型，按照序列内可容纳的类型，可以划分为以下两组：</p>
<ul>
<li><strong>容器序列</strong>：list、tuple 和 collections.deque 这些序列类能存放不同类型的数据；</li>
<li><strong>扁平序列</strong>：str、bytes、bytearray、memoryview、array.array 和 range 这类序列类只能容纳一种或某种特定类型的数据。</li>
</ul>
<p>容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列存放的是值而不是引用。扁平序列存储在一段连续的内存空间之上，只能存放诸如字符、字节和数值这种基础类型。</p>
<p>序列类型还能按照能否被修改来分类：</p>
<ul>
<li><strong>可变序列</strong>：list、bytearray、memoryview、array.array 和 collections.deque；</li>
<li><strong>不可变序列</strong>：tuple、str、bytes 和 range。</li>
</ul>
<p>可变序列 MutableSequence 也定义在 <code>collections.abc</code> 模块中，并在继承 Sequence 的基础上还添加了一些支持序列修改的默认方法，如 <code>append()</code>、<code>pop()</code> 方法等。除了 Sequence 基类中要实现的 <code>__getitem__</code> 和 <code>__len__</code> 方法外，可变序列还要求具体子类必须实现 <code>__setitem__</code>、<code>__delitem__</code> 和 <code>insert()</code> 方法。</p>
<p>序列不可变意味着序列一旦被声明赋值，序列的大小就固定下来，其内的元素也不能被修改。这里用来说明序列可变不可变的典型案例是列表和元组。在 Python 中，列表是可变的，元组是不可变的。列表可变体现在它支持对元素的增加删除和直接赋值，且列表支持<strong>就地运算</strong>，比如使用 “+=” 运算符可以直接将一个可迭代对象中的元素添加到当前列表的末尾。而元组是不可变的，元组一经定义大小就已固定，不能增加删除元素，也不对其内元素重新赋值。即使元组也支持就地运算符，但会生成一个新的元组对象重新绑定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>]  <span class="comment"># list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4411278528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4411278528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4410964416</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t += (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4411277824</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>此外，Python 中的可散列对象一定是不可变类型，散列方法 <code>__hash__</code> 通常和 <code>__eq__</code> 方法一起用来判断两个对象是否相等，如集合 set 和字典的键要求元素是可散列的，这被用来判断元素是否重复。所以，元组可以作为集合的元素和字典的键，而列表却不可以。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t1) == <span class="built_in">id</span>(t2)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(t1) == <span class="built_in">hash</span>(t2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>,)])</span><br><span class="line">&#123;(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>,)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(&#123;(<span class="number">1</span>, <span class="number">2</span>): <span class="number">1</span>&#125;)</span><br><span class="line">&#123;(<span class="number">1</span>, <span class="number">2</span>): <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注：在散列时，元组内的每一项元素会被散列然后进行 XOR 异或运算，因此只有当元组中的每个元素都是不可变类型时，该元组才能被散列。</p>
<h2 id="map、filter-与列表推导"><a href="#map、filter-与列表推导" class="headerlink" title="map、filter 与列表推导"></a>map、filter 与列表推导</h2><p>列表是 Python 中非常重要且常用的内置类型，列表被注册为可变序列的虚拟子类，<code>MutableSequence.register(list)</code>，所以列表的性质与可变序列性质相符，可以阅读 <code>collections.abc</code> 模块中 MutableSequence 类的源码进行了解。列表的性质不做过多介绍，这一节我想介绍一下列表推导。在上一节中就曾经使用 <code>all()</code>、<code>any()</code> 方法结合列表推导，巧妙地展示了哪些内置类型是序列类的子类。</p>
<p>在介绍列表推导之前，有必要先介绍以下几个函数：<code>map()</code>、<code>filter()</code> 和 <code>reduce()</code> 函数。这几个函数是函数式编程的范例函数。它们都是用于处理可迭代序列的基本函数，所以被视为可迭代数据集函数式编程的基石，包含了数据集的映射、过滤和规约三个思想。所有支持函数式编程的语言都提供了这些函数的接口。Java 8 新增的 Stream API 配合箭头函数可以写出很优雅的链式函数，同样，JavaScript 中也支持链式写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&gt; l.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x)</span><br><span class="line">[ <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> ]</span><br><span class="line">&gt; l.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x).filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">10</span>)</span><br><span class="line">[ <span class="number">16</span>, <span class="number">25</span> ]</span><br><span class="line">&gt; l.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x).filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">10</span>).reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)</span><br><span class="line"><span class="number">41</span></span><br></pre></td></tr></table></figure>

<p>相比之下，Python 中的写法就不那么优雅了，map、filter 和 reduce 函数作为内置库或者标准库中的函数提供，序列本身并没有实现这些方法，所以不能通过 dot 运算符直接调用，而需要将序列作为这些函数的参数传入。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a><code>map()</code></h3><blockquote>
<p><code>map(func, *iterables) --&gt; map object</code></p>
<p>Make an iterator that computes the function using arguments from each of the iterables.  Stops when the shortest iterable is exhausted.</p>
</blockquote>
<p>map 函数，又称映射函数，定义在内置模块 builtins 模块中。map 函数将可迭代对象的每个元素依次应用于 func 函数进行映射，返回的 map object 是一个可以依次产出映射后元素的生成器对象，可以使用 <code>list()</code> 包装一次性输出。传入的函数 func 可以是预先定义好的函数，也可以是 lambda 表达式定义的匿名函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(square, <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x106ebb910</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(square, <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>

<p>从函数签名来看，map 函数能够接受多个可迭代对象，映射时将依次从每个可迭代对象中各取出一个元素应用于 func 函数，因此 func 也须接受同样数量的参数。如果这些可迭代对象的元素个数不一致，以个数最少的为标杆，即个数最少的可迭代对象遍历完毕时终止迭代。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x * y, <span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x * y, <span class="built_in">range</span>(<span class="number">10</span>), <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a><code>filter()</code></h3><blockquote>
<p><code>filter(function or None, iterable) --&gt; filter object</code></p>
<p>Return an iterator yielding those items of iterable for which function(item) is true. If function is None, return the items that are true.</p>
</blockquote>
<p>filter 函数，又称过滤函数，定义在内置模块 builtins 模块中。过滤函数将可迭代对象中的每个元素应用于谓词函数 function 后为 True 的保留下来。返回的 filter object 也是一个生成器对象，可以依次产出过滤后为真的元素。如果 function 为 None，直接判断元素是否为真值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">5</span>, <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="literal">None</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="number">0.0</span>, -<span class="number">1</span>, [], (<span class="number">1</span>, <span class="number">2</span>)]))</span><br><span class="line">[<span class="number">1</span>, <span class="literal">True</span>, -<span class="number">1</span>, (<span class="number">1</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a><code>reduce()</code></h3><blockquote>
<p><code>reduce(function, sequence[, initial]) -&gt; value</code></p>
<p>Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. For example, reduce(lambda x, y: x + y, [1, 2, 3, 4, 5]) calculates ((((1 + 2) + 3) + 4) + 5).  If initial is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty.</p>
</blockquote>
<p>reduce 函数，又称规约函数，定义在 functools 模块中。规约函数的参数除了函数和序列之外，还接收一个可选的初始值。规约函数会将一个序列从左至右逐步规约为一个值。参数 function 接收两个参数，第一个参数代表每步规约后的累积值（首次规约为初始值），第二个参数代表每次迭代的序列中的元素，返回值为规约的结果，作为下一步规约的第一个参数传入。也就是说，function 函数的第一个参数、每步规约的返回值和 reduce 函数的返回值应为同一类型，function 的第二个参数为迭代序列的元素类型，两者可以是相同类型也可以是不同类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x + y, <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="number">45</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">concat_string</span>(<span class="params">s, ch</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> s + <span class="built_in">str</span>(ch)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(concat_string, [<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>], <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;0a1b&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h3><p>如果想像 JavaScript 代码演示的那样，依次对一个序列数据流进行映射、过滤和规约操作，Python 的写法会显得不那么优雅。由于序列必须作为参数传入，无法放在左侧使用 dot 运算符进行链式书写，我们不得不编写多层嵌套的表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &lt; <span class="number">50</span>, <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, <span class="built_in">range</span>(<span class="number">10</span>))))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(operator.add, (<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &lt; <span class="number">50</span>, <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, <span class="built_in">range</span>(<span class="number">10</span>)))))</span><br><span class="line"><span class="number">140</span></span><br></pre></td></tr></table></figure>

<p>且不说冗余的 lambda 关键字，即使预先定义了函数使用函数名代替，整个表达式从右至左的执行循序也会不利于理解。所幸的是，Python 提供了一种精炼的表达式，来代替多层嵌套下纠缠不清的 map 和 filter 方法，那就是<strong>列表推导</strong>（list comprehension）。</p>
<p>列表推导是一个语法糖，可以根据可迭代对象构建出一个新的列表。列表推导使用一对中括号 “[]”，内部至少包含一个 for 循环表达式，对应 map 方法；以及可选的 if 条件表达式，对应 filter 方法。列表推导返回的是列表类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x &lt; <span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[_ * _ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> _ &lt; <span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>,)] <span class="keyword">for</span> x <span class="keyword">in</span> y]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>表达式内的变量是一个局部变量，作用域仅限于该列表推导表达式。但 Python2 中的列表推导存在变量泄漏问题，表达式内的变量会影响到上下文中的同名变量，在 Python 3 中这个缺陷已被修复。</p>
<p>列表推导也支持<strong>多重循环</strong>，即多个 for 循环表达式，这些 for 表达式会按照从左至右的顺序来嵌套。与多层嵌套的 for 循环函数一致，先定义（左侧）的 for 循环在外层，后定义（右侧）的 for 循环在内层。外层定义的变量可用作内层的 for 循环，如上述代码中的最后一个列表推导式。如果用函数形式书写，那么代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>,)] <span class="keyword">for</span> x <span class="keyword">in</span> y]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">flat</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>,)]:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> x <span class="keyword">in</span> y:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(flat())</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>字典和集合也有类似的推导机制，可以通过这些推导机制创建衍生的数据结构。字典推导可以从任何以键值对为元素的可迭代对象中构建出字典。集合推导可以从可迭代对象中去除重复元素，构建集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;i: j <span class="keyword">for</span> j, i <span class="keyword">in</span> d.items()&#125;  <span class="comment"># 字典推导</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;i <span class="keyword">for</span> i <span class="keyword">in</span> d.keys()&#125;  <span class="comment"># 集合推导</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="列表推导的最佳实践"><a href="#列表推导的最佳实践" class="headerlink" title="列表推导的最佳实践"></a>列表推导的最佳实践</h4><p>使用列表推导的原则是：<strong>只用于创建新的列表，并且尽量保持简短，不建议使用含有两个以上表达式的列表推导</strong>。依照函数式编程中的纯函数定义，函数不应该对传入的参数进行修改，否则会产生副作用。所以列表推导不该对传入序列做修改，而应该只用于创建新的列表。尽量保持简短则是出于可读性的考量。如果包含两个较长的表达式，可以考虑拆分为两行。Python 会忽略 []、{} 和 () 中换行，所以可以省略不太好看的续行符 \。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>

<p>如果列表推导式过长，就要考虑是否需要使用函数形式改写，有时命名清晰且带有缩进的函数可读性要更高。</p>
<p>列表推导也不是银弹，相较于生成器表达式的惰性求值，它会<strong>及早求值</strong>（eager evaluation）。在声明了一个列表推导式时，序列中的所有数据都会被即时处理，并将处理后的完整列表存放在内存中。并且在推导过程中，对于输入序列的每个值都可能创建一个仅含一项元素的全新列表。所以当序列的数据量很大时，如读文件或读数据库，将会消耗大量内存并导致程序崩溃。所以，列表推导另一个最佳实践是：<strong>使用生成器表达式代替数据量较大的列表推导</strong>。生成式表达式将在后续章节进行介绍。</p>
<h2 id="可迭代对象、迭代器和生成器源码分析"><a href="#可迭代对象、迭代器和生成器源码分析" class="headerlink" title="可迭代对象、迭代器和生成器源码分析"></a>可迭代对象、迭代器和生成器源码分析</h2><p>迭代，或称循环，是数据处理的基石。Python 中的可迭代类型的抽象基类定义在 <code>collections.abc</code> 模块中，从抽象层次来说，可以分为以下三类：</p>
<ul>
<li><strong>可迭代对象</strong>，<code>class Iterable(metaclass=ABCMeta)</code>，抽象类；</li>
<li><strong>迭代器</strong>，<code>class Iterator(Iterable)</code>，继承自 Iterable 的抽象类；</li>
<li><strong>生成器</strong>，<code>class Generator(Iterator)</code>，继承自 Iterator 的抽象类。</li>
</ul>
<p>在这三个抽象基类的实现中，都有一个名为 <code>__subclasshook__</code> 的钩子方法，用于将实现了特定方法的类绑定为这些抽象基类的虚拟子类。如下是可迭代对象 Iterable 的部分代码，钩子方法检查了类中有无实现 <code>__iter__</code> 方法，对于实现了的类，会被绑定为 Iterable 的虚拟子类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterable</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span>(<span class="params">cls, C</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterable:</span><br><span class="line">            <span class="keyword">return</span> _check_methods(C, <span class="string">&quot;__iter__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br></pre></td></tr></table></figure>

<p>联系到鸭子类型一节中所说的“协议”的概念，可以得出结论：可迭代对象的协议需要实现 <code>__iter__</code> 方法；类似的，迭代器协议需要同时实现 <code>__iter__</code> 和 <code>__next__</code> 方法；生成器协议要更复杂一些，除了这两个方法外还需要实现  <code>send()</code>、<code>throw()</code> 和 <code>close()</code> 方法，这三个方法体现了生成器除了迭代之外的功能：可以用作<strong>协程</strong>。</p>
<p>除了钩子方法之外，<code>collections.abc</code> 模块中还使用 register 关键字手动绑定了 Iterator 和 Generator 的虚拟子类。这里截取了部分源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_keyiterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(&#123;&#125;.keys()))</span><br><span class="line">dict_valueiterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(&#123;&#125;.values()))</span><br><span class="line">dict_itemiterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(&#123;&#125;.items()))</span><br><span class="line">list_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>([]))</span><br><span class="line">range_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(<span class="built_in">range</span>(<span class="number">0</span>)))</span><br><span class="line">set_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(<span class="built_in">set</span>()))</span><br><span class="line">str_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">tuple_iterator = <span class="built_in">type</span>(<span class="built_in">iter</span>(()))</span><br><span class="line"></span><br><span class="line">Iterator.register(dict_keyiterator)</span><br><span class="line">Iterator.register(dict_valueiterator)</span><br><span class="line">Iterator.register(dict_itemiterator)</span><br><span class="line">Iterator.register(list_iterator)</span><br><span class="line">Iterator.register(range_iterator)</span><br><span class="line">Iterator.register(set_iterator)</span><br><span class="line">Iterator.register(str_iterator)</span><br><span class="line">Iterator.register(tuple_iterator)</span><br><span class="line"></span><br><span class="line">generator = <span class="built_in">type</span>((<span class="keyword">lambda</span>: (<span class="keyword">yield</span>))())</span><br><span class="line">Generator.register(generator)</span><br></pre></td></tr></table></figure>

<p>上述代码出现的所有内置类型，包括 list、range、set、str 和 tuple，都实现了 <code>__iter__</code> 方法，所以都是可迭代对象。特殊一点的是字典的键、值和键值对，也都分别被定义为可迭代的视图类型 KeysView、ValuesView 和 ItemsView。这些类型都是 Python 的集合类型，集合由于继承了 Iterable 类，所以 <strong>Python 中的所有集合都是可迭代对象</strong>。此处说的集合不是内置类型 set 而是 Collection，定义在 <code>collections.abc</code> 模块中。也有人将 Collection 称之为“容器”的，这里将其称之为集合而不是容器是为了与 <code>collections.abc</code> 模块中的另一个类 Container 做区分。集合类的钩子方法会去检测是否实现了 <code>__len__</code>、<code>__iter__</code> 和 <code>__contains__</code> 这三个方法。</p>
<p>尽管上述所说的这些内置类型都是可迭代对象，但要注意它们并不是迭代器，被注册的是经过 <code>iter()</code> 方法包装后的类型。也就是说，访问这些内置类型的 <code>__iter__</code> 方法将会返回一个迭代器，即 <code>iter(iterable) -&gt; iterator</code>。迭代器除了能被 for 循环遍历外，还能使用 <code>next()</code> 方法产出下一个值。编码时如果要使用 <code>next()</code> 方法，首先要注意对象是不是一个迭代器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(l, Iterator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">iter</span>(l)</span><br><span class="line">&lt;list_iterator <span class="built_in">object</span> at <span class="number">0x106e2f640</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(<span class="built_in">iter</span>(l))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>除了可迭代对象和迭代器之外，<code>collections.abc</code> 模块中还定义了生成器类 Generator，并将形如 <code>type((lambda: (yield))())</code> 的类型注册为了生成器的虚拟子类。其中，yield 是一个关键字，意为产出一个值。<strong>只要 Python 函数的定义中含有 yield 关键字，该函数就是生成器函数，调用生成器函数时会返回一个生成器对象</strong>。<code>lambda: (yield)</code> 语句其实是定义了一个返回生成器函数的匿名函数，再调用这个生成器函数得到生成器对象，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> (<span class="keyword">yield</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen()</span><br><span class="line">&lt;generator <span class="built_in">object</span> gen at <span class="number">0x104b36660</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(gen())</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">generator</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">(<span class="params"><span class="keyword">lambda</span>: (<span class="params"><span class="keyword">yield</span></span>)</span>)(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">generator</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>生成器尤为重要，有必要将其作为单独的一节进行介绍。下一节我们将介绍生成器函数的执行过程，以及如何使用生成器表达式返回一个生成器对象。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>所有生成器都是迭代器，因为生成器完全实现了迭代器接口。不过，根据《设计模式：可复用面向对象软件的基础》一书的定义，迭代器用于从集合中取出元素，而生成器用于“凭空”生成元素。通过斐波那契数列能很好地说明二者之间的区别：斐波纳契数列中的数有无穷多个，无法将它们都装在一个集合里，但是生成器可以在每次需要时生成一项元素。因此，尽管 Python 社区中经常将迭代器和生成器视为同一概念，你也要明白生成器所具有的特殊语义。</p>
<h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><p>前面我们说到，生成器函数是包含了 yield 关键字的函数，调用生成器函数时会返回一个生成器对象。也就是说，生成器函数是生成器的工厂函数。因此，生成器函数和普通的函数有着显著的行为差异：即使没有 return 语句，生成器函数依然会返回一个生成器对象。就算有，定义在 yield 语句后的 return 返回值也会被忽略。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen()</span><br><span class="line">&lt;generator <span class="built_in">object</span> gen at <span class="number">0x10ddd9820</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(gen())</span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>“yield” 这个单词，除了产出还有<strong>让步</strong>的含义，对于生成器函数中的 yield 来说，这两个含义都成立。让步体现在，生成器函数在执行到 yield 语句产出值后，会作出让步，暂停执行生成器，让调用方继续工作，直到需要下一个值时再调用 <code>next()</code>。下面使用 for 循环来更清楚地说明生成器函数定义体的执行过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;continue&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> gen_AB():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, c)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">start</span><br><span class="line">--&gt; A</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">--&gt; B</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>迭代时，for 机制的作用与 <code>g = iter(gen_AB())</code> 一样，生成器的 <code>__iter__</code> 方法会返回生成器对象本身，然后每次迭代时调用 <code>next(g)</code>。</p>
<ul>
<li>在 for 循环中第一次隐式调用 next 函数时，会打印 ‘start’，然后停留在第一个 yield 语句，产出值 ‘A’；</li>
<li>第二次隐式调用 next 函数时，会打印 ‘continue’，然后停留在第一个 yield 语句，产出值 ‘B’；</li>
<li>第三次隐式调用 next 函数时，打印 ‘end’，到达函数定义体的末尾，导致生成器对象抛出 StopIteration 异常。for 机制会捕获异常，因此循环终止时不会报错。</li>
</ul>
<p>如果显式调用 <code>next()</code> 方法，那么生成器函数定义体被执行的过程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = <span class="built_in">iter</span>(gen_AB())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line">start</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line">end</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>在这个例子中你可以看到，定义在生成器函数体内的 print 语句并没有在生成器函数被调用时就立即打印，而被延迟到调用 <code>next(g)</code> 时才打印。同样，如果在生成器函数中加入复杂的处理逻辑，该逻辑只在被 <code>next()</code> 调用时才进行处理，从而达到延迟处理的目的。我们将生成器的这一特性归纳为<strong>惰性求值</strong>（lazy evaluation），即尽可能地延后求值，只在需要时才进行求值。这样做的优点是可以节省内存，还可能避免无用的处理。</p>
<p>与惰性求值相对的是<strong>及早求值</strong>（eager evaluation），比如之前介绍的列表推导，列表这种数据结构一定要求内部的元素是已明确其值的，并且会将完整的列表保存在内存中。因此，《Effective Python》中提出这么一条：<strong>考虑用生成器来改写直接返回列表的函数</strong>。实际上，Python 3 已经对一些原本原本返回列表的函数使用生成器进行了改写。比如 Python 2 中返回完整列表的 <code>range()</code> 函数，现在也返回一个类似生成器的对象。如果一定要让 <code>range()</code> 函数返回列表，必须明确指明，如 <code>list(range(100))</code>。</p>
<p>定义生成器函数时，唯一需要留意的就是：<strong>函数返回的那个迭代器是有状态的</strong>，调用者不应该反复使用它。</p>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>除了定义包含 yield 关键字的生成器函数可以返回生成器外，生成器表达式也可以返回生成器对象。相比于列表推导的及早求值，生成器表达式能够进行惰性求值：不会迫切地构建列表，而是返回一个生成器，按需产出元素。也就是说，如果说列表推导时构建列表的工厂，那么生成器表达式就是构建生成器的工厂。</p>
<p>生成器表达式与列表推导的唯一区别是使用了一对圆括号 “()” 代替列表推导中的中括号 “[]”。我们使用之前定义的生成器函数 <code>gen_AB()</code> 来演示生成器表达式与列表推导之间的区别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()]  <span class="comment"># list comprehension</span></span><br><span class="line">start</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> res1:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">--&gt; A</span><br><span class="line">--&gt; B</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB())  <span class="comment"># generator expression</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x10dea8f20</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> res2:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">start</span><br><span class="line">--&gt; A</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">--&gt; B</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>归因于列表的及早求值，在声明列表推导表达式时，<code>gen_AB()</code> 函数中的 print 语句被立即执行了，函数产出的两个值 ‘A’、’B’ 也被存放在构建出的列表中。而生成器表达式则将这个过程推迟到值真正需要之时，即 for 循环隐式调用 <code>next()</code> 之时。</p>
<p>前面提到，生成器对象是有状态的，这里体现在，一个生成器对象产出的值只能被消费一次，除非定义一个新的个生成器对象重新绑定。你可以想象成，生成器对象中存在不能回头的“指针”，每次调用 <code>next()</code> 方法时指向下一个元素，这个过程不可逆。所以对于同一个生成器对象重复调用时可能会产生意想不到的结果。比如下面代码中第二次调用 <code>list(res2)</code> 返回一个空列表，因为第一次调用时“指针”就已经到头了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(res2)</span><br><span class="line">start</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(res2)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(res2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>所以如果要对生成器对象进行多次迭代，一种方法是使用列表将生成器中的所有元素备份下来，另一种是定义一个新的生成器对象重新绑定。由此可见，尽管生成器对象相比列表能够通过惰性求值节省内存，但如果每次迭代时定义新的生成器对象，求值过程也会被重复多次。而列表推导只会在声明时进行一次求值，并将结果保存在列表中可供多次迭代调用，这其实是一种空间消耗和时间消耗的权衡。</p>
<h3 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h3><p>刚才所提到的生成器产出值被消费的概念，也侧面体现了生成器可以作为“协程”的语义。“协程”从字面意思理解就是协作的进程，协作的进程之间需要进行通信，就需要消费者和生产者之间建立通道。从 Python 3.3 开始引入了一个新的句法：<code>yield from</code>，类似于其他语言中的 await 关键字。它可以在两个生成器之间建立通道，将产出的值从一个生成器传输到另一个生成器。</p>
<p>如果生成器函数需要产出其他生成器的值，传统的做法是使用 for 循环遍历生成器的元素并产出。以下定义了一个能够产出多个生成器产出值的生成器函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">chain</span>(<span class="params">*iterables</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> i</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1 = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(chain(g1, g2))</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>引入的 <code>yield from</code> 句法可以直接将一个生成器的所有产出值产出，而不用遍历生成器对象。因此我们可以编写只有一层的 for 循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">chain</span>(<span class="params">*iterables</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> <span class="keyword">from</span> it</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1 = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain(g1, g2)</span><br><span class="line">&lt;generator <span class="built_in">object</span> chain at <span class="number">0x10dea8e40</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(chain(g1, g2))</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>chain 函数依然返回一个生成器对象，其中的 <code>yield from it</code> 语句对 it 对象所做的第一件事是调用 <code>iter(it)</code> 获得一个迭代器，所以 it 对象可以是任何可迭代对象。我们将 <code>yield from &lt;iterable&gt;</code> 表达式中用于获取值的 <code>&lt;iterable&gt;</code> 称为<strong>子生成器</strong>（subgenerator），即上面代码中的 g1、g2；将包含了 <code>yield from</code> 语句的生成器函数，即 chain 函数，称为委派生成器。<code>yield from</code> 的主要功能是打开双向通道，把最外层的调用层与最内层的子生成器连接起来，这样二者可以直接发送和产出值。</p>
<p>上述的例子只能勉强算一个协程的案例，其中的“协作”部分体现的不够明显，只是简单的将一个生成器的值传输给另一个生成器产出。真正的协作应该是通过生成器对象的 <code>send()</code> 方法将值从客户端传输给生成器。在后面章节我们会专门介绍协程，里面会提及生成器的 <code>send()</code>、<code>throw()</code> 和 <code>close()</code> 方法，以及 <code>yield from</code> 句法的其他作用。</p>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 函数详解</title>
    <url>/2021/04/12/Python-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>除了用户定义的函数，调用运算符，即 “()” 括号对，还能应用到其他对象上。我们将能应用调用运算符的对象称为<strong>可调用对象</strong>，通过内置的 <code>callable()</code> 方法可以判断对象是否是可调用对象。在 Python 3 的<a href="https://docs.python.org/3/reference/datamodel.html">数据模型文档</a>中，一共列出了 7 种可调用对象：</p>
<ul>
<li><strong>内置函数和内置方法</strong>：使用 C 语言（CPython）实现的函数和方法，如 <code>len()</code> 和 <code>alist.append()</code>；</li>
<li><strong>用户定义的函数</strong>：包括使用 def 创建的普通函数和 lambda 创建的匿名函数；</li>
<li><strong>实例方法与类方法</strong>：定义在类中的方法，实例方法是指第一个参数为 <code>self</code> 的方法，类方法是指第一个参数为 <code>cls</code> 的方法；</li>
<li><strong>类</strong>：对类使用调用运算符，如 <code>C()</code>，会执行类的 <code>__new__</code> 方法创建类的实例，然后执行 <code>__init__</code> 初始化；</li>
<li><strong>类的实例</strong>：如果类定义了 <code>__call__</code> 方法，那它的实例可以作为函数调用；</li>
<li><strong>生成器函数</strong>：内部使用了 yield 关键字的函数，调用生成器函数会返回生成器对象；</li>
<li><strong>协程函数和异步生成器函数</strong>：从 Python 3.5 开始支持使用 <code>async def</code> 关键字来定义协程函数，如果内部包含 yield 关键字则被称为异步生成器函数。该函数被调用时会返回一个异步迭代器对象。</li>
</ul>
<h3 id="自定义的可调用类型"><a href="#自定义的可调用类型" class="headerlink" title="自定义的可调用类型"></a>自定义的可调用类型</h3><p>在装饰器一节，我们已经认识到了，装饰器不仅可以是函数，也可以是类。任何类只要实现了 <code>__call__</code> 方法，那它就是可调用对象，就可以表现的如同函数。因此，我们可以编写用户自定义的可调用类型，将其用在任何期待函数的地方。下面我将通过 Java 和 Python 两种语言，展现它们在可调用类型上的异同。</p>
<p>假设现有一副扑克，要求按照 <code>A, 2 ~ 10, J, Q, K</code> 的顺序进行排序。在 Java 中，可以通过 <code>Collections.sort()</code> 集合类的接口对一个集合进行排序。Python 也提供了内置的 <code>sorted()</code> 方法，对可迭代对象进行排序。但两种语言都不支持直接对字符串和数字类型进行比较，所以还需要实现特定的排序逻辑。</p>
<p>Java 中要实现排序逻辑通常有两种方法。一种是让类实现 Comparable 接口，重写其中的 <code>compareTo()</code> 抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Poker</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Poker otherPoker)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重点想展示第二种方法：新建一个实现了 Comparator 接口的比较器类，重写其 <code>compare()</code> 抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PokerComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Poker</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Poker firstPoker, Poker secondPoker)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// return ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PokerComparator pokerComparator = <span class="keyword">new</span> PokerComparator();</span><br><span class="line">Collections.sort(pokers, pokerComparator);</span><br></pre></td></tr></table></figure>

<p>对于这种方法，需要将比较器对象作为第二个参数传入 <code>Collections.sort()</code> 接口中。由于 Java 对象不能将函数作为参数的限制，我们定义了一个辅助类，实际上这个类对我们而言只有一个方法有用，那就是 <code>compare()</code> 方法，<code>Collections.sort()</code> 接口会去调用该方法，所以它就是对应的排序逻辑，只不过是用类实现的。</p>
<p>Python 的函数可以直接作为参数传递，但我们接下来要讲的是如何定义一个类似 Comparator 的类，让它能实现排序逻辑。</p>
<p>Python 内置的排序方法 <code>sorted()</code>，<strong>允许接收一个关键字参数 key 作为排序的键</strong>，比如 <code>key=len</code> 时依照元素的长度进行排序。对于扑克牌 A ~ K，可以维护一个映射数字类型的字典，比如将 ‘K’ 映射到 13，排序时直接通过映射的数值大小排序。维护一个字典，函数当然可以做到，但将其作为类的属性更加合适。可以定义一个扑克序列类，在初始化这个类时就构建好字典。为了让类可被调用，还需要实现 <code>__call__</code> 方法，直接返回字典中扑克牌对应的数值作为排序的键。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PokerOrder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._seq = &#123;<span class="built_in">str</span>(i): i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)&#125;</span><br><span class="line">        self._seq.setdefault(<span class="string">&#x27;J&#x27;</span>, <span class="number">11</span>)</span><br><span class="line">        self._seq.setdefault(<span class="string">&#x27;Q&#x27;</span>, <span class="number">12</span>)</span><br><span class="line">        self._seq.setdefault(<span class="string">&#x27;K&#x27;</span>, <span class="number">13</span>)</span><br><span class="line">        self._seq.setdefault(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._seq.get(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self._seq)</span><br></pre></td></tr></table></figure>

<p>由于 PokerOrder 类实现了 <code>__call__</code> 方法，它的实例会被 <code>callable()</code> 方法判定为可调用对象，可以直接应用调用运算符，传入扑克牌值返回对应数值。在排序时，将 PokerOrder 类的实例作为关键字传入，相当于将序列中的每项元素执行 <code>__call__</code> 方法返回的值作为键进行排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pokerorder = PokerOrder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pokerorder.show()</span><br><span class="line">&#123;<span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;10&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;J&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;Q&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;K&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(pokerorder)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pokerorder(<span class="string">&#x27;K&#x27;</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;2&#x27;</span>], key=pokerorder)</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;K&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>将类定义为可调用类型，不仅能维护内部属性，还能自定义方法，比如如上代码中的 <code>show()</code> 方法。除此之外，在实现更复杂的排序逻辑时，比如按照花色排序等，使用类要比使用函数更合适。甚至如果你觉的 PokerOrder 类应该被实现为单例模式，还可以添加 <code>__new__</code> 方法保证创建类中的字典只会被创建一次。</p>
<h2 id="函数对象与方法对象"><a href="#函数对象与方法对象" class="headerlink" title="函数对象与方法对象"></a>函数对象与方法对象</h2><p>Python 中一切皆对象，不管是函数还是类中定义的方法都是对象。对于类中的实例方法来说，通过类访问该实例方法，如 <code>C.foo</code>，会返回一个<strong>函数对象</strong>，即 <code>function</code> 类型；通过实例访问实例方法，如 <code>c.foo</code>，会返回一个<strong>绑定方法对象</strong>，即 <code>method</code> 类型，该方法对象绑定在实例上。对于类方法而言，无论是通过类还是实例访问，都返回绑定方法对象，该方法对象绑定在类上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self, x</span>):</span> <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span>    @<span class="built_in">classmethod</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">cls, x</span>):</span> <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.foo</span><br><span class="line">&lt;function C.foo at <span class="number">0x10d613f70</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(C.foo)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">function</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span> = <span class="title">C</span>()</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">C</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10b0a5820</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span>.<span class="title">foo</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">C</span>.<span class="title">foo</span> <span class="title">of</span> &lt;<span class="title">__main__</span>.<span class="title">C</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10b0a5820</span>&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">c.foo</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">method</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">C</span>.<span class="title">bar</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">C</span>.<span class="title">bar</span> <span class="title">of</span> &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">C</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span>.<span class="title">bar</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">C</span>.<span class="title">bar</span> <span class="title">of</span> &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">C</span>&#x27;&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法对象中包含一些特殊的只读属性：</p>
<ul>
<li><code>__self__</code> 为类实例对象本身；</li>
<li><code>__func__</code> 为函数对象；</li>
<li><code>__doc__</code> 为方法的文档，与 <code>__func__.__doc__</code> 作用相同；</li>
<li><code>__name__</code> 为方法名称，与 <code>__func__.__name__</code> 作用相同；</li>
<li><code>__module__</code> 为方法所属模块的名称，没有则为 None。</li>
</ul>
<p><strong>访问方法对象的 <code>__func__</code> 属性会获得函数对象</strong>。虽然两者都能通过调用运算符 “()” 调用，但函数对象还需要手动传入第一个位置的参数，即 <code>self</code> 和 <code>cls</code> 参数，方法对象则不需要。原因在于，<strong>调用方法对象会调用对应的下层函数对象 <code>__func__</code>，并将 <code>__self__</code> 参数插入到参数列表的开头</strong>，如果是实例方法则插入类实例，如果是类方法则插入类本身。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self, x</span>):</span> <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span>    @<span class="built_in">classmethod</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">cls, x</span>):</span> <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.foo(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.foo.__func__(c, <span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.bar(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.bar.__func__(C, <span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>就如同上述代码所展示的，对于实例方法 <code>foo()</code> 来说，调用 <code>c.foo(1)</code> 相当于调用 <code>c.foo.__func__(c, 1)</code>。对于类方法 <code>bar()</code> 来说，无论是调用 <code>c.bar(1)</code> 还是 <code>C.bar(1)</code> 都相当于调用 <code>C.bar.__func__(C, 1)</code>。</p>
<h3 id="函数内省"><a href="#函数内省" class="headerlink" title="函数内省"></a>函数内省</h3><p>将函数作为对象处理，可以用于运行时内省，类似于 Java 中的反射，可以在运行时获取函数的信息，比如注解、闭包、参数默认值等。下面列出了一些函数对象特有的属性和方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="built_in">set</span>(<span class="built_in">dir</span>(func)) - <span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="built_in">object</span>)))</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__call__&#x27;</span>, <span class="string">&#x27;__closure__&#x27;</span>, <span class="string">&#x27;__code__&#x27;</span>, <span class="string">&#x27;__defaults__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__get__&#x27;</span>, <span class="string">&#x27;__globals__&#x27;</span>, <span class="string">&#x27;__kwdefaults__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p><code>dir()</code> 函数可以查看一个模块或一个类中的所有属性，当然方法也算方法属性。上述代码将 func 函数对象与常规对象 object 的属性集合做了一个差集，只打印函数对象特有的属性。下表对这些特有属性做了简要说明。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>__annotations__</code></td>
<td>dict</td>
<td>参数和返回值的注解</td>
</tr>
<tr>
<td><code>__call__</code></td>
<td>method-wrapper</td>
<td>实现 () 运算符，即可调用对象协议</td>
</tr>
<tr>
<td><code>__closure__</code></td>
<td>tuple</td>
<td>函数闭包，即自由变量的绑定（没有则是None）</td>
</tr>
<tr>
<td><code>__code__</code></td>
<td>code</td>
<td>编译成字节码的函数元数据和函数定义体</td>
</tr>
<tr>
<td><code>__defaults__</code></td>
<td>tuple</td>
<td>形式参数的默认值</td>
</tr>
<tr>
<td><code>__get__</code></td>
<td>method-wrapper</td>
<td>实现只读描述符协议</td>
</tr>
<tr>
<td><code>__globals__</code></td>
<td>dict</td>
<td>函数所在模块中的全局变量</td>
</tr>
<tr>
<td><code>__kwdefaults__</code></td>
<td>dict</td>
<td>仅限关键字形式参数的默认值</td>
</tr>
<tr>
<td><code>__name__</code></td>
<td>str</td>
<td>函数名称</td>
</tr>
<tr>
<td><code>__qualname__</code></td>
<td>str</td>
<td>函数的限定名称，如 Random.choice</td>
</tr>
</tbody></table>
<p>函数内省经常被一些框架使用发挥出强大效果。比如 <code>__defaults__</code>、<code>__code__</code> 和 <code>__annotations__</code> 属性，经常被 IDE 用来提取关于函数签名的信息，我们之前也提到过 IDE 和 lint 工具使用函数注解做静态类型检查。还比如一些 Python Web 后端框架，可以自动解析 HTTP 请求中的参数将其注入到接口函数中执行，而不用程序员手动处理。</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>Python 最好的特性之一就是提供了极为灵活的参数处理机制。除了基础的定位参数（positional argument）之外，Python 还支持传入关键字参数（keyword argument），如我们之前所使用的内置方法 <code>sorted()</code>，就支持关键字参数 key 与 reverse。关键字参数允许提供默认值，如果无默认值一般为 None。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Return a new list containing all items from the iterable in ascending order.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">A custom key function can be supplied to customize the sort order, and the</span></span><br><span class="line"><span class="string">reverse flag can be set to request the result in descending order.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">sorted</span>(iterable, /, *, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>Java 5 中引入了不定长参数，允许在形参后添加 <code>...</code> 表示该形参可以接收多个参数值，多个参数将被当做数组传入，如 <code>void foo(String... args)</code>。Python 也支持<strong>不定长参数</strong>，它的形式是在参数名称前添加星号运算符，如 <code>*args</code>，不定长参数将被打包成<strong>元组</strong>传入。除此之外，Python 还支持传入<strong>非具名关键字参数</strong>，即没有明确指定名称的关键字参数，如 <code>**kwargs</code>，参数将会被打包成一个<strong>字典</strong>传入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;args: &#x27;</span>, args)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;kwargs: &#x27;</span>, kwargs)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, key1=<span class="number">1</span>, key2=<span class="string">&#x27;b&#x27;</span>) </span><br><span class="line">args: (<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">kwargs: &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;b&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果同时使用 <code>*args</code> 和 <code>**kwargs</code>，<code>*args</code> 参数必须要在 <code>**kwargs</code> 之前。它们可以与其他类型的参数混合使用，但<strong>参数的顺序必须是：定位参数，默认参数，不定长参数，具名关键字参数和非具名关键字参数</strong>。即如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">record</span>(<span class="params">name, age=<span class="number">18</span>, *phones, email=<span class="literal">None</span>, **other</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;name: &#x27;</span>, name)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;age: &#x27;</span>, age)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;phones: &#x27;</span>, phones)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;email: &#x27;</span>, email)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;other: &#x27;</span>, other)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="number">123456</span>, <span class="number">654321</span>, email=<span class="string">&#x27;abc@email.com&#x27;</span>, height=<span class="number">180</span>, weight=<span class="number">90</span>)</span><br><span class="line">name: Jack</span><br><span class="line">age: <span class="number">20</span></span><br><span class="line">phones: (<span class="number">123456</span>, <span class="number">654321</span>)</span><br><span class="line">email: abc@email.com</span><br><span class="line">other: &#123;<span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">90</span>&#125;</span><br></pre></td></tr></table></figure>

<p>其中，默认参数与具名关键字参数形式上一样，默认参数通常是用来简化函数调用者的传参的。这两者可以通过位置进行区分，在不定长参数之前的是默认参数，之后的是关键字参数。如果要传入不定长参数，默认参数就不能省略，此时默认参数被视为定位参数（默认值失去了意义），其后的非关键字参数会被不定长参数 <code>*phones</code> 捕获。如果省略了默认参数，那么不定长参数的第一个元素会被赋值给默认参数。具名关键字参数则没有这一限制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>record(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">123456</span>, <span class="number">654321</span>, height=<span class="number">180</span>)</span><br><span class="line">name:  Jack</span><br><span class="line">age:  <span class="number">123456</span></span><br><span class="line">phones:  (<span class="number">654321</span>,)</span><br><span class="line">email:  <span class="literal">None</span></span><br><span class="line">other:  &#123;<span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>仅限关键字参数</strong>（keyword-only argument）是 Python 3 新增的特性。如果定义函数时想指定仅限关键字参数，需要将它们放在带有 <code>*</code> 的不定长参数之后。如果不想支持不定长参数，可以在签名中放一个 <code>*</code>，标志着定位参数到此终结，之后的参数只能以关键字形式提供，即仅限关键字参数。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, *, b, c=<span class="number">3</span></span>):</span> </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a, b, c</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，仅限关键字参数不一定要有默认值，但如果没有默认值，调用函数时必须传入该参数。内置方法 <code>sorted()</code> 的参数就包含一个 <code>*</code>，其后的 key 和 reverse 参数就是带有默认值的仅限关键字参数。</p>
<h3 id="函数参数的最佳实践"><a href="#函数参数的最佳实践" class="headerlink" title="函数参数的最佳实践"></a>函数参数的最佳实践</h3><p>对于函数参数如何正确的使用，《Effective Python》给出了一些建议。我结合自己的一些看法，给出如下几点建议。</p>
<p>第一点，<strong>使用不定长参数减少视觉杂讯</strong>。这是一种比喻，目的是使函数签名内容不要过于过多，而应凸显重要部分。如果一个函数支持传入多个相同类型的对象，或对不同类型的对象做相同处理，可以考虑不定长参数（或者组合成一个可迭代对象传入）。拿 Python 的内置方法来举例，<code>map()</code> 的最后一个参数就是不定长参数 <code>*iterables</code>，支持传入多个可迭代对象；<code>print()</code> 方法的第一个参数 <code>*values</code> 也是不定长参数，对于传入多个参数，不管它们是什么类型都能将其打印。</p>
<p>第二点，<strong>使用关键字参数来表达可选的行为</strong>。关键字参数的名称可以辅助调用者明确参数的用途，比如 <code>sorted()</code> 方法中的 reverse 参数用来反向排序。关键字参数还能提供默认值，就如同一个开关，如果使用函数默认功能，就不需要操心这些参数，还可以避免传参时的重复代码。如果想开启附加功能，可以传入指定的关键字参数。带有默认值的关键字参数还能在不改变调用代码的基础上为函数添加新功能，保证了代码的兼容性。从另一种角度看，带有默认值的关键字参数提供了类似多态重载的动态语言特性，虽然 Python 并不支持函数重载。</p>
<p>第三点，<strong>使用仅限关键字参数来确保代码清晰</strong>。关键字参数可以提高可读性，但不能保证调用者一定使用关键字来明确指出参数的含义，关键字参数可以通过位置来赋值，比如定义的函数 <code>def func(a, b=1)</code> 可以通过 <code>func(1, 2)</code> 来为关键字参数 b 赋值。如果有必要，可以使用仅限关键字参数来强制调用者使用关键字。比如 <code>sorted()</code> 方法签名 <code>*</code> 后指定的仅限关键字参数 key 和 reverse。</p>
<p>第四点，<strong>使用 None 而不是可变序列为参数默认值赋空</strong>。绝对不要将参数默认值指定为空的可变序列 <code>[]</code> 和 <code>&#123;&#125;</code>。参数的默认值会在模块被加载时执行一次并绑定，如果默认值定义为了可变序列，那么以默认形式调用函数的代码都会共享同一份序列，从而导致难以预料的结果。比如如下解析 JSON 的函数，默认值为空字典，在解析出错时将其返回，导致两个对象共用一个字典。解决的方法是使用 None 作为参数默认值，在函数内重新赋值为空字典，并添加文档说明参数默认值的实际行为。如果参数默认值是动态变化的，如当前时间，也应如此做。总之，要避免参数默认值是可变的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">data, default=&#123;&#125;</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> json.loads(data)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ValueError:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> default</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = decode(<span class="string">&#x27;bad data&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar = decode(<span class="string">&#x27;also bad&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo <span class="keyword">is</span> bar</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>第五点，<strong>避免修改传入参数的值</strong>。函数式编程中非常强调的一点是，函数要无副作用。无副作用指的是函数内部不与外部互动（最典型的情况是，修改全局变量的值），产生除函数本身运算以外的其他效果。函数无副作用，意味着函数要保持独立，不依赖于上下文环境，不得修改外部变量包括传入参数的值。即使函数要在传入参数本身上做运算，也应该新建一个副本将其返回。就拿 <code>sorted()</code> 来说，即使排序前后元素位置没有变化，也返回一个全新的列表。除此之外，<code>map()</code>、<code>filter()</code> 等其他内置方法也都遵循这一点，不对参数本身做修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(l)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(l) <span class="keyword">is</span> l</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义的-sorted-函数"><a href="#自定义的-sorted-函数" class="headerlink" title="自定义的 sorted() 函数"></a>自定义的 <code>sorted()</code> 函数</h3><p>在本章中我一直拿内置的 <code>sorted()</code> 函数来举例，不妨自己来实现一个。借此案例我想演示：如何使用仅限关键字参数，如何编写高阶函数，以及如何使用卫语句对异常参数进行处理。</p>
<p>这里的排序算法不是关键，使用的是最简单的冒泡排序算法。函数签名上尽可能与 <code>sorted()</code> 保持一致，为了保证函数无副作用，函数内部新建了一个列表副本保存传入可迭代序列的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">iterable, *, key=<span class="literal">None</span>, reverse=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">callable</span>(key):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">type</span>(key)&#125;</span> object is not callable&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    _l = <span class="built_in">list</span>(iterable)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(_l)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> _l[j] &gt; _l[i]:</span><br><span class="line">                    _l[j], _l[i] = _l[i], _l[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> key(_l[j]) &gt; key(_l[i]):</span><br><span class="line">                    _l[j], _l[i] = _l[i], _l[j]</span><br><span class="line">    <span class="keyword">if</span> reverse:</span><br><span class="line">        _l.reverse()</span><br><span class="line">    <span class="keyword">return</span> _l</span><br></pre></td></tr></table></figure>

<p>仅限关键字参数是指在 <code>*</code> 运算符之后定义的关键字参数，在调用时必须指定关键字名称，如上述函数中的 key 和 reverse 关键字。</p>
<p>在函数的开头，首先判断传入的 key 参数在非 None 情况下是否是可调用的，若不可调用则抛出 TypeError 异常。这种 if 条件分支语句叫做<strong>卫语句</strong>（guard clause），目的是将可能出错的每个分支做单独检查，要么抛出异常要么立即返回。通过在函数头部的集中处理及早抛出各种可能的异常（又称迅速失败），避免无效的运算。函数真正的实现代码放在卫语句之后，保证运行到此处时所有条件都已通过。</p>
<p>通过了卫语句检测的 key 参数是可调用的，在函数内部直接使用 <code>key()</code> 调用。对于接收函数作为参数的 <code>sort()</code> 函数，我们将其称之为<strong>高阶函数</strong>，这也是 Python 函数式编程特性之一。</p>
<p>下面是测试方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_should_sort_number_sequence</span>(<span class="params">self</span>):</span></span><br><span class="line">    _l = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>]</span><br><span class="line">    result = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">    <span class="keyword">assert</span> sort(_l) == result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_should_sort_sequence_with_key_function</span>(<span class="params">self</span>):</span></span><br><span class="line">    _l = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;aab&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;aabb&#x27;</span>]</span><br><span class="line">    result = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;aab&#x27;</span>, <span class="string">&#x27;aabb&#x27;</span>]</span><br><span class="line">    <span class="keyword">assert</span> sort(_l, key=<span class="built_in">len</span>) == result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_should_sort_sequence_with_key_function_and_reverse</span>(<span class="params">self</span>):</span></span><br><span class="line">    _l = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;aab&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;aabb&#x27;</span>]</span><br><span class="line">    result = [<span class="string">&#x27;aabb&#x27;</span>, <span class="string">&#x27;aab&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    <span class="keyword">assert</span> sort(_l, key=<span class="built_in">len</span>, reverse=<span class="literal">True</span>) == result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_should_raise_error_when_key_function_is_not_callable</span>(<span class="params">self</span>):</span></span><br><span class="line">    _l = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>]</span><br><span class="line">    <span class="keyword">with</span> pytest.raises(TypeError) <span class="keyword">as</span> e:</span><br><span class="line">        sort(_l, key=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>pytest 框架支持对抛出异常的测试，使用 with 语句加 <code>pytest.raises()</code> 方法可以断言定义体内调用的方法是否会抛出对应的异常。</p>
<h3 id="与-运算符"><a href="#与-运算符" class="headerlink" title="* 与 ** 运算符"></a><code>*</code> 与 <code>**</code> 运算符</h3><p>在 Python 中，<code>*</code> 与 <code>**</code> 运算符除了能用作数学运算符中的乘法和乘方之外，还有一些其他的巧妙用法。之前讨论的函数中的不定长参数 <code>*args</code> 和不具名关键字参数 <code>**kwargs</code> 是它们的经典用法之一。此外，这两个运算符还可以用来对参数列表进行<strong>拆包</strong>。</p>
<p>运用 <code>*</code> 运算符可以把一个可迭代对象拆开作为函数的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>, b=<span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a=<span class="number">1</span>, b=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(*t)</span><br><span class="line">a=<span class="number">1</span>, b=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>类似的，运用 <code>**</code> 运算符可以把一个字典拆开作为函数的参数，同名键会绑定到对应的具名参数上，如果函数还定义了非具名关键字参数 <code>**kwargs</code>，除了绑定的同名键外余下参数会被 <code>**kwargs</code> 捕获。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a=<span class="literal">None</span>, b=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>, b=<span class="subst">&#123;b&#125;</span>, kwargs=<span class="subst">&#123;kwargs&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(**d)</span><br><span class="line">a=<span class="number">1</span>, b=<span class="number">2</span>, kwargs=&#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>*</code> 运算符对于函数参数中的可迭代对象拆包概念，在 Python 3 被扩展到了<strong>平行赋值</strong>。在平行赋值中，<code>*</code> 前缀只能被用在一个变量名前，但这个变量可以出现在赋值表达式的任何位置，用来处理剩下的元素。拆包所赋值的元素是列表类型，即使其中只有一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *rest, d, e = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, rest, d, e</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *rest, c, d, e = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, rest, c, d, e</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>Python 中的 lambda 关键字用于创建<strong>匿名函数</strong>。lambda 表达式的格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments : statement</span><br></pre></td></tr></table></figure>

<p>表达式以 lambda 关键字开头，冒号 “:” 左侧是函数的<strong>传入参数</strong>，当有多个入参时使用逗号划分开，冒号右侧是<strong>返回值</strong>的表达式语句，函数会根据表达式计算结果并将其返回。lambda 表达式会创建一个函数对象，可以对其赋值并如同普通函数一样使用。下面定义了一个求平方的 lambda 表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>square = <span class="keyword">lambda</span> x : x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x101631e50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(<span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>lambda 句法只是语法糖，上述定义的 lambda 表达式与如下使用 def 关键字定义的普通函数没有本质区别，甚至 lambda 表达式的功能要更加受限。由于 Python 简单的句法限制了 lambda 定义体只能使用纯表达式，不能进行赋值，也不能使用 while 和 try 等 Python 语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square</span><br><span class="line">&lt;function square at <span class="number">0x101631dc0</span>&gt;</span><br></pre></td></tr></table></figure>

<p>在 Python 中，<strong>lambda 表达式的通常作用是作为参数传入给高阶函数</strong>。比如在列表推导一节介绍的 map、filter 和 reduce 函数，这些函数接收一个函数作为参数，如果不想额外定义函数，那么使用 lambda 表达式创建匿名函数就是最佳的应用场景。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x : x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x : x &lt; <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>除了上述这种应用场景之外，Python 很少使用匿名函数。受到句法的限制，lambda 表达式无法实现复杂的函数功能。同时，在使用 lambda 表达式时要尽可能保证表达式的清晰简短，否则冗长的 lambda 表达式将会导致代码难以阅读。此时，应该使用 def 关键字创建普通函数，即《Effective Python》所提倡的：<strong>使用辅助函数来取代复杂的表达式</strong>，并赋予函数清晰的名称以提高代码可读性。</p>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 属性、特性和描述符</title>
    <url>/2021/04/26/Python-%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><p>在 Python 中，数据属性和处理数据的方法统称为属性（attribute），方法也可称为方法属性，本质上是可调用的（callable）属性。Python 提供了丰富的 API 用于控制访问属性，以及实现动态属性。即使访问不存在的属性，也可以通过特殊方法实现“虚拟属性”，从而即时计算属性的值。</p>
<h3 id="处理属性的特殊属性"><a href="#处理属性的特殊属性" class="headerlink" title="处理属性的特殊属性"></a>处理属性的特殊属性</h3><p>为了方便处理属性，Python 定义了一些特殊属性，包括：</p>
<ul>
<li><code>__class__</code>：对象所属类的引用。<code>obj.__class__</code> 与 <code>type(obj)</code> 效果一致。类和类的实例都具有属性，有些属性只能在类中查询，比如特殊方法；</li>
<li><code>__dict__</code>：存储类或实例的可写属性的字典。如果设置了 <code>__slots__</code> 属性，实例可能没有 <code>__dict__</code> 属性；</li>
<li><code>__slots__</code>：类可以定义这个属性，限制实例能拥有哪些属性。该属性的值可以是个可迭代对象，但通常会使用元组。如果类设置了 <code>__slots__</code> 属性且 <code>__slots__</code> 中不包含 <code>&#39;__dict__&#39;</code>，那么该类的实例没有 <code>__dict__</code> 属性。</li>
</ul>
<h4 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a><code>__dict__</code></h4><p>默认情况下，Python 会使用名为 <code>__dict__</code> 的字典存储类和实例中的可写属性。其中，<strong>类属性字典</strong>由名为 <code>mappingproxy</code> 的代理对象包装，<code>mappingproxy</code> 定义在 <code>collections.abc</code> 模块中，特别指代类属性字典的类型：<code>mappingproxy = type(type.__dict__)</code>。类属性字典包含显式定义在类中的字段和方法，以及一些可写的特殊属性，包括模块、字典、弱引用和文档字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.b = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, </span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function Foo.__init__ at <span class="number">0x1051fe8b0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;Foo&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;Foo&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>类属性不仅限于类字典中所展示的，还包含一些不可变的类属性，比如所属类的引用 <code>__class__</code>，直接父类组成的元组 <code>__bases__</code> 等。</p>
<p><strong>实例属性字典</strong>则是普通的字典类型，为实例属性赋值，会动态的修改实例字典。如果属性不存在，则将其添加到字典中，包括在初始化方法 <code>__init__</code> 中赋值的实例属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.c = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h4><p>Python 解释器会默认在类的构造方法 <code>__new__</code> 中创建 <code>__dict__</code> 存放实例属性，在访问时通过访问实例字典读取属性值。由于字典底层使用了散列表结构，对属性的存取会相当迅速。但同时，为了减少散列冲突，散列表的大小通常要远大于键的数量，这种基于空间换时间的考量会导致字典会消耗大量内存。为此，Python 提供了 <code>__slots__</code> 属性，该属性会覆盖 <code>__dict__</code> 属性，<strong>使用类似元组的结构存储实例变量</strong>，从而达到节省内存的目的。</p>
<p>我沿用之前定义的 Person 类做了测试，它包含 name 和 age 两个实例属性。使用列表推导生成一百万个 Person 对象，分别对默认使用 <code>__dict__</code> 和添加了 <code>__slots__</code> 属性的内存占用情况进行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ time python3 slots.py --use-dict </span><br><span class="line">Initial RAM Usage:    5,472,256</span><br><span class="line">  Final RAM Usage:  186,380,288</span><br><span class="line">python3 slots.py --use-dict  1.11s user 0.07s system 99% cpu 1.187 total</span><br><span class="line">➜ time python3 slots.py --use-slots</span><br><span class="line">Initial RAM Usage:    5,476,352</span><br><span class="line">  Final RAM Usage:   76,369,920</span><br><span class="line">python3 slots.py --use-slots  0.74s user 0.04s system 99% cpu 0.788 total</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>__slots__</code> 后内存占用得到显著优化，只占了使用 <code>__dict__</code> 的一半不到，运行速度也更快。</p>
<p><strong>定义 <code>__slots__</code> 的方式</strong>是，创建一个名为 <code>__slots__</code> 的类属性，把它的值设为一个字符串构成的可迭代对象（通常使用元组），其中的元素名称代表实例属性，比如<code>__slots__ = (&#39;name&#39;, &#39;age&#39;)</code>。定义 <code>__slots__</code> 属性相当于告诉解释器：这个类的所有实例属性都在这儿了。<strong>实例不能再有 <code>__slots__</code> 所列之外的其他属性</strong>。但应该明白，<code>__slots__</code> 并不是用来禁止类的用户新增实例属性的手段，而只是一种内存优化方案。</p>
<p>如果你阅读 <code>collections.abc</code> 模块的源码，会发现其中的类都存在一行 <code>__slots__ = ()</code> 代码。即使这些类没有实例属性，使用空元组定义的 <code>__slots__</code> 属性可以避免类的构造方法创建 <code>__dict__</code> 空字典，空字典也会在堆上分配内存空间。对于集合这种基本数据类型，有必要为其声明空元组形式的 <code>__slots__</code> 属性。此外，对于模式固定的数据库记录，以及特大型数据集，也有必要声明 <code>__slots__</code> 属性。</p>
<p>上面介绍的这些特殊属性，在一些访问和处理属性的内置函数和特殊方法中会被使用。下面列出这些函数和方法。</p>
<h3 id="处理属性的内置函数"><a href="#处理属性的内置函数" class="headerlink" title="处理属性的内置函数"></a>处理属性的内置函数</h3><p><code>dir([object])</code>：列出对象的大多数属性。object 参数是可选的，缺省时会列出当前模块的属性。dir 函数能够审查对象有没有 <code>__dict__</code> 和 <code>__slots__</code> 属性，并列出其中的键。</p>
<p><code>getattr(object, name[, default])</code>：从对象中读取属性值。获取的属性可能来自对象所属的类或超类。如果没有找到指定属性，则抛出 AttributeError 异常，或返回预设默认值。</p>
<p><code>hasattr(object, name)</code>：会调用 getattr 函数查看能否获取指定的属性，当抛出 AttributeError 异常时返回 False。</p>
<p><code>setattr(object, name, value)</code>：为对象指定的属性设值。这个函数可能会创建一个新属性，或者覆盖现有的属性。前提是对象能够接受这个值，比如设定了 <code>__slots__</code> 的对象不能添加新属性。</p>
<p><code>vars([object])</code>：返回对象的 <code>__dict__</code> 属性，参数缺省时返回当前模块的 <code>__dict__</code> 属性。vars 函数不能处理设定了 <code>__slots__</code> 属性的对象。</p>
<h3 id="处理属性的特殊方法"><a href="#处理属性的特殊方法" class="headerlink" title="处理属性的特殊方法"></a>处理属性的特殊方法</h3><p><code>__getattribute__(self, name)</code>：除了访问特殊属性和特殊方法，尝试获取指定的属性时总会调用这个方法。dot 运算符、<code>getattr</code> 和 <code>hasattr</code> 会调用这个方法。该方法内部定义了属性访问规则，当未找到指定属性时抛出 AttributeError 异常，<code>__getattr__</code> 方法会被调用。</p>
<p><code>__getattr__(self, name)</code>：仅当获取指定属性失败时，即处理不存在的属性时被调用。用户自定义的类可以实现 <code>__getattr__</code> 方法从而动态计算属性的值。</p>
<p><code>__setattr__(self, name, value)</code>：尝试为指定属性设值时总会调用该方法。dot 运算符和 <code>setattr</code> 会调用这个方法。该方法内部定义了属性设值规则。</p>
<p><code>__delattr__(self, name)</code>：使用 del 关键字删除属性时会调用这个方法。</p>
<p><code>__dir__(self)</code>：内置函数 <code>dir()</code> 会调用这个方法。</p>
<h3 id="属性访问规则"><a href="#属性访问规则" class="headerlink" title="属性访问规则"></a>属性访问规则</h3><p>Python 解释器在访问属性时会按照一定的规则，从入口方法 <code>__getattribute__</code> 开始，按照顺序依次查找，如果找到则返回，未找到则抛出异常，调用 <code>__getattr__</code> 动态计算虚拟属性。属性访问规则如下：</p>
<ol>
<li><code>__getattribute__</code> 方法</li>
<li>数据描述符</li>
<li>实例对象的字典</li>
<li>类的字典</li>
<li>非数据描述符</li>
<li>父类的字典</li>
<li><code>__getattr__</code> 方法</li>
</ol>
<p>注：其中，数据描述符是实现了 <code>__get__</code> 和 <code>__set__</code> 描述符协议的类。描述符的内容，会在后面做详细介绍。</p>
<p>查询属性的入口方法 <code>__getattribute__</code> 实现逻辑的伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">name</span>)：</span></span><br><span class="line"><span class="function">    # 先在类(<span class="params">包括父类、祖先类</span>)字典中查找数据描述符</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">find</span> <span class="title">data</span> <span class="title">descriptor</span> <span class="title">in</span> <span class="title">class</span> <span class="title">and</span> <span class="title">base</span> <span class="title">class</span> <span class="title">__dict__</span>:</span></span><br><span class="line">        <span class="comment"># 如果是数据描述符，则调用该数据描述符的 __get__ 方法并将结果返回</span></span><br><span class="line">        <span class="keyword">return</span> descriptor.__get__(instance, instance.__class__)</span><br><span class="line">    <span class="comment"># 如果不是数据描述符，继续查询实例字典</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> instance.__dict__:</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[name]</span><br><span class="line">    <span class="comment"># 实例字典中没有，则继续查询类字典</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> instance.__class__.__dict__:</span><br><span class="line">        <span class="keyword">return</span> instance.__class__.__dict__[name]</span><br><span class="line">    <span class="comment"># 在类和父类字典中查询非数据描述符</span></span><br><span class="line">    <span class="keyword">if</span> find non-data descriptor <span class="keyword">in</span> <span class="class"><span class="keyword">class</span> <span class="title">and</span> <span class="title">base</span> <span class="title">class</span> <span class="title">__dict__</span>:</span></span><br><span class="line">        <span class="comment"># 如果找到，返回描述符实例</span></span><br><span class="line">        <span class="keyword">return</span> descriptor.instance</span><br><span class="line">    <span class="comment"># 如果不是描述符，继续在父类字典中查找</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> baseclass __dict__:</span><br><span class="line">        <span class="keyword">return</span> baseclass.__dict__[name]</span><br><span class="line">    <span class="comment"># 如果依然没有找到，抛出异常，__getattr__ 函数会被调用</span></span><br><span class="line">    <span class="keyword">raise</span> AttributeError</span><br></pre></td></tr></table></figure>

<p>为实例属性赋值则没有这么麻烦，<code>__setattr__</code> 作为入口方法，只需要判断属性是否是数据描述符，如果是则调用其 <code>__set__</code> 方法，如果不是则为实例字典添加新的属性。<code>__setattr__</code> 实现逻辑的伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__setattr__(name, value):</span><br><span class="line">    <span class="comment"># 先在类(包括父类、祖先类)字典中查找描述符</span></span><br><span class="line">    <span class="keyword">if</span> find data descriptor <span class="keyword">in</span> <span class="class"><span class="keyword">class</span> <span class="title">and</span> <span class="title">base</span> <span class="title">class</span> <span class="title">__dict__</span>:</span></span><br><span class="line">        <span class="comment"># 如果是数据描述符，则调用描述符的 __set__ 方法进行设值</span></span><br><span class="line">        descriptor.__set__(instance, value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 否则，为实例属性字典添加新值</span></span><br><span class="line">        instance.__dict__[name] = value</span><br></pre></td></tr></table></figure>

<p>由此也可以发现，Python 存取属性的方式特别不对等。通过实例访问属性时，如果实例中没有指定属性，那么会尝试获取类属性。而为实例中的属性赋值时，如果属性不存在会在实例中创建该属性，根本不影响类。</p>
<p>下面介绍如何使用 <code>__getattr__</code> 方法动态计算虚拟属性。</p>
<h3 id="自定义-getattr-即时计算属性"><a href="#自定义-getattr-即时计算属性" class="headerlink" title="自定义 __getattr__ 即时计算属性"></a>自定义 <code>__getattr__</code> 即时计算属性</h3><p>处理 JSON 是非常常见的需求，JavaScript 对 JSON 具有天生的支持，可以使用 dot 运算符链式获取属性的值，如 <code>res.cities[0].ext.province</code>。而 Python 原生的字典不支持使用 dot 运算符直接获取属性，只能使用 <code>res[&#39;cities&#39;][0][&#39;ext&#39;][&#39;province&#39;]</code> 的形式，会显得格外冗长。但可以通过实现一个近似字典的类，达到同样的效果。如下是 Python 中的效果演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> json_parser <span class="keyword">import</span> JsonParser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json = &#123;</span><br><span class="line"><span class="meta">... </span>  <span class="string">&quot;code&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line"><span class="meta">... </span>  <span class="string">&quot;cities&quot;</span>: [</span><br><span class="line"><span class="meta">... </span>    &#123;</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;lat&quot;</span>: <span class="string">&quot;41.2334465&quot;</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;lng&quot;</span>: <span class="string">&quot;116.9772857&quot;</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;citycode&quot;</span>: <span class="number">207</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;ext&quot;</span>: &#123;</span><br><span class="line"><span class="meta">... </span>        <span class="string">&quot;province&quot;</span>: <span class="string">&quot;河北省&quot;</span>,</span><br><span class="line"><span class="meta">... </span>        <span class="string">&quot;city&quot;</span>: <span class="string">&quot;承德市&quot;</span></span><br><span class="line"><span class="meta">... </span>      &#125;</span><br><span class="line"><span class="meta">... </span>    &#125; </span><br><span class="line"><span class="meta">... </span>  ]</span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = JsonParser(json)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.code</span><br><span class="line"><span class="string">&#x27;200&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.cities[<span class="number">0</span>].citycode</span><br><span class="line"><span class="number">207</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.cities[<span class="number">0</span>].ext.province</span><br><span class="line"><span class="string">&#x27;河北省&#x27;</span></span><br></pre></td></tr></table></figure>

<p>能够使用 dot 运算符链式获取属性的关键在于定义在 JsonParser 中的 <code>__getattr__</code> 方法。前面已经说过，Python 解释器在查询对象属性失败时会调用 <code>__getattr__</code> 方法动态计算属性。下面代码定义了动态计算的逻辑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonParser</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, arg</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(arg, Mapping):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(arg, MutableSequence):</span><br><span class="line">            <span class="keyword">return</span> [cls(i) <span class="keyword">for</span> i <span class="keyword">in</span> arg]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self._data = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> JsonParser(self._data[name])</span><br></pre></td></tr></table></figure>

<p>通过 <code>__getattr__</code> 方法递归地创建 JsonParser 类，并将下级的 JSON 结构  <code>_data[name]</code> 作为构造参数传入。构造方法 <code>__new__</code> 会判断传入参数的类型，如果是映射类型直接创建 JsonParser 对象，如果是可变序列，则通过列表推导式返回 JsonParser 列表。之所以要这么处理是因为 JSON 结构可能是数组，除了映射结构还需要对数组类型进行解析，以支持 <code>cities[0]</code> 式的访问。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>在 Java 中，为了控制属性的访问权限，一般会将属性设置为私有属性，并为可以公开的属性设置公有的 getter 和 setter 方法。这样做还有一个好处，可以在方法内添加对属性的验证，比如保证商品的数量不会是负数。如果想更进一步，可以按照领域驱动设计的理念，可以将属性设置为实体类 Entity，在类中对属性进行校验。这两种思想在 Python 中也都有对应的实现，前一种对应于特性，后一种对应于描述符。</p>
<p>特性经常用于把公开的属性变成使用读值方法和设置方法管理的属性，且在不影响客户端代码的前提下实施业务规则。使用 <code>get/set + 属性名</code> 的命名方式不符合 Python 一贯的简约作风，为此 Python 提供了特性，即 property。property 是一个类形式的函数装饰器，本质上它是一个<strong>描述符类</strong>（实现了描述符协议）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">property</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        fget: <span class="type">Optional</span>[<span class="type">Callable</span>[[<span class="type">Any</span>], <span class="type">Any</span>]] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">        fset: <span class="type">Optional</span>[<span class="type">Callable</span>[[<span class="type">Any</span>, <span class="type">Any</span>], <span class="literal">None</span>]] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">        fdel: <span class="type">Optional</span>[<span class="type">Callable</span>[[<span class="type">Any</span>], <span class="literal">None</span>]] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">        doc: <span class="type">Optional</span>[<span class="built_in">str</span>] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span>(<span class="params">self, fget: <span class="type">Callable</span>[[<span class="type">Any</span>], <span class="type">Any</span>]</span>) -&gt; <span class="built_in">property</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span>(<span class="params">self, fset: <span class="type">Callable</span>[[<span class="type">Any</span>, <span class="type">Any</span>], <span class="literal">None</span>]</span>) -&gt; <span class="built_in">property</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleter</span>(<span class="params">self, fdel: <span class="type">Callable</span>[[<span class="type">Any</span>], <span class="literal">None</span>]</span>) -&gt; <span class="built_in">property</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj: <span class="type">Any</span>, <span class="built_in">type</span>: <span class="type">Optional</span>[<span class="built_in">type</span>] = ...</span>) -&gt; <span class="type">Any</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, obj: <span class="type">Any</span>, value: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, obj: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fget</span>(<span class="params">self</span>) -&gt; <span class="type">Any</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fset</span>(<span class="params">self, value: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fdel</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br></pre></td></tr></table></figure>

<p>使用函数形式的装饰器会返回一个嵌套的高阶函数，类形式的装饰器也类似，使用 <code>@property</code> 装饰的方法会被包装成特性类。特性类具有 getter、setter 和 deleter 方法属性，这三个属性也都返回 property 对象。</p>
<p>因此，用 <code>@property</code> 装饰的读值方法，如下的 <code>amount(self)</code> 方法，相当于返回一个 <code>property(amount)</code> 特性对象，将读值方法作为初始化参数 fget 传入。而后可以使用 <code>@amount.setter</code> 装饰设值方法，此时设值方法 amount 返回的是特性对象，setter 是它的方法属性。相当于 <code>property(amount).setter(amount)</code>，第二个 amount 是设值方法，将设值方法作为 fset 参数传入 setter 方法。也因此，<code>@amount.setter</code> 必须要定义在被 <code>@property</code> 装饰的设置方法之后。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, price, amount</span>):</span></span><br><span class="line">        self.price = price</span><br><span class="line">        self.amount = amount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.amount</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">amount</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._amount</span><br><span class="line"></span><br><span class="line"><span class="meta">    @amount.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">amount</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> value &gt;= <span class="number">0</span>:</span><br><span class="line">            self._amount = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;item amount must &gt;= 0&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>读值方法可以不与实例属性名一致，但要保证，读值方法名称、设值方法名称和 <code>@amount.setter</code> 装饰器中的名称三者保持一致，即都为 amount。这样，在访问属性时可以通过 <code>item.amount</code> 的形式对真正的实例属性 <code>self._amount</code> 进行读值和赋值。其实，初始化函数中的 <code>self.amount = amount</code> 语句就已经在使用特性的设置方法了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;_amount&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.total_price()</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.total_price()</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount = -<span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: item amount must &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到，真正被操作的实例属性 <code>_amount</code> 被保存在实例字典中。</p>
<p>任何对 <code>item.amount</code> 的读值和设值操作，都会经过由特性包装的读值和设值方法进行处理。由于在设值方法中对属性值做了非负验证，所以将其设置为负值会抛出 ValueError 异常。</p>
<p>需要注意的是，特性是类属性，被保存于类的 <code>__dict__</code> 字典中。在使用 <code>obj.attr</code> 这样的表达式时，不会从 obj 开始查询 attr 属性，而是从实例所属的类，即 <code>obj.__class__</code> 开始，仅当类中没有名为 attr 的特性时，才会去查询实例字典。也就是说，<strong>特性的读值和设值方法要优先于实例字典</strong>，只有直接存取 <code>__dict__</code> 属性才能跳过特性的处理逻辑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;attribute&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function LineItem.__init__ at <span class="number">0x105459a60</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;total_price&#x27;</span>: &lt;function LineItem.total_price at <span class="number">0x105459af0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;amount&#x27;</span>: &lt;<span class="built_in">property</span> <span class="built_in">object</span> at <span class="number">0x105487680</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;_amount&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__[<span class="string">&#x27;_amount&#x27;</span>] = -<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这条规则不仅适用于特性，还适用于数据描述符，其实，特性也是数据描述符。或者换句话说，正是由于数据描述符的访问优先级要高于实例字典，特性的读值和设值方法访问才优先于实例字典。下面我们介绍描述符。</p>
<h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><p>描述符是 Python 的独有特征，不仅在应用层，内置库和标准库中也有使用。除了特性之外，使用描述符的还有方法、classmethod 和 staticmethod 装饰器，以及 functools 模块中的诸多类。理解描述符是精通 Python 的关键，本章的话题就是描述符。</p>
<p><strong>描述符是实现了特定协议的类</strong>，这个协议包括 <code>__get__</code>、<code>__set__</code> 和 <code>__delete__</code> 方法。特性类 property 实现了完整的描述符协议。通常，可以只实现部分协议。其实，我们在真实代码中见到的大多数描述符只实现了 <code>__get__</code> 和 <code>__set__</code> 方法，还有很多只实现了其中的一个。</p>
<h3 id="定制描述符实现属性验证"><a href="#定制描述符实现属性验证" class="headerlink" title="定制描述符实现属性验证"></a>定制描述符实现属性验证</h3><p><strong>描述符是对多个属性运用相同存取逻辑的一种方式</strong>。假设我们想为之前定义的 LineItem 类中的 price 和 amount 属性都设置非负验证，一种方式是为它们都编写读值和设值方法，但这会造成代码重复。为了避免这个问题，Python 提出了一种面向对象的解决方式，那就是定制描述符类。</p>
<p>在下面的代码中，定义了一个名为 Quantity 的描述符类，用于管理 LineItem 的属性。我们将 LineItem 类称为托管类，被管理的属性称为托管属性。Quantity 类的实例属性 attribute 指代托管属性的名称，由初始化方法传入。通过在托管类中声明类属性的形式，如 <code>price = Quantity(&#39;price&#39;)</code> 将描述符实例绑定给 price 属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, attribute</span>):</span></span><br><span class="line">        self.attribute = attribute</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> value &gt;= <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.attribute] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;<span class="subst">&#123;self.attribute&#125;</span> must &gt;= 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    price = Quantity(<span class="string">&#x27;price&#x27;</span>)</span><br><span class="line">    amount = Quantity(<span class="string">&#x27;amount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, price, amount</span>):</span></span><br><span class="line">        self.price = price</span><br><span class="line">        self.amount = amount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.amount</span><br></pre></td></tr></table></figure>

<p>描述符类中定义了 <code>__set__</code> 方法，当尝试为托管属性赋值时，会调用这个方法并对值做验证。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;amount&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount = -<span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: amount must &gt;= <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.price = -<span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: price must &gt;= <span class="number">0</span>                            </span><br></pre></td></tr></table></figure>

<p><strong><code>__set__</code> 方法的签名</strong>：<code>def __set__(self, instance, value) -&gt; None: ...</code>。第一个参数 self 是<strong>描述符实例</strong>，即 <code>LineItem.price</code> 或 <code>LineItem.amount</code>；第二个参数 instance 是<strong>托管类实例</strong>，即 LineItem 实例；第三个参数 value 是要设置的值。在为属性赋值时，必须直接操作托管实例的 <code>__dict__</code>，如果使用内置的 setattr 函数，将会重复调用 <code>__set__</code> 导致无限递归。</p>
<p>由于读值方法不需要特殊的逻辑，所以这个描述符类没有定义 <code>__get__</code> 方法。一般情况下，如果没有 <code>__get__</code> 方法，为了给用户提供内省和其他元编程技术支持，通过托管类访问属性会返回描述符实例。通过实例访问则会去实例字典中查询对应属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.attribute]</span><br></pre></td></tr></table></figure>

<p><strong><code>__get__</code> 方法的签名</strong>：<code>def __get__(self, instance, owner) -&gt; Any: ...</code>。与 <code>__set__</code> 方法相同，<code>__get__</code> 方法的第一个参数代表描述符实例，第二个参数代表托管类实例。而第三个参数 owner 是<strong>托管类的引用</strong>，当通过托管类访问属性时会被使用，返回类字典中的描述符实例，可以理解为 <code>instance.__class__</code>。</p>
<p>此时通过托管类访问属性会得到描述符实例，通过实例访问属性会得到托管属性的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.amount</span><br><span class="line">&lt;lineitem_with_descriptor.Quantity <span class="built_in">object</span> at <span class="number">0x108c52760</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;lineitem_with_descriptor&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;price&#x27;</span>: &lt;lineitem_with_descriptor.Quantity <span class="built_in">object</span> at <span class="number">0x10abd1910</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;amount&#x27;</span>: &lt;lineitem_with_descriptor.Quantity <span class="built_in">object</span> at <span class="number">0x10ac037f0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function LineItem.__init__ at <span class="number">0x10abd8af0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;total_price&#x27;</span>: &lt;function LineItem.total_price at <span class="number">0x10abd8b80</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>同一时刻，内存中可能存在许多 LineItem 实例，但只会存在两个描述符实例：<code>LineItem.price</code> 和 <code>LineItem.amount</code>。这是因为描述符实例被定义为 LineItem 的类属性，会出现在 LineItem 的类字典中，由全部实例共享。</p>
<h3 id="描述符分类"><a href="#描述符分类" class="headerlink" title="描述符分类"></a>描述符分类</h3><p>我们将同时实现了 <code>__get__</code> 和 <code>__set__</code> 方法的描述符类称为<strong>数据描述符</strong>，将只实现了 <code>__get__</code> 的描述符类称为<strong>非数据描述符</strong>。在 CPython 的描述符对象 <a href="https://github.com/python/cpython/blob/master/Objects/descrobject.c">descrobject</a> 的源码中，会检查描述符是否有 <code>__set__</code> 方法来返回描述符是否是数据描述符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyDescr_IsData</span><span class="params">(PyObject *ob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Py_TYPE(ob)-&gt;tp_descr_set != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python 社区在讨论这些概念时会用不同的术语，数据描述符也被称为<strong>覆盖型描述符</strong>或强制描述符，非数据描述符也被称为<strong>非覆盖型描述符</strong>或遮盖型描述符。总之，这两者的区别在于是否实现了 <code>__set__</code> 方法。之所以这么分类，是由于 Python 中<strong>存取属性方式的不对等性</strong>，我们在属性访问规则一节中提到了这点。这种不对等的处理方式也对描述符产生影响。</p>
<p>描述符的覆盖体现在，如果实现了 <code>__set__</code> 方法，即使描述符是类属性，也会覆盖对实例属性的赋值操作。比如 <code>item.amount = -1</code> 不会直接修改实例字典，而是强制执行描述符的 <code>__set__</code> 方法对数值进行非负验证。</p>
<p>如果没有实现 <code>__set__</code> 方法，比如 Python 中的方法就是以非覆盖型描述符实现的，只定义了 <code>__get__</code> 方法。如果类中定义了名为 method 的方法，使用 <code>obj.method = 1</code> 会直接修改实例字典，即<strong>实例属性会遮盖同名描述符属性</strong>，但类中的描述符属性依然存在。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span>():</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.method = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;method&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.method</span><br><span class="line">&lt;function C.method at <span class="number">0x10f7ff940</span>&gt;</span><br></pre></td></tr></table></figure>

<p>综上所述，数据描述符的表现形式更像可以被随意赋值的数据，提供了完备的取值方法 <code>__get__</code> 和设值方法 <code>__set__</code>。而非数据描述符表现形式不像数据，比如 Python 中的方法，为非数据描述符赋值会遮盖掉实例的同名描述符属性。</p>
<p>以上讨论的都是是否存在 <code>__set__</code> 方法的情形，其实，也可以没有读值方法 <code>__get__</code>，比如我们定义的 Quantity 描述符。一般情况下，没有读值方法时访问属性会返回描述符对象本身。然而访问 LineItem 实例属性 <code>item.amount</code> 会得到对应数值。这是因为在它的初始化方法 <code>__init__</code> 中已经调用了描述符的 <code>__set__</code> 方法，该方法为实例字典 <code>__dict__</code> 创建了同名实例属性，由于实例属性会遮盖同名描述符属性，读取属性会返回实例字典中的值而不是描述符对象。这也是为什么将实现了 <code>__set__</code> 的描述符称为遮盖型描述符的原因。</p>
<p>总之，<strong>按照属性访问规则，数据描述符在实例字典之前被访问（调用 <code>__get__</code> 和<code>__set__</code> 方法），非数据描述符在实例字典之后被访问（可能会被遮盖）</strong>。</p>
<h3 id="方法是描述符"><a href="#方法是描述符" class="headerlink" title="方法是描述符"></a>方法是描述符</h3><p>定义在类中的方法会变成绑定方法（bound method），这是 Python 语言底层使用描述符的最好例证。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span>():</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.method</span><br><span class="line">&lt;bound method C.method of &lt;__main__.C <span class="built_in">object</span> at <span class="number">0x10f837580</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.method</span><br><span class="line">&lt;function C.method at <span class="number">0x10fff6b80</span>&gt;</span><br></pre></td></tr></table></figure>

<p>通过类和实例访问函数返回的是不同的对象。CPython 中定义的函数对象 <a href="https://github.com/python/cpython/blob/master/Objects/funcobject.c">funcobject</a> 实现了描述符协议的 <code>__get__</code> 方法，即如下的 <code>func_descr_get</code> 方法。与描述符一样，通过托管类访问函数时，传入的 obj 参数为空，函数的 <code>__get__</code> 方法会返回自身的引用。通过实例访问函数时，返回的是绑定方法对象，并把托管实例绑定给函数的第一个参数（即 self），这与 functool.partial 函数的行为一致。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Bind a function to an object */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject *</span></span><br><span class="line"><span class="function"><span class="title">func_descr_get</span><span class="params">(PyObject *func, PyObject *obj, PyObject *type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == Py_None || obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(func);</span><br><span class="line">        <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyMethod_New(func, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Method objects are used for bound instance methods returned by instancename.methodname.</span></span><br><span class="line"><span class="comment">   ClassName.methodname returns an ordinary function. */</span></span><br><span class="line"><span class="function">PyObject * <span class="title">PyMethod_New</span><span class="params">(PyObject *func, PyObject *self)</span></span></span><br></pre></td></tr></table></figure>

<p>绑定方法对象还有个 <code>__call__</code> 方法，用于处理真正的调用过程。这个方法会调用 <code>__func__</code> 属性引用的原始函数，把函数的第一个参数设为绑定方法的 <code>__self__</code> 属性。这就是<strong>形参 self 的隐式绑定过程</strong>。</p>
<h3 id="使用描述符的最佳实践"><a href="#使用描述符的最佳实践" class="headerlink" title="使用描述符的最佳实践"></a>使用描述符的最佳实践</h3><p><strong>使用特性以保持简单</strong>：内置的 property 类创建的是数据描述符，<code>__get__</code> 和 <code>__set__</code> 方法都实现了。特性的 <code>__set__</code> 方法默认抛出 AttributeError: can’t set attribute，因此创建只读属性最简单的方式是使用特性。且由于特性存在 <code>__set__</code> 方法，不会被同名实例属性遮盖。</p>
<p><strong>只读描述符也要实现 <code>__set__</code> 方法</strong>：如果使用描述符类实现只读数据属性，要记住，<code>__get__</code> 和 <code>__set__</code> 方法必须都定义。否则，实例的同名属性会遮盖描述符。只读属性的 <code>__set__</code> 方法只需抛出 AttributeError 异常，并提供合适的错误消息。</p>
<p><strong>非特殊的方法可以被实例属性遮盖</strong>：Python 的方法只实现了 <code>__get__</code> 方法，所以对与方法名同名的属性将会遮盖描述符，也就是说 <code>obj.method = 1</code> 负值后通过实例访问 method 将会得到数字 1，但不影响类或其他实例。然而，特殊方法不受这个问题影响。因为解释器只会在类中查询特殊方法。也就是说 <code>repr(x)</code> 执行的其实是 <code>x.__class__.__repr__(x)</code>，因此 x 的 <code>__repr__</code> 属性对 <code>repr(x)</code> 方法调用没有影响。出于同样的原因，实例的 <code>__getattr__</code> 属性不会破坏常规的属性访问规则。</p>
<p><strong>用于验证的描述符可以只实现 <code>__set__</code> 方法</strong>：对仅用于验证的描述符来说，<code>__set__</code> 方法应该检查 value 参数是否有效，如果有效，使用与描述符实例同名的名称作为键，直接在实例字典中设值，如 Quantity 中的 <code>instance.__dict__[self.attribute] = value</code> 语句。这样，从实例字典中读取同名属性就不需要经过 <code>__get__</code> 方法处理。</p>
<p><strong>仅有 <code>__get__</code> 方法的描述符可以实现高效缓存</strong>：如果仅实现了 <code>__get__</code> 方法，那么创建的是非数据描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例字典中获取值，而不会再出发描述符的 <code>__get__</code> 方法。</p>
<h3 id="描述符应用场景"><a href="#描述符应用场景" class="headerlink" title="描述符应用场景"></a>描述符应用场景</h3><p>当将描述符逻辑抽象到单独的代码单元中，如 Quantity 类中，就可以在整个应用中进行重用。在一些框架中，会将描述符定义在单独的工具模块中，比如 Django 框架中与数据库交互的模型字段类，就是描述符类。你会发现下面这段 Django 的测试用例的代码与我们定义的 LineItem 非常类似。只不过我们的描述符类 Quantity 换成了他们的 models.CharFiled 等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    books = models.ManyToManyField(Book)</span><br><span class="line">    person = models.OneToOneField(<span class="string">&#x27;Person&#x27;</span>, models.CASCADE, null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>当然，目前定义的描述符类还有提升的空间，比如 <code>price = Quantity(&#39;price&#39;)</code> 使用字符串对属性名进行初始化可能并不那么可靠。又比如想为字段设置更多限定，比如 Django 中设置的字段 max_length 等。其实，Django 框架使用到了 Python 更高阶的类元编程的特性 —— 元类。除了开放框架，一般用不到这个特性。后面我们会对元类加以介绍。</p>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 环境准备</title>
    <url>/2021/01/18/Python-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h2 id="Python-版本"><a href="#Python-版本" class="headerlink" title="Python 版本"></a>Python 版本</h2><p>目前 Python 主要活跃的有 Python 2.x 和 Python 3.x 两个大版本，与 C++ 和 Java 这种向后兼容的语言不同，Python 的两个版本互不兼容。舍弃兼容性是一种设计上的取舍，在我看来 Python 这种尤为注重“简约”的语言，敢于大胆摒弃一些有设计缺陷的旧包袱，从而拥抱新特性的作风，未尝不是一种 Pythonic 的体现，很大程度上避免了走向像 C++ 一样越来越臃肿晦涩的道路。</p>
<p>Python 核心团队已于 2019 年正式宣布将在 2020 年停止对 Python2 的更新，在此期间会对 Python2 版本进行一些 bug 修复、安全增强以及移植等工作，以便使开发者顺利的从 Python2 迁移到 Python3。Python 2.7 是 2.x 系列的最后一个版本，官网上最新的 Python 2.7.18 版本发布于 2020 年 4 月 20 日。官方停止 Python2 更新的主要动机是想进行 Python3 的推广，以及同时维护两个版本给他们带来的工作负担。目前大部分 Python 开源项目已经兼容 Python3 了，所以<strong>强烈建议使用 Python3 来开发新的项目</strong>。</p>
<p>一般较新的 Linux 发行版已经预装了 Python2 和 Python3，如果没有，也可以通过各自的包管理器进行安装和更新。Mac OS 环境下可以通过 Homebrew 工具来安装 Python，可以附加 <code>@ + 版本号</code> 安装指定版本。在一般情况下（不手动修改软链接），命令行中的 <code>python</code> 通常是 python 2.7 或其旧版本的别名，<code>python3</code> 才指代 Python3 版本，可以通过 <code>--version</code> 参数来查看安装的具体版本。由于两个版本互不兼容，在命令行运行 Python 脚本前需要先确定其所用的 Python 版本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ brew install python  <span class="comment"># brew install python@2.7</span></span><br><span class="line">➜ python --version </span><br><span class="line">Python 2.7.10</span><br><span class="line"></span><br><span class="line">➜ brew install python3  <span class="comment"># brew install python@3.8</span></span><br><span class="line">➜ python3 --version</span><br><span class="line">Python 3.8.6</span><br></pre></td></tr></table></figure>

<p>有时也需要在代码中，也就是<strong>运行时确定 Python 版本</strong>，此时用到的是内置的 sys 模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(sys.version)</span><br><span class="line"><span class="number">3.8</span><span class="number">.6</span> (default, Oct  <span class="number">8</span> <span class="number">2020</span>, <span class="number">14</span>:07:<span class="number">53</span>) </span><br><span class="line">[Clang <span class="number">11.0</span><span class="number">.0</span> (clang-<span class="number">1100.0</span><span class="number">.33</span><span class="number">.17</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(sys.version_info)</span><br><span class="line">sys.version_info(major=<span class="number">3</span>, minor=<span class="number">8</span>, micro=<span class="number">6</span>, releaselevel=<span class="string">&#x27;final&#x27;</span>, serial=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>可以通过在运行时判断 Python 版本从而达到较好的兼容性，这在 Python 的内置模块以及标准库中使用较多。由于 <code>version_info</code> 本身是个 tuple 类型，重载了比较运算符，所以可以像下面这样直接进行比较：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># builtins.pyi</span></span><br><span class="line"><span class="keyword">if</span> sys.version_info &gt;= (<span class="number">3</span>, <span class="number">9</span>):</span><br><span class="line">    <span class="keyword">from</span> types <span class="keyword">import</span> GenericAlias</span><br><span class="line"></span><br><span class="line"><span class="comment"># contextlib2.py</span></span><br><span class="line"><span class="keyword">if</span> sys.version_info[:<span class="number">2</span>] &gt;= (<span class="number">3</span>, <span class="number">4</span>):</span><br><span class="line">    _abc_ABC = abc.ABC</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    _abc_ABC = abc.ABCMeta(<span class="string">&#x27;ABC&#x27;</span>, (<span class="built_in">object</span>,), &#123;<span class="string">&#x27;__slots__&#x27;</span>: ()&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的源码来自于两个不同的文件，阅读源码可以发现一些 Python 版本变更的内容。比如自 Python 3.9 引入的 GenericAlias 类型；Python 3.4 之前继承抽象类时还得使用 ABCMeta 形式。</p>
<p>一般情况下，除非你开发的是供他人使用的第三方库，并不需要你在运行时显式判断版本。一方面是版本对于你是可控的，另一方面是如果滥用版本判断会降低代码的整洁性。如果不得不这么做，可以像内置模块 builtins.pyi 一样在存根文件中统一进行处理。</p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><blockquote>
<p><strong>pip</strong> - The Python Package Installer. You can use pip to install packages from the Python Package Index (PyPI) and other indexes.</p>
</blockquote>
<p><a href="https://pip.pypa.io/en/stable/">pip</a> 是 Python 的包安装和管理工具，类似于 npm 之于 JavaScript。Python 3.x 以上的发行版本中都是自带 pip 的。在使用之前先确定 pip 的版本，Python3 中的 pip 是 pip3 的别名，但如果安装了 Python2 的 pip，那么在为 Python3 项目安装依赖时请使用 pip3 命令，因为这两个命令会将依赖安装在不同的目录下。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ pip --version</span><br><span class="line">pip 20.3.3 from /usr/<span class="built_in">local</span>/lib/python3.8/site-packages/pip (python 3.8)</span><br></pre></td></tr></table></figure>

<p>常见的 pip 命令使用可以查阅官方文档，或者 <code>pip -h</code> 查阅帮助文档。与 JavaScript 的 package.json 一样，Python 也提供了统一管理依赖的配置文件 <strong>requirements.txt</strong>。文件中可以指定依赖的版本号，如果缺省则默认安装最新依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">####### example-requirements.txt #######</span><br><span class="line">beautifulsoup4              # Requirements without Version Specifiers</span><br><span class="line">docopt == 0.6.1             # Version Matching. Must be version 0.6.1</span><br><span class="line">keyring &gt;= 4.1.1            # Minimum version 4.1.1</span><br><span class="line">coverage != 3.5             # Version Exclusion. Anything except version 3.5</span><br><span class="line">Mopidy-Dirble ~= 1.1        # Compatible release. Same as &gt;= 1.1, == 1.*</span><br></pre></td></tr></table></figure>

<p>使用 <code>-r</code> 参数指定通过 requirements.txt 文件安装依赖：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>有时我们需要进行项目迁移，比如将本地项目部署至服务器，为了保证重新安装依赖时不影响项目的正常运行，可以使用 freeze 指令将所需的依赖和具体版本号写入 requirements.txt 文件中，再一次性安装所有依赖。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ pip freeze &gt; requirements.txt</span><br><span class="line">➜ cat requirements.txt </span><br><span class="line">certifi==2020.11.8</span><br><span class="line">matplotlib==3.3.2</span><br><span class="line">numpy==1.19.4</span><br><span class="line">six==1.15.0</span><br></pre></td></tr></table></figure>

<h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>在 JavaScript 中，使用 npm 安装依赖会在当前目录下生成一个 node_modules 文件夹，依赖会被安装在这个文件夹中。除非指定 <code>-g</code> 或 <code>--global</code> 参数，将会在全局环境中安装依赖，在 Mac OS 或 Linux 系统中一般会被安装到 <code>/usr/local/lib/node_modules</code> 目录下。这样做的好处是将全局环境与局部环境隔离，避免依赖冲突，尤其是两个项目依赖同一个库的不同版本时。</p>
<p>Python 中也有类似的问题，《Effective Python – 编写高质量Python代码的59个有效方法》一书中的协作开发章节就提到：<strong>使用虚拟环境隔离项目</strong>。问题在于，通过 pip 命令安装的依赖是全局性的，这意味着这些安装好的模块可能会影响系统内的所有 Python 程序。全局依赖会被安装在特定 Python 版本的目录下，如 <code>/usr/local/lib/python3.8/site-packages</code>，对于使用 Python 3.8 的所有项目来说依赖是共享的。</p>
<p>为此，Python 提供了一种解决方案，类似于 JavaScript 的局部环境，隔离出一个单独的 Python 局部环境，这种方案的典型就是 venv。</p>
<h3 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h3><blockquote>
<p><strong>venv</strong> (for Python 3) and <strong>virtualenv</strong> (for Python 2) allow you to manage separate package installations for different projects. If you are using Python 3.3 or newer, the venv module is the preferred way to create and manage virtual environments. venv is included in the Python standard library and requires no additional installation.</p>
</blockquote>
<p>从 Python 2.7 开始，Python 社区开发了一些较底层的创建<strong>虚拟环境</strong>（virtual environment）的工具，在 Python 2.7 中这个工具叫做 virtualenv，这是一个三方工具，需要使用 pip 安装。而《Effective Python》一书中提到的工具 pyvenv 是 Python 3.3 所引入的，但由于一些缺陷在 Python 3.6 中已被弃用。取而代之的是 Python 3.5 引入的内置模块 venv，可以通过 <code>python3 -m venv</code> 使用这个命令。</p>
<p><a href="https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#creating-a-virtual-environment">官方文档</a>中已经明确给出建议，如果使用的是 Python 3.3 及以后的版本，更加推荐使用 venv 去管理你的虚拟环境。下面我们扼要的介绍一下 venv 命令的使用方式。</p>
<p>首先创建一个空项目 myproject，在该目录下执行 <code>python3 -m venv venv</code> 命令，第二个 venv 是创建的虚拟环境的文件夹名，系统中的环境会被拷贝到该目录下，包括 bin 中的 pip 和 python 命令，而 pip 安装的依赖会存放在 lib 目录中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ mkdir myproject; <span class="built_in">cd</span> myproject</span><br><span class="line">➜ python3 -m venv venv</span><br><span class="line">➜ ls -F</span><br><span class="line">venv/</span><br><span class="line">➜ ls -F venv</span><br><span class="line">bin/        include/    lib/        pyvenv.cfg</span><br></pre></td></tr></table></figure>

<p>为了启用这套虚拟环境需要先运行<strong>激活</strong>脚本，启用后会发现命令行多了 <code>(venv)</code>  前缀，这明确的提示了开发者现在处于虚拟环境中。默认情况下虚拟环境只安装了 pip 和 setuptools 两个初始依赖，此时的环境已经独立于全局环境，全局依赖不会影响到此项目。pip 和 python3 命令都指向虚拟环境 bin 目录下的命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ <span class="built_in">source</span> venv/bin/activate</span><br><span class="line">(venv) ➜ pip list    </span><br><span class="line">Package    Version</span><br><span class="line">---------- -------</span><br><span class="line">pip        20.2.1</span><br><span class="line">setuptools 49.2.1</span><br><span class="line">(venv) ➜ <span class="built_in">which</span> python3</span><br><span class="line">/Users/s1mple/Downloads/myproject/venv/bin/python3</span><br><span class="line">(venv) ➜ python3 --version</span><br><span class="line">Python 3.8.6</span><br></pre></td></tr></table></figure>

<p>退出虚拟环境时使用 <code>deactivate</code> 命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(venv) ➜ deactivate</span><br><span class="line">➜ <span class="built_in">which</span> python3</span><br><span class="line">/usr/<span class="built_in">local</span>/bin/python3</span><br></pre></td></tr></table></figure>

<p>为了代替手动的在命令行创建虚拟环境，PyCharm 集成了 virtualenv 工具，并且官方文档已经标明：Python 3.3 版本之前使用第三方的 virtualenv 工具，Python 3.3 之后使用内置的 venv 模块。在新建项目时可以选择 New Virtualenv Environment 自动创建虚拟环境。</p>
<p>有了虚拟环境，我们就可以使用 <code>pip freeze</code> 命令和 requirements.txt 文件很方便的重现一套环境。此外，在使用 venv 时，应当尽量避免移动环境目录，包括重命名项目名称，因为所有的路径（包括 python3 命令所指向的路径），都以硬编码的形式写在了安装目录中，更改目录路径将导致环境失效。解决办法是修改 <code>bin/active</code> 脚本中的 VIRTUAL_ENV 路径值，并重新激活。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># active</span></span><br><span class="line">VIRTUAL_ENV=<span class="string">&quot;/Users/s1mple/Downloads/myproject/venv&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p>如果你觉得 pip + venv 的方式太过底层，也可以使用 Anaconda。Anaconda 是一个更高层次的包管理器和环境管理器，它依托于 conda 之上开发的，conda 可以理解为整合了 pip 和 venv 的功能，区别在于 conda 是跨平台和不限语言的（支持 R 语言）。PyCharm 也对 conda 提供了支持，可以直接通过 conda 创建虚拟环境。</p>
<p>Anaconda 的下载文件较大（500MB），不仅自带 Python 还附带了许多常用数据科学包，已经成为了数据科学方向百宝箱式的存在。Anaconda 也提供可视化界面。总的来说，对于不太熟悉底层操作的数据分析师来说，Anaconda 易于上手体验友好。但对于软件开发来说，Anaconda 显得过于臃肿，这也是我不选择使用它的原因。现如今的 Python 环境支持官方库已经做的很好，如果不是做数据科学方向的，建议使用原生的 pip + venv。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#creating-a-virtual-environment">官方文档 Installing packages using pip and virtual environments</a></li>
<li><a href="https://docs.python.org/3/library/venv.html">官方文档 venv — Creation of virtual environments</a></li>
<li><a href="https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe">What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc?</a></li>
</ul>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 编码规范</title>
    <url>/2021/01/02/Python-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<blockquote>
<p>PEP，全称 Python Enhancement Proposals，译为 Python 增强提案。PEP 已经成为 Python 发布新特性的主要机制，它会收集社区对 Python 的改进意见，经过核心开发者的审查和认可最终形成提案向公众公示。<a href="https://www.python.org/dev/peps/">PEP 的官网首页</a> 也是 PEP 0 的地址，在这里官方列举了所有的 PEP 的索引，你可以按序号、标题和类型进行检索。</p>
</blockquote>
<h2 id="Python-之禅"><a href="#Python-之禅" class="headerlink" title="Python 之禅"></a>Python 之禅</h2><p>Python 开发者喜欢用 “Pythonic” 这个单词来形容符合 Python 编码风格的代码。这种风格既不是严格的规范也不是编译器强加给开发者的规则，而是大家在使用 Python 语言协同工作的过程中逐渐形成的习惯。要记住：<strong>Python 开发者不喜欢复杂的事物，他们崇尚直观、简洁而又易读的代码</strong>。为此，Python 语言的早期贡献者 Tim Peters 提出了 <a href="https://www.python.org/dev/peps/pep-0020/">PEP 20 – The Zen of Python</a>，译为 Python 之禅，提出了共计 19 条 Python 编码的指导性原则。这已经作为一个彩蛋加入到 Python 标准库中，你可以在 Python 交互式命令行中敲入 <code>import this</code> 查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&#x27;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&#x27;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&#x27;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&#x27;s do more of those!</span><br></pre></td></tr></table></figure>

<p>这 19 条指导思想强调了代码简约可读的重要性，其中的大多数条目不仅仅适用于 Python，也适用于任何一门其他语言。</p>
<h2 id="Python-风格指导"><a href="#Python-风格指导" class="headerlink" title="Python 风格指导"></a>Python 风格指导</h2><p>除此之外，<a href="https://www.python.org/dev/peps/pep-0008/">PEP 8 – Style Guide for Python Code</a> 也是每个 Python 程序员应当阅读的，相较于 Python 之禅它提出了更为细致的建议，目的是让 Python 程序员遵循一致的编码风格。PEP 8 中的大部分都能在 Pycharm IDE 中找到智能提示，缩进、空格与空行也可以通过代码格式化快捷键（Reformat Code）来一键规范化，在 Mac OS 中默认快捷键为 <code>Cmd + Alt + L</code>，Windows 中为 <code>Ctrl + Alt + L</code>。如果你不使用 PyCharm，也可以安装 Pylint，这是一款 Python 源码静态分析工具，可以自动检测代码是否符合 PEP 8 风格指南。</p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>这里，我想强调一下 Python 中的命名规范。PEP 8 提倡采用不用的命名风格来区分 Python 语言中的不同角色：</p>
<ul>
<li>文件名（模块名）使用小写字母，单词间以下划线连接，如 <code>base_futures.py</code>；私有模块使用单个下划线开头，如 <code>_collections_abc.py</code>；</li>
<li>函数、变量及属性名，使用小写字母，单词间以下划线连接，如 <code>dict_keys</code>；</li>
<li>受保护的属性和函数（子类可以访问），使用单个下划线开头，如 <code>_protected_method</code>；</li>
<li>私有的属性和函数（子类也不能访问），使用两个下划线开头，如 <code>__private_method</code>；</li>
<li>类与异常，以每个单词首字母大写来命名，如 <code>BaseHandler</code>、<code>TypeError</code>；</li>
<li>模块级别的常量，全部用大写字母，单词间以下划线连接，如 <code>STDIN_FILENO</code>；</li>
<li>类中的实例方法（instance method），首个参数命名为 <code>self</code> 表示对象自身；类方法（class method），首个参数命名为 <code>cls</code> 表示类自身。</li>
</ul>
<p>有几点需要说明的是，Python 中<strong>下划线前缀仅仅是个约定</strong>，由于 Python 没有 public、protected、private 等访问权限控制关键字，只能以有没有下划线开头这种约定俗成的规范告诉程序员这个变量或函数的范围，注意这并不是强制约束。即使函数以下划线开头，在导入模块后仍能够通过 dot 运算符直接访问。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> another</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another.external_func()</span><br><span class="line">This <span class="keyword">is</span> a external_func.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another._internal_func()</span><br><span class="line">This <span class="keyword">is</span> a _internal_func.</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，如果通过 * 通配符导入的模块，单下划线以及双下划线开头的函数和属性并不会被导入到当前模块中，除非导入模块显式定义了包含这些函数和属性的 <code>__all__</code> 列表（但通常不会这么做）。此外，也不建议通过通配符导入模块，应当按照最小导入原则，显式的导入需要用到的函数和属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> another <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>external_func()</span><br><span class="line">This <span class="keyword">is</span> a external_func.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_internal_func()</span><br><span class="line">NameError: name <span class="string">&#x27;_internal_func&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<p>在命名时，尤其要<strong>避免以双下划线开头且结尾的命名格式</strong>，如 <code>__foo__</code>，这是 Python 内置的魔法方法（magic methods，或称特殊方法，如 <code>__init__</code>），以及内置属性（如 <code>__code__</code>）的命名方式。因为你不能保证在后续版本中 Python 不会将 <code>__foo__</code> 作为内置方法或属性。</p>
<p>如果你阅读 Python 标准库源码，会发现基本上私有命名都是以单下划线开头，不论是私有函数还是私有类或是私有变量和常量，很少会看到以双下划线开头的。PEP 8 也提倡对于<strong>非公有方法和属性使用单个下划线开头</strong>，只有在避免子类命名冲突时才采用双下划线开头（且不以双下划线结尾），这是由于双下划线前缀会导致 Python 解释器改写属性名称（name mangling）。比如下面代码中的 <code>__v3</code> 就被改写为 <code>_Foo__v3</code> 类名 + 变量名的格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    v1 = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    _v2 = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    __v3 = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    __v4_ = <span class="number">4</span> </span><br><span class="line"><span class="meta">... </span>    __v5__ = <span class="number">5</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[_ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">dir</span>(Foo) <span class="keyword">if</span> <span class="string">&#x27;v&#x27;</span> <span class="keyword">in</span> _]</span><br><span class="line">[<span class="string">&#x27;_Foo__v3&#x27;</span>, <span class="string">&#x27;_Foo__v4_&#x27;</span>, <span class="string">&#x27;__v5__&#x27;</span>, <span class="string">&#x27;_v2&#x27;</span>, <span class="string">&#x27;v1&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>上面代码使用一个<strong>单独的下划线</strong> <code>_</code> 作为循环中的变量名称，代表这个变量是临时的，名称无关紧要，你可以将其理解为<strong>占位符</strong>。</p>
<p>PEP 8 还提到，对于与 Python 保留关键字命名冲突的公有属性，可以采用<strong>单个下划线结尾</strong>的命名格式，这要优于使用缩略格式。比如下面的 <code>class_</code> 变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tkinter.Toplevel(master, class_=<span class="string">&#x27;ClassName&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>另外，Python 在维持语义清晰的原则上为了保证简洁性，一些<strong>简短的介词和连词间会省略下划线</strong>，并没有严格的按照单词间下划线连接，而是直接拼接，比如 <code>isinstance</code>、<code>__setattr__</code> 和 <code>getstate</code>。</p>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 运算符重载</title>
    <url>/2021/03/18/Python-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>运算符重载这个语言特性其实一直备受争议，鉴于太多 C++ 程序员滥用这个特性，Java 之父 James Gosling 很干脆的决定不为 Java 提供运算符重载功能。但另一方面，正确的使用运算符重载确实能提高代码的可读性和灵活性。为此，Python 施加了一些限制，在灵活性、可用性和安全性之间做到了平衡。主要包括：</p>
<ul>
<li>不能重载内置类型的运算符</li>
<li>不能新建运算符，只能重载现有的</li>
<li>is、and、or 和 not 运算符不能重载（但位运算符 &amp;、| 和 ~ 可以）</li>
</ul>
<p>Python 的运算符重载非常方便，只需要<strong>重写对应的特殊方法</strong>。在上面一节我们已经介绍了如何重载一个向量类的 “+” 和 “==” 运算符，实现还算简单，接下来我们考虑一个更复杂的情形：不只限于二维向量相加的 Vector 类，以引入 Python 运算符重载更全面的知识点。</p>
<h3 id="改进版的-Vector"><a href="#改进版的-Vector" class="headerlink" title="改进版的 Vector"></a>改进版的 Vector</h3><p>考虑到高维向量的应用场景，我们应当支持不同维度向量的相加操作，并且为低维向量的缺失值做默认添 0 处理，这也是一些统计分析应用的常用缺失值处理方式。基于此，首先要确定的便是，Vector 类的构造函数不再只接收固定数量和位置的参数，而应当接收可变参数。</p>
<p>通常情况下，Python 函数接收可变参数有两种处理方式。一种是接收不定长参数，即 <code>*args</code>，这样我们就可以用类似 <code>Vector(1, 2)</code> 或 <code>Vector(1, 2, 3)</code> 的方式来初始化不同维数的向量类。在这种情况下，函数会将不定长参数打包成名为 <code>args</code> 的元组进行处理，当然能满足迭代的需求。虽然这种方式看上去很直观，但考虑到向量类从功能上讲也是一个序列类，而 Python 中的内置序列类型的构造方法基本上都是接收<strong>可迭代对象</strong>（Iterable）作为参数，考虑到一致性我们也采取这种形式，并且通过重写 <code>__repr__</code> 输出更直观的向量类的数学表示形式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, components: Iterable</span>):</span></span><br><span class="line">        self._components = array(<span class="string">&#x27;i&#x27;</span>, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self._components))</span><br></pre></td></tr></table></figure>

<p>为了方便之后对向量分量的处理，将其保存在一个数组中，第一个参数 ‘i’ 标明这是一个整型数组。这样做还有一个好处就是，保证了向量序列的不可变性，这一点同 Python 内置类型不可变列表 tuple 类似。如此定义后，我们可以这样实例化 Vector 类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector(<span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>由于 Vector 类接收 Iterable 对象作为构造参数，而任何实现了 <code>__iter__</code> 方法的类都会被绑定为 Iterable 的子类，所以可以传入 list、tuple 和 range 等可迭代对象。</p>
<p>接下来，重载 Vector 类的加号运算符，为了满足之前所说的低维向量默认添 0 处理，我们引入迭代工具包下的 <code>zip_longest</code> 方法，它可以接收多个可迭代对象，将其打包成一个个的元组，如 <code>zip_longest(p, q, ...) --&gt; (p[0], q[0]), (p[1], q[1]), ...</code>。同时关键字参数 fillvalue 可以指定填充的默认值。但在这之前，由于 <code>zip_longest</code> 参数必须是可迭代对象，我们还需要为 Vector 类实现 <code>__iter__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br></pre></td></tr></table></figure>

<p><code>__add__</code> 的实现逻辑很简单，按位相加返回一个新的 Vector 对象，在构造 Vector 对象时使用到了生成器表达式，而生成器 Generator 是 Iterable 的子类，所以也符合构造参数的要求。</p>
<p>为了验证效果，还需要重载 <code>==</code> 运算符，考虑到两个向量维度可能不同，首先要对维度，也就是向量分量的个数进行比较，为此需要重写 <code>__len__</code> 方法。其次是进行按位比较，内置的 zip 函数可以将两个迭代对象打包从而同时进行遍历。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self) == <span class="built_in">len</span>(other) <span class="keyword">and</span> <span class="built_in">all</span>(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(self, other))</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践：用 zip 函数同时遍历两个迭代器</strong>。《Effective Python》的第 11 条提到了这一点。在 Python 中经常会遇到需要平行地迭代两个序列的情况。一般的做法是，写一个 for 循环对一个序列进行迭代，然后想办法获得其索引，通过索引访问第二个序列的对应元素。常见的做法是借助 enumerate 函数，通过 <code>for index, item in enumerate(items)</code> 的方式获取索引。现在有一种更优雅的写法，使用内置的 zip 函数，它可以将两个及以上的迭代器封装成生成器，这个生成器能在每次迭代时从每个迭代器中取出下一个值构成元组，再结合元组拆包就能达到平行取值的目的，如上述代码中的 <code>for a, b in zip(self, other)</code>。显然，这种方式可读性更高。但如果待遍历序列不等长，zip 函数会提前终止，这可能导致意外的结果。所以在<strong>不确定序列是否等长</strong>的条件下，可以考虑使用 itertools 模块中过的 <code>zip_longest</code> 函数。</p>
<p>至此，重载的 “+” 和 “==” 运算符初步完成了，可以编写测试用例进行验证了，作为本系列第一个比较全面的测试类，我将在文末贴出完整的测试代码，这里先在控制台演示重载之后的效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + Vector((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>由于 <code>__add__</code> 方法中的 other 只要求是可迭代对象而没有类型限制，所以重载的加号运算符不止可以对两个 Vector 实例进行相加，也支持 Vector 实例与一个可迭代对象相加，不管是 list、tuple 还是其他 Iterable 类型。但需要注意的是，可迭代对象必须作为第二个操作数，也就是 “+” 右侧的操作数。理解这一点并不难，因为我们只实现了 Vector 的 <code>__add__</code> 方法，而 Python 的内置类型类可不明白怎么对加上一个向量进行处理，比如下面报错提示的 tuple 类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">1</span>) + v1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate <span class="built_in">tuple</span> (<span class="keyword">not</span> <span class="string">&quot;Vector&quot;</span>) to <span class="built_in">tuple</span></span><br></pre></td></tr></table></figure>

<h4 id="反向运算符"><a href="#反向运算符" class="headerlink" title="反向运算符"></a>反向运算符</h4><p>那么有什么方法，不需要重写 tuple 类中的 <code>__add__</code> 方法（显然这种方式也不合理），也能使重载的加号运算符支持 <code>(1, 1) + v1</code> 呢？答案是有的，在此之前，不得不提到 Python 的<strong>运算符分派机制</strong>。</p>
<p>对于中缀运算符，Python 提供了特殊的分派机制。对于表达式 <code>a + b</code>，解释器会执行以下几步操作：</p>
<ol>
<li>如果 a 有 <code>__add__</code> 方法且不返回 NotImplemented，调用 <code>a.__add__(b)</code>；</li>
<li>如果 a 没有 <code>__add__</code> 方法或调用返回 NotImplemented，检查 b 有没有 <code>__radd__</code> 方法，如果有且不返回 NotImplemented，调用 <code>b.__radd__(a)</code>；</li>
<li>如果 b 没有 <code>__radd__</code> 方法或调用返回 NotImplemented，抛出 TypeError。</li>
</ol>
<p>注：NotImplemented 是 Python 内置的特殊单例值，如果运算符特殊方法不能处理给定的操作数，那么要把它返回给解释器。</p>
<p>如果将 <code>__add__</code> 称为正向方法，那么 <code>__radd__</code> 就可以称为 <code>__add__</code> 方法的<strong>反向方法</strong>，或者右向方法，这个方法的作用是支持操作数从右至左进行计算。因此，为了支持 <code>(1, 1) + v1</code>，我们需要定义 Vector 类的反向方法。而反向方法只需要委托给已经定义好的 <code>__add__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self + other</span><br></pre></td></tr></table></figure>

<p><code>__radd__</code> 通常就是这么简单，由于解释器调用的是 <code>b.__radd__(a)</code>，而这里的 b 即 v1 是一个 Vector 实例，能够与一个元组相加，所以这时 <code>(1, 1) + v1</code> 不会再报错。同时，还对 <code>__add__</code> 方法做了些修改：<strong>捕获 TypeError 异常并返回 NotImplemented</strong>。这也是一种重载中缀运算符时的最佳实践，抛出异常将导致算符分派机制终止，而抛出 NotImplemented 则会让解释器再尝试调用反向运算符方法。当运算符左右操作数是不同类型时，反向方法也许能够正常运算。</p>
<p>现在，验证重载的反向运算符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">1</span>) + v1</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] + v1</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>对于比较运算符，正向和反向调用使用的是同一系列方法，只不过对调了参数。注意是同一系列而不是同一方法。例如，对 “==” 来说，正向调用是 <code>a.__eq__(b)</code>，那么反向调用就是 <code>b.__eq__(a)</code>；而对 “&gt;” 来说，正向 <code>a.__gt__(b)</code> 的反向调用是 <code>b.__lt__(a)</code>。</p>
<p>如果正向调用左操作数的 <code>__eq__</code> 方法返回 NotImplemented，Python 解释器会去尝试反向调用右操作数的 <code>__eq__</code> 方法，若右操作数也返回 NotImplemented，解释器不会抛出 TypeError 异常，而是会比较对象的 ID 作最后一搏。</p>
<p>对元组和 Vector 实例比较的具体步骤如下：</p>
<ol>
<li>尝试调用 tuple 的 <code>__eq__</code> 方法，由于 tuple 不认识 Vector 类，返回 NotImplemented；</li>
<li>尝试调用 Vector 的 <code>__eq__</code> 方法，返回 True。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">2</span>) == Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>另外，对于 “!=” 运算符，Python 3 的最佳实践是只实现 <code>__eq__</code> 方法而不实现它，因为从 object 继承来的 <code>__ne__</code> 方法会对 <code>__eq__</code> 返回的结果取反。而 Python 2 则不同，重载 “==” 的同时也应重载 “!=” 运算符。Python 之父 Guido 曾提到这是 Python 2 的一个设计缺陷且已在 Python 3 中修复了。</p>
<h4 id="就地运算符"><a href="#就地运算符" class="headerlink" title="就地运算符"></a>就地运算符</h4><p>增量赋值运算符，也称就地运算符，如 “+=”，有两种运算方式。对于不可变类型来说，<code>a += b</code> 的作用与 <code>a = a + b</code> 完全一致，增量赋值不会修改不可变目标，而是<strong>新建实例</strong>，然后重新绑定，也就是说运算前后的 a 不是同一对象。对于不可变类型，这是预期的行为。</p>
<p>而对于实现了就地运算符方法，如 <code>__iadd__</code>，的可变类型来说，<code>a += b</code> 会调用该方法就地修改左操作数，而不是创建一个新的对象。这一点，Python 的内置类型，不可变的 tuple 和可变的 list 就可以很好的说明。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4359598592</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t += (<span class="number">3</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">4359584960</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4360054336</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4360054336</span></span><br></pre></td></tr></table></figure>

<p>阅读源码你会发现，list 类 实现了 <code>__iadd__</code> 方法而 tuple 类没有实现。对 list 而言，”+=” 就地运算符的逻辑与其 <code>extend()</code> 方法相同，将一个可迭代对象的元素依次追加到当前列表的末尾。而对 tuple 而言，即使没有定义 <code>__iadd__</code> 方法，使用 “+=” 也会委托给 <code>__add__</code> 方法进行运算返回一个新的 tuple 对象。</p>
<p>从设计层面考虑，Vector 应当与元组一致，被设计成不可变类型，即每次对向量进行运算后生成一个新的向量。站在函数式编程的角度，这种设计无副作用（不在函数内部修改传入参数状态），从而避免一些难以预料的问题。因此<strong>对于不可变类型，一定不能实现就地特殊方法</strong>。对 Vector 使用 “+=” 运算符会调用现有的 <code>__add__</code> 方法生成一个新的 Vector 实例。<code>v1 += (1, 1)</code> 与 <code>v1 = v1 + (1, 1)</code> 行为一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(v1)</span><br><span class="line"><span class="number">4360163280</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 += (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(v1)</span><br><span class="line"><span class="number">4359691376</span></span><br></pre></td></tr></table></figure>

<h3 id="附录：代码"><a href="#附录：代码" class="headerlink" title="附录：代码"></a>附录：代码</h3><h4 id="vector-py"><a href="#vector-py" class="headerlink" title="vector.py"></a>vector.py</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, components: Iterable</span>):</span></span><br><span class="line">        self._components = array(<span class="string">&#x27;i&#x27;</span>, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self._components))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self) == <span class="built_in">len</span>(other) <span class="keyword">and</span> <span class="built_in">all</span>(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(self, other))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self + other</span><br></pre></td></tr></table></figure>

<h4 id="vector-test-py"><a href="#vector-test-py" class="headerlink" title="vector_test.py"></a>vector_test.py</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestVector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_compare_two_vectors_with_override_compare_operators</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        v2 = Vector((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        v3 = Vector([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">        v4 = Vector([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> v1 == v2</span><br><span class="line">        <span class="keyword">assert</span> v3 != v2</span><br><span class="line">        <span class="keyword">assert</span> v4 != v3</span><br><span class="line">        <span class="keyword">assert</span> (<span class="number">1</span>, <span class="number">2</span>) == v2</span><br><span class="line">        <span class="keyword">assert</span> v2 == [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_add_two_same_dimension_vectors_with_override_add_operator</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        v2 = Vector((<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        result = Vector([<span class="number">2</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> result == v1 + v2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_add_two_different_dimension_vectors_with_override_add_operator</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        v2 = Vector((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        result = Vector([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> result == v1 + v2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_add_vector_and_iterable_with_override_add_operator</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> v1 + (<span class="number">1</span>, <span class="number">1</span>) == (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">assert</span> v1 + [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] == (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_add_iterable_and_vector_with_override_radd_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> (<span class="number">1</span>, <span class="number">1</span>) + v1 == (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] + v1 == (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_should_create_new_vector_when_use_incremental_add_operator</span>(<span class="params">self</span>):</span></span><br><span class="line">        v1 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        id1 = <span class="built_in">id</span>(v1)</span><br><span class="line">        v1 += (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">id</span>(v1) != id1</span><br></pre></td></tr></table></figure>

<h3 id="附录：常见可重载运算符"><a href="#附录：常见可重载运算符" class="headerlink" title="附录：常见可重载运算符"></a>附录：常见可重载运算符</h3><h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">特殊方法</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center"><code>__neg__</code></td>
<td align="left">一元取负算术运算符</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center"><code>__pos__</code></td>
<td align="left">一元取正算术运算符</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center"><code>__invert__</code></td>
<td align="left">对整数按位取反，定义为 ~x == -(x+1)</td>
</tr>
</tbody></table>
<h4 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">正向方法</th>
<th align="center">反向方法</th>
<th align="center">就地方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center"><code>__add__</code></td>
<td align="center"><code>__radd__</code></td>
<td align="center"><code>__iadd__</code></td>
<td align="center">加法或拼接</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"><code>__sub__</code></td>
<td align="center"><code>__rsub__</code></td>
<td align="center"><code>__isub__</code></td>
<td align="center">减法</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center"><code>__mul__</code></td>
<td align="center"><code>__rmul__</code></td>
<td align="center"><code>__imul__</code></td>
<td align="center">乘法或重复复制</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center"><code>__truediv__</code></td>
<td align="center"><code>__rtruediv__</code></td>
<td align="center"><code>__itruediv__</code></td>
<td align="center">除法</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center"><code>__floordiv__</code></td>
<td align="center"><code>__rfloordiv__</code></td>
<td align="center"><code>__ifloordiv__</code></td>
<td align="center">整除</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center"><code>__mod__</code></td>
<td align="center"><code>__rmod__</code></td>
<td align="center"><code>__imod__</code></td>
<td align="center">取模</td>
</tr>
<tr>
<td align="center"><code>divmod()</code></td>
<td align="center"><code>__divmod__</code></td>
<td align="center"><code>__rdivmod__</code></td>
<td align="center"><code>__idivmod__</code></td>
<td align="center">返回由整除的商和模数组成的元组</td>
</tr>
<tr>
<td align="center">**，<code>pow()</code></td>
<td align="center"><code>__pow__</code></td>
<td align="center"><code>__rpow__</code></td>
<td align="center"><code>__ipow__</code></td>
<td align="center">取幂</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center"><code>__matmul__</code></td>
<td align="center"><code>__rmatmul__</code></td>
<td align="center"><code>__imatmul__</code></td>
<td align="center">矩阵乘法</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center"><code>__and__</code></td>
<td align="center"><code>__rand__</code></td>
<td align="center"><code>__iand__</code></td>
<td align="center">按位与</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center"><code>__or__</code></td>
<td align="center"><code>__ror__</code></td>
<td align="center"><code>__ior__</code></td>
<td align="center">按位或</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center"><code>__xor__</code></td>
<td align="center"><code>__rxor__</code></td>
<td align="center"><code>__ixor__</code></td>
<td align="center">按位异或</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center"><code>__lshift__</code></td>
<td align="center"><code>__rlshift__</code></td>
<td align="center"><code>__ilshift__</code></td>
<td align="center">按位左移</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center"><code>__rshift__</code></td>
<td align="center"><code>__rrshift__</code></td>
<td align="center"><code>__irshift__</code></td>
<td align="center">按位右移</td>
</tr>
</tbody></table>
<h4 id="比较运算符-1"><a href="#比较运算符-1" class="headerlink" title="比较运算符"></a>比较运算符</h4><table>
<thead>
<tr>
<th align="center">分组</th>
<th align="center">中缀运算符</th>
<th align="center">正向方法调用</th>
<th align="center">反向方法调用</th>
<th align="center">后备机制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">相等性</td>
<td align="center">a == b</td>
<td align="center"><code>a.__eq__(b)</code></td>
<td align="center"><code>b.__eq__(a)</code></td>
<td align="center">返回 <code>id(a) == id(b)</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a != b</td>
<td align="center"><code>a.__ne__(b)</code></td>
<td align="center"><code>b.__ne__(a)</code></td>
<td align="center">返回 <code>not (a == b)</code></td>
</tr>
<tr>
<td align="center">排序</td>
<td align="center">a &gt; b</td>
<td align="center"><code>a.__gt__(b)</code></td>
<td align="center"><code>b.__lt__(a)</code></td>
<td align="center">抛出 TypeError</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a &lt; b</td>
<td align="center"><code>a.__lt__(b)</code></td>
<td align="center"><code>b.__gt__(a)</code></td>
<td align="center">抛出 TypeError</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a &gt;= b</td>
<td align="center"><code>a.__ge__(b)</code></td>
<td align="center"><code>b.__le__(a)</code></td>
<td align="center">抛出 TypeError</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a &lt;= b</td>
<td align="center"><code>a.__le__(b)</code></td>
<td align="center"><code>b.__ge__(a)</code></td>
<td align="center">抛出 TypeError</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 装饰器与闭包</title>
    <url>/2020/12/20/Python-%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h2><p>虽然《流畅的Python》作者一再强调 Python 不是一门函数式编程语言，但它的的确确具备了一些函数式编程的特性。其中的一个重要特性是：Python 将<strong>函数作为一等公民</strong>。这与 JavaScript、Scala 等语言一样，意味着在这类语言中：<strong>函数与其他数据类型处于同等地位，函数可以定义在函数内部，也可以作为函数的参数和返回值</strong>。基于这个特性，我们可以很容易的定义高阶函数。来看一个 JavaScript 的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数将一个函数作为了返回值，很明显它是一个高阶函数，那么问题来了：这样定义有什么作用或者是好处呢？事实上，这段代码是 JavaScript 中的一个优雅的函数式编程库 <a href="https://ramdajs.com/">Ramda</a> 对于加法实现的基本思路（还需要可变参数以及参数个数判断）。最终我们可以这样去使用它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> R = <span class="built_in">require</span>(<span class="string">&#x27;ramda&#x27;</span>)</span><br><span class="line">R.add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// -&gt; 3</span></span><br><span class="line"><span class="keyword">const</span> increment = R.add(<span class="number">1</span>) <span class="comment">// 返回一个函数</span></span><br><span class="line">increment(<span class="number">2</span>) <span class="comment">// -&gt; 3</span></span><br><span class="line">R.add(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// -&gt; 3</span></span><br></pre></td></tr></table></figure>

<p>既可以像代码第二行一次性传入两个参数，也可以像代码第三、四行分两个阶段传入，这与代码第五行效果一致。我们将这种特性称为<strong>函数柯里化（Currying）</strong>，这样做的好处一是可以<strong>代码重用</strong>，就像特意将 <code>R.add(1)</code> 取名为 increment 一样，它可以单独地作为一个递增函数；二是可以实现<strong>惰性求值</strong>，只有当函数收集到了所有所需参数，才进行真正的计算并返回结果，这一点在许多流处理框架中有广泛使用。</p>
<p>Python 中的函数之所以可以作为一等公民，究其原因，是因为 Python 中的<strong>一切皆是对象</strong>，即 <em>Everything in Python is an object</em>。使用 <code>def</code> 关键字定义的任何函数，都是 <code>function</code> 类的一个实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(func)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">function</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>既然函数是对象，那就可以持有属性，这也是为什么 Python 中函数可以持有外部定义的变量（也就是闭包问题）的根本原因。这一点与 Java 和 C++ 这类语言是有本质区别的。以 Java8 为例，虽然 Java8 提供了一些语法糖让我们得以编写所谓的“高阶函数”，但 Java 中的函数（方法）依然不能脱离类或者对象而存在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .stream()</span><br><span class="line">        .filter(i -&gt; i &gt;= <span class="number">3</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>上述代码第三行接收一个 Lambda 表达式作为参数，第四行接收一个方法引用，看上去函数可以作为参数传入。但实际上，Java 编译器会将它们转换为<strong>函数接口（Functional Interfaces）</strong>的具体实现，函数接口是 Java8 函数式编程引入的核心概念。例如上述代码中的 <code>System.out::println</code> 方法引用会被实例化为 Consumer 函数接口的具体实现，Consumer 是 Java8 提供的四类函数接口中的一类，称为消费者接口，它有一个 accept 抽象方法接受一个输入且返回值为空，编译器将会用 <code>System.out.println(t)</code> 重写这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer consumer = System.out::println;</span></span><br><span class="line"><span class="comment">// consumer.accept(&quot;hello&quot;);</span></span><br></pre></td></tr></table></figure>

<p>所以在 Java8 中，看似函数可以作为参数传入，但实际上传入的依旧是类的实例。如果对 Java8 的函数式编程感兴趣可以参考这篇：<a href="https://s2mple.xyz/2018/11/16/Java8%20%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/">Java8 函数接口</a>。</p>
<p>言归正传，既然已经清楚了 Python 中可以定义高阶函数，那么接下来就可以探讨一下 Python 怎么使用高阶函数实现装饰器的。但在这之前，不得不提及一下什么是闭包。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>首先注意，只有涉及到<strong>嵌套函数</strong>才会存在闭包问题。而不要将闭包与匿名函数搞混，是不是匿名函数不是必要条件，只是人们通常将闭包与匿名函数搭配使用罢了（尤其是在 JavaScript 中）。</p>
<p>实际上，闭包是指<strong>延伸了作用域的函数</strong>，关键在于它<strong>能够访问定义体之外定义的非全局变量</strong>。听上去有些绕，不过看看下面这段代码就很好理解了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_average</span>():</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">average</span>(<span class="params">new_value</span>):</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = <span class="built_in">sum</span>(series)</span><br><span class="line">        <span class="keyword">return</span> total / <span class="built_in">len</span>(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> average</span><br></pre></td></tr></table></figure>

<p>关注点放在 series 这个变量。它定义在内层函数 average 之外并在内层函数中做了修改（末尾追加了一个值）。并且，内层函数被当作外层函数的返回值返回。显然，内层函数 average 设计出来是为了多次调用的，然而 series 是在内层函数之外定义的，当多次调用 average 时 series 作用域是否已经消亡了呢？答案是否。看看下面的输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_average()  <span class="comment"># 返回 average 函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">1</span>)  <span class="comment"># (1) / 1</span></span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">2</span>)  <span class="comment"># (1 + 2) / 2</span></span><br><span class="line"><span class="number">1.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">3</span>)  <span class="comment"># (1 + 2 + 3) / 3</span></span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p>原因在于，上述代码中的 series 变量声明语句与 average 函数定义体构成了一个闭包，average 函数的作用域延伸到函数外部，换句话说，series 已经绑定到 average 函数对象上了。我们将 series 这种变量称为<strong>自由变量</strong>（free variable）。可以通过 Python 提供的内省属性访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class="line">(<span class="string">&#x27;series&#x27;</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x104301400</span>: <span class="built_in">list</span> <span class="built_in">object</span> at <span class="number">0x1041a9580</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><code>__code__.co_freevars</code> 以元组形式存放了自由变量的<strong>名称</strong>。要想访问自由变量的值，需要通过 <code>__closure__</code> 属性，也就是说，实际上 series 是绑定到 <code>avg.__closure__</code> 中的。Python 在自由变量之上包装了一个 cell 对象，用 <code>cell_contents</code> 存放其真正的值。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器，又称函数装饰器，本质上是一个<strong>可调用对象</strong>（实现了 <code>__call__</code> 方法），可以是一个函数或者一个类。它的作用是可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能。装饰器接受一个函数作为参数，即被装饰的函数，可能会对这个函数进行处理然后将它返回，或者替换为另一个函数或可调用对象。</p>
<p>先来看一个最简单的装饰器示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">decorate</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;running decorator...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> func</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@decorate</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">target</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;running target...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">running decorator...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target()</span><br><span class="line">running target...</span><br></pre></td></tr></table></figure>

<p>上述代码定义了一个名为 decorate 的装饰器，然后通过 <code>@decorate</code> 标注在 target 函数上表明用它来装饰 target 函数。乍一看，这与 Java 中的注解语法是一样的，但其实两者作用是完全不同的。Java 中的注解只是元数据，不会对被修饰的对象做任何修改，必须通过运行时的反射（<code>getAnnotation</code> 方法）才能发挥它的作用。而在 Python 中，<strong>装饰器的作用就是定义一个嵌套函数</strong>。你可以理解为，通过装饰器装饰后，target 函数被重新定义为了如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure>

<p>但装饰器与这样直接定义还是有几点区别的。第一点，<strong>装饰器是在被装饰的函数定义之后立即执行的</strong>，这通常是在<strong>导入时</strong>（import），也就是 Python 加载模块时发生的。如果你足够细心，就会发现上述代码中的 <code>&#39;running decorator...&#39;</code> 是在 target 函数定义后就被立即打印了，并且调用 target 函数时也没有重复打印。也就是说，<strong>函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行</strong>。这突出了 Python 的导入时和运行时的区别。</p>
<p>第二点，函数装饰器既然要体现它的“装饰”语义，就需要接收一个函数作为参数然后返回一个函数，无论返回的函数是原封不动的原函数还是“装饰”后的函数。也就是说，<strong>装饰器对于函数调用者是透明的</strong>。那么，装饰器返回一个其他类型就没有意义。事实证明，如果返回了其他类型，代码运行将会报出 TypeError 错误（没有找到 <code>__call__</code> 方法）。而如果只是嵌套函数 <code>decorate(target)</code> 的写法是没有返回类型的限制的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;running decorator...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TypeError: &#x27;int&#x27; object is not callable</span></span><br></pre></td></tr></table></figure>

<h3 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h3><p>事实上，<strong>大多数装饰器会在内部定义一个函数然后将其返回</strong>，原封不动地返回被装饰的函数是没有多大用处的。像这样的双层嵌套函数足以应对绝大多数的装饰器需求了，其最大的好处是：可以<strong>支持带有参数的被装饰函数</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">target</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[INFO]: the function <span class="subst">&#123;func.__name__&#125;</span>() is running...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure>

<p>不管原函数（被装饰函数）func 接收什么类型的参数，在使用 logger 装饰器时都将被打包成定位参数 <code>*args</code> 和仅限关键字参数 <code>**kwargs</code>，原封不动的传入到装饰器的内部函数 target 中，执行完装饰逻辑后通过 <code>func(*args, **kwargs)</code> 执行原函数。从而能够实现“不修改原有函数接口、不影响原有函数执行”的前提下添加额外功能。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@logger</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age=<span class="number">18</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(name, age)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line">[INFO]: the function person() <span class="keyword">is</span> running...</span><br><span class="line">Jack <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>除了被装饰函数可以带有参数外，装饰器本身也可以带有参数，如 <code>@logger(Level.INFO)</code> 在装饰器中指定日志等级，根据业务逻辑标注在不同的函数上，从而最大程度的发挥装饰器的灵活性。</p>
<p>接下来，我会结合一个更实用的例子 —— 记录被装饰函数运行时间的计时器，展示如何定义并使用一个带参装饰器。同时，你还将看到闭包问题是如何在装饰器中体现的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span>(<span class="params">unit=TimeUnit.SECONDS</span>):</span>  <span class="comment"># ①</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span>  <span class="comment"># ②</span></span><br><span class="line">            start = time.perf_counter()</span><br><span class="line">            result = func(*args, **kwargs)  <span class="comment"># ③</span></span><br><span class="line">            end = time.perf_counter()</span><br><span class="line">            arg_str = <span class="string">&#x27;, &#x27;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">            <span class="keyword">if</span> unit == TimeUnit.SECONDS:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;running <span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;arg_str&#125;</span>): <span class="subst">&#123;end - start&#125;</span>s&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;running <span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;arg_str&#125;</span>): <span class="subst">&#123;(end - start) * <span class="number">1000</span>&#125;</span>ms&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure>

<p>带参装饰器比无参装饰器多了一层嵌套，这是一种妥协，原因是<strong>装饰器只能且必须接收一个函数作为参数</strong>，所以为了使装饰器接收其他参数，不得不在之上再包装一层函数。在上述代码的三层函数中，最外层定义的 clock 函数是参数化装饰器<strong>工厂函数</strong>，第二层 decorate 函数才是真正的装饰器，wrapper 函数则是执行装饰逻辑的包裹函数（被装饰函数在其中执行）。</p>
<p>此外代码中用带圈数字标注的几个需要注意的点是：</p>
<ul>
<li>① 最外层的 clock 工厂函数接收一个名为 unit 的时间单位的参数，默认值为秒（这里采用枚举类型）；</li>
<li>② <strong>如果被装饰的函数带参数，只需要把装饰器最内层函数跟被装饰函数的参数列表保持一致即可</strong>。这里 wrapper 函数接收任意个定位参数 <code>*args</code> 和仅限关键字参数 <code>**kwargs</code>，写成这样的目的是想体现 clock 计时器的泛用性，你可以在 ③ 处原封不动地将这些参数传给被装饰函数 func 调用；</li>
<li>③ func 实际上是定义在 wrapper 外层的自由变量（作为 decorate 的参数传入），所以它已经被绑定到 wrapper 的闭包中。</li>
</ul>
<p>③ 处是被装饰函数真正执行的地方，上下两行使用计时器记录并统计了 func 函数运行前后的时间差值，在打印时根据传入 clock 的参数决定打印时间单位采用秒还是毫秒。我们来看看如何使用这个装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@clock()</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">secs</span>):</span></span><br><span class="line"><span class="meta">... </span>    time.sleep(secs)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@clock(unit=TimeUnit.SECONDS)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">sleep_secs</span>(<span class="params">secs</span>):</span></span><br><span class="line"><span class="meta">... </span>    time.sleep(secs)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@clock(unit=TimeUnit.MILL_SECONDS)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">sleep_ms</span>(<span class="params">ms</span>):</span></span><br><span class="line"><span class="meta">... </span>    time.sleep(ms / <span class="number">1000</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sleep(<span class="number">0.1</span>)</span><br><span class="line">running sleep(<span class="number">0.1</span>): <span class="number">0.10221230299998751</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sleep_secs(<span class="number">1</span>)</span><br><span class="line">running sleep_secs(<span class="number">1</span>): <span class="number">1.000441283999976</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sleep_ms(<span class="number">100</span>)</span><br><span class="line">running sleep_ms(<span class="number">100</span>): <span class="number">103.84234799994374</span>ms</span><br></pre></td></tr></table></figure>

<p>需要注意，第一个空参装饰器 <code>@clock()</code>，其中的 <code>()</code> 是不能省略的，它使用了 <code>TimeUnit.SECONDS</code> 作为默认参数，这是在 clock 定义处声明的。此外，clock 装饰器中的参数并不是和函数名绑定的，打印的时间单位完全取决于传入 clock 装饰器的参数。比如，也可以让 sleep_ms 按照秒的格式打印时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@clock(unit=TimeUnit.SECONDS)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">sleep_ms</span>(<span class="params">ms</span>):</span></span><br><span class="line"><span class="meta">... </span>    time.sleep(ms / <span class="number">1000</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sleep_ms(<span class="number">100</span>)</span><br><span class="line">running sleep_ms(<span class="number">100</span>): <span class="number">0.10072612899966771</span>s</span><br></pre></td></tr></table></figure>

<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>前面提到，装饰器本质上是一个可调用对象。到目前为止，给出的示例都是函数类型的装饰器，函数当然是可调用对象。但如果阅读 Python 源码，会发现许多装饰器是用类定义的，比如内置模块中的 property、classmethod 和 staticmethod 类。这些类都可调用对象（callable），对于用户来说，自定义一个类装饰器需要让这个类实现 <code>__call__</code> 方法，这样解释器在运行时会将这个类绑定为 Callable 类的子类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="built_in">property</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="built_in">staticmethod</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span> ...</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(Foo())</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> <span class="type">Callable</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(Foo, <span class="type">Callable</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>对于不含参数的类装饰器来说，除了需要实现 <code>__call__</code> 方法之外，唯一要做的就是在构造函数 <code>__init__</code> 中初始化被装饰函数。下面定义了一个基于类的无参装饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[INFO]: the function <span class="subst">&#123;self._func.__name__&#125;</span>() is running...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._func(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>函数类型的装饰器是将装饰逻辑定义在嵌套函数的内部函数中，而无参类装饰器则是将装饰逻辑定义在类中的 <code>__call__</code> 方法内，类装饰器同样可以装饰带有参数的函数。两者的区别只不过是，定义函数装饰器时被装饰函数 func 作为参数传入，定义类装饰器时 func 作为属性传入。类装饰器同样是以 <code>@ + 类名</code> 的形式标注在被装饰函数上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> class_decorator <span class="keyword">import</span> Logger</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@Logger</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age=<span class="number">18</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(name, age)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line">[INFO]: the function person() <span class="keyword">is</span> running...</span><br><span class="line">Jack <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>定义类形式的装饰器与函数形式的装饰器并无太大差别，本质上 Python 解释器都将它们作为可调用对象进行处理。只不过现在最外层的装饰器工厂函数变成了类，传入的装饰器的参数变成了类的属性；而第二层对应的是 <code>__call__</code> 方法，接收被装饰函数作为参数；<code>__call__</code> 方法内还需定义执行装饰逻辑的包裹函数。用类改写的日志装饰器的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, level=<span class="string">&#x27;INFO&#x27;</span></span>):</span></span><br><span class="line">        self._level = level</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;self._level&#125;</span>]: the function <span class="subst">&#123;func.__name__&#125;</span>() is running...&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>使用时可以指定日志的输出级别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@Logger(<span class="string">&#x27;Debug&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age=<span class="number">18</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(name, age)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line">[Debug]: the function person() <span class="keyword">is</span> running...</span><br><span class="line">Jack <span class="number">18</span></span><br></pre></td></tr></table></figure>

<h3 id="面向切面的程序设计"><a href="#面向切面的程序设计" class="headerlink" title="面向切面的程序设计"></a>面向切面的程序设计</h3><p>面向切面的程序设计是一种程序设计思想，旨在将横切关注点与业务主体进行分离。<strong>横切关注点</strong>指的是一些具有横越多个模块的行为，使用传统的软件开发方法不能够达到有效的模块化的一类特殊关注点。通俗点说，面向切面编程就是<strong>使得解决特定领域问题的代码从业务逻辑中独立出来</strong>。业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过切面来封装、维护。</p>
<p>联系到本文所编写的几个装饰器，日志记录 logger、性能测试 clock 计时器，这些都是较为常见的<strong>横切关注点</strong>。试想一下，如果需要记录多个函数的运行时间，在这些函数内部硬编码计时代码是否合适？显然，这不仅会造成代码重复，更关键的是破坏了函数的存粹性（将不该属于它的计时功能强加于它），造成了代码的紧耦合。现在有了装饰器，只需要在需要计时的函数之上添加 <code>@clock</code> 标注即可，计时器的逻辑统一在装饰器中定义和维护，实现了与业务代码的解耦。</p>
<p>因此，装饰器非常适用于有切面需求的场景，诸如：插入日志、性能测试、事务处理、缓存、权限校验等。装饰器是解决这类问题的绝佳设计。通过装饰器，我们可以抽离出与函数功能本身无关的代码到装饰器中，从而实现面向切面编程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《流畅的 Python》</li>
<li><a href="https://s2mple.xyz/2018/05/24/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a></li>
<li><a href="http://blog.jenkster.com/2015/12/which-programming-languages-are-functional.html">Which Programming Languages Are Functional?</a></li>
</ul>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 面向对象</title>
    <url>/2021/05/12/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><strong>面向对象程序设计</strong>（Object-oriented programming，缩写 OOP）是指一种程序设计范型，它强调一切行为都是基于<strong>对象</strong>（object）完成的，而对象则指的是<strong>类</strong>（class）的实例。对象被作为程序的基本单元，数据和行为方法封装在其中，以提高软件的重用性、灵活性和扩展性，对象的行为方法可以访问和修改对象的数据。通过对象之间的相互协作，完成复杂的程序功能。面向对象编程语言具备封装、抽象、继承、多态等特性。</p>
<p>封装，又称<strong>信息隐藏</strong>，是指利用抽象数据类型（ADT）将数据和基于数据的操作封装在一起，尽可能地隐藏内部细节，只暴露一些公共接口与外部发生交互。面向对象编程语言使用类进行封装，数据和基于数据的操作对应于类的属性和方法。</p>
<p>具备封装性的面向对象程序设计隐藏了方法的具体执行步骤，取而代之的是对象之间的消息传递。举个例子，假设一个“歌唱家”想要“唱歌”，她当然知道自己该如何发声，但其他人没有必要了解她发声的细节，只管欣赏她美妙的歌喉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 一个面向过程的程序会这样写： */</span><br><span class="line">定义莱丝</span><br><span class="line">莱丝.设置音调(5)</span><br><span class="line">莱丝.吸气()</span><br><span class="line">莱丝.吐气()</span><br><span class="line"></span><br><span class="line">/* 当唱歌方法被封装到类中，任何歌唱家都可以简单地使用： */</span><br><span class="line">定义歌唱家类</span><br><span class="line">声明莱丝是一个歌唱家</span><br><span class="line">莱丝.唱歌()</span><br></pre></td></tr></table></figure>

<h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><p>使用封装能够对成员属性和方法进行精确的访问控制，通常来说，成员会依照它们的访问权限被分为3种：公有成员、私有成员以及保护成员，保护成员是指可以被子类访问的成员。有的语言更进一步：Java 专门提供了 public、private、protected 和缺省四个级别的访问权限控制关键字。Python 则更提倡开放，尽管没有强制要求，但也建议程序员使用带有下划线的命名风格来规范属性和方法的访问权限。</p>
<p>在 Python 中，非下划线开头的属性称为公有属性，单下划线或双下划线开头的属性称为私有属性，双下划线开头的私有属性不会被子类可见，Python 社区很少提及受保护的属性。PEP 8 提倡<strong>对于非公有方法和属性使用单个下划线开头</strong>，只有在避免子类命名冲突时才采用双下划线开头，这是因为解释器会改写双下划线开头的属性，改写为类名 + 变量名的格式。比如下面代码中的 <code>__v3</code> 就被改写为 <code>_C__v3</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    v1 = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    _v2 = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    __v3 = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[_ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">dir</span>(C) <span class="keyword">if</span> <span class="string">&#x27;v&#x27;</span> <span class="keyword">in</span> _]</span><br><span class="line">[<span class="string">&#x27;_C__v3&#x27;</span>, <span class="string">&#x27;_v2&#x27;</span>, <span class="string">&#x27;v1&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>即便如此，Python 也不能严格保证私有属性不能被外部访问。子类之所以不能访问父类的双下划线开头的属性，只是因为改写后的属性名称不相符而已。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">C</span>):</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B._v2</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B._C__v3</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>对于私有属性，《Effective Python》也建议尽量少用双下划线开头的属性，宁可让子类更多地访问父类的单下划线开头的私有属性，也不要使用双下划线命名限制子类访问，并在文档中把这些属性的合理用法告知子类的开发者。</p>
<p>为什么 Python 不从语法上严格保证私有属性的私密性呢？因为 Python 社区认为开放要比封闭好。而且，Python 提供了一些操作属性的特殊方法，如 <code>__getattr__</code>，使得无法隔绝私有属性的访问，既然如此，那么就默认开发者遵循 Python 编码风格和规范，能够按需操作类内部的属性。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽象是解决问题的法宝。良好的抽象策略可以简化问题的复杂度，并且提高系统的通用性和可扩展性。在面向对象程序设计出现直接，面向过程的程序设计多是针对的过程抽象。所谓过程抽象是将问题域中具有明确功能定义的操作抽取出来，将其定义为函数。而面向对象程序设计针对的是数据抽象，是较过程抽象更高级别的抽象方式，通过将描述客体的属性和行为绑定在一起，实现统一的抽象，从而达到对现实世界客体的真正模拟。</p>
<p>类是具有相同属性（数据元素）和行为（功能）的对象的抽象。因此，对象的抽象是类，类的具体化就是对象，也可以说<strong>类是抽象数据类型，对象是类的实例</strong>。类具有属性，它是对象的状态的抽象，用数据结构来存储类的属性。类具有操作，它是对象的行为的抽象，用操作名和实现该操作的方法来描述。类的每一个实例对象都具有这些数据和操作方法。</p>
<p>抽象可以具有层次性，由类的继承结构所体现。高层次的抽象封装行为，为低层次的抽象提供签名，可以不实现具体细节，比如抽象基类或接口。低层次的抽象实现具体细节，提供对象实例化功能。通过抽象的层次性和结构性，可以减小问题求解的复杂度。</p>
<p>从 C++ 2.0 起（1989 年发布），这门语言开始使用抽象类指定接口。Java 的设计者选择不支持类的多重继承，这排除了使用抽象类作为接口规范的可能性，因为一个类通常会实现多个接口。但是，Java 设计者提供了 interface 这个语言结构，以更明确的方式定义接口，并允许一个类实现多个接口 —— 这是一种多重继承。自 Java 8 起，接口可以提供方法实现，即默认方法，使得 Java 中的接口与 C++ 和 Python 中的抽象基类更像了。但它们之间有个关键的区别：Java 的接口没有状态。Java 之后使用最广泛的 JVM 语言要数 Scala 了，它就实现了性状（trait）。不管怎么说，让我们先从抽象基类开始，了解 Python 中的高层次抽象类型。</p>
<h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>在引入抽象基类（Abstract base classes，缩写 ABC）之前，Python 就已经很成功了。Python 倡导使用<strong>鸭子类型和协议</strong>，忽略对象的真正类型，转而关注对象有没有实现所需的方法、签名和语义。这使得 Python 编码更加宽松，不需要严格的类型限制。因此抽象基类并不是 Python 的第一选择，大概也因为此，直至 Python 语言诞生 15 年后，Python 2.6 中才引入抽象基类。</p>
<p>但这并不意味着抽象基类一无是处，相反，它被广泛应用于 Java、C# 等面向对象语言中。抽象基类的常见用途是实现接口时作为基类使用，它与普通基类的区别在于：</p>
<ul>
<li>抽象基类不能实例化；</li>
<li>具体子类必须实现抽象基类的抽象方法。</li>
</ul>
<p>正是由于抽象基类限定了子类必须实现特定的方法，它被经常用于构建框架。你可以在 Python 标准库的 <code>collections.abc</code> 和 <code>numbers</code> 模块中见到抽象基类的身影。</p>
<p>Python 中定义抽象基类需要用到标准库提供的 <code>abc</code> 模块，该模块由 <a href="https://www.python.org/dev/peps/pep-3119/">PEP 3119 – Introducing Abstract Base Classes</a> 提案所引入。它支持两种方式定义抽象基类，一种是使用 <code>abc.ABCMeta</code> 作为元类。声明元类的 <code>metaclass</code> 关键字参数是 Python 3 引入的，在此之前 Python 2 还得使用 <code>__metaclass__</code> 类属性。另一种是直接继承 <code>abc.ABC</code> 类，需要注意 ABC 的类型仍然是 ABCMeta。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, ABCMeta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(ABC)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">abc</span>.<span class="title">ABCMeta</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">class</span> <span class="title">MyABC</span>(<span class="params">metaclass=ABCMeta</span>):</span> </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br></pre></td></tr></table></figure>

<p>一般通过继承 <code>ABC</code> 来简单地创建抽象基类，当遇到可能会导致元类冲突的多重继承时，也可以使用 <code>ABCMeta</code> 作为元类来定义抽象基类。</p>
<p><code>abc</code> 模块还提供了用于声明<strong>抽象方法</strong>的装饰器 <code>@abstractmethod</code>。抽象方法定义体中通常只有文档字符串。在导入时，Python 不会检查抽象方法是否被实现，而是在实例化时检查。如果没有实现，将抛出 <code>TypeError</code> 异常提示无法实例化抽象类。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">... </span>    @abstractmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_method</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="string">&quot;&quot;&quot;My abstract method&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">MyABC</span>):</span> </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Can<span class="string">&#x27;t instantiate abstract class C with abstract methods my_abstract_method</span></span><br></pre></td></tr></table></figure>

<p>抽象方法可以有实现代码，但即便实现了，子类也必须覆盖抽象方法。通常这样做的目的是在子类中使用 <code>super()</code> 复用基类的方法，为它添加功能而不是从头实现。其实在抽象基类出现之前，抽象方法会抛出 <code>NotImplementedError</code> 异常，提示子类必须实现该抽象方法。</p>
<p>除了 <code>@abstractmethod</code> 之外，<code>abc</code> 模块还定义了 <code>@abstractclassmethod</code>、<code>@abstractstaticmethod</code> 和 <code>@abstractproperty</code> 装饰器，可用于装饰类方法、静态方法和特性。但自 Python 3.3 起这三个装饰器就被废弃了，因为可以使用装饰器堆叠达到同样的效果。在堆叠时，要保证 <code>@abstractmethod</code> 是最内层的装饰器，即最靠近函数定义体。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_classmethod</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_staticmethod</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_property</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @my_abstract_property.setter</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_property</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：PEP 3119 提案同时也引入并定义了集合类型的抽象基类，包括容器和迭代器类型，可以参考提案的 <a href="https://www.python.org/dev/peps/pep-3119/#abcs-for-containers-and-iterators">ABCs for Containers and Iterators</a> 一节。这些集合类型被统一定义在 <code>collections.abc</code> 模块中。为了减少加载时间，Python 3.4 在 <code>collections</code> 包之外实现了这个模块，即 <code>_collections_abc.py</code>，所以在导入时要使用 <code>collections.abc</code> 与 <code>collections</code> 分开导入。</p>
<h3 id="注册虚拟子类"><a href="#注册虚拟子类" class="headerlink" title="注册虚拟子类"></a>注册虚拟子类</h3><p>Python 中的抽象基类还有一个重要的实用优势：可以使用 register 将某个类声明为一个抽象基类的“虚拟”子类，这样就不用显式继承。这打破了继承的强耦合，与面向对象编程的惯有知识有很大出入，因此在使用继承时要多加小心。</p>
<p>虚拟子类不会从抽象基类中继承任何方法和属性，但类型检查函数 <code>issubclass()</code> 和 <code>isinstance()</code> 都会通过。Python 不会检查虚拟子类是否符合抽象基类的接口，即便实例化时也不会检查，但会在调用时抛出异常。因此，为了避免运行时错误，虚拟子类要实现抽象基类的所有抽象方法。</p>
<p>注册虚拟子类的 <code>register()</code> 方法可以作为普通函数调用，也可以作为装饰器使用。如下定义的抽象基类 Drawable 中定义了一个抽象方法 draw，可以随机抽取一个元素。我们实现了一个扑克类 Poker，使用装饰器形式将 Poker 类注册为 Drawable 的虚拟子类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawable</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Random draw an item.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Drawable.register</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poker</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.suits = (<span class="string">&#x27;Spade&#x27;</span>, <span class="string">&#x27;Heart&#x27;</span>, <span class="string">&#x27;Diamond&#x27;</span>, <span class="string">&#x27;Club&#x27;</span>)</span><br><span class="line">        self.numbers = (*<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>), <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">52</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        suit = self.suits[random.randint(<span class="number">0</span>, <span class="number">3</span>)]</span><br><span class="line">        number = self.numbers[random.randint(<span class="number">0</span>, <span class="number">12</span>)]</span><br><span class="line">        <span class="keyword">return</span> suit, number</span><br></pre></td></tr></table></figure>

<p>使用 <code>@Drawable.register</code> 与直接调用方法的 <code>Drawable.register(Poker)</code> 效果相同，这样即使不用显式继承，Poker 类也会被解释器视为 Drawable 抽象基类的子类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>poker = Poker()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>poker.draw()</span><br><span class="line">(<span class="string">&#x27;Diamond&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(Poker, Drawable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(poker, Drawable)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>注册虚拟子类被广泛应用于 <code>collections.abc</code> 模块中，比如将内置类型 tuple、str、range 和 memoryview 注册为序列类型 Sequence 的虚拟子类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">tuple</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">str</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">range</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">memoryview</span>)</span><br></pre></td></tr></table></figure>

<h4 id="subclasshook-钩子方法"><a href="#subclasshook-钩子方法" class="headerlink" title="__subclasshook__ 钩子方法"></a><code>__subclasshook__</code> 钩子方法</h4><p>有时甚至不需要手动注册，抽象基类也能将一个类绑定为虚拟子类。比如 Poker 类会被绑定为 <code>collections.abc.Sized</code> 的虚拟子类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Sized</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(Poker, Sized)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这是由于 Sized 抽象基类内部实现了一个名为 <code>__subclasshook__</code> 的钩子方法。这个方法会去检查类中是否包含 <code>__len__</code> 方法，如果包含，那么类型检查 <code>issubclass()</code> 和 <code>isinstance()</code> 会返回 True。</p>
<p>同理，我们可以为 Drawable 类实现此钩子方法，方法的两个参数指代的均是类对象 <code>__class__</code>。这样即使不手动注册，实现了 draw 方法的扭蛋机类 Capsule 也会被判定为 Drawable 的子类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawable</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Random draw an item.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span>(<span class="params">cls, C</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Drawable:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;draw&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(C)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Capsule</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line"><span class="comment"># &gt;&gt;&gt; issubclass(Capsule, Drawable)</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>实际上，很少需要为自己编写的抽象基类实现 <code>__subclasshook__</code> 方法，虽然这符合 Python 对于“鸭子类型”的定义，但这样做可靠性很低。好比说，不能指望任何实现了 draw 方法的类都是 Drawable 类型（可随机抽取元素），因为 draw 可能还指代其他语义，比如画图。</p>
<p>类型检查函数 <code>issubclass()</code> 和 <code>isinstance()</code> 之所以会返回 True，是由于定义在 ABCMeta 类中的 <code>__subclasscheck__</code>  和 <code>__instancecheck__</code> 特殊方法会覆盖其行为。在 ABCMeta 的构造方法中定义了一些 WeakSet 类型的类属性：<code>_abc_registry</code>、<code>_abc_cache</code> 和 <code>_abc_negative_cache</code>，它们会动态的存放抽象基类的虚拟子类（类型检查时会动态添加）。可以通过调试接口 <code>_dump_registry()</code> 查看一个抽象基类的虚拟子类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Drawable._dump_registry()</span><br><span class="line">Class: __main__.Drawable</span><br><span class="line">Inv. counter: <span class="number">45</span></span><br><span class="line">_abc_registry: <span class="built_in">set</span>()</span><br><span class="line">_abc_cache: &#123;&lt;weakref at <span class="number">0x10b0e5220</span>; to <span class="string">&#x27;type&#x27;</span> at <span class="number">0x7f9c88f3e380</span> (Poker)&gt;, &lt;weakref at <span class="number">0x10b0fe9a0</span>; to <span class="string">&#x27;type&#x27;</span> at <span class="number">0x7f9c88cb0dc0</span> (Capsule)&gt;&#125;</span><br><span class="line">_abc_negative_cache: <span class="built_in">set</span>()</span><br><span class="line">_abc_negative_cache_version: <span class="number">45</span></span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：ABCMeta 类的 Python 源码可以在 <code>_py_abc</code> 模块中查看。CPython 提供了一套基于 C 语言的更高效实现，仅在其导入失败时，才导入 <code>_py_abc</code> 模块中的 ABCMeta。</p>
<h4 id="白鹅类型"><a href="#白鹅类型" class="headerlink" title="白鹅类型"></a>白鹅类型</h4><p>最早提出“鸭子类型”的 Alex Martelli 建议在鸭子类型的基础上添加“白鹅类型”。白鹅类型是指，只要 cls 是抽象基类，即 cls 的元类是 <code>abc.ABCMeta</code>，就可以使用 <code>isinstance(obj, cls)</code>。事实上，虚拟子类就是一种白鹅类型，当我们向抽象基类注册一个虚拟子类时，ABCMeta 会将该类保存在抽象基类的类属性中，以供类型检查使用。</p>
<p>虚拟子类是抽象基类动态性的体现，也是符合 Python 风格的方式。它允许我们动态地改变类的属别关系。抽象基类定义了一系列方法，并给出了方法应当实现的功能，在这一层次上，“白鹅类型”能够对类型进行甄别。当一个类继承自抽象基类时，语言本身限制了该类必须完成抽象基类定义的语义；当一个类注册为虚拟子类时，限制则来自于编写者自身（成年人）。两种类都能通过“白鹅类型”的校验，不过虚拟子类提供了更好的灵活性与扩展性。例如，一个框架允许第三方插件时，采用虚拟子类即可以明晰接口，又不会影响内部的实现。</p>
<h3 id="自定义的抽象基类"><a href="#自定义的抽象基类" class="headerlink" title="自定义的抽象基类"></a>自定义的抽象基类</h3><p>在各类编程语言中，基础的数据结构都必不可少，比如链表、堆栈、集合等，对于这些数据结构，语言会对它们进行抽象，定义接口并设计一套继承体系。Java 将这些数据结构统称为容器（意指用于容纳数据），从最底层的 List、Set、Map 等接口，到 AbstractList、AbstractSet、AbstractMap 等抽象类，再到最上层的 ArrayList、HashSet、HashMap 等具体实现类，越靠近上层的类方法越丰富，但底层的接口和抽象类是框架的骨架，构成了整个容器框架。同时，接口和抽象类也是体现 Java 语言多态性（向上转型）的重要设计。</p>
<p>Python 的容器抽象基类定义在 <code>collections.abc</code> 模块中，其 UML 类图如下所示：</p>
<p><img src="/2021/05/12/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/uml.png" alt="162525d70561a8d42f3e5007ef176c0c.png"></p>
<p>下面我们尝试使用 Python 中的抽象基类实现一个自定义的容器类型。为了简化，这个容器类型仅支持新增 <code>push()</code> 和删除 <code>pop()</code> 两个操作。由于不同子类的具体实现不同，比如栈是先进后出，队列是先进先出，所以这两个方法被定义为抽象方法。此外还提供了检视容器元素的 <code>inspect()</code> 方法，由于实现逻辑相同，因此 <code>inspect()</code> 可以是具体方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, iterable=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> iterable:</span><br><span class="line">            self._items = <span class="built_in">list</span>(iterable)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._items = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Remove and return item. Raises IndexError if container is empty.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Add item.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._items</span><br></pre></td></tr></table></figure>

<p>可以看到，抽象基类既可以拥有抽象方法，也可以拥有具体方法。代码中的初始化方法 <code>__init__</code> 和 <code>inspect()</code> 方法都是具体方法，但子类依然可以覆盖具体方法，或者使用 <code>super()</code> 调用它们进行功能增强。</p>
<h3 id="自定义的抽象基类的子类"><a href="#自定义的抽象基类的子类" class="headerlink" title="自定义的抽象基类的子类"></a>自定义的抽象基类的子类</h3><p>接下来我们实现 Container 抽象基类的两个具体子类：栈和队列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params">Container</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(self._items):</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;Stack is empty.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._items.pop()  <span class="comment"># remove last item</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self._items.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params">Container</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(self._items):</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;Queue is empty.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._items.pop(<span class="number">0</span>)  <span class="comment"># remove first item</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self._items.append(item)</span><br></pre></td></tr></table></figure>

<p>由于具体子类继承自抽象基类 Container，所以在类声明时必须明确指定类扩展自 Container 类。并且覆盖抽象基类中的两个抽象方法。栈和队列的 <code>pop()</code> 行为不同，栈满足先进后出，而队列满足先进先出，并在容器为空时均抛出 IndexError 异常。接下来验证栈和队列的特性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack = Stack([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.push(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.inspect()</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue = Queue([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.push(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.pop()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.inspect()</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="何时使用抽象基类"><a href="#何时使用抽象基类" class="headerlink" title="何时使用抽象基类"></a>何时使用抽象基类</h3><p>对于简单的个人应用，优先使用现有的抽象基类，而不是自己编写抽象基类，因为这很容易造成过度设计。毕竟对于 Python 来说，“简单”永远是这门语言的核心，滥用抽象基类会造成灾难性后果，太注重语言的表面形式对于以实用和务实著称的 Python 可不是好事。</p>
<p>抽象基类可以约束各个子类实现相同的一套 API。除此之外，抽象基类的一个用途是运行时的类型检查，可以使用 <code>isinstance()</code> 检查某个对象是否是抽象基类的子类型，即是否实现了特定的接口。这便于我们对于不同的情形进行分支处理或异常捕获。</p>
<p>尽管抽象基类使得类型检查变得更容易了，但也不该过度使用它。Python 的核心在于它是一门动态语言，如果处处都强制实现类型约束，那么会使代码变得复杂且丑陋。我们应该拥抱 Python 的灵活性。</p>
<p>因此对于抽象基类的使用，要着重声明：除非构建的是允许用户扩展的框架，否则不要轻易定义抽象基类。日常使用中，我们与抽象基类的联系应该是创建现有抽象基类的子类。当你拥有像创建新的抽象基类的想法时，首先尝试使用常规的鸭子类型来解决问题。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象编程语言的一个重要功能就是“继承”，它可以使得在现有类的基础上，无需编写重复代码就可以实现功能的扩展。继承体现了从一般到特殊的过程。</p>
<p>通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。在某些面向对象语言中，一个子类可以继承自多个父类，这称为多重继承。Python 是一门支持多重继承的语言。</p>
<p>Python 的继承句法是，在类声明的括号中添加父类名，如 <code>class C(Base):</code> 声明了类 C 继承自基类 Base。当声明多重继承时，使用逗号隔开，如 <code>class C(BaseA，BaseB):</code>。</p>
<p>子类会继承父类的非私有属性和方法，包括类属性。这里的私有属性是指以双下划线开头且不以双下划线结尾命名的属性，由于 Python 的名称改写机制，这类私有属性将会被改写为“类名 + 属性名”的格式，所以不能被子类通过原有名称访问。</p>
<p>如下，B 类派生自 A 类，继承了 A 类的所有非私有属性和方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">... </span>    attr1 = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.attr2 = <span class="number">2</span> </span><br><span class="line"><span class="meta">... </span>        self._attr3 = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>        self.__attr4 = <span class="number">4</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span> </span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;class A method&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = B()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.attr1</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.attr2</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b._attr3</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__attr4</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;B&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__attr4&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.method()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">method</span></span></span><br></pre></td></tr></table></figure>

<p>子类可以覆盖父类的属性和方法，或者使用 <code>super()</code> 调用父类方法，在原有方法基础上添加新功能。<code>super()</code> 的一个重要用途是用于初始化方法 <code>__init__</code> 中。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line"><span class="meta">... </span>    attr1 = <span class="string">&#x27;b1&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">super</span>().__init__()</span><br><span class="line"><span class="meta">... </span>        self.attr5 = <span class="number">5</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">super</span>().method()</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;class B method&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = B()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.attr1</span><br><span class="line"><span class="string">&#x27;b1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;attr2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;_attr3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;_A__attr4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;attr5&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.method()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">method</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span> <span class="title">method</span></span></span><br></pre></td></tr></table></figure>

<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>Python 支持多重继承。人们对于多重继承褒贬不一，C++ 中对于多重继承的滥用一直饱受诟病，借鉴自 C++ 的 Java 选择直接移除了多重继承特性，采用接口（Interface）作为代替，并取得了巨大的成功。事实证明，接口是一种更加优雅的多重继承解决方案。</p>
<p>多重继承首先要解决的问题就是潜在的<strong>命名冲突</strong>，如果一个类继承自两个不相关的类，这两个类拥有实现不同的同名方法，那么该调用哪一个？这种冲突被称为“菱形问题”。为了解决这个问题，Python 会按照特定的顺序遍历继承图。这个顺序称为<strong>方法解析顺序</strong>（Method Resolution Order，缩写 MRO）。<strong>类有一个名为 <code>__mro__</code> 的类属性，它的值是一个元组，按照方法解析顺序存放各个超类的名称</strong>。</p>
<h4 id="mro-方法解析顺序"><a href="#mro-方法解析顺序" class="headerlink" title="__mro__ 方法解析顺序"></a><code>__mro__</code> 方法解析顺序</h4><p>我们定义一个继承结构，类 D 继承自类 B 和 C，而类 B 和 C 又都继承自类 A。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class A:&#x27;</span>, self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class B:&#x27;</span>, self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class C:&#x27;</span>, self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B, C</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>从继承结构上来看，这是一个菱形结构，会存在调用同名方法的二义性。那么，调用 D 实例的 <code>speak()</code> 方法会去调用哪个父类呢？</p>
<p>答案是会调用 B 的 <code>speak()</code> 方法。D 类的 <code>__mro__</code> 属性如下，访问 D 的方法，会按照 <code>D -&gt; B -&gt; C -&gt; A</code> 的顺序进行解析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = D()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.speak()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> &lt;multiple_inheritance.D <span class="built_in">object</span> at <span class="number">0x1086a6580</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D.__mro__</span><br><span class="line">(&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">multiple_inheritance</span>.<span class="title">D</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">multiple_inheritance</span>.<span class="title">B</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">multiple_inheritance</span>.<span class="title">C</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">multiple_inheritance</span>.<span class="title">A</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：方法解析顺序不会列出虚拟子类的被注册超类。因此虚拟子类也不会从被注册超类中继承任何方法。</p>
<h4 id="super-调用链"><a href="#super-调用链" class="headerlink" title="super() 调用链"></a><code>super()</code> 调用链</h4><p>在使用 <code>super()</code> 调用父类方法时，也遵循方法解析顺序。如果父类中的方法也包含 <code>super()</code> 语句，则按照方法解析顺序调用下一个父类的方法（下一个父类可能不是当前父类的直接父类）。比如如下添加了 <code>super()</code> 语句的 <code>speak()</code> 方法打印如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class A:&#x27;</span>, self)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().speak()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class B:&#x27;</span>, self)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().speak()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class C:&#x27;</span>, self)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B, C</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().speak()</span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D().speak()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> &lt;__main__.D <span class="built_in">object</span> at <span class="number">0x10edc8b80</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> &lt;__main__.D <span class="built_in">object</span> at <span class="number">0x10edc8b80</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> &lt;__main__.D <span class="built_in">object</span> at <span class="number">0x10edc8b80</span>&gt;</span><br></pre></td></tr></table></figure>

<p>按照 <code>D -&gt; B -&gt; C -&gt; A</code> 的方法解析顺序，D 中的 <code>super()</code> 方法跳转到 B，B 中的 <code>super()</code> 方法跳转到 C（而不是 B 的直接父类 A），C 中的 <code>super()</code> 方法再跳转到 A。由于 <code>super()</code> 语句在 print 语句之前，最终呈现出的打印顺序是方法解析顺序的出栈顺序。</p>
<h4 id="方法解析顺序的单调性"><a href="#方法解析顺序的单调性" class="headerlink" title="方法解析顺序的单调性"></a>方法解析顺序的单调性</h4><p>方法解析顺序不仅考虑继承图，还考虑子类声明中所列的超类顺序。如果 D 类声明为 <code>class D(B, C):</code>，那么 D 类一定会先于 B、C 类被搜索，且 B 类一定先于 C 类被搜索。我们将这种 <code>D -&gt; B -&gt; C</code> 的顺序称为<strong>方法解析顺序的单调性</strong>。 用户在定义继承关系时必须要遵循单调性原则。</p>
<p>Python 方法解析顺序采用的 C3 算法会检查方法解析顺序的单调性。简单地说，C3 算法的基本逻辑是，每定义好一个继承关系顺序，算法会将所有顺序按照满足单调性的方式整合起来，如果整合过程出现冲突，算法会抛出错误。</p>
<p>如下所示，由于定义 B 类时声明为 <code>class B(A):</code>，所以 B 的解析顺序要先于 A，然而在使用 <code>class C(A, B):</code> 声明 C 类时，A 的解析顺序又先于 B，因此发生冲突，抛出异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Cannot create a consistent method resolution</span><br><span class="line">order (MRO) <span class="keyword">for</span> bases A, B</span><br></pre></td></tr></table></figure>

<p>在 Python 标准库中，最常使用多重继承的是 <code>collections.abc</code> 模块，其中的类都定义为抽象基类。抽象基类类似于 Java 中的接口声明，只不过它可以提供具体方法。因此在 <code>collections.abc</code> 模块中频繁使用多重继承并没有问题，它为 Python 的集合类型构建了一个继承体系。然而，滥用多重继承容易得到令人费解和脆弱的设计。《Effective Python》中也提到：只在使用混入时才使用多重继承。为此，有必要先介绍一下混入类。</p>
<h3 id="混入类"><a href="#混入类" class="headerlink" title="混入类"></a>混入类</h3><p>除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，那就是<strong>混入</strong>（mixin），这在 Scala 和 JavaScript 使用颇多。如果一个类的作用是为多个不相关的子类提供方法实现，从而实现重用，但不体现 “is-a” 语义，应该把这个类明确定义为混入类。从概念上讲，混入不定义新类型，只是打包方法，便于重用。因此，<strong>混入类绝对不能实例化，而且具体类不能只继承混入类</strong>。</p>
<p>Python 没有提供定义混入类的专有关键字，而是推荐在名称末尾加上 “Mixin” 后缀。而在 Scala 中，使用 trait（特性）关键字来声明混入类，TypeScript 中则使用 implements 关键字来继承混入类。</p>
<p>抽象基类可以实现具体方法，因此也可以作为混入使用。<code>collections.abc</code> 模块中的抽象基类在一定程度上可以被视为混入类，它们都声明了 <code>__slots__ = ()</code> 语句，表明了混入类不能具有实例属性，即混入类不能被实例化。但是，抽象基类可以定义某个抽象类型，而混入做不到，因此，抽象基类可以作为其他类的唯一基类，而混入绝不能作为唯一超类。但是，抽象基类有个局限是混入类没有的，即：抽象基类中提供具体实现的抽象方法只能与抽象基类及其超类中的方法协作。</p>
<p>一些三方库和框架中也有用到混入，比如 Django 框架，我截取了 <a href="https://github.com/django/django/blob/main/django/views/generic/base.py">Django 视图模块</a>的一小部分源码，以便更好的理解混入类与多重继承的关系。</p>
<h4 id="Django-源码"><a href="#Django-源码" class="headerlink" title="Django 源码"></a>Django 源码</h4><p>在 Django 中，视图是可调用对象，它的参数是表示 HTTP 请求的对象，返回值是一个表示 HTTP 响应的对象。我们要关注的是这些响应对象。响应可以是简单的重定向，没有主体内容，为我们导向另一个 url，也可以是复杂的网页内容，需要使用 HTML 模版渲染，最终呈现在浏览器终端上。为此，Django 框架提供了重定向视图 RedirectView，以及模版视图 TemplateView。</p>
<p>我们将注意力放在 TemplateView 类上，它继承自三个类，从左到右分别是模版响应混入类 TemplateResponseMixin、上下文混入类 ContextMixin，以及视图基类 View。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateView</span>(<span class="params">TemplateResponseMixin, ContextMixin, View</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Render a template. Pass keyword arguments from the URLconf to the context.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span> </span><br><span class="line">        context = self.get_context_data(**kwargs)</span><br><span class="line">        <span class="keyword">return</span> self.render_to_response(context)</span><br></pre></td></tr></table></figure>

<p>从类型上来说，TemplateView 依然是一个视图类型。View 是所有视图的基类，提供核心功能，如 dispatch 方法。RedirectView 由于不需要渲染，所以只继承了 View 类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Intentionally simple parent class for all views. Only implements</span></span><br><span class="line"><span class="string">    dispatch-by-method and simple sanity checking.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    http_method_names = [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>, <span class="string">&#x27;trace&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, **kwargs</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">as_view</span>(<span class="params">cls, **initkwargs</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self, request, *args, **kwargs</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">http_method_not_allowed</span>(<span class="params">self, request, *args, **kwargs</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">options</span>(<span class="params">self, request, *args, **kwargs</span>):</span> ...</span><br></pre></td></tr></table></figure>

<p>两个混入类 TemplateResponseMixin 和 ContextMixin 并不代表某一特定类型，而是打包了若干属性和方法，此类方法又不是 RedirectView 所需要的，因此不能定义在 View 基类中。TemplateResponseMixin 提供的功能只针对需要使用模版的视图，除了 TemplateView 还提供给其他视图，例如用于渲染列表的 ListView 视图以及默认视图 DetailView 等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateResponseMixin</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A mixin that can be used to render a template.&quot;&quot;&quot;</span></span><br><span class="line">    template_name = <span class="literal">None</span></span><br><span class="line">    template_engine = <span class="literal">None</span></span><br><span class="line">    response_class = TemplateResponse</span><br><span class="line">    content_type = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render_to_response</span>(<span class="params">self, context, **response_kwargs</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_template_names</span>(<span class="params">self</span>):</span> ...</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextMixin</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A default context mixin that passes the keyword arguments received by</span></span><br><span class="line"><span class="string">    get_context_data() as the template context.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    extra_context = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context_data</span>(<span class="params">self, **kwargs</span>):</span> ...</span><br></pre></td></tr></table></figure>

<p>Django 基于类的视图 API 是多重继承的一个优雅示例，尤其是 Django 的混入类易于理解：各个混入类的目的明确，且都以 “Mixin” 作为后缀。</p>
<h3 id="继承的最佳实践"><a href="#继承的最佳实践" class="headerlink" title="继承的最佳实践"></a>继承的最佳实践</h3><p><strong>明确使用继承的目的</strong>：在决定使用继承之前，首先明确这么做的目的。如果是为了继承重用代码，那么组合和委托也可以达到相同效果。《设计模式：可复用面向对象软件的基础》一书中明确指出：“<strong>优先使用对象组合，而不是类继承</strong>”。组合体现的是 “has-a” 语义，与继承相比，组合的耦合性更低，可扩展性更高。继承并不是银弹，继承意味着父类与子类的强耦合性，一旦父类接口发生变化，所有子类都会受到影响。如果继承用错了场合，那么后期的维护可能是灾难性的。但如果目的是继承接口，创建子类型，实现 “is-a” 关系，那么使用继承是合适的。<strong>接口继承是框架的支柱</strong>，如果类的作用是定义接口，就应该明确定义为抽象基类，就像 <code>collections.abc</code> 模块所做的那样。</p>
<p><strong>不要继承多个具体类</strong>：最多只有一个具体父类，也可以没有。也就是说，除了这一个具体父类之外，其余都是抽象基类或混入。并且，如果抽象基类或混入的组合被经常使用，那么就可以考虑定义一个聚合类，使用易于理解的方式将他们结合起来，就如同 <code>collections.abc</code> 模块中定义的 Collection 类：<code>class Collection(Sized, Iterable, Container):</code>。</p>
<p><strong>只在使用混入时才使用多重继承</strong>：这比上一条要更加严苛，尽管抽象基类有时可被视为混入类。不管怎么说，如果不是开发框架，尽量避免使用多重继承，如果不得不用多重继承，请使用混入类。混入类不会破坏现有的继承结构树，它就像小型的可插拔的扩展接口坞，目的不是声明 “is-a” 关系，而是为子类扩展特定功能。所以有时也将混入类称为混入组件。</p>
<p><strong>在声明多重继承自混入类和基类时，先声明混入类，最后声明基类</strong>：这是由于，在定义混入类时使用 <code>super()</code> 是普遍的。为了保证继承自混入类和基类的子类，在调用方法时会执行基类的同名方法，需要先声明混入类再声明基类。这样，按照方法解析顺序的单调性，混入类中的 <code>super()</code> 方法会调用到基类中的方法。</p>
<p>如下定义了一个属性只能赋值一次的字典，为其属性赋值时，按照方法解析顺序，会先调用混入类的 <code>__setitem__</code> 方法，执行到 <code>super()</code> 语句，调用基类 UserDict 的 <code>__setitem__</code> 方法进行设值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> UserDict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetOnceMappingMixin</span>:</span></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="built_in">str</span>(key) + <span class="string">&#x27; already set&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__setitem__(key, value)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetOnceDefaultDict</span>(<span class="params">SetOnceMappingMixin, UserDict</span>):</span> ...</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>collections</code> 模块子类化内置类型</strong>：内置类型的原生方法使用 C 语言实现，不会调用子类中覆盖的方法。比如，如下 DoubleDict 中定义的 <code>__setitem__</code> 方法并不会覆盖初始化方法 <code>__init__</code> 中的设值方法。因此，需要定制 list、dict 或 str 类型时，应该使用 <code>collections</code> 模块中的 UserList、UserDict 或 UserString 等。这些类是对内置类型的包装，会把操作委托给内置类型 —— 这是标准库中优先选择组合而不是继承的又一例证。如果所需的行为与内置类型区别很大，那么子类化 <code>collections.abc</code> 中的抽象基类自己实现或许更加容易。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DoubleDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">super</span>().__setitem__(key, value * <span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = DoubleDict(a=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> UserDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DoppelDict</span>(<span class="params">UserDict</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">super</span>().__setitem__(key, value * <span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = DoppelDict(a=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 鸭子类型和特殊方法</title>
    <url>/2021/03/10/Python-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Python-是动态强类型语言"><a href="#Python-是动态强类型语言" class="headerlink" title="Python 是动态强类型语言"></a>Python 是动态强类型语言</h2><blockquote>
<p><strong>Dynamic programming language</strong>: In computer science, a dynamic programming language is a class of high-level programming languages, which at runtime execute many common programming behaviours that <strong>static programming languages perform during compilation</strong>. These behaviors could include an extension of the program, by <strong>adding new code, by extending objects and definitions, or by modifying the type system</strong>.</p>
</blockquote>
<p>以上内容摘自维基百科对于动态编程语言（Dynamic programming language）的定义。动态语言是相对于静态语言而言的。相比之下，静态语言有更严格的语法限制，在编译阶段就能够确定数据类型，典型的静态语言包括 C、C++ 和 Java 等。这一类语言的优势在于代码结构规范，易于调试和重构。缺点则是语法冗杂，编码方式不灵活。</p>
<p>而动态语言最典型的特点在于不需要编码时指定数据类型，类型信息由运行时推断得出。常见的动态语言都是一些脚本语言，比如 JavaScript、Python、PHP 等。这类语言虽然调试和重构的支持不如静态语言，但由于没有类型约束编码更加灵活。</p>
<p>Python 就是一门动态编程语言，编码时不用指定类型，且运行时可以变更数据类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">a</span> = &#x27;1&#x27;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">a</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>尽管 “PEP 484 – Type Hints” 引入了类型提示，但它明确指出：Python 依旧是一门动态类型语言，作者从未打算强制要求使用类型提示，甚至不会把它变成约定。但是 API 作者能够添加可选的类型注解，执行某种静态类型检查。</p>
<p>另外值得注意的是，虽然 Python 支持运行时变更数据类型，但变量所指向的内存地址空间已经在变更时发生了变化。也就是说，数据类型变更后不再指向原先的内存地址空间。我们可以用查看对象内存地址的 <code>id()</code> 函数加以验证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">4316699376</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">123456</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">4316579216</span></span><br></pre></td></tr></table></figure>

<h3 id="强弱类型"><a href="#强弱类型" class="headerlink" title="强弱类型"></a>强弱类型</h3><p>确定了 Python 是动态语言后，接下来我们讨论<strong>强弱类型</strong>语言。首先，强弱类型与是否是动态语言没有必然联系，动态语言并不一定就是弱类型语言，Python 就是一门动态强类型语言。这里的“强弱”可以理解为用以<strong>描述编程语言对于混入不同类型的值进行运算时的处理方式</strong>。</p>
<p>比如在弱类型语言 JavaScript 中，我们可以直接对字符串和数值类型进行相加，虽然得出的结果并不一定是我们想要的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="string">&#x27;1&#x27;</span> + <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>

<p>出现这种现象的原因是 JavaScript 支持<strong>变量类型的隐式转换</strong>。上面的例子就是将数值类型隐式转换为了字符串类型再进行相加。也因此，JavaScript 中才会存在三个等号的判等运算符 <code>===</code>。与 <code>==</code> 不同，<code>===</code> 在判等时不会进行隐式转换，所以才会有下面这样的结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">1</span> == <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="number">1</span> === <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>而 Python 作为强类型语言，不支持类型的隐式转换，所以整型和字符型相加会直接报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> + <span class="string">&#x27;2&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">&#x27;int&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>

<p>所以，强弱类型语言的区别体现在：强类型语言在遇到函数声明类型和实际调用类型不符合的情况时会直接出错或者编译失败；而弱类型的语言可能会进行隐式转换，从而产生难以意料的结果。</p>
<h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><p>在面向对象的静态类型语言中，如果要实现一个带特定功能的序列类型，你可能会想到使用继承，以期能在添加特定功能的同时尽可能的重用代码。这符合面向对象的设计原则，但在 Python 中，继承却不是首选方案。</p>
<p>在 Python 这类动态类型语言中，有一种风格叫做<strong>鸭子类型</strong>（duck typing）。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口决定的，而是由”<strong>当前方法和属性的集合</strong>“决定。这个概念最早来源于 James Whitcomb Riley 提出的“鸭子测试”，“鸭子测试”可以这样表述：“如果一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么它就可以被称为鸭子。”</p>
<p>在 Python 中创建功能完善的序列类型无需使用继承，只需实现符合序列协议的方法。那么，协议又是什么呢？在面向对象编程中，协议是非正式的接口，只在文档中定义，不在代码中定义，可以看作是约定俗成的惯例。例如，Python 的迭代器协议就包含 <code>__iter__</code> 和 <code>__next__</code> 两个方法，任何实现了 <code>__iter__</code> 和 <code>__next__</code> 方法的类，Python 解释器会将其视为迭代器，所有迭代器支持的操作，该类也会支持，譬如 <code>next()</code> 方法和 <code>for</code> 循环。用鸭子类型来解释就是：这个类看起来像是迭代器，那它就是迭代器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">IterDuck</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = IterDuck()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(IterDuck, Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(i, Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>由于实现了迭代器协议，上面代码中的 IterDuck 类甚至不需要显式的继承 Iterator 类，Python 解释器就已经将它绑定为 Iterator 类的子类。</p>
<p><strong>在鸭子类型中，关注点在于对象的行为，即提供的方法，而不在于对象所属的类型。</strong></p>
<h3 id="序列协议"><a href="#序列协议" class="headerlink" title="序列协议"></a>序列协议</h3><p>序列协议之所以要专门作为单独的一节，是因为序列在 Python 中尤为重要，Python 会特殊对待看起来像是序列的对象。序列协议包含 <code>__len__</code> 和 <code>__getitem__</code> 两个方法。任何类，只要实现了 <code>__len__</code> 和 <code>__getitem__</code> 方法，就可以被看作是一个序列，即使这一次 Python 解释器不再将其绑定为 Sequence 类的子类。</p>
<p>由于序列的特殊性，如果你知道类的具体应用场景，甚至只需要实现序列协议的一部分。下面的代码演示了一个只实现了 <code>__getitem__</code> 方法的类，对于序列操作的支持程度：尽管只实现了 <code>__getitem__</code> 方法，但 SeqDuck 实例却可以使用 <code>for</code> 循环迭代以及 <code>in</code> 运算符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">SeqDuck</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">range</span>(<span class="number">3</span>)[index]</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SeqDuck()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>]  <span class="comment"># __getitem__</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> s: <span class="built_in">print</span>(i)  <span class="comment"># __iter__</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> <span class="keyword">in</span> s  <span class="comment"># __contains__</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>即使没有 <code>__iter__</code> 方法，SeqDuck 实例依然是可迭代的对象，因为当 Python 解释器发现存在 <code>__getitem__</code> 方法时，会尝试调用它，传入从 0 开始的整数索引进行迭代（这是一种后备机制）。同样的，即使没有 <code>__contains__</code> 方法，但 Python 足够智能，能够迭代 SeqDuck 实例检查有没有指定元素。</p>
<p>综上，鉴于序列协议的重要性，如果没有 <code>__iter__</code> 和 <code>__contains__</code> 方法，Python 会尝试调用 <code>__getitem__</code> 方法设法让迭代和 <code>in</code> 运算符可用。</p>
<h3 id="绑定虚拟子类"><a href="#绑定虚拟子类" class="headerlink" title="绑定虚拟子类"></a>绑定虚拟子类</h3><p>你也许会有个疑问，为什么 IterDuck 和 SeqDuck 都没有显示继承父类，但 IterDuck 却是 Iterator 类的子类，而 SeqDuck 不是 Sequence 的子类呢？这要归因于 Python 的<strong>虚拟子类</strong>机制。一般情况下，使用 <code>register()</code> 方法可以将一个类注册为另一个类的虚拟子类，比如 <code>collections.abc</code> 模块中是这样将内置类型 tuple、str、range 和 memoryview 注册为序列类 Sequence 的虚拟子类的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">tuple</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">str</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">range</span>)</span><br><span class="line"><span class="type">Sequence</span>.register(<span class="built_in">memoryview</span>)</span><br></pre></td></tr></table></figure>

<p>这也是为什么这些类的显示继承父类是 object，但同样能应用序列类的诸多方法。而对于用户自定义的类型来说，<strong>即使不注册，抽象基类也能把一个类识别为虚拟子类，这需要抽象基类实现一个名为 <code>__subclasshook__</code> 的特殊的钩子方法</strong>。如下是 <code>collections.abc</code> 模块中 Iterator 抽象基类的源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _collections_abc.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>(<span class="params">Iterable</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span>(<span class="params">cls, C</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterator:</span><br><span class="line">            <span class="keyword">return</span> _check_methods(C, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__next__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br></pre></td></tr></table></figure>

<p>对于实现了迭代器协议，即 <code>__iter__</code> 和 <code>__next__</code> 方法的类来说，它就会被钩子方法检测到并绑定为 Iterator 的虚拟子类，这解释了为什么 <code>issubclass(IterDuck, Iterator)</code> 会验证通过。类似的，可迭代对象 Iterable 协议要更加宽松，因为它只检查了 <code>__iter__</code> 方法。</p>
<p>那么为什么 SeqDuck 没有被绑定为 Sequence 的子类呢？因为 Sequence 类没有实现 <code>__subclasshook__</code> 钩子方法。Python 对序列的子类要求更加严格，即使实现了序列协议 <code>__len__</code> 和 <code>__getitem__</code> 方法的类可以被视为一个序列，但依然不能称之为序列的子类。最典型的例子就是内置类型字典。虽然字典实现了这两个方法，但它不能通过整数偏移值获取元素，且字典内的元素顺序是无序的，所以不能将其视为 Sequence 的子类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> <span class="type">Sequence</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;__getitem__&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">dict</span>) <span class="keyword">and</span> <span class="string">&#x27;__len__&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">dict</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">dict</span>, <span class="type">Sequence</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(d, <span class="type">Sequence</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">1</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>想要更深入地理解鸭子类型，必须要了解 Python 中的特殊方法。前面我们提到的以双下划线开头和结尾的方法，比如 <code>__iter__</code>，就称为<strong>特殊方法</strong>（special methods），或称为<strong>魔法方法</strong>（magic methods）。</p>
<p>Python 标准库和内置库包含了许多特殊方法，需要注意的是，永远不要自己命名一个新的特殊方法，因为你不知道下个 Python 版本会不会将其纳入到标准库中。我们需要做的，是重写现有的特殊方法，并且通常情况下，不需要显式的调用它们，应当使用更高层次的封装方法，比如使用 <code>str()</code> 代替 <code>__str__()</code>，对特殊方法的调用应交由 Python 解释器进行。</p>
<p>Python 对于一些内置方法及运算符的调用，本质上就是调用底层的特殊方法。比如在使用 <code>len(x)</code> 方法时，实际上会去查找并调用 x 对象的 <code>__len__</code> 方法；在使用 <code>for</code> 循环时，会去查找并调用对象的 <code>__iter__</code> 方法，如果没有找到这个方法，那会去查找对象的 <code>__getitem__</code> 方法，正如我们之前所说的这是一种后备方案。</p>
<p>可以说，特殊方法是 Python 语言灵活的精髓所在，下面我们结合鸭子类型一章中的 SeqDuck 类与特殊方法，尝试还原 Python 解释器运行的逻辑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqDuck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, pos</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">range</span>(<span class="number">3</span>)[pos]</span><br></pre></td></tr></table></figure>

<ol>
<li>Python 解释器读入 SeqDuck 类，对所有双下划线开头结尾的特殊方法进行检索。</li>
<li>检索到 <code>__getitem__</code> 方法，方法签名符合序列协议。</li>
<li>当需要对 SeqDuck 实例进行循环迭代时，首先查找 <code>__iter__</code> 方法，未找到。</li>
<li>执行 <code>__getitem__</code> 方法，传入从 0 开始的整数索引进行迭代直至索引越界终止循环。</li>
</ol>
<p>该过程可以理解为 Python 解释器对 SeqDuck 类的功能进行了<strong>运行时扩充</strong>。显然这增强了 Python 语言的动态特性，但另一方面也解释了为什么 Python 运行效率较低。</p>
<p>下面我将对一些常用特殊方法进行介绍。</p>
<h3 id="new-amp-init"><a href="#new-amp-init" class="headerlink" title="__new__ &amp; __init__"></a><code>__new__</code> &amp; <code>__init__</code></h3><p>在 Java 和 C# 这些语言中，可以使用 <code>new</code> 关键字创建一个类的实例。Python 虽然没有 <code>new</code> 关键字，但提供了 <code>__new__</code> 特殊方法。在实例化一个 Python 类时，最先被调用的就是 <code>__new__</code> 方法。大多数情况下不需要我们重写 <code>__new__</code> 方法，Python 解释器也会执行 object 中的 <code>__new__</code> 方法创建类实例。但如果要使用单例模式，那么 <code>__new__</code> 方法就会派上用场。下面的代码展示了如何通过 <code>__new__</code> 控制只创建类的唯一实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line"><span class="meta">... </span>    _instance = <span class="literal">None</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>        cls._instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> cls._instance</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = Singleton()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Singleton()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 <span class="keyword">is</span> s2  <span class="comment">## id(s1) == id(s2)</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><code>__init__</code> 方法则类似于构造函数，如果需要对类中的属性赋初值，可以在 <code>__init__</code> 中进行。在一个类的实例被创建的过程中，<code>__new__</code> 要先于 <code>__init__</code> 被执行，因为要先创建好实例才能进行初始化。<code>__new__</code> 方法的第一个参数必须是 <code>cls</code> 类自身，<code>__init__</code> 方法的第一个参数必须是 <code>self</code> 实例自身。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;__new__ magic method is called&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span> (<span class="string">&quot;__init__ magic method is called&quot;</span>)</span><br><span class="line"><span class="meta">... </span>        self.name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Employee()</span><br><span class="line">__new__ magic method <span class="keyword">is</span> called</span><br><span class="line">__init__ magic method <span class="keyword">is</span> called</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.name</span><br><span class="line"><span class="string">&#x27;Jack&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于 Python 不支持方法重载，即同名方法只能存在一个，所以 Python 类只能有一个构造函数。如果需要定义和使用多个构造器，可以使用带默认参数的 <code>__init__</code> 方法，但这种方法实际使用还是有局限性。另一种方法则是使用带有 <code>@classmethod</code> 装饰器的类方法，可以像使用类的静态方法一样去调用它生成类的实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, sex=<span class="string">&#x27;MAlE&#x27;</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">male</span>(<span class="params">cls, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">female</span>(<span class="params">cls, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls(name, <span class="string">&#x27;FEMALE&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">p1 = Person(<span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line">p2 = Person(<span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;FEMALE&#x27;</span>)</span><br><span class="line">p3 = Person.female(<span class="string">&#x27;Neo&#x27;</span>)</span><br><span class="line">p4 = Person.male(<span class="string">&#x27;Tony&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="str-amp-repr"><a href="#str-amp-repr" class="headerlink" title="__str__ &amp; __repr__"></a><code>__str__</code> &amp; <code>__repr__</code></h3><blockquote>
<p>str() is used for creating output for end user while repr() is mainly used for debugging and development. repr’s goal is to be <strong>unambiguous</strong> and str’s is to be <strong>readable</strong>.</p>
</blockquote>
<p><code>__str__</code> 和 <code>__repr__</code> 都可以用来输出一个对象的字符串表示。使用 <code>str()</code> 时会调用 <code>__str__</code> 方法，使用 <code>repr()</code> 时则会调用 <code>__repr__</code> 方法。<code>str()</code> 可以看作 string 的缩写，类似于 Java 中的 <code>toString()</code> 方法；<code>repr()</code> 则是 representation 的缩写。</p>
<p>这两个方法的区别主要在于受众。<code>str()</code> 通常是输出给终端用户查看的，可读性更高。而 <code>repr()</code> 一般用于调试和开发时输出信息，所以更加强调含义准确无异义。在 Python 控制台以及 Jupyter notebook 中输出对象信息会调用的 <code>__repr__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="literal">True</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x  <span class="comment"># list.__repr__</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="literal">True</span>]</span><br></pre></td></tr></table></figure>

<p>如果类没有定义 <code>__repr__</code> 方法，控制台会调用 object 类的 <code>__repr__</code> 方法输出对象信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a  <span class="comment"># object.__repr__</span></span><br><span class="line">&lt;__main__.A <span class="built_in">object</span> at <span class="number">0x104b69b50</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>__str__</code> 和 <code>__repr__</code> 也可以提供给 <code>print</code> 方法进行输出。如果只定义了一个方法则调用该方法，如果两个方法都定义了，会优先调用 <code>__str__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;repr: Foo&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;str: Foo&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line"><span class="built_in">repr</span>: Foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">str</span>: Foo</span><br></pre></td></tr></table></figure>

<h3 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h3><p>在 Python 中，函数是一等公民。这意味着 Python 中的函数可以作为参数和返回值，可以在任何想调用的时候被调用。为了扩充类的函数功能，Python 提供了 <code>__call__</code> 特殊方法，允许类的实例表现得与函数一致，可以对它们进行调用，以及作为参数传递。这在一些需要保存并经常更改状态的类中尤为有用。</p>
<p>下面的代码中，定义了一个从 0 开始的递增器类，它保存了计数器状态，并在每次调用时计数加一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Incrementor</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.counter = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.counter += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.counter</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inc = Incrementor()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inc()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inc()</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>允许将类的实例作为函数调用，如上面代码中的 <code>inc()</code>，本质上与 <code>inc.__call__()</code> 直接调用对象的方法并无区别，但它可以以一种更直观且优雅的方式来修改对象的状态。</p>
<p><code>__call__</code> 方法可以接收可变参数, 这意味着可以像定义任意函数一样定义类的 <code>__call__</code> 方法。当 <code>__call__</code> 方法接收一个函数作为参数时，那么这个类就可以作为一个函数装饰器。基于类的函数装饰器就是这么实现的。如下代码我在 func 函数上使用了类级别的函数装饰器 Deco，使得在执行函数前多打印了一行信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Deco</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.func = func</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;decorate...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@Deco</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;execute function&#x27;</span>, name)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">decorate...</span><br><span class="line">execute function foo</span><br></pre></td></tr></table></figure>

<p>实际上类级别的函数装饰器必须要实现 <code>__call__</code> 方法，因为本质上函数装饰器也是一个函数，只不过是一个接收被装饰函数作为参数的高阶函数。有关装饰器可以详见装饰器一章。</p>
<h3 id="add"><a href="#add" class="headerlink" title="__add__"></a><code>__add__</code></h3><p>Python 中的运算符重载也是通过重写特殊方法实现的。比如重载 “+” 加号运算符需要重写 <code>__add__</code>，重载比较运算符 “==” 需要重写 <code>__eq__</code> 方法。合理的重载运算符有助于提高代码的可读性。下面我将就一个代码示例进行演示。</p>
<p>考虑一个平面向量，由 x，y 两个坐标构成。为了实现向量的加法（按位相加），重写了加号运算符，为了比较两个向量是否相等重写了比较运算符，为了在控制台方便验证结果重写了 <code>__repr__</code> 方法。完整的向量类代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Vector(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x + other.x, self.y + other.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.x == other.x <span class="keyword">and</span> self.y == other.y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ne__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.__eq__(other)</span><br></pre></td></tr></table></figure>

<p>在控制台验证结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v2</span><br><span class="line">Vector(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == v2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v1 == Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>重载了 “+” 运算符后，可以直接使用 <code>v1 + v2</code> 对 Vector 类进行向量相加，而不必要编写专门的 <code>add()</code> 方法，并且重载了 <code>==</code> 运算符取代了 <code>v1.equals(v2)</code> 的繁冗写法。从代码可读性来讲直接使用运算符可读性更高，也更符合数学逻辑。</p>
<p>当然，运算符重载涉及的知识点不止于此，《流畅的 Python》将其作为单独的一章，可见其重要性。下一节我们将就运算符重载进行深入的讨论。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://foofish.net/dynamic_type_and_duck_type.html">Python：动态语言与鸭子类型</a></li>
<li><a href="https://www.tutorialsteacher.com/python/magic-methods-in-python">Python - Magic or Dunder Methods
</a></li>
<li><a href="https://www.pythonlikeyoumeanit.com/Module4_OOP/Special_Methods.html">Python Like You Mean It - Special Methods</a></li>
<li><a href="https://sikasjc.github.io/2018/09/02/magicmethods2/">全面学习Python魔法方法(magic methods)</a></li>
<li><a href="https://hellowac.github.io/programing%20teach/2017/06/06/fluentpython13.html">流畅的python - 重载运算符</a></li>
</ul>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 持久化</title>
    <url>/2018/03/16/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>Redis 不仅可以基于内存进行高速的数据读写，还提供了两种持久化方式，即 <strong>RDB</strong>(or <strong>Redis Database</strong>) 和 <strong>AOF</strong>(or <strong>Append Only File</strong>)，本文主要介绍这两种持久化方式的原理及区别</p>
</blockquote>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><blockquote>
<p>RDB 持久化可以在指定的时间间隔内生成数据集的<strong>快照</strong>(snapshot)</p>
</blockquote>
<ul>
<li><p>我们可以在配置文件<code>/etc/redis/redis.conf</code>中查看 RDB 持久化的配置</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################           </span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>
<p>  格式如下<code>save &lt;seconds&gt; &lt;changes&gt;</code>，比如<code>save 900 1</code>就表示 <strong>900秒内如果有超过一个键被修改就自动保存一次数据集</strong></p>
</li>
<li><p>另外两个重要信息就是快照写入的文件名以及文件夹路径</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir /var/lib/redis</span><br></pre></td></tr></table></figure>
<p>  可以看到快照的文件名是<code>dump.rdb</code>，保存路径<code>/var/lib/redis</code>，<strong>RDB 和 AOF 的持久化文件都保存在这个目录下</strong></p>
</li>
<li><p>另外也可以在<code>redis-cli</code>中查看配置</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG GET save</span><br><span class="line">1) &quot;save&quot;</span><br><span class="line">2) &quot;900 1 300 10 60 10000&quot;</span><br></pre></td></tr></table></figure>
<p>  可以通过调用<code>SAVE</code>或<code>BGSAVE</code> (background save)，手动进行数据集保存</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="RDB-的特性"><a href="#RDB-的特性" class="headerlink" title="RDB 的特性"></a>RDB 的特性</h3><ul>
<li><p>RDB 是一个非常紧凑的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于备份</p>
</li>
<li><p>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 <strong><code>fork</code>出一个子进程</strong>，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作</p>
</li>
<li><p><strong>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快</strong></p>
</li>
<li><p>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然你可以通过设置来控制保存 RDB 文件的频率。但是，因为 RDB 文件需要保存整个数据集的状态，所以它并不是一个轻松的操作。因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下，一旦发生故障停机，你就可能会丢失好几分钟的数据</p>
</li>
<li><p>每次保存 RDB 的时候，Redis 都要<code>fork</code>出一个子进程，并由子进程来进行实际的持久化工作。<strong>在数据集比较庞大时，<code>fork</code>可能会非常耗时</strong>，造成服务器在某某毫秒内停止处理客户端；如果数据集非常巨大，并且 CPU 时间非常紧张的话，甚至可能会停止长达整整一秒。虽然 AOF 重写也需要进行<code>fork</code>，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失</p>
</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><blockquote>
<p>AOF 持久化记录服务器执行的所有<strong>写操作命令</strong>，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被 <strong>追加(append)</strong> 到文件的末尾。 Redis 还可以在后台对 AOF 文件进行 <strong>重写(rewrite)</strong> ，使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小</p>
</blockquote>
<ul>
<li><p>在配置文件中查看 AOF 设置</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line"></span><br><span class="line"># By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="line"># good enough in many applications, but an issue with the Redis process or</span><br><span class="line"># a power outage may result into a few minutes of writes lost (depending on</span><br><span class="line"># the configured save points).</span><br><span class="line">#</span><br><span class="line"># The Append Only File is an alternative persistence mode that provides</span><br><span class="line"># much better durability. For instance using the default data fsync policy</span><br><span class="line"># (see later in the config file) Redis can lose just one second of writes in a</span><br><span class="line"># dramatic event like a server power outage, or a single write if something</span><br><span class="line"># wrong with the Redis process itself happens, but the operating system is</span><br><span class="line"># still running correctly.</span><br><span class="line">#</span><br><span class="line"># AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="line"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="line"># with the better durability guarantees.</span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><span class="line"></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># The fsync() call tells the Operating System to actually write data on disk</span><br><span class="line"># instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="line"># data on disk, some other OS will just try to do it ASAP.</span><br><span class="line">#</span><br><span class="line"># Redis supports three different modes:</span><br><span class="line">#</span><br><span class="line"># no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="line"># always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="line"># everysec: fsync only one time every second. Compromise.</span><br><span class="line">#</span><br><span class="line"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span><br><span class="line"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span><br><span class="line"># &quot;no&quot; that will let the operating system flush the output buffer when</span><br><span class="line"># it wants, for better performances (but if you can live with the idea of</span><br><span class="line"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span><br><span class="line"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span><br><span class="line"># everysec.</span><br><span class="line">#</span><br><span class="line"># If unsure, use &quot;everysec&quot;.</span><br><span class="line"></span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认<code>appendonly no</code>，需要改为<code>yes</code>开启 AOF 功能，修改后重启<code>redis-server</code>，发现<code>/var/lib/redis</code>多了个<code>appendonly.aof</code>文件，即以 Redis 协议格式保存的一条条命令</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /var/lib/redis</span><br><span class="line">appendonly.aof  dump.rdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们打开<code>redis-cli</code>执行一些写操作</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set foo &quot;foooo&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set bar &quot;barrr&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;foo&quot;</span><br><span class="line">2) &quot;bar&quot;</span><br></pre></td></tr></table></figure>
<p>  查看<code>appendonly.aof</code>，文件可读性很强，<code>*3</code>表示命令由 3 个短语构成，<code>$3</code>表示短语长度为 3，第一句<code>SELECT 0</code>表示选中第一个数据库</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*2</span><br><span class="line">$6</span><br><span class="line">SELECT</span><br><span class="line">$1</span><br><span class="line">0</span><br><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$3</span><br><span class="line">foo</span><br><span class="line">$5</span><br><span class="line">foooo</span><br><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$3</span><br><span class="line">bar</span><br><span class="line">$5</span><br><span class="line">barrr</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们将上述文件 13 ~ 19 行删除，重启<code>redis-server</code>，发现第二个键已被我们人工删除。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;foo&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>实际上，Redis 服务器在重启时会读入 AOF 文件，按顺序执行每条命令来还原数据集</p>
</blockquote>
<h3 id="AOF-的特性"><a href="#AOF-的特性" class="headerlink" title="AOF 的特性"></a>AOF 的特性</h3><ul>
<li><p>从配置文件的注释也可以看出 **AOF 持久化比 Redis 持久化更耐用(durability)**。可以设置不同的 fsync 策略</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># appendfsync always    // 每次执行写入命令时 fsync</span><br><span class="line">appendfsync everysec    // 每秒钟一次 fsync</span><br><span class="line"># appendfsync no    // 无 fsync</span><br></pre></td></tr></table></figure>
<p>  默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据</p>
</li>
<li><p>当 Redis 启动时，如果 RDB 持久化和 AOF 持久化都被打开了，那么程序会优先使用 AOF 文件来恢复数据集，因为 <strong>AOF 文件所保存的数据通常是最完整的</strong></p>
</li>
<li><p>AOF 文件有序地保存了对数据库执行的所有写入操作，可读性很高，可用于分析、操作回滚。举个例子，如果你不小心执行了<code>FLUSHALL</code>命令， 但只要 AOF 文件未被重写，那么只要停止服务器，移除 AOF 文件末尾的 <code>FLUSHALL</code>命令，并重启 Redis ，就可以将数据集恢复到<code>FLUSHALL</code>执行之前的状态</p>
</li>
<li><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写，<strong>重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合</strong>。也可以通过<code>BGREWRITEAOF</code>命令手动重写 AOF 文件，因此我们可以做个测试，一直<code>SET</code>和<code>DEL</code>某个 key，在重写后发现 AOF 文件中多余的步骤已被删除</p>
</li>
<li><p>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。在一般情况下，<code>appendfsync everysec</code>性能依然非常高，因为它是性能和数据安全性之间的平衡点。<code>appendfsync always</code>策略在实际使用中非常慢，频繁调用 fsync 注定了这种策略不可能快得起来</p>
</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><blockquote>
<p>一般来说，如果想达到足以媲美 PostgreSQL 的数据安全性，你应该<strong>同时使用两种持久化功能</strong>。有很多用户都只使用 AOF 持久化，但并不推荐这种方式: 因为定时生成 RDB 快照非常便于进行数据库备份，并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。<br>实际上，官方也提出未来可能会将 AOF 和 RDB 整合成单个持久化模型。</p>
</blockquote>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://redis.io/topics/persistence">Redis Persistence — 官网</a></li>
<li><a href="http://doc.redisfans.com/topic/persistence.html">Redis持久化 — 中文文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 安装及初步使用</title>
    <url>/2018/03/15/Redis%E5%AE%89%E8%A3%85%E5%8F%8A%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p><strong>Redis</strong> 是一个开源的使用 ANSI C 语言编写的高性能 <strong>Key-Value</strong> 数据库，是一个<strong>可基于内存亦可持久化的日志型</strong>的 <strong>NoSQL</strong> 数据库。它将数据保存在内存中，在项目中可用于保存编码表、Token 等<strong>少量数据存储，高速读写访问</strong>的场景</p>
</blockquote>
<h2 id="Installing"><a href="#Installing" class="headerlink" title="Installing"></a>Installing</h2><ul>
<li><p>我的服务器系统为 Ubuntu 16.04 ，直接使用 <strong>apt</strong> 安装。当然也可以在<a href="https://redis.io/download">官网</a>下载压缩包解压安装</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install -y redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>Redis 的命令主要有两个，一个是服务端命令<code>redis-server</code>，用于启动 Redis 。还有个客户端命令<code>redis-cli</code>，可用于访问 Redis</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server -v    // 查看版本</span><br><span class="line">redis-server -h    // 查看帮助</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完成后 redis-server 已经启动了，默认端口号 <strong>6379</strong>     </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ps -ef | grep redis</span><br><span class="line">redis    14689     1  0 10:43 ?     00:00:00 /usr/bin/redis-server 127.0.0.1:6379</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意到 Redis 默认启动时只允许本机（即 127.0.0.1）访问，如果要允许其他主机访问或使用 <strong>GUI</strong> 图形化管理工具，可以修改配置文件<code>/etc/redis/redis.conf</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1 =&gt; bind 0.0.0.0</span><br></pre></td></tr></table></figure>
<p>  如果只需某几个 IP 访问 Redis 服务器，可以修改为对应 IP 以增强安全性</p>
</li>
<li><p>修改完成后重启 Redis</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service redis-server restart</span><br></pre></td></tr></table></figure>
<p>  使用<code>service redis-server status</code>命令可以查看 Redis 状态</p>
</li>
</ul>
<h2 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h2><blockquote>
<p><code>redis-cli</code>是客户端程序，可以使用一些命令操作 Redis 数据库，具体命令参考 <a href="https://redis.io/commands">Redis 官网</a>，或者 <a href="http://doc.redisfans.com/">Redis 命令参考</a></p>
</blockquote>
<ul>
<li><p>直接输入<code>redis-cli</code>进入客户端，设置一个键值对</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; set foo &quot;bar&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>redis-cli</code>也可查看 Redis 的配置，使用<code>config get</code>，命令大小写不敏感，可以使用<code>TAB</code>补全</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG GET bind</span><br><span class="line">1) &quot;bind&quot;</span><br><span class="line">2) &quot;0.0.0.0&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以修改配置，比如我们可以设置 Redis 数据库的密码，默认是不设密码的</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG SET requirepass passwd</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET requirepass</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; AUTH passwd</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;passwd&quot;</span><br></pre></td></tr></table></figure>
<p>  修改密码的格式为<code>CONFIG SET requirepass password</code>，修改后需要先登录认证，命令为<code>AUTH password</code></p>
</li>
</ul>
<h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><blockquote>
<p>Mac 下我使用的 Redis 图形化管理工具是 <strong>Redis Desktop Manager</strong></p>
</blockquote>
<ul>
<li><p>输入配置信息连接 Redis 服务器<br><img src="/0.png" alt="99B23802-7EA6-4ECE-9A1F-A63F31624FA0"></p>
</li>
<li><p>连接上后查看我们刚才设置的键值对<br><img src="/1.png" alt="92EF26D6-3278-43C7-BB81-C34D0D6E6DC7"></p>
</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://redis.io/">Redis 官网</a></li>
<li><a href="http://doc.redisfans.com/">Redis 命令参考</a></li>
<li><a href="http://www.redis.net.cn/tutorial/3501.html">Redis 中文网</a></li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 集成 GitHub 第三方认证</title>
    <url>/2018/04/13/Spring%20Cloud%E9%9B%86%E6%88%90GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>最近遇到需要在 Spring Cloud 框架中加入<strong>用户认证</strong>的功能，发现 GitHub 有第三方认证功能，遂先写了个 demo 实现通过 GitHub 三方认证完成用户认证，虽然不是最终解决方案，但是有助于理解用户认证的流程</p>
</blockquote>
<ul>
<li><p>代码沿用之前的 <a href="https://s2mple.xyz/sidecar/">Sidecar – 将Node应用引入Spring Cloud</a> 博客中的代码，用到以下模块</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">─ sidecar-example</span><br><span class="line">   ├── author-service    // 需要认证才能访问的微服务</span><br><span class="line">   ├── eureka-server    // 注册中心</span><br><span class="line">   └── api-gateway    // 网关，一切访问的入口</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>主要修改的是<code>api-gateway</code>，实现效果就是：<strong>用户通过<code>api-gateway</code>访问任何一个微服务，需要先跳转到 GitHub 进行认证，认证通过后才获取访问权限</strong></p>
</blockquote>
<h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><p>在这之前，有一些概念需要先了解</p>
<h3 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h3><blockquote>
<p><strong>SSO</strong>(or <strong>Single Sign On</strong>) <strong>单点登录</strong>，是目前比较流行的企业业务整合的解决方案之一。SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。非常适用于微服务架构，可以实现<strong>在一个微服务应用登录后（通常有专门的认证服务器），即可访问该微服务集群中的所有其他微服务</strong>。</p>
</blockquote>
<h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><blockquote>
<p>大家平时肯定遇到过第三方登录的情况，不知道有没有仔细想过它的流程。假设现在我们用微博账号登录简书</p>
</blockquote>
<ul>
<li><p>最传统的办法是让用户直接在简书的登录页面输微博的账号和密码，简书通过用户的账号和密码去微博那里获取用户数据，但这样做有很多严重的缺点：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简书需要保存用户的微博账号和密码，这样很不安全。</span><br><span class="line">简书拥有了获取用户在微博所有的权限，包括删除好友、给好友发私信、更改密码、注销账号等危险操作。</span><br><span class="line">用户只有修改微博密码，才能收回赋予简书的权限。但是这样做会使得其他所有通过微博登录的第三方应用程序全部失效。</span><br><span class="line">只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有使用微博登录的网站的数据泄漏。</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了解决以上的问题，OAuth 协议应运而生。我们来看一下它的流程</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简书问新浪微博：我想要获取用户 A 的头像和昵称，请你提供</span><br><span class="line">微博说：我需要经过用户Ａ 本人的许可 =&gt; 然后微博询问用户 A 是否要授权简书访问自己的头像和昵称</span><br><span class="line">用户授权后，微博对简书说：我给你一个临时钥匙（Token），你访问我带了这把钥匙，我就把用户的资料给你</span><br></pre></td></tr></table></figure></li>
<li><p>以上流程可由下图表示<br><img src="/0.jpg" alt="291523855245_.pic"></p>
</li>
<li><p>其中最关键的两个部分如下</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">② 用户同意授权给客户端，则认证服务器返回 Code，即授权码</span><br><span class="line">③ 客户端带着 Code，去认证服务器申领 Token</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><blockquote>
<p>以上模式称为授权码模式 (<strong>authorization code</strong>) ，是目前功能最完整、流程最严密的客户端授权模式。它的特点就是通过客户端服务器，与”服务提供商”的认证服务器进行互动</p>
</blockquote>
<ul>
<li><p>步骤如下</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户访问客户端，后者将前者导向认证服务器。</span><br><span class="line">认证服务器询问用户是否给予客户端授权。</span><br><span class="line">若用户给予授权，认证服务器将用户导向客户端事先指定的&quot;重定向URI&quot;（redirection URI），同时附上一个授权码。</span><br><span class="line">客户端收到授权码，附上早先的&quot;重定向URI&quot;，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</span><br><span class="line">认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</span><br></pre></td></tr></table></figure>
<p>  <img src="/1.png" alt="bg2014051204"></p>
</li>
</ul>
<h2 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h2><blockquote>
<p>接下来进入正题，如何基于 GitHub 进行第三方认证。首先，我们需要先前往 GitHub 注册一个新的 OAuth App</p>
</blockquote>
<ul>
<li><p>前往<code>https://github.com/settings/developers</code>点击<code>Register a new application</code>，出现如下界面，填写相应信息。注意，主页和回调的 URL 填写的都是<code>api-gateway</code>的地址<br><img src="/2.png" alt="B2241479-07A7-4E03-BB62-BCA4CDA5A4A3"></p>
</li>
<li><p>注册成功后生成的<code>Client ID</code>和<code>Client Secret</code>是后续需要填写到配置文件中<br><img src="/3.png" alt="C65DDEFD-F282-4F12-A211-938767ECD7DA"></p>
</li>
</ul>
<h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><blockquote>
<p>接下来就是编码<code>api-gateway</code>实现重定位到刚注册的 OAuth App 进行认证</p>
</blockquote>
<ul>
<li><p>添加 Maven 依赖</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在主类上添加<code>@EnableOAuth2Sso</code>注解</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableOAuth2Sso</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了测试过滤情况，我加入了<code>/</code>和<code>/test</code>接口，除此之外，还有<code>/user</code>接口返回 GitHub 个人信息的接口</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;welcome&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">user</span><span class="params">(Principal user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>application.yml</code></p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5555</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:9090/eureka/</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">author-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/author-service/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">author-service</span></span><br><span class="line">    <span class="attr">book-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/book-service/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">node-sidecar</span></span><br><span class="line"></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">ignored:</span> <span class="string">/,/test</span>  <span class="comment"># 认证忽略的接口</span></span><br><span class="line">  <span class="attr">sessions:</span> <span class="string">never</span>   <span class="comment"># session 策略</span></span><br><span class="line">  <span class="attr">oauth2:</span></span><br><span class="line">    <span class="attr">sso:</span></span><br><span class="line">      <span class="attr">loginPath:</span> <span class="string">/login</span>   <span class="comment"># 登录路径</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">      <span class="attr">clientId:</span> <span class="string">554906e366f7861eab21</span></span><br><span class="line">      <span class="attr">clientSecret:</span> <span class="string">e1286e1ac17599c7a8638bb24649e79f5aabddfd</span></span><br><span class="line">      <span class="attr">userAuthorizationUri:</span> <span class="string">https://github.com/login/oauth/authorize</span>   <span class="comment"># 进行用户授权的路径</span></span><br><span class="line">      <span class="attr">accessTokenUri:</span> <span class="string">https://github.com/login/oauth/access_token</span>   <span class="comment"># 获取 token 的路径</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">userInfoUri:</span> <span class="string">https://api.github.com/user</span></span><br><span class="line">      <span class="attr">preferTokenInfo:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><blockquote>
<p>现在就可以进行测试了。陆续启动<code>eureka-server</code>、<code>api-gateway</code>、<code>author-service</code>三个微服务</p>
</blockquote>
<ul>
<li><p>访问<code>localhost:5555/</code>和<code>localhost:5555/test</code>接口，发现均不需要认证，即<code>security.ignored: /,/test</code>配置生效<br><img src="/4.png" alt="1C21C2B8-E689-4BBC-94EE-4ED74796994C"></p>
</li>
<li><p>接下来通过网关访问<code>author-service</code>的接口，正常需要通过 GitHub 认证，事实证明确实如此。访问<code>http://localhost:5555/author-service/author/1</code>接口，跳转到<strong>用户授权</strong>界面<br><img src="/5.png" alt="D2FCA844-1A95-4907-A350-68A21ACCE38C"></p>
</li>
<li><p>确认授权后重定位到<code>/author-service/author/1</code>接口返回数据<br><img src="/6.png" alt="ED7EE656-F376-408D-9DB8-2C6908799A07-1"></p>
</li>
<li><p>还可以访问<code>http://localhost:5555/user</code>来获取 GitHub 账号的信息，这个就不贴图了，自己测试即可</p>
</li>
<li><p>再回到 GitHub 的 OAuth 界面，发现<code>0 user</code>变成<code>1 user</code>了，在此你可以弃用所有的用户 Token 以及重置 Client Secret 密钥<br><img src="/7.png" alt="7E65EF94-3B65-4FE3-B814-29C6B8A54ECF"> </p>
</li>
</ul>
<h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote>
<p>以下分析主要是为了看清重定位、URL 的参数和<code>application.yml</code>中的配置有何关联</p>
</blockquote>
<ul>
<li><p>访问<code>http://localhost:5555/author-service/author/1</code>后，重定位到<code>http://localhost:5555/login</code><br><img src="/8.png" alt="D33AA927-F963-41C7-BE5F-6AA7C4FF09AF"></p>
</li>
<li><p>访问<code>http://localhost:5555/login</code>重定位<code>https://github.com/login/oauth/authorize</code>即 GitHub 的用户授权路径<br><img src="/9.png" alt="E652C938-12A3-4A56-9367-0D07D76B1B66"></p>
</li>
<li><p><code>/login/oauth/authorize</code>这个界面才是用户看到的需要点击授权的页面，我们来看下 URL 携带的参数：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client_id: 554906e366f7861eab21</span><br><span class="line">redirect_uri: http://localhost:5555/login</span><br><span class="line">response_type: code</span><br><span class="line">state: z2MaR7</span><br></pre></td></tr></table></figure></li>
<li><p>用户点击确认授权后，注意此 Token 非彼 Token<br><img src="/10.png" alt="71F69537-2DE4-49BD-AC22-774211576934"></p>
</li>
<li><p>接下来带着 code 和 state 访问<code>http://localhost:5555/login</code>再重定位到<code>http://localhost:5555/author-service/author/1</code>真正想访问的接口<br><img src="/11.png" alt="05DAA887-01B1-42F4-9C20-0820777E7D92"></p>
</li>
</ul>
<blockquote>
<p>事实上，由于申领 Token 这一步是在客户端的后台服务器上完成的，所以对用户不可见。其实客户端在用户点击授权后向<code>https://github.com/login/oauth/access_token</code>发送了一个 POST 请求，并带上<code>client_id</code>、<code>client_secret</code>、上一步获取的<code>code</code>以及<code>redirect_uri</code>等参数，由此来获取<code>access_token</code></p>
</blockquote>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://cloud.spring.io/spring-cloud-security/">Spring Cloud Security - 官网</a></li>
<li><a href="https://developer.github.com/apps/building-oauth-apps/authorization-options-for-oauth-apps/">Authorization options for OAuth Apps</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解 OAuth 2.0 - 阮一峰</a></li>
<li><a href="https://www.jianshu.com/p/0db71eb445c8">OAuth 认证流程详解</a></li>
<li><a href="https://segmentfault.com/a/1190000011098539">Spring Cloud Security 集成 CAS 对微服务认证</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Sidecar -- 将 Node 应用引入 Spring Cloud</title>
    <url>/2018/03/31/Sidecar%20--%20%E5%B0%86Node%E5%BA%94%E7%94%A8%E5%BC%95%E5%85%A5Spring%20Cloud/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>Sidecar 起源于 <a href="https://github.com/Netflix/Prana">Netflix Prana</a>，它的目的是将 <strong>Non-JVM</strong> 语言整合到 Netflix OSS 生态系统中，如今 Spring Cloud 将 Spring Boot 与 Netflix OSS 整合成一套微服务解决框架，大大简化了程序员的开发。而 Sidecar 就是其中的一个衍生物，用于将 Non-JVM 语言，譬如 Node.js、Python 引入至 Spring Cloud 框架中。</p>
</blockquote>
<ul>
<li><p>本文的示例代码已上传至 <a href="https://github.com/s1mplecc/sidecar-example">Github</a></p>
</li>
<li><p>使用 Maven 构建的多模块项目<code>sidecar-example</code>，并将 Node.js 开发的<code>book-service</code>模块拷贝至一个项目中</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 模块结构如下</span><br><span class="line">─ sidecar-example</span><br><span class="line">   ├── author-service   // Java 开发的微服务，用于测试服务间通信</span><br><span class="line">   ├── eureka-server    // 注册中心</span><br><span class="line">   ├── node-sidecar    // Sidecar，用于将 Node 应用引入 Spring Cloud</span><br><span class="line">   └── book-service    // Node.js 开发的微服务</span><br></pre></td></tr></table></figure></li>
<li><p>使用的 Spring Boot 版本及 Spring Cloud 全家桶版本</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Sidecar"><a href="#Sidecar" class="headerlink" title="Sidecar"></a>Sidecar</h2><blockquote>
<p>先来看看引入 Sidecar 需要做些什么</p>
</blockquote>
<ul>
<li><p><strong>添加 Maven 依赖</strong>，很简单，甚至于不需要<code>eureka-client</code>的依赖，因为它已经整合至 Sidecar 的依赖中</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-sidecar<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来是<strong>注解</strong>，在 Sidecar 主类上添加<code>@EnableSidecar</code>注解，我们来看看这个注解包含些什么</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(SidecarConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableSidecar &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  包含了<strong>网关 Zuul</strong> 以及微服务结构中不可或缺的<strong>熔断器 Hystrix</strong></p>
</li>
<li><p>最后是<strong>配置文件</strong>，在<code>application.yml</code>中添加如下配置</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9091</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">node-sidecar</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:9090/eureka/</span></span><br><span class="line"><span class="attr">sidecar:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">  <span class="attr">health-uri:</span> <span class="string">http://localhost:$&#123;sidecar.port&#125;/health</span></span><br></pre></td></tr></table></figure>
<p>  声明服务名和注册中心地址都没什么问题，最核心的就是 sidecar 的几个配置，包括</p>
<ul>
<li><code>sidecar.port</code> 监听的 Node 应用的端口号，</li>
<li><code>sidecar.health-uri</code> Node 应用的健康检查接口的 uri</li>
</ul>
</li>
</ul>
<h4 id="健康检查接口"><a href="#健康检查接口" class="headerlink" title="健康检查接口"></a>健康检查接口</h4><blockquote>
<p>Node.js 的微服务应用<code>book-service</code>我采用的 <strong>Koa</strong> 框架，这里不多赘述，需要注意的是：该应用必须实现一个<code>/health</code>健康检查接口，Sidecar 应用会每隔几秒访问一次该接口，并将该服务的健康状态返回给 Eureka</p>
</blockquote>
<ul>
<li><p>只需要返回<code>&#123; status: &#39;UP&#39; &#125;</code>这样一串 Json 即可</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Koa = require(&#x27;koa&#x27;)</span><br><span class="line">const router = require(&#x27;koa-router&#x27;)()</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line"></span><br><span class="line">// log request URL:</span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`)</span><br><span class="line">  await next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// add routes:</span><br><span class="line">router.get(&#x27;/health&#x27;, async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.response.body = &#123;</span><br><span class="line">    status: &#x27;UP&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// add router middleware:</span><br><span class="line">app.use(router.routes())</span><br><span class="line"></span><br><span class="line">app.listen(3000)</span><br><span class="line">console.log(&#x27;app started at port 3000...&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><blockquote>
<p>到目前为止，Sidecar 和 Node 服务已准备就绪，我们按顺序启动 <strong>eureka-server</strong> =&gt; <strong>book-service</strong> =&gt; <strong>node-sidecar</strong></p>
</blockquote>
<ul>
<li><p>访问 Eureka 的 WebUI <code>http://localhost:9090/</code>，Sidecar 已被注册到 Eureka 上，并且状态为 UP<br><img src="/0.png" alt="B89413D5-130D-4F5D-BB76-7559B6B0A036">如果我们停掉<code>book-service</code>，则<code>node-sidecar</code>的服务状态会变为 Down，显示服务不可用</p>
</li>
<li><p>访问 Sidecar 的首页<code>http://localhost:9091/</code>，提供了三个接口<br><img src="/1.png" alt="A2B5DA24-46A6-40B9-9129-54EC7FA0F329"></p>
</li>
<li><p>访问<code>/health</code>可以得到 Node 应用返回的健康报告</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  访问<code>hosts/node-sidecar</code>可以的到 Sidecar 实例的一些信息</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;port&quot;</span>: <span class="number">3000</span>,</span><br><span class="line">        <span class="attr">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">&quot;instanceInfo&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;instanceId&quot;</span>: <span class="string">&quot;192.168.1.8:node-sidecar:9091&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;app&quot;</span>: <span class="string">&quot;NODE-SIDECAR&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;appGroupName&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;ipAddr&quot;</span>: <span class="string">&quot;192.168.1.8&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;sid&quot;</span>: <span class="string">&quot;na&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;homePageUrl&quot;</span>: <span class="string">&quot;http://localhost:3000/&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;statusPageUrl&quot;</span>: <span class="string">&quot;http://localhost:9091/info&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;healthCheckUrl&quot;</span>: <span class="string">&quot;http://localhost:9091/health&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;secureHealthCheckUrl&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;vipAddress&quot;</span>: <span class="string">&quot;node-sidecar&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;secureVipAddress&quot;</span>: <span class="string">&quot;node-sidecar&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;countryId&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;dataCenterInfo&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;@class&quot;</span>: <span class="string">&quot;com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;MyOwn&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;hostName&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;leaseInfo&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;renewalIntervalInSecs&quot;</span>: <span class="number">30</span>,</span><br><span class="line">                <span class="attr">&quot;durationInSecs&quot;</span>: <span class="number">90</span>,</span><br><span class="line">                <span class="attr">&quot;registrationTimestamp&quot;</span>: <span class="number">1522469074848</span>,</span><br><span class="line">                <span class="attr">&quot;lastRenewalTimestamp&quot;</span>: <span class="number">1522469344919</span>,</span><br><span class="line">                <span class="attr">&quot;evictionTimestamp&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;serviceUpTimestamp&quot;</span>: <span class="number">1522469074848</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;isCoordinatingDiscoveryServer&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">&quot;lastUpdatedTimestamp&quot;</span>: <span class="number">1522469074849</span>,</span><br><span class="line">            <span class="attr">&quot;lastDirtyTimestamp&quot;</span>: <span class="number">1522469044798</span>,</span><br><span class="line">            <span class="attr">&quot;actionType&quot;</span>: <span class="string">&quot;ADDED&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;asgName&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;overriddenStatus&quot;</span>: <span class="string">&quot;UNKNOWN&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;secure&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;uri&quot;</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;serviceId&quot;</span>: <span class="string">&quot;NODE-SIDECAR&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>  可以看到，该实例维护了 Node 应用的访问地址<code>&quot;uri&quot;: &quot;http://localhost:3000&quot;</code>，这也是接下来要说的：其他微服务可以通过 Sidecar 的服务名声明式调用 Node 服务</p>
</li>
</ul>
<h2 id="声明式服务调用"><a href="#声明式服务调用" class="headerlink" title="声明式服务调用"></a>声明式服务调用</h2><blockquote>
<p>以上，我们已经验证了 Eureka 可以通过 Sidecar 间接的管理基于 Node 的微服务。而在微服务体系中，还有非常重要的一点，就是服务间的调用。Spring Cloud 允许我们使用<strong>服务名</strong>进行服务间的调用，摒弃了原先的固定写死的 IP 地址，便于服务集群的横向拓展及维护。那么，Non-JVM 的微服务与其他服务间是否可以通过服务名互相调用呢，答案是可以的。</p>
</blockquote>
<h3 id="被调用"><a href="#被调用" class="headerlink" title="被调用"></a>被调用</h3><blockquote>
<p>我们假设下面一个场景，book-service 提供了根据 bookId 返回对应 book 信息的接口，其中包含 authorId，而 author-service 需要根据该 authorId 获取到对应的作者信息。也就是 author-service 需要访问 book-service 的<code>/book/:bookId</code>接口拿到 authorId</p>
</blockquote>
<ul>
<li><p>先在 book-service 中实现<code>/book/:bookId</code>接口，先固定返回 authorId 为 1</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&#x27;/book/:bookId&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.response.body = &#123;</span><br><span class="line">    <span class="attr">bookId</span>: ctx.params.bookId,</span><br><span class="line">    <span class="attr">authorId</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">description</span>: <span class="string">&quot;This is a book.&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>而在 author-service 中声明式服务调用使用的是 Spring Cloud 整合的 <strong>Feign</strong>，Maven 依赖如下</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>author-service 作为 book-service 服务的调用者，需要声明 Client 接口，代码如下</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;node-sidecar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookServiceClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/book/&#123;bookId&#125;&quot;)</span></span><br><span class="line">    <span class="function">Book <span class="title">getBook</span><span class="params">(<span class="meta">@PathVariable(&quot;bookId&quot;)</span> String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  注意到<code>@FeignClient</code>注解中调用的服务名填写的是 node-sidecar (大小写不敏感)，因为自始至终 Eureka 中注册的是 Sidecar 的信息，而 Sidecar 实例维护了 book-service 的地址信息，所以它可以将请求转发至 book-service</p>
</li>
<li><p>在 author-service 中提供<code>/book/&#123;bookId&#125;/author</code>接口</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BookServiceClient bookServiceClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/book/&#123;bookId&#125;/author&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Author <span class="title">getAuthor</span><span class="params">(<span class="meta">@PathVariable</span> String bookId)</span></span>&#123;</span><br><span class="line">        Book book = bookServiceClient.getBook(bookId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Author(book.getAuthorId(),<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 author-service ，访问<code>http://localhost:9092/book/1/author</code></p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;authorId&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;authorName&quot;</span>: <span class="string">&quot;Jack&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="调用其他微服务"><a href="#调用其他微服务" class="headerlink" title="调用其他微服务"></a>调用其他微服务</h3><blockquote>
<p>其他微服务可以通过 Sidecar 实例的服务名间接调用基于 Node 的 book-service。同样的，book-service 也可以通过服务名调用其他微服务，这要归功于<code>@EnableZuulProxy</code></p>
</blockquote>
<ul>
<li>访问<code>http://localhost:9091/author-service/book/1/author</code>惊讶的发现，这和我们访问<code>http://localhost:9092/book/1/author</code>结果是一样的，这是由于 Sidecar 引入了 Zuul 网关，它可以获取 Eureka 上注册的服务的地址信息，从而进行路由跳转<br><img src="/2.png" alt="A44BC958-7050-4530-8855-7F0042A6C32F"></li>
</ul>
<blockquote>
<p><strong>Tips:</strong> Spring Cloud Zuul 通过与 Eureka 的整合，将自身注册为 Eureka 服务治理下的应用，同时从 Eureka 获取其他所有微服务的示实例信息。对于路由规则的维护，Zuul 默认会将服务名作为 ContextPath 的方式创建路由映射</p>
</blockquote>
<ul>
<li><p>那接下来就简单了，先在 author-service 中添加一个接口返回作者描述</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/author/&#123;authorId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthorDescription</span><span class="params">(<span class="meta">@PathVariable</span> String authorId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;This is an author description of &quot;</span> + authorId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>再在 book-service 中添加 book 的详细信息接口，需要去调用上述的作者描述接口</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> SIDECAR_URI = <span class="string">&#x27;http://localhost:9091&#x27;</span></span><br><span class="line"><span class="keyword">const</span> AUTHOR_SERVICE = <span class="string">&#x27;author-service&#x27;</span></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/book/:bookId/detailed&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> axios.get(<span class="string">`<span class="subst">$&#123;SIDECAR_URI&#125;</span>/<span class="subst">$&#123;AUTHOR_SERVICE&#125;</span>/author/1`</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    ctx.response.body = &#123;</span><br><span class="line">      <span class="attr">bookId</span>: ctx.params.bookId,</span><br><span class="line">      <span class="attr">authorId</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">      <span class="attr">authorDescription</span>: res.data,</span><br><span class="line">      <span class="attr">description</span>: <span class="string">&#x27;This is a book.&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>, error))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>  这里采用的 author-service 服务名去访问的该服务，而不是固定的 IP 地址，格式为<code>$&#123;SIDECAR_URI&#125;/$&#123;AUTHOR_SERVICE&#125;</code></p>
</li>
<li><p>访问<code>http://localhost:3000/book/1/detailed</code></p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;bookId&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;authorId&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;authorDescription&quot;</span>: <span class="string">&quot;This is an author description of 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;This is a book.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Api-Gateway"><a href="#Api-Gateway" class="headerlink" title="Api-Gateway"></a>Api-Gateway</h2><blockquote>
<p>后来我又加入了<code>api-gateway</code>去验证网关能否通过<code>node-sidecar</code>的服务名去将访问 API 的请求转发到<code>book-service</code>，事实证明确实是可以的</p>
</blockquote>
<ul>
<li><p><code>api-gateway</code>的 Maven 依赖</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>需要在主类上加上<code>@EnableZuulProxy</code> Zuul 网关和<code>@EnableDiscoveryClient</code>注解</p>
</li>
<li><p>配置文件</p>
<pre><code class="yml">spring:
  application:
    name: api-gateway
server:
  port: 5555
  context-path: /
eureka:
  instance:
    hostname: localhost
  client:
    serviceUrl:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:9090/eureka/
zuul:
  routes:
    author-service:
      path: /author-service/**
      serviceId: author-service
    book-service:
      path: /book-service/**
      serviceId: node-sidecar
</code></pre>
</li>
<li><p>访问<code>http://localhost:5555/book-service/book/1</code>，在接口层面，<code>node-sidecar</code>其实是不可见的，访问的还是<code>book-service</code>的 API<br><img src="/3.png" alt="WX20180403-110158">  </p>
</li>
<li><p>由此，如果<code>book-service</code>需要横向拓展为一个集群，无非是多创建几个对应的 Sidecar 应用，它们的服务名只要是一样的，那就可以通过网关去实现负载均衡，甚至我第二个<code>book-service</code>用 Python 写也没有问题</p>
</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><blockquote>
<p>由此，基于 Non-JVM 语言的微服务，通过 Sidecar ，实现了服务向 Eureka 的注册与健康检查，并且可以通过服务名进行服务间调用。基本上可以说 Non-JVM 应用通过 Sidecar 完美的融入了 Spring Cloud 生态圈。</p>
</blockquote>
<ul>
<li>附上一张架构图<br><img src="/4.png" alt="sidecar"></li>
</ul>
<h2 id="Preferences"><a href="#Preferences" class="headerlink" title="Preferences"></a>Preferences</h2><ul>
<li><a href="https://github.com/marshalYuan/spring-cloud-example/blob/master/docs/sidecar.md">使用 Sidecar 将 Node.js 引入 Spring Cloud</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 配置</title>
    <url>/2017/12/02/Vim%20%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>全局配置 <strong>/usr/share/vim/vimrc</strong>，不建议修改。建议修改当前用户配置 <strong>~/.vimrc</strong>，加载配置时会覆盖全局配置。</p>
</blockquote>
<ul>
<li>我的Vim配置，我只是轻量级用户，不像某些大佬（变态）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">syntax on</span><br><span class="line"><span class="built_in">set</span> smartindent</span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="built_in">set</span> expandtab</span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> ic <span class="string">&quot;搜索忽略大小写</span></span><br><span class="line"><span class="string">set hlsearch</span></span><br><span class="line"><span class="string">set incsearch</span></span><br><span class="line"><span class="string">set number</span></span><br><span class="line"><span class="string">set ruler</span></span><br><span class="line"><span class="string">set cursorline</span></span><br><span class="line"><span class="string">set nocompatible &quot;</span>关闭vi兼容</span><br><span class="line"><span class="built_in">set</span> nowrap <span class="string">&quot;关闭超屏自动换行</span></span><br><span class="line"><span class="string">set encoding=utf-8</span></span><br><span class="line"><span class="string">set fileencodings=utf-8,ucs-bom,GB2312,big5</span></span><br><span class="line"><span class="string">filetype plugin indent on</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap . $</span></span><br><span class="line"><span class="string">nnoremap , ^</span></span><br><span class="line"><span class="string">nnoremap &lt;F2&gt; :set number!&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap &lt;F3&gt; :exec exists(&#x27;syntax_on&#x27;) ? &#x27;syn off&#x27; : &#x27;syn on&#x27;&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap &lt;F4&gt; :set wrap!&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap &lt;F5&gt; :set hlsearch!&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>自动补全</span><br><span class="line">:inoremap ( ()&lt;ESC&gt;i</span><br><span class="line">        :inoremap ) &lt;c-r&gt;=ClosePair(<span class="string">&#x27;)&#x27;</span>)&lt;CR&gt;</span><br><span class="line">:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O</span><br><span class="line">    :inoremap &#125; &lt;c-r&gt;=ClosePair(<span class="string">&#x27;&#125;&#x27;</span>)&lt;CR&gt;</span><br><span class="line">    :inoremap [ []&lt;ESC&gt;i</span><br><span class="line">    :inoremap ] &lt;c-r&gt;=ClosePair(<span class="string">&#x27;]&#x27;</span>)&lt;CR&gt;</span><br><span class="line">    :inoremap <span class="string">&quot; &quot;</span><span class="string">&quot;&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">    :inoremap &#x27; &#x27;&#x27;&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">function! ClosePair(char)</span></span><br><span class="line"><span class="string">    if getline(&#x27;.&#x27;)[col(&#x27;.&#x27;) - 1] == a:char</span></span><br><span class="line"><span class="string">    return &quot;</span>\&lt;Right&gt;<span class="string">&quot;</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">    return a:char</span></span><br><span class="line"><span class="string">    endif</span></span><br><span class="line"><span class="string">    endfunction</span></span><br></pre></td></tr></table></figure>

<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul>
<li>主要设置语法高亮、智能缩进、高亮搜索、显示行号、编码格式</li>
<li>配置快捷键映射，<code>,</code>跳转到行首<code>.</code>跳转到行尾，<code>F2</code>开关显示行号，<code>F3</code>开关语法高亮，<code>F4</code>开关超屏换行，<code>F5</code>开关高亮搜索</li>
<li><code>nnoremap</code>中n表示<strong>normal</strong>模式，i表示<strong>insert</strong>模式，nore表示<strong>no recursion</strong>非递归映射，<code>&lt;CR&gt;</code>表示回车</li>
<li>最后是设置智能补全</li>
<li><strong>.rc(run commands)</strong> 文件，通常在程序的启动阶段被调用</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="https://www.zhihu.com/question/20151659">到底 VIM 能配置到多强大的程度？</a><br><a href="http://blog.guorongfei.com/2015/08/31/vim-basic/">利器系列之 —— 编辑利器 Vim 之基础配置</a>，非常好的博客，推荐关注</li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP 协议</title>
    <url>/2018/01/02/TCP%EF%BC%8FIP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>最近在看 <strong>《鸟哥的Linux私房菜–服务器架设》</strong> 这本书，感觉受益匪浅，特别是关于网络、各种协议、安全等方面的知识讲得比较透彻。所以整理了一篇博客，也算顺便温习一遍上学时计算机网络学的知识 </p>
</blockquote>
<ul>
<li>本片博客主要介绍 <strong>TCP/IP</strong> 协议及各层之间的职责</li>
<li>图片使用微软的 <strong>Office Lens</strong> 拍取鸟哥书中图片截取而来</li>
</ul>
<hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li><p>最初，网络的数据传递被划分为如下七个层次，亦即 <strong>OSI七层协议</strong> (or <strong>Open System Interconnection</strong>)<br><img src="/0.JPG" alt="IMG_0058-3"></p>
</li>
<li><p>可以看到，数据包从一个应用程序传递到网络上的另一个应用程序，是一层一层传递的过程，<strong>每一层只认识对方相同层级的数据</strong>，而<strong>数据头</strong>(<strong>Header</strong>)就包含了互相认识的信息，所以<strong>数据自顶向下被层层Header包裹起来</strong>，最后在物理介质上传输</p>
</li>
</ul>
<blockquote>
<p>通俗理解，网络协议干的事就是让数据能<strong>精确投递</strong>到另一个人手中，你比如说网络层的<strong>IP数据包</strong>的 <strong>Header</strong> 就包含了源IP地址、目的IP地址等信息，再比如传输层的源端口号、目的端口号</p>
</blockquote>
<ul>
<li><p>而如今的 <strong>TCP/IP协议</strong> 是由 <strong>OSI七层协议</strong> 简化而来的<br><img src="/1.JPG" alt="IMG_0059"></p>
</li>
<li><p>实际上就是简化合并了一些没那么重要的层，相反，从 <strong>TCP/IP</strong> 的命名就可以看出<strong>传输层</strong>和<strong>网络层</strong>的重要性</p>
</li>
</ul>
<hr>
<h2 id="Link-Layer"><a href="#Link-Layer" class="headerlink" title="Link Layer"></a>Link Layer</h2><blockquote>
<p>网络接口层需要知道的就是<strong>MAC数据帧</strong>，能被网络接口设备（即网卡）处理的数据包裹，也是最终物理层编码成比特流的数据</p>
</blockquote>
<ul>
<li><p>以太网（<strong>Ethernet</strong>）是现有局域网采用的最通用的通信协议标准，主要定义了局域网内的传输协议（比如<strong>CSMA/CD</strong>），还有数据帧的格式、大小等。以太网的传输主要就是网卡对网卡的传输</p>
</li>
<li><p>数据从一个网卡出，以<strong>数据帧(frame)</strong> 在链路上传递，再从另一个网卡进，所以<strong>MAC数据帧</strong>必须包含了来源和目标的网卡卡号<br><img src="/2.png" alt="C7A05D1BF522B158CE16E65E6BED7209"></p>
</li>
<li><p><strong>MAC地址</strong>(or <strong>Media Access Control</strong>)，其实指的就是网卡卡号(<strong>Hardware Address</strong>，硬件地址)，每张以太网卡出厂就会有个独一无二的卡号</p>
</li>
<li><p>可以看到我的 <strong>MAC地址</strong>，以及 <strong>MTU</strong>(or <strong>Maximum Transmission Unit</strong>)为1500，也就是说一个数据帧最大传输 <strong>1500bytes</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">    ether 8c:85:90:85:e3:c7 </span><br></pre></td></tr></table></figure>
<p>  <img src="/3.png" alt="Screen-Shot-2018-01-02-at-9.58.18-PM"></p>
</li>
</ul>
<hr>
<h2 id="Internet-Layer"><a href="#Internet-Layer" class="headerlink" title="Internet Layer"></a>Internet Layer</h2><blockquote>
<p>在网络层传输的是<strong>IP数据包</strong>，<strong>IP</strong> 的全称是 <strong>Internet Protocol</strong> ，目前有<strong>IPv4</strong>和<strong>IPv6</strong>两个版本，本文涉及的为<strong>IPv4</strong></p>
</blockquote>
<ul>
<li><p>IP数据包的 <strong>Header</strong>，<strong>Version</strong> 版本（如IPv4），<strong>Total Length</strong> 该IP数据包总长度，最长 <strong>2^16-1</strong> 即 <strong>65535 bytes</strong>（字节为单位）<br><img src="/4.JPG" alt="IMG_0061-1"></p>
</li>
<li><p><strong>Identification</strong>辨识码，IP数据包会被封装成数据帧在网络上传输，那就一定不能大于数据帧的 <strong>MTU</strong> ，如果IP数据包超过数据帧的最大长度，则需要分片，辨识码用于<strong>辨识、重组</strong>属于同一数据包的IP数据包</p>
</li>
<li><p><strong>Time To Live</strong>( or <strong>TTL</strong>)存活时间，最大255，每经过一个路由器<strong>减一</strong>，为0时该IP数据包将会被直接抛弃</p>
</li>
<li><p><strong>Protocol Number</strong>协议代码，用于记录数据包使用的协议，常见的有 <strong>TCP、UDP、ICMP</strong><br><img src="/5.jpg" alt="498ADD4210B624434245C9BFF2F58F6A"></p>
</li>
</ul>
<h3 id="IP-Address"><a href="#IP-Address" class="headerlink" title="IP Address"></a>IP Address</h3><blockquote>
<p>我们经常说的<strong>IP地址</strong>相当于主机在网络中的<strong>身份号码</strong>。因为是IPv4，所以是32位地址，我们平时用 <strong>“ . “</strong> 分隔每8位，再用十进制表示，所以才有了类似 <strong>192.168.0.1</strong> 这种IP地址，IPv4 可表示 <strong>0.0.0.0 ~ 255.255.255.255</strong> 共 <strong>2^32</strong> 个IP地址</p>
</blockquote>
<ul>
<li>IP由<strong>网段号(Net_ID)</strong> 和<strong>主机号(Host_ID)</strong> 组成，<strong>Net_Id</strong> 相同意味着处于同一物理网络中，<strong>Host_ID</strong> 区分该网络中的不同主机</li>
</ul>
<h4 id="IP-分组"><a href="#IP-分组" class="headerlink" title="IP 分组"></a>IP 分组</h4><ul>
<li><p>IP被分组用于不同范围的网络，通常我们会接触到的是<strong>A、B、C</strong>三组，以 <strong>Net_ID</strong> 前几位区别</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Class A : 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==&gt; Net_ID 的开头是 <span class="number">0</span></span><br><span class="line">          |--net--|---------host------------|</span><br><span class="line">Class B : 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==&gt; Net_ID 的开头是 <span class="number">10</span></span><br><span class="line">          |------net-------|------host------|</span><br><span class="line">Class C : 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  ==&gt; Net_ID 的开头是 <span class="number">110</span></span><br><span class="line">          |-----------net-----------|-host--|</span><br></pre></td></tr></table></figure>
</li>
<li><p>从A到C随着 <strong>Net_ID</strong> 位数减少和 <strong>Host_ID</strong> 位数增加，意味着该组网络上的可用子网（主机）数减少，网络的作用范围变小，比如 <strong>Class B</strong> 常用于企业网络，<strong>Class C</strong> 常用于家庭网络</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class A :   0.xx.xx.xx ~ 127.xx.xx.xx</span><br><span class="line">Class B : 128.xx.xx.xx ~ 191.xx.xx.xx</span><br><span class="line">Class C : 192.xx.xx.xx ~ 223.xx.xx.xx</span><br></pre></td></tr></table></figure>
</li>
<li><p>私有 IP 也分别在 A, B, C 三个 Class 当中各保留一段作为私有 IP 网段</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class A：10.0.0.0    ~ 10.255.255.255</span><br><span class="line">Class B：172.16.0.0  ~ 172.31.255.255</span><br><span class="line">Class C：192.168.0.0 ~ 192.168.255.255</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Network、Broadcast、Netmask"><a href="#Network、Broadcast、Netmask" class="headerlink" title="Network、Broadcast、Netmask"></a>Network、Broadcast、Netmask</h4><ul>
<li><p>通常 <strong>Host_ID</strong> 全为 0 用来表示整个网段的地址 **(Network IP)**，比如 <strong>192.168.0.0</strong></p>
</li>
<li><p><strong>Host_ID</strong> 全为 1 则表示为广播的地址 <strong>(Broadcast IP)</strong> ，广播可用于对局域网中所有主机传递数据，比如 <strong>192.168.0.255</strong></p>
</li>
<li><p><strong>Netmask(子网掩码)</strong> 标识了<strong>Net_ID</strong> 占用位数和可使用的 <strong>Host_ID</strong> 位数，比如 <strong>192.168.0.0 ~ 192.168.0.255</strong> 这个 <strong>Class C</strong> 网络，它的子网掩码就是 <strong>255.255.255.0</strong>，这个网络也可以 <strong>192.168.0.0/24</strong> 这样表示，格式为<code>网段地址/Net_ID位数</code>，比如 <strong>0.0.0.0/0</strong> 代表全网段</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">11000000.10101000</span><span class="number">.00000000</span><span class="number">.00000000</span>      Network:   <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="number">11000000.10101000</span><span class="number">.00000000</span><span class="number">.11111111</span>      Broadcast: <span class="number">192.168</span><span class="number">.0</span><span class="number">.255</span></span><br><span class="line">|----------Net_ID---------|-host--|</span><br></pre></td></tr></table></figure></li>
<li><p>还可以继续进行子域的切分，比如 <strong>192.168.0.0 ~ 192.168.0.255</strong> 中拿出一位 <strong>Host_ID</strong> 作为 <strong>Net_ID</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11000000.10101000.00000000.0 0000000</span><br><span class="line">11000000.10101000.00000000.1 0000000</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样就划分出了两个子网，表示方式为 <strong>192.168.0.0/25</strong> 和 <strong>192.168.0.128/25</strong>，每个子网下可分配<code>2^7</code>个 Host</p>
</li>
</ul>
<h4 id="Loopback-IP"><a href="#Loopback-IP" class="headerlink" title="Loopback IP"></a>Loopback IP</h4><blockquote>
<p>除了预留的私有 IP 网段外，还预留了内部回环网段 <strong>127.0.0.0/8</strong>，默认的主机 <strong>(localhost)</strong> 的IP是 <strong>127.0.0.1</strong>，不需要网卡即可访问</p>
</blockquote>
<ul>
<li><p>这个在查看<code>/etc/hosts</code>时可以看到这一行，IPv6 用<code>::1</code>表示</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1	localhost</span><br><span class="line">255.255.255.255	broadcasthost</span><br><span class="line">::1             localhost</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行<code>ifconfig</code>看到的<code>lo0</code>也是回环地址的相关信息</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ ifconfig </span><br><span class="line">lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384</span><br><span class="line">    options=1203&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt;</span><br><span class="line">    inet 127.0.0.1 netmask 0xff000000 </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Gateway-Router"><a href="#Gateway-Router" class="headerlink" title="Gateway/Router"></a>Gateway/Router</h3><blockquote>
<p>网关/路由器的功能就是负责<strong>不同网络间</strong>的数据包传递 **(IP Forwarding)**，也就是不同 <strong>Net_ID</strong> 的网络间进行数据包的转发</p>
</blockquote>
<ul>
<li>每台主机或者路由器内部都会维护一个<strong>路由表(Route table)</strong> ，发送 IP 数据包时查询该表。若目标 IP 与本机 IP 的 <strong>Net_ID</strong> 相同时（同一网络），则会直接通过局域网将数据包传送给目标主机。若不属于同一网络，则查询是否有相符合的设置，如果还没有，则将数据包发往<strong>默认网关(Default Gateway)</strong></li>
</ul>
<h4 id="Route-Table"><a href="#Route-Table" class="headerlink" title="Route Table"></a>Route Table</h4><ul>
<li><p>在 Ubuntu 下执行<code>route</code>，或者 Mac 中执行<code>netstat -nr</code>可以查看路由表</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         192.168.1.253   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      *               255.255.0.0     U     0      0        0 docker0</span><br><span class="line">127.0.0.1       *               255.0.0.0       U     0      0        0 lo0</span><br><span class="line">192.168.1.0     *               255.255.255.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>➤ <strong>Destination</strong> 就是目标网络的 <strong>Net_ID</strong><br>➤ <strong>Gateway</strong> 是对应的网关，可以看到我的默认网关为 <strong>192.168.1.253</strong> ，由于 <strong>Host_ID</strong> 全为 0 或 1 被 <strong>Network</strong> 和 <strong>Broadcast</strong> 占用，一般网关设置为最后几个可用 IP，<strong>Gateway</strong> 为 <strong>*</strong> 或者 <strong>0.0.0.0</strong> 表示数据包传输到该网络不需要通过网关，比如内网、回环<br>➤ <strong>Genmask</strong> 就是子网掩码，与 <strong>Destination</strong> 一起标识目的主机或者路由器所在的网段的地址<br>➤ <strong>Iface</strong>(or <strong>Interface</strong>)，IP数据包将从哪个网卡接口转发<br>➤ <strong>Flags</strong>，标识位，<strong>U</strong> 表示该路由可用、<strong>G</strong> 表示需要经由 <strong>Gateway</strong></p>
</blockquote>
</li>
</ul>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><blockquote>
<p><strong>DHCP</strong>( or <strong>Dynamic Host Configuration Protocol</strong>，<strong>动态主机配置协议</strong>)是一个局域网的网络协议，使用UDP协议工作，可以给内部网络自动分配IP地址</p>
</blockquote>
<ul>
<li>现在再看电脑上网络设置相关字段应该都明白其意思了<br><img src="/6.png" alt="861DECFB-DB0E-4863-A958-4448C560B145"></li>
</ul>
<hr>
<h2 id="Transport-Layer"><a href="#Transport-Layer" class="headerlink" title="Transport Layer"></a>Transport Layer</h2><blockquote>
<p>网络层的 IP 数据包只负责将数据送到正确的目标主机去，但这个数据包有没有被正确接收就是传输层的任务了，传输层常见协议有两个，一个是<strong>可靠的、面向连接</strong>的 <strong>TCP</strong> 协议，一个是<strong>不可靠的、无连接</strong>的 <strong>UDP</strong> 协议</p>
</blockquote>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul>
<li>TCP 数据包的报头<br><img src="/7.JPG" alt="IMG_0091"></li>
</ul>
<blockquote>
<p>➤ <strong>Source Port、Destination Port</strong>，源端口号、目的端口号，用于区分数据包到底发往哪个应用程序。端口号 16 位，也就是说最大 65535<br>➤ <strong>Sequence Number</strong>(数据包序号)，TCP数据包要被装入IP数据包中，如果过大也需要分段，该字段记录每个数据包的序号用于<strong>重组</strong><br>➤ <strong>Acknowledge Number</strong>(响应序号)，用于确认之前传递的数据包已被正确接收下<br>➤ <strong>Code</strong>(or <strong>Control Flag</strong>，<strong>状态控制码</strong>)有 6 位，表示 6 个不同的属性，为 1 则为真。主要关心的有下面两个：<strong>ACK</strong>(or <strong>Acknowledge</strong>)若为 1，代表该数据包为<strong>响应数据包</strong>；<strong>SYN</strong>(or <strong>Synchronous</strong>)若为 1，表示发送端希望双方建立同步处理，即<strong>建立连接</strong> </p>
</blockquote>
<ul>
<li>常见端口号<br><img src="/8.JPG" alt="IMG_0095"></li>
</ul>
<h4 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h4><blockquote>
<p>TCP 协议正是通过<strong>三次握手协议</strong>了来确认两个主机的连接</p>
</blockquote>
<p><img src="/9.JPG" alt="IMG_0096"></p>
<blockquote>
<p>如图，假设左边是客户端，右边是服务器端。<br>➠ 客户端向服务端发送一个 TCP 数据包，并请求连接 <strong>(SYN = 1)<strong>，数据包序号为 10001<br>➠ 当服务器接到客户端的数据包后回传一个同时带有 <strong>(SYN=1, ACK=1)</strong> 的封包，表示</strong>确认收到，也请求客户端连接</strong>。其中 <strong>Acknowledge</strong> 是要给客户端确认用的，所以该数字比 <strong>Sequence Number</strong> 多一号 <strong>(ack = 10001 + 1 = 10002)</strong> 。而服务器也必须要确认客户端接收到服务器的数据包才行，所以也会随机产生一个 <strong>(seq = 20001)</strong> 发送给客户端<br>➠ 当客户端收到来自服务器端的 <strong>(ack = 10002)</strong> 就能够确认之前的数据包被正确接受了，同时发送一个数据包 <strong>(ACK = 1, ack = 20002)</strong> 给服务器表示确认收到服务端的数据包<br>➠ 服务器收到数据包后确认无误即可与客户端建立连接</p>
</blockquote>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><blockquote>
<p>TCP 面向连接，需要三次握手，传输的成本较高，并且还会有严密的检测机制，不符合要求的数据包会请求重传，所以是<strong>可靠传输</strong>。而与 TCP 不同，UDP 不提供可靠的传输模式，没有 TCP 的三次握手，传输的消耗自然较低，所以 UDP 适用与视频、音频等<strong>实时性</strong>要求较高，但数据<strong>准确性</strong>要求较低的场合</p>
</blockquote>
<ul>
<li><p>UDP数据包的报头就很简单了<br><img src="/10.JPG" alt="IMG_0098-1"></p>
</li>
<li><p>另外，很多的软件其实是同时提供 TCP 与 UDP 的传输协议的，举例来说，查询主机名的 DNS 服务就同时提供了 UDP/TCP 协议。由于 UDP 较为快速，会先使用 UDP 进行传输，当使用 UDP 无法取得正确的数据时，便转换为较为可靠的 TCP 传输。这样可以同时兼顾快速与可靠的传输</p>
</li>
</ul>
<hr>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><blockquote>
<p><strong>DNS</strong>(or <strong>Domain Name System，域名解析系统</strong>)，需要有专门的 <strong>DNS</strong> 主机用于保存<strong>域名</strong>与 <strong>IP</strong> 的对应关系，一般我们连接上网络后，运营商会提供他们的<strong>DNS服务器</strong>，这样我们输入的<code>www.baidu.com</code>才会转换成对应的IP地址</p>
</blockquote>
<ul>
<li><p>查看主机的 <strong>DNS</strong> 设置，一般保存在<code>/etc/resolv.conf</code>中</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 192.168.0.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>该文件在你连接网络时会自动生成，不同的网络会有不同的 <strong>DNS</strong> 设置，比如我的阿里云服务器的配置如下，这就是阿里内部的DNS服务器的IP了</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)            </span><br><span class="line">#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN</span><br><span class="line">nameserver 100.100.2.136</span><br><span class="line">nameserver 100.100.2.138</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Trunk Based Development 主干开发模型</title>
    <url>/2018/09/27/Trunk%20Based%20Development%20%E4%B8%BB%E5%B9%B2%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>在之前的博文中我们介绍了 Git Flow 分支模型，正如文中所说，Git Flow 偏向于控制管理，使用了较多的分支，流程颇为复杂。大量的团队在实践过程中也遇到了颇多问题，其中大部分来自长期存在的分支。随着软件开发模型的演进，GitHub Flow、Trunk Based Development 等模型也应运而生，也已被 Google、Facebook、TW 等企业实践。本文主要介绍 TBD 模型。</p>
</blockquote>
<h2 id="Git-Flow的问题"><a href="#Git-Flow的问题" class="headerlink" title="Git Flow的问题"></a>Git Flow的问题</h2><ul>
<li><p><strong>合并冲突</strong>，合并冲突在使用 Git Flow 是非常常见的。原因很简单：如果你有多个并行功能分支，他们长时间存在，那么很可能代码库的相同部分在两个功能分支中被分别更改。合并冲突不仅对于需要手动解决的开发人员来说是令人沮丧的，也增加了在代码中破坏某些功能的风险，因为当你不得不决定使用哪个版本代码时，很容易犯错。</p>
</li>
<li><p><strong>功能分离</strong>，在合并到同一个分支之前，你不能测试两个功能的组合。当你在单独的分支中开发几天甚至几周的功能时，当合并回主分支后，可能也会发生两个功能的相互作用影响了你的代码。</p>
</li>
<li><p><strong>并没有做到持续交付</strong>，在 Git Flow 分支模型下，发布是非常有计划的，一个 feature 必须要经过一系列步骤才能到达生产环境，在时间上平均一个 feature 都要等待 两周时间才能长线，这样的等待并非是需求上的“按计划发布”，而是从技术上就造成了发布瓶颈，显然难以达到持续交付的要求。</p>
</li>
<li><p><strong>与持续集成相悖</strong>，你会发现，在坚持持续集成实践的情况下，feature 分支是一件非常矛盾的事情。持续集成鼓励更加频繁的代码集成和交互，让冲突越早解决越好。feature 分支的代码隔离策略却在尽可能推迟代码的集成。</p>
</li>
</ul>
<h2 id="GitHub-Flow"><a href="#GitHub-Flow" class="headerlink" title="GitHub Flow"></a>GitHub Flow</h2><blockquote>
<p><a href="https://guides.github.com/introduction/flow/">GitHub Flow</a> 是一个更轻量级的软件开发模型，示意图如下。它摒弃了 Git Flow 中繁杂的分支，<strong>只保留一个主分支 master</strong>。开发新功能时从 master 分支上拉取 feature 分支，开发完成后发起 <strong>Pull-Request</strong>，小组内进行评审和反馈，此时也进行 <strong>Code Review</strong>。测试通过后合并回主分支。</p>
</blockquote>
<p><img src="/0.png" alt="GitHub-Flow2-1"></p>
<p>相比于 Git Flow，这种方式因为省去了一些分支而降低了复杂度，同时也更符合持续集成的思想，以一张故事卡为集成的最小单位，相对来说集成的周期短，反馈的速度也快，能够及早的遇到问题并及早解决。</p>
<p>顺着持续集成的思想，如果我们把 GitHub Flow 分支模型做得再极致一点，我们不要 feature 分支，或者把 feature 分支只留在本地；不需要使用 Pull-Request 而是直接 Push 到远程 master 分支，我们就做到了 Trunk based Development。</p>
<h2 id="TBD"><a href="#TBD" class="headerlink" title="TBD"></a>TBD</h2><blockquote>
<p><strong>Trunk based Development</strong>，又叫<strong>主干开发</strong>，是一套代码分支管理策略，开发人员之间通过约定向被指定为<strong>主干</strong>的分支提交代码，以此抵抗因为长期存在的多分支导致的开发压力。此举可<strong>避免分支合并的困扰，保证随时拥有可发布的版本</strong>。“主干”这个词隐喻了树木生长的场景，树木最粗最长的部位是主干，分支从主干分离出来但是长度有限。</p>
</blockquote>
<p><img src="/1.jpg" alt="what_is_trunk"></p>
<p>使用主干开发后，我们的代码库原则上就只能有一个 Trunk 分支即 master 分支了，所有新功能的提交也都提交到 master 分支上，保证每次提交后 master 分支都是可随时发布的状态。没有了分支的代码隔离，测试和解决冲突都变得简单，持续集成也变得稳定了许多，但也有如下几个问题：</p>
<ul>
<li><p><strong>如何避免发布引入未完成 Feature</strong>，答案是使用 <strong>Feature Toggle</strong>。在代码库里加一个特性开关来随时打开和关闭新特性是最容易想到的也是最容易被质疑的解决方案。Feature Toggle 是有成本的，不管是在加 Toggle 时的代码设计，还是在移除 Toggle 时的人力成本和风险，都是需要和它带来的价值进行衡量的。</p>
</li>
<li><p><strong>如何进行线上 Bug Fix</strong>，答案是在发布时打上 Release Tag，一旦发现这个版本有问题，如果此时 master 分支还没有其他提交，那可以直接在 master 分支上 Hot Fix 然后合并至 release 分支；如果 master 分支已经有了提交就需要做以下三件事：</p>
<ul>
<li>从 Release Tag 创建发布分支。</li>
<li>在 master 上做 Fix Bug 提交。</li>
<li>将 Fix Bug 提交 <strong>Cherry Pick</strong> 到 release 分支。</li>
<li>为 release 分支打上新的 Tag 并做一次发布。</li>
</ul>
</li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>主干开发是助力实现<strong>持续集成</strong>和<strong>持续交付</strong>的关键因素。开发团队的成员一天多次地将代码提交到主干分支，满足了持续交付的必要条件。团队的工作在 24 小时内就可以被整合，这保证了代码版本随时处于可发布状态，使得持续交付成为可能。</p>
</li>
<li><p>你可以选择直接向主干分支提交代码的方式（适用于小团队）或者采用 Pull-Request 的方式，只要保证特性分支不能长期存在，并且产品是独立存在的。</p>
</li>
<li><p>根据团队规模和提交频率，<strong>特性分支可用于合并到主干分支前的代码审查和持续集成</strong>。这些特性分支可以让开发人员在代码合并到主干分支之前进行持续审查，而对于较小规模的团队，则可以直接向主干分支提交。</p>
</li>
<li><p>根据预期的发布频率，你的团队或许需要实时从主干分支创建<strong>发布分支</strong>以确保发布版本不会有新的提交，这些分支应该在发布完成后一段时间内删除。另一方面，你的团队也可以选择从主干分支发布而不需要发布分支，并采用“<strong>修复前进（fix forward）</strong>”的策略进行 bug fix，这种发布策略适用于高吞吐量的团队（high-throughput teams）。</p>
</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://cn.trunkbaseddevelopment.com/">TBD中文官网</a></li>
<li><a href="https://www.duyidong.com/2017/10/29/trunk-base-development/#Github-Flow">分支模型与主干开发</a></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>npm、nrm、nvm的使用以及Mac下如何管理Node版本</title>
    <url>/2017/12/27/npm%E3%80%81nrm%E3%80%81nvm%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8AMac%E4%B8%8B%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86Node%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><blockquote>
<p>npm(node依赖包管理器，node package manager)，官方或权威机构提供了一个公共的软件源（类似 Homebrew、yum），可方便我们下载并管理 JavaScript 依赖</p>
</blockquote>
<p>安装了 node 就包含了 npm 的安装</p>
<p>安装依赖，<code>-g</code>参数表示全局安装，不带参数则安装在当前目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install lodash</span><br><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure>

<p>可查看已安装的全局依赖（默认安装到 <code>/usr/local/lib/node_modules</code> 目录下），<code>--depth</code>显示的树深度，不加<code>-g</code>参数查看当前目录安装的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ npm ls -g --depth=0</span><br><span class="line">/usr/local/lib</span><br><span class="line">├── npm@5.6.0</span><br><span class="line">├── nrm@1.0.2</span><br><span class="line">└── vue-cli@2.9.2</span><br></pre></td></tr></table></figure>

<p>卸载依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall lodash</span><br></pre></td></tr></table></figure>

<p>搜索某个依赖，以及显示某个依赖的具体信息，经测试，只有官方的源可以<code>search</code>，其他源未做相应支持</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm search lodash</span><br><span class="line">npm [view|show|info] lodash</span><br></pre></td></tr></table></figure>

<p><code>npm config ls</code>查看配置信息，<code>-l</code>参数查看详细配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ npm config ls</span><br><span class="line">; cli configs</span><br><span class="line">metrics-registry = &quot;https://registry.npmjs.org/&quot;</span><br><span class="line">scope = &quot;&quot;</span><br><span class="line">user-agent = &quot;npm/5.6.0 node/v9.3.0 darwin x64&quot;</span><br><span class="line"></span><br><span class="line">; userconfig /Users/s1mple/.npmrc</span><br><span class="line">registry = &quot;https://registry.npmjs.org/&quot;</span><br><span class="line"></span><br><span class="line">; builtin config undefined</span><br><span class="line">prefix = &quot;/usr/local&quot;</span><br><span class="line"></span><br><span class="line">; node bin location = /usr/local/Cellar/node/9.3.0_1/bin/node</span><br><span class="line">; cwd = /Users/s1mple/WebstormProjects/vue/table</span><br><span class="line">; HOME = /Users/s1mple</span><br><span class="line">; &quot;npm config ls -l&quot; to show all defaults.</span><br></pre></td></tr></table></figure>

<p>默认软件源为国外的官方软件源，速度较慢，可修改为国内软件源，比如淘宝</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>npm 还可以登录，需要先在官网注册一个账号，然后 <code>npm login</code> 登录，就可以将自己写的模块 <code>publish</code> 上去，有点类似于 Docker 的个人仓库，网站地址为 <code>https://www.npmjs.com/~&#123;username&#125;</code>。另外，还有一些命令简写，比如<code>i</code>代替 <code>install</code>，<code>rm</code> 代替 <code>uninstall</code>，执行 <code>npm -l</code> 查看那些命令下面有哪些 alias</p>
<h2 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h2><blockquote>
<p>nrm(npm注册处管理器，npm registry manager)，方便我们切换软件源</p>
</blockquote>
<p>全局安装 nrm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g nrm</span><br></pre></td></tr></table></figure>

<p>nrm 内置了一些软件源，带<code>*</code>星号的表示当前使用的软件源，也可以使用 <code>nrm current</code> 查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ nrm ls</span><br><span class="line"></span><br><span class="line">* npm ---https://registry.npmjs.org/</span><br><span class="line">  cnpm --http://r.cnpmjs.org/</span><br><span class="line">  taobao https://registry.npm.taobao.org/</span><br><span class="line">  nj ----https://registry.nodejitsu.com/</span><br><span class="line">  rednpm http://registry.mirror.cqupt.edu.cn/</span><br><span class="line">  npmMirror  https://skimdb.npmjs.com/registry/</span><br><span class="line">  edunpm http://registry.enpmjs.org/</span><br></pre></td></tr></table></figure>

<p>切换软件源，比如换成淘宝的，相当于手动修改了<code>~/.npmrc</code>中的<code>registry</code>配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ nrm use taobao</span><br><span class="line"></span><br><span class="line">    Registry has been set to: https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>


<p>可以执行<code>nrm test</code>测试网络延迟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ nrm test npm</span><br><span class="line"></span><br><span class="line">* npm ---2608ms</span><br><span class="line"></span><br><span class="line">➜  ~ nrm test taobao</span><br><span class="line"></span><br><span class="line">  taobao 246ms</span><br><span class="line"></span><br><span class="line">➜  ~ nrm test cnpm</span><br><span class="line"></span><br><span class="line">  cnpm --256ms</span><br></pre></td></tr></table></figure>

<p><code>npm home taobao</code>打开对应源的官方网站</p>
<h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><blockquote>
<p>nvm(node版本管理器，node version manager)，可以安装、管理不同版本 node 并进行切换</p>
</blockquote>
<p>安装，完成后重启终端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -ohttps://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br></pre></td></tr></table></figure>
<p>这个脚本克隆了 nvm repository 到<code>~/.nvm</code>并在<code>~/.bash_profile, ~/.zshrc, ~/.profile, ~/.bashrc</code>中加入环境变量</p>
<p>安装最新的 node</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ nvm install node</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Now using node v9.3.0 (npm v5.5.1)</span><br><span class="line">Creating default alias: default -&gt; node (-&gt; v9.3.0)</span><br></pre></td></tr></table></figure>

<p>或安装指定版本，执行<code>nvm ls-remote</code>可列出所有可以安装的版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ nvm install 8.9.3</span><br></pre></td></tr></table></figure>

<p>查看已安装 node 版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ nvm ls</span><br><span class="line">-&gt;       v8.9.3</span><br><span class="line">         v9.3.0</span><br><span class="line">         system</span><br><span class="line">default -&gt; node (-&gt; v9.3.0)</span><br><span class="line">node -&gt; stable (-&gt; v9.3.0) (default)</span><br><span class="line">stable -&gt; 9.3 (-&gt; v9.3.0) (default)</span><br></pre></td></tr></table></figure>

<p>箭头指向当前使用的版本，切换版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ nvm use 9.3.0</span><br><span class="line">Now using node v9.3.0 (npm v5.5.1)</span><br></pre></td></tr></table></figure>

<p>还可以指定默认的node版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm alias default 8.9.3</span><br></pre></td></tr></table></figure>

<h2 id="Mac管理Node版本"><a href="#Mac管理Node版本" class="headerlink" title="Mac管理Node版本"></a>Mac管理Node版本</h2><p>最近有尝试将 Hexo 博客包括 Next 主题进行升级，也是遇到了很多坑，版本进行一点点的改动，都可能导致整个博客网站 run 不起来，无奈之下只能封存了现有的版本，劝自己不要手贱去更新。如果以后有更新的强迫意愿，只能考虑在全新环境下进行博客内容的迁移。</p>
<p>其中我遇到的一个比较头疼的问题就是 node 的版本问题。Hexo 在 node 版本为8或者14时均不能正常运行，<code>hexo s</code> 以及发布命令 <code>hexo g -d</code> 都跑不起来，只有在 node 版本为10时才可以正常运行。</p>
<p>我之前使用过 <code>brew install node</code> 安装了最新的版本14，虽然可以用nvm去管理 node 版本，但由于要想使用 nvm，必须先执行 <code>[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;</code> 和 <code>[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;</code> 这两条命令（配在了我的 <code>~/.zshrc</code> 中），极大影响了终端的打开速度，每打开一个终端都要跑一遍 <code>.zshrc</code>，效率难以忍受。再者平时切换 node 版本的频率要远低于执行 Hexo 命令的频率。所以我决定还是回到用Mac的 <code>brew</code> 工具去管理 node 版本。</p>
<p>查看可用版本，并安装需要版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ brew search node</span><br><span class="line">➜ brew install node@10</span><br></pre></td></tr></table></figure>

<p>现在是有两个版本的，node为原先安装的14版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ brew list | grep node</span><br><span class="line">node</span><br><span class="line">node@10</span><br></pre></td></tr></table></figure>

<p>解绑原先的 node@14，绑定到 node@10，由于 node 自带 npm，需要先删除原有的 npm 依赖，否则会有冲突</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ brew unlink node</span><br><span class="line">➜ rm -rf /usr/local/lib/node_modules/npm</span><br><span class="line">➜ brew link node@10 --force</span><br></pre></td></tr></table></figure>

<p>查看是否绑定成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ which node</span><br><span class="line">/usr/local/bin/node</span><br><span class="line">➜ node -v</span><br><span class="line">v10.22.1</span><br></pre></td></tr></table></figure>

<p>现在 node 版本就切换到10了，新打开的终端中的 node 版本也为10。如果还想切换回 node@14，有两种方法：一是使用 nvm 进行切换，但这样新打开终端 node 版本还是14，适用于短暂的更换 node 版本；第二种办法是使用 <code>brew unlink</code> 解绑再绑定 node@14，这种适用于主环境需要14版本的情况。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.npmjs.com/">npm 官方文档</a></li>
<li><a href="https://github.com/creationix/nvm/blob/master/README.md">nvm Github官方手册</a></li>
<li><a href="https://mrxf.github.io/2017/04/18/osx-using-the-brew-to-manage-multiple-node-version/">OS X中使用brew管理多个node版本</a></li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>一道有趣的路径规划算法题（Java 版）</title>
    <url>/2019/02/15/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88Java-%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>图中有一个无向图，其中圈内数字代表一个地点，边线上的数字代表长度 Le（双向相同）。机场一辆小型VIP电动摆渡车在起点 A，要去 3 个贵宾厅（V1，V2，V3）接贵宾（每个贵宾厅限1个VIP），送到 3 个对应航班机位（S1，S2，S3），即 V1 至 S1，V2 至 S2，V3 至 S3。VIP 电动摆渡车同时最多装下 2 个 VIP。</p>
<p><img src="/2019/02/15/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88Java-%E7%89%88%EF%BC%89/1.jpg" alt="ff858a30049f1753177d2691a50f09b1.jpeg"></p>
<p><strong>要求</strong>：VIP 电动摆渡车该怎么走路径最短？这个最短路径的长度是多少？这里 A 是出发点，最后一个 VIP（不限次序）送达地为终点。为了简化问题，假设贵宾厅VIP已在贵宾厅等候上车，VIP 电动摆渡车在接送期间不用等待。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看到最短路径，不难想到 Dijkstra 等最短路径算法，这些算法用于求出一个图（Graph）中任意两个顶点（Vertex）的最短距离。但是本文待求解的问题不止于此，而是包含起始点 A 在内的 7 个点（A、V1、V2、V3、S1、S2、S3），我们需要先<strong>规划路线</strong>使得摆渡车依次通过这 7 个点，再求出这些路线中的最短路线。</p>
<p>综上所诉，该问题被拆解为以下两步：<br>第一步，<strong>列出从 A 出发经由其余 6 个点的所有可能的路线</strong>。<br>第二步，<strong>对于给定的任意两个点，求出它们之间的最短路径</strong>（例如给定 A、V2 两个点，可得从 A 到 V2 的最短路径为 2 -&gt; 6 -&gt; 7）。<br>然后对于每条路线，计算每一段（即两个点之间）的最短路径即可得到整条路线的最短路径。</p>
<p>由此，可以看出本题涉及两个算法，即第一步中的<strong>排序算法</strong>，和第二步中的<strong>最短路径算法</strong>。</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>我们需要对 V1、V2、V3、S1、S2、S3 六个点进行排序。当然为满足题目的要求，排序得出的路线必须满足以下几个条件：</p>
<ol>
<li><strong>第一个点必须是 V，最后一个点必须是 S</strong></li>
<li>因为摆渡车最多载两个，所以<strong>不能出现连续的三个 V</strong></li>
<li>为确保将用户送达目的点，<strong>对应的 V 不能排在对应的 S 后面</strong>，比如不能排出 S1 … V1</li>
</ol>
<h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p><strong>Point</strong>，枚举类，对应着包括起点 A 在内的七个点。阔号中的整数类型表示点在图中的索引。同时基于 Java 面向对象的思想，赋予它一些验证方法以验证当前路径是否符合上述三个条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    A(<span class="number">2</span>, START),</span><br><span class="line">    V1(<span class="number">3</span>, VIP),</span><br><span class="line">    V2(<span class="number">7</span>, VIP),</span><br><span class="line">    V3(<span class="number">4</span>, VIP),</span><br><span class="line">    S1(<span class="number">12</span>, DESTINATION),</span><br><span class="line">    S2(<span class="number">11</span>, DESTINATION),</span><br><span class="line">    S3(<span class="number">13</span>, DESTINATION);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> index; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isV</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isS</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">matchedV</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        VIP, DESTINATION, START</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Route</strong>，对应着路线，下面粘贴了部分代码，包括验证当前路线是否合法的 <code>isLegal()</code> 方法，路径上追加点的 <code>add(Point)</code> 方法，以及预留的 <code>minDistance()</code> 方法用于计算这条路径的最短距离。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Route</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Point&gt; route;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLegal</span><span class="params">()</span> </span>&#123; ... &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Point point)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>排序算法的核心思路是：</p>
<ol>
<li>首先需要一个容器用于所有装符合条件的 Route。</li>
<li>Route 用来装当前<strong>已入队列</strong>的 Point。</li>
<li>Remain Points Container 用于存放<strong>尚未入队列</strong>的 Point。</li>
<li>从 Remain Points Container <strong>依次拿出一个 Point，追加入 Route，判断是否合法</strong>，合法则继续，不合法则退出。</li>
<li>第 4 步是一个<strong>递归</strong>的步骤，如下图，假设第一个点装入了 V1，第二个点在装入的时候可以装入 V2、V3、S1、S2、S3，其中 S2、S3 因为不合法而终止递归，剩下的 V2、V3、S1 三个点 fork 出三种情况继续向下递归。</li>
<li>直到 Route 将六个点全部装入后，将该 Route 加入第 1 步的容器中。</li>
</ol>
<p><img src="/2019/02/15/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88Java-%E7%89%88%EF%BC%89/2.jpeg" alt="3921ebbd368ce17e79a7b2f574d7673c.jpeg"></p>
<p><strong>RouteGenerator</strong> 类，用于生成所有符合条件的路线。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Route&gt; routes = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 第 1 步的容器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Route&gt; <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fork(<span class="keyword">new</span> Route(), List.of(V1, V2, V3, S1, S2, S3));</span><br><span class="line">        <span class="keyword">return</span> routes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fork</span><span class="params">(<span class="keyword">final</span> Route route, <span class="keyword">final</span> List&lt;Point&gt; remain)</span> </span>&#123; <span class="comment">// 入参分别对应 2、3 步</span></span><br><span class="line">        <span class="keyword">if</span> (!route.isLegal()) &#123; <span class="comment">// 判断是否合法，不合法则中断递归</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (route.size() == <span class="number">6</span>) &#123; <span class="comment">// 当六个点全部装入后，将该路线加入第 1 步的容器并中断递归</span></span><br><span class="line">            routes.add(route); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; remain.size(); i++) &#123;</span><br><span class="line">            List&lt;Point&gt; temp = Lists.newArrayList(remain);</span><br><span class="line">            Point next = temp.remove(i); <span class="comment">// 从未入队列的点中选出一个加入路线</span></span><br><span class="line">            Route route1 = route.copy();</span><br><span class="line">            route1.add(next);</span><br><span class="line"></span><br><span class="line">            fork(route1, temp); <span class="comment">// 递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>排序后得到结果，一共 54 种符合条件的情况。算法耗时在 40ms 左右。该算法相较于全排列后再进行筛选，可以避免创建不必要的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A -&gt; V1 -&gt; V2 -&gt; S1 -&gt; V3 -&gt; S2 -&gt; S3</span><br><span class="line">A -&gt; V1 -&gt; V2 -&gt; S1 -&gt; V3 -&gt; S3 -&gt; S2</span><br><span class="line">A -&gt; V1 -&gt; V2 -&gt; S1 -&gt; S2 -&gt; V3 -&gt; S3</span><br><span class="line">...</span><br><span class="line">A -&gt; V2 -&gt; V3 -&gt; S3 -&gt; V1 -&gt; S1 -&gt; S2</span><br><span class="line">A -&gt; V2 -&gt; V3 -&gt; S3 -&gt; V1 -&gt; S2 -&gt; S1</span><br><span class="line">A -&gt; V2 -&gt; V3 -&gt; S3 -&gt; S2 -&gt; V1 -&gt; S1</span><br><span class="line">...</span><br><span class="line">A -&gt; V3 -&gt; S3 -&gt; V2 -&gt; V1 -&gt; S1 -&gt; S2</span><br><span class="line">A -&gt; V3 -&gt; S3 -&gt; V2 -&gt; V1 -&gt; S2 -&gt; S1</span><br><span class="line">A -&gt; V3 -&gt; S3 -&gt; V2 -&gt; S2 -&gt; V1 -&gt; S1</span><br></pre></td></tr></table></figure>

<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><p>本题中的最短路径算法我选用的 Dijkstra 算法，亦就是大学数据结构课程中最为常知的最短路径算法。算法的详细步骤这里就不再赘述了，可以参考一篇博客 <a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html">Dijkstra最短路算法
</a>。</p>
<h3 id="建模-1"><a href="#建模-1" class="headerlink" title="建模"></a>建模</h3><p>Dijkstra 算法的核心建模思想是使用一个二维数组，记录每个顶点到其他顶点的距离，如果不能直达，则设为 ∞。那么本题的图可以使用如下二维数组来表示，由于是无向图，所以关于对角线对称。</p>
<p><img src="/2019/02/15/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88Java-%E7%89%88%EF%BC%89/3.png" alt="afe039363dc9b79e775321fa5a6dee22.png"></p>
<p>反应在 Java 代码中则是如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> I = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INFINITY = I;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo: maybe read from graph with python</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrix() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line"><span class="comment">//               1  2  3  4  5  6  7  8  9  10 11 12 13 14 15</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, I, I, <span class="number">1</span>, I, I, I, I, I, I, I, I, I, I&#125;, <span class="comment">// 1</span></span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, I, I, <span class="number">2</span>, I, I, I, I, I, I, I, I, I&#125;, <span class="comment">// 2</span></span><br><span class="line">                &#123;I, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, I, I, I, <span class="number">2</span>, I, I, I, I, I, I, I&#125;, <span class="comment">// 3</span></span><br><span class="line">                &#123;I, I, <span class="number">1</span>, <span class="number">0</span>, I, I, I, I, I, I, I, I, I, I, <span class="number">3</span>&#125;, <span class="comment">// 4</span></span><br><span class="line">                &#123;<span class="number">1</span>, I, I, I, <span class="number">0</span>, <span class="number">1</span>, I, I, <span class="number">1</span>, I, I, I, I, I, I&#125;, <span class="comment">// 5</span></span><br><span class="line">                &#123;I, <span class="number">2</span>, I, I, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, I, I, I, I, I, I, I, I&#125;, <span class="comment">// 6</span></span><br><span class="line">                &#123;I, I, I, I, I, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, I, <span class="number">1</span>, I, I, I, I, I&#125;, <span class="comment">// 7</span></span><br><span class="line">                &#123;I, I, <span class="number">2</span>, I, I, I, <span class="number">1</span>, <span class="number">0</span>, I, I, <span class="number">1</span>, I, I, I, I&#125;, <span class="comment">// 8</span></span><br><span class="line">                &#123;I, I, I, I, <span class="number">1</span>, I, I, I, <span class="number">0</span>, <span class="number">3</span>, I, <span class="number">2</span>, I, I, I&#125;, <span class="comment">// 9</span></span><br><span class="line">                &#123;I, I, I, I, I, I, <span class="number">1</span>, I, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, I, <span class="number">2</span>, I, I&#125;, <span class="comment">// 10</span></span><br><span class="line">                &#123;I, I, I, I, I, I, I, <span class="number">1</span>, I, <span class="number">1</span>, <span class="number">0</span>, I, I, <span class="number">1</span>, I&#125;, <span class="comment">// 11</span></span><br><span class="line">                &#123;I, I, I, I, I, I, I, I, <span class="number">2</span>, I, I, <span class="number">0</span>, <span class="number">2</span>, I, I&#125;, <span class="comment">// 12</span></span><br><span class="line">                &#123;I, I, I, I, I, I, I, I, I, <span class="number">2</span>, I, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, I&#125;, <span class="comment">// 13</span></span><br><span class="line">                &#123;I, I, I, I, I, I, I, I, I, I, <span class="number">1</span>, I, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, <span class="comment">// 14</span></span><br><span class="line">                &#123;I, I, I, <span class="number">3</span>, I, I, I, I, I, I, I, I, I, <span class="number">1</span>, <span class="number">0</span>&#125;, <span class="comment">// 15</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p>Dijkstra 算法的核心思想是：每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下：</p>
<ol>
<li>使用一个 <code>dis[]</code> 数组记录源点到其余所有点的最短路径。初始化为 matrix 二维数组的对应行。</li>
<li>将所有的顶点分为两部分：已知最短路程的顶点集合 P 和未知最短路径的顶点集合 Q。最开始，已知最短路径的顶点集合 P 中只有源点一个顶点。我们这里用一个  <code>book[]</code> 数组来记录哪些点在集合 P 中。例如对于某个顶点 i，如果 <code>book[i]</code> 为 1 则表示这个顶点在集合 P 中，如果 <code>book[i]</code> 为 0 则表示这个顶点在集合 Q 中。</li>
<li>在集合 Q 的所有顶点中选择一个离源点 s 最近的顶点 u（即 <code>dis[u]</code> 最小）加入到集合 P。并考察所有以点 u 为起点的边，对每一条边进行松弛操作。例如存在一条从 u 到 v 的边，使得 <code>s -&gt; u -&gt; v</code> 的长度 <code>dis[u] + e[u][v]</code> 比目前已知的 <code>dis[v]</code> 的值更小，那么我们就可以用新值来更新当前 <code>dis[v]</code> 中的值（即<strong>松弛</strong>）。</li>
<li>重复第 3 步，如果集合 Q 为空，算法结束。最终 dis 数组中的值就是源点到所有顶点的最短路径。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] e;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dijkstra</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.e = graph.matrix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = e[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init dis[]</span></span><br><span class="line">        <span class="keyword">int</span>[] dis = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        System.arraycopy(e[start - <span class="number">1</span>], <span class="number">0</span>, dis, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init book[]</span></span><br><span class="line">        <span class="keyword">int</span>[] book = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        book[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = INFINITY;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (book[j] == <span class="number">0</span> &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">                    min = dis[j];</span><br><span class="line">                    u = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            book[u] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e[u][v] &lt; INFINITY) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dis[v] &gt; dis[u] + e[u][v]) &#123;</span><br><span class="line">                        dis[v] = dis[u] + e[u][v];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dis[end - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 Dijkstra 算法我有想过使用缓存 Cache 去进行优化，为了避免重复计算两个点之间的最短距离，但实际上效果反而不好，其实这是一种空间换时间的取舍，虽然不用重复计算，但是需要额外的空间存储已计算过的路径。然而在本题中并不适用这种优化。</p>
<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p>结合 Dijkstra 算法，我们可以补全之前 Route 类中预留的 <code>minDistance()</code> 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Route.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AtomicReference&lt;Point&gt; pre = <span class="keyword">new</span> AtomicReference&lt;&gt;(Point.A);</span><br><span class="line">    <span class="keyword">return</span> route.stream()</span><br><span class="line">            .map(p -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> min = dijkstra.min(pre.get().index(), p.index());</span><br><span class="line">                pre.set(p);</span><br><span class="line">                <span class="keyword">return</span> min;</span><br><span class="line">            &#125;)</span><br><span class="line">            .reduce(<span class="number">0</span>, (i1, i2) -&gt; i1 + i2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在主方法中运行可得答案，运行耗时在 100ms 左右。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> before = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    List&lt;Route&gt; routes = <span class="keyword">new</span> RouteGenerator().generate();</span><br><span class="line">    routes.forEach(route -&gt; System.out.println(route + <span class="string">&quot; 最短路径长度: &quot;</span> + route.minDistance()));</span><br><span class="line">    Route shortestRoute = routes.stream().min(Comparator.comparing(Route::minDistance)).get();</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;\n其中最短路径为 %s, 路径长度为 %s.&quot;</span>, shortestRoute, shortestRoute.minDistance()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> after = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;运行耗时:&quot;</span> + (after - before) + <span class="string">&quot;ms.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中最短路径为 A -&gt; V2 -&gt; S2 -&gt; V1 -&gt; V3 -&gt; S3 -&gt; S1, 路径长度为 16.</span></span><br><span class="line"><span class="comment">// 运行耗时:108ms.</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是想向大家展示 Java <strong>面向对象处理问题</strong>的优势。虽然可能代码量会多一些，但是在重构和梳理编码过程的时候，这种面向对象的思想无疑会带来很多好处。例如本文中 Route、Point、Graph 这些类的建模相较于面向过程编码更符合人的直觉；以及<strong>为避免贫血对象，我们赋予类丰富的行为</strong>，例如一些验证方法、<code>minDistance()</code> 等方法；同时还要多写<strong>单元测试</strong>，这样可以随时验证算法的正确性，而不用等到编码完成的最后再去肉眼比对结果。</p>
<p>代码已经上传到 <a href="https://github.com/s1mplecc/route-plan">GitHub</a> 上，包含了相对全面的单元测试，需要注意的是使用的 Java 11 版本。以后可能会使用 Python 编码实现，再比较两种语言的优劣势。</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 五种数据类型</title>
    <url>/2018/03/16/Redis%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文介绍 Redis 的五种数据类型，并结合 redis-cli 交互式命令行，以及 Node.js 应用演示如何与 Redis 的五种数据类型进行交互，在文章最后还有关于过期时间设置的介绍。相关代码已上传至 <a href="https://github.com/s1mplecc/koa-redis-example">GitHub</a>。</p>
<ul>
<li>Node.js 应用使用 Koa2 框架，与 Redis 的操作都使用 Restful API 的形式展现，使用 Postman 测试接口；</li>
<li>使用的依赖为<code>ioredis</code>，执行 <code>npm i ioredis</code> 安装依赖。之前有尝试 <code>noderedis</code>，但是在服务器上部署运行有连接不上 Redis 的 Bug 出现。</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Redis 通常被称为<strong>数据结构服务器</strong>，因为它提供了五种数据类型用于数据存储，包括 <strong>String</strong> 字符串、<strong>Hash</strong> 哈希、<strong>List</strong> 列表、<strong>Set</strong> 集合、<strong>Zset</strong> 有序集合</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Redis String 是 Redis 最基本的类型，用于保存字符串类型的 Key-Value 键值对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET string:s1 hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET string:s1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; DEL string:s1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>Node.js 应用中的 <code>contollers/string.js</code> 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)()</span><br><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;../config/redis&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setString = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.set(<span class="string">&#x27;string:s1&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getString = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.get(<span class="string">&#x27;string:s1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> delString = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.del(<span class="string">&#x27;string:s1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/string&#x27;</span>, setString)</span><br><span class="line">router.get(<span class="string">&#x27;/string&#x27;</span>, getString)</span><br><span class="line">router.delete(<span class="string">&#x27;/string&#x27;</span>, delString)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>

<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Redis Hash 是一个 String 类型的 Field-Value 映射表，类似于 Java 的 HashMap，特别适合用于<strong>存储对象</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMSET hash:hash1 name &quot;jack&quot; age 10 score 90</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HGET hash:hash1 name</span><br><span class="line">&quot;jack&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL hash:hash1</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;jack&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;10&quot;</span><br><span class="line">5) &quot;score&quot;</span><br><span class="line">6) &quot;90&quot;</span><br><span class="line">127.0.0.1:6379&gt; HDEL hash:hash1 name age</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; HGETALL hash:hash1</span><br><span class="line">1) &quot;score&quot;</span><br><span class="line">2) &quot;90&quot;</span><br><span class="line">127.0.0.1:6379&gt; DEL hash:hash1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是，<code>HGETALL key</code>命令用于获取键的映射列表，<code>HGETALL key field</code>用于获取某个字段的值，<code>HDEL key field</code>用于删除键的某个字段，<code>DEL key</code>才是删除整个键。</p>
<p><code>contollers/hash.js</code> 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setHash = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> student = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="number">90</span></span><br><span class="line">  &#125;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.hmset(<span class="string">&#x27;hash:hash1&#x27;</span>, student)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getHashAll = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;hash:hash1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getHashByField = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.hget(<span class="string">&#x27;hash:hash1&#x27;</span>, ctx.params.field)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> delHash = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.del(<span class="string">&#x27;hash:hash1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> delHashByField = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.hdel(<span class="string">&#x27;hash:hash1&#x27;</span>, ctx.params.field)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/hash&#x27;</span>, setHash)</span><br><span class="line">router.get(<span class="string">&#x27;/hash&#x27;</span>, getHashAll)</span><br><span class="line">router.get(<span class="string">&#x27;/hash/:field&#x27;</span>, getHashByField)</span><br><span class="line">router.delete(<span class="string">&#x27;/hash&#x27;</span>, delHash)</span><br><span class="line">router.delete(<span class="string">&#x27;/hash/:field&#x27;</span>, delHashByField)</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis 列表是简单的字符串列表，<strong>按照插入顺序排序</strong>。你可以添加一个元素到列表的头部（左边）或者尾部（右边），列表中的<strong>元素可以重复</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH list:list1 hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list:list1 world my friend</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; RPUSH list:list1 right push</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; LLEN list:list1</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list:list1 0 5</span><br><span class="line">1) &quot;friend&quot;</span><br><span class="line">2) &quot;my&quot;</span><br><span class="line">3) &quot;world&quot;</span><br><span class="line">4) &quot;hello&quot;</span><br><span class="line">5) &quot;right&quot;</span><br><span class="line">6) &quot;push&quot;</span><br><span class="line">127.0.0.1:6379&gt; LPOP list:list1</span><br><span class="line">&quot;friend&quot;</span><br><span class="line">127.0.0.1:6379&gt; RPOP list:list1</span><br><span class="line">&quot;push&quot;</span><br><span class="line">127.0.0.1:6379&gt; LINDEX list:list1 2</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p><code>LPUSH</code>添加到列表头部（Left Push），<code>RPUSH</code>添加到列表头部（Right Push）。相应的，<code>LPOP</code>和<code>RPOP</code>即从列表头和列表尾移除一个元素并获取该值。<code>LREM</code>根据参数<code>count</code>的值，移除列表中与参数 value 相等的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。</span><br><span class="line">count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。</span><br><span class="line">count = 0 : 移除表中所有与 VALUE 相等的值。</span><br></pre></td></tr></table></figure>

<p>语法如下：<code>LREM key count value</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LRANGE list:list1 0 100</span><br><span class="line">1) &quot;my&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">3) &quot;hello&quot;</span><br><span class="line">4) &quot;right&quot;</span><br><span class="line">5) &quot;hello&quot;</span><br><span class="line">6) &quot;foo&quot;</span><br><span class="line">7) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; LREM list:list1 -2 hello</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list:list1 0 100</span><br><span class="line">1) &quot;my&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">3) &quot;hello&quot;</span><br><span class="line">4) &quot;right&quot;</span><br><span class="line">5) &quot;foo&quot;</span><br></pre></td></tr></table></figure>

<p><code>contollers/list.js</code> 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pushListAndGetAll = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    redis.lpush(<span class="string">&#x27;list:list1&#x27;</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    redis.rpush(<span class="string">&#x27;list:list1&#x27;</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> length = <span class="keyword">await</span> redis.llen(<span class="string">&#x27;list:list1&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;length&#x27;</span>, length)</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.lrange(<span class="string">&#x27;list:list1&#x27;</span>, <span class="number">0</span>, length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> popList = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> lPopValue = <span class="keyword">await</span> redis.lpop(<span class="string">&#x27;list:list1&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> rPopValue = <span class="keyword">await</span> redis.rpop(<span class="string">&#x27;list:list1&#x27;</span>)</span><br><span class="line">  ctx.body = &#123; lPopValue, rPopValue &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deleteListByValue = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.lrem(<span class="string">&#x27;list:list1&#x27;</span>, <span class="number">0</span>, ctx.params.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/list&#x27;</span>, pushListAndGetAll)</span><br><span class="line">router.delete(<span class="string">&#x27;/list&#x27;</span>, popList)</span><br><span class="line">router.delete(<span class="string">&#x27;/list/:value&#x27;</span>, deleteListByValue)</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis 的 Set 是 String 类型的<strong>无序集合</strong>。集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是 O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD set:set1 hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD set:set1 my friend hello world</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS set:set1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">3) &quot;friend&quot;</span><br><span class="line">4) &quot;my&quot;</span><br><span class="line">127.0.0.1:6379&gt; SREM set:set1 my</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SPOP set:set1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS set:set1</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">2) &quot;friend&quot;</span><br></pre></td></tr></table></figure>

<p><code>SMEMBERS</code>返回集合中的所有成员，<code>SPOP</code>移除并返回集合中的一个随机元素，<code>SREM</code>移除集合中一个或多个成员。</p>
<p><code>contollers/set.js</code> 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addMembersAndGetAll = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  redis.sadd(<span class="string">&#x27;set:set1&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;friend&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.smembers(<span class="string">&#x27;set:set1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> popRandomMember = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.spop(<span class="string">&#x27;set:set1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> removeMemberByValue = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.srem(<span class="string">&#x27;set:set1&#x27;</span>, ctx.params.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/set&#x27;</span>, addMembersAndGetAll)</span><br><span class="line">router.delete(<span class="string">&#x27;/set/random&#x27;</span>, popRandomMember)</span><br><span class="line">router.delete(<span class="string">&#x27;/set/:value&#x27;</span>, removeMemberByValue)</span><br></pre></td></tr></table></figure>

<h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>Redis Zset，即有序集合（sorted set），和集合一样也是 String 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 Double 类型的<strong>分数</strong> (<strong>Score</strong>)。Redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数却可以重复。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD zset:zset1 1 a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZADD zset:zset1 2 b 3 c 4 d 5 e</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE zset:zset1 0 4</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;d&quot;</span><br><span class="line">5) &quot;e&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREM zset:zset1 c</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANK zset:zset1 d</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE zset:zset1 d</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure>
<p><code>ZREM</code>移除有序集合中的一个或多个成员，<code>ZRANK key member</code>返回有序集合中指定成员的索引，<code>ZSCORE</code>返回有序集中，成员的分数值。</p>
<p><code>contollers/set.js</code> 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addMembersAndGetAll = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> students = [[<span class="string">&#x27;Jack&#x27;</span>, <span class="number">99</span>], [<span class="string">&#x27;John&#x27;</span>, <span class="number">90</span>], [<span class="string">&#x27;Tony&#x27;</span>, <span class="number">88</span>], [<span class="string">&#x27;Helen&#x27;</span>, <span class="number">92</span>]]</span><br><span class="line">  students.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    redis.zadd(<span class="string">&#x27;zset:zset1&#x27;</span>, item[<span class="number">1</span>], item[<span class="number">0</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> count = <span class="keyword">await</span> redis.zcard(<span class="string">&#x27;zset:zset1&#x27;</span>)</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.zrange(<span class="string">&#x27;zset:zset1&#x27;</span>, <span class="number">0</span>, count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> removeMemberByValue = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> redis.zrem(<span class="string">&#x27;zset:zset1&#x27;</span>, ctx.params.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/zset&#x27;</span>, addMembersAndGetAll)</span><br><span class="line">router.delete(<span class="string">&#x27;/zset/:value&#x27;</span>, removeMemberByValue)</span><br></pre></td></tr></table></figure>

<h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><p>在使用 Redis 的时候遇到了需要设置过期时间的情况，需要注意的是：<strong>Redis 只能针对最顶级的 KEY，也就是五种数据结构设置过期时间</strong>，而不能针对譬如 Hash 中的某一条映射设置。在设计数据存储类型时需要考虑到这点。</p>
<p>设置过期时间使用<code>EXPIRE</code>关键字，时间单位为秒(s)，时间到后，整个 hash:hash1 键将被删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXPIRE hash:hash1 60</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>可以使用<code>TTL</code>查看 KEY 的剩余过期时间，<code>TTL</code>为 -1 表示未设置过期时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; TTL hash:hash1</span><br><span class="line">(integer) 46</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.runoob.com/redis/redis-tutorial.html">Redis 教程</a></li>
<li><a href="http://www.redis.cn/commands/expire.html">Redis 过期时间</a></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 P, NP, NPC 以及 NP-Hard 问题？</title>
    <url>/2020/09/22/%E4%BB%80%E4%B9%88%E6%98%AFP-NP-NPC%E4%BB%A5%E5%8F%8ANP-Hard%E9%97%AE%E9%A2%98%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度并不是表示一个程序解决问题需要花多少时间，而是<strong>当问题规模扩大后，程序需要的时间长度增长得有多快</strong>。</p>
<p>不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序性能很好，具有$O(1)$的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是$O(n)$，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于$O(n^2)$的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是$O(a^n)$的指数级复杂度，甚至$O(n!)$的阶乘级复杂度。</p>
<p>我们将复杂度量级按照数量级递增进行排序得到下图，并将其分为两类：<strong>多项式量级</strong>和<strong>非多项式量级</strong>，后者的复杂度远远大于前者。</p>
<p><img src="/2020/09/22/%E4%BB%80%E4%B9%88%E6%98%AFP-NP-NPC%E4%BB%A5%E5%8F%8ANP-Hard%E9%97%AE%E9%A2%98%EF%BC%9F/0.jpg" alt="3723793cc5c810e9d5b06bc95325bf0a.jpeg"></p>
<p>多项式级的复杂度包括$O(1),O(log(n)),O(n^a)$等，它的规模n出现在底数的位置；非多项式级只包含$O(a^n),O(n!)$两种，其复杂度计算机往往不能承受。</p>
<p>自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。举个例子，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。</p>
<p>还有另外一个经典的问题：<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE">Hamilton回路</a>。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后回到起点的路径（满足这个条件的路径叫做Hamilton回路）。这个问题目前还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。</p>
<p>由此，我们根据复杂度分级，将问题进行分类。最简单的一类问题被称为P问题，按复杂度依次递增，又有NP问题、NPC问题和NP-Hard问题。先来看看P问题的定义。</p>
<h2 id="P问题"><a href="#P问题" class="headerlink" title="P问题"></a>P问题</h2><blockquote>
<p>定义：在计算复杂度理论中，P（polynomial time class）是在复杂度类问题中可于确定型图灵机以多项式量级（或称多项式时间）求解的决定性问题。</p>
</blockquote>
<p>简单来说，就是<strong>一个P问题可以在多项式（$O(n^k)$）的时间复杂度内被解决</strong>。</p>
<p>P问题比较容易理解，它是复杂度最低的一类问题。事实上，计算机能解决的问题绝大部分都属于P问题，譬如排序、最小树、最短路、最大流、最小费用流、最大匹配等常见问题都是多项式时间可解的P类问题。</p>
<p>然而另一类问题如<a href="https://zh.wikipedia.org/wiki/TSP">旅行商问题(TSP)</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92">整数线性规划问题(ILP)</a>至今仍未找到多项式时间算法，又往往无法证明多项式算法的不存在性。在这类问题中，又存在一类特殊的问题，即：<strong>我无法在多项式时间内解决该问题，但我可以找到该问题的一个解，然后在多项式时间内验证该解是否正确</strong>。我们将这类问题归类为<strong>NP问题</strong>。举个例子，前面的Hamilton回路问题，虽然它不是P问题，但我可以找到一条路径，并在$O(n)$时间内验证这条路径是否经过每个顶点一次（每个顶点遍历一次）。</p>
<h2 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h2><blockquote>
<p>定义：非确定多项式类（non-deterministic polynomial，缩写：NP）是指在在非确定型图灵机上可以用多项式时间复杂度的算法解决的问题。</p>
</blockquote>
<p>简单来说，NP问题是指<strong>可以在多项式时间内猜出一个解或验证一个解的正确性的问题</strong>。</p>
<p>很显然，前面所说的Hamilton回路属于NP问题。但若是问题变成这样：试问一个图中是否不存在Hamilton回路？该问题就没法在多项式的时间里进行验证了，因为除非你验证过所有的路径，否则你不敢断定它“没有Hamilton回路”。</p>
<p>之所以要定义NP问题，是因为通常<strong>只有NP问题才有可能找到多项式的算法</strong>。若是一个问题连在多项式时间内验证一个解是否正确都做不到，那我们不指望能存在一个解决它的多项式级的算法。事实上信息学中的号称最困难的问题——“NP问题”，其实就是在探讨<strong>NP问题与P问题的关系</strong>。</p>
<p>很显然，所有的P问题都是NP问题，即$P \subset NP$。因为，如果能在多项式时间内解决一个问题，必然能在多项式时间内验证一个问题的解是否正确。那么问题就变成了：<strong>是否所有的NP问题都是P问题，即究竟是否有P=NP?</strong> </p>
<p>目前为止，这个问题还未被证明或推翻。但人们普遍认为，P≠NP，也就是说，多数人相信，<strong>存在至少一个不可能有多项式级复杂度的算法的NP问题</strong>。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，即所谓的NPC问题。正是NPC问题的存在，使人们相信P≠NP。下面我们介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p>
<h2 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h2><blockquote>
<p>定义：如果一个问题满足：</p>
<ol>
<li>它是一个NP问题。</li>
<li>其他属于NP的问题都可在多项式时间内归约成它。</li>
</ol>
<p>我们就将这类问题称为NP-完全问题（NP-Complete，缩写为NP-C或NPC）</p>
</blockquote>
<p>为了说明NPC问题，我们先引入一个概念——<strong>规约(Reducibility)<strong>。简单地说，一个问题A可以规约为问题B的含义是，可以用问题B的解法解决问题A。所以，B的时间复杂度是大于等于A的时间复杂度的。也就是说：</strong>A规约为B，B比A问题要更泛化、更难求解；但一旦B问题解决了，A问题也随之解决了</strong>。</p>
<p>《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以规约为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以找到一个“规则”：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以规约为TSP问题：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。</p>
<p>很显然，规约具有一项重要的性质：<strong>传递性</strong>。如果问题A可规约为问题B，问题B可规约为问题C，则问题A一定可规约为问题C。当然，我们所说的“可规约”是指的可“多项式地”规约(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。规约的过程只有用多项式的时间完成才有意义。</p>
<p>现在我们已经知道，一个问题规约为另一个问题，时间复杂度增加了，问题的应用范围也增大了。<strong>结合规约的传递性，通过对某类问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替原先复杂度较低但应用范围也更小的一类问题的算法</strong>。自然地，我们会想问，如果不断地规约上去，能否找到一个时间复杂度最高，并且能“通吃”所有的NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，<strong>存在这样一个NP问题，所有的NP问题都可以规约成它</strong>。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是所谓的NPC问题，也就是NP-完全问题。到这里你应该可以理解完全（Complete）的含义了。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，<strong>NPC问题是一类NP问题中最复杂的问题，也是在P≠NP假设下最不可能找到多项式时间（化简为P）的问题</strong>。</p>
<p>既然所有的NP问题都能规约为NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p>
<p>那么有没有比NPC问题更复杂的问题呢？答案是有的，就是我们接下来介绍的NP-Hard问题。</p>
<h2 id="NP-Hard问题"><a href="#NP-Hard问题" class="headerlink" title="NP-Hard问题"></a>NP-Hard问题</h2><blockquote>
<p>定义：如果所有NP问题都可以多项式时间归约到某个问题，则称该问题为NP-困难问题（NP-hardness, non-deterministic polynomial-time hardness，缩写为NP-Hard）。</p>
</blockquote>
<p>注意到，一个NP-Hard问题未必可以在多项式时间内验证一个解的正确性，即<strong>NP-Hard问题不一定是NP问题</strong>，也就是NP-Hard问题只满足NPC问题定义的第二个条件。因此我们可以<strong>将NPC问题理解为即是NP问题又是NP-Hard问题的一类问题</strong>。也就是说，NP-Hard问题要比NPC问题的范围更广。从时间复杂性上来考虑，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高更难以解决。换句话说，即使NPC问题有多项式时间的解（P=NP），NP-Hard问题依然可能没有多项式时间的解。</p>
<p>研究生数模竞赛中遇到的基本都是NP-Hard问题，在P≠NP的假设下，只能设计启发式算法或者近似算法，求得令人满意的可行解。<strong>启发式算法</strong>是一个基于直观或经验构造的算法，在可接受的花费(指计算时间和空间)下给出待解决优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。启发式算法以仿自然体算法为主，主要有遗传算法、蚁群算法、模拟退火法、神经网络等；<strong>近似算法</strong>则可以相当快速地找到合理的解决方案，需要证明解决方案的近似性，即所有实例中最坏情况下可以保证近似解的范围，并且运行时间合理。近似算法对于任何实例通常可得到一个有质量保证的解。近似性常用近似比、近似方案来度量。近似算法往往设计方法不难，比如贪心法、动态规划、基于线性规划的方法，但近似性的证明非常难。两者相辅相成。</p>
<h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p>基于P≠NP和P=NP两种猜想，我们得到描述P, NP, NPC，以及NP-Hard之间关系的欧拉图：</p>
<p><img src="/2020/09/22/%E4%BB%80%E4%B9%88%E6%98%AFP-NP-NPC%E4%BB%A5%E5%8F%8ANP-Hard%E9%97%AE%E9%A2%98%EF%BC%9F/1.png" alt="4dead7744239cc0042d7f029f3c3875a.png"></p>
<p>可以看到，在P≠NP假设下，P与NPC没有交集，亦即我们之前提到的，NPC问题最不可能化简为P问题。而在P=NP问题下，即使是最复杂的NPC问题也可以化简为P问题，因为从定义来说NPC也是一个NP问题。</p>
<h2 id="确定型与非确定型图灵机"><a href="#确定型与非确定型图灵机" class="headerlink" title="确定型与非确定型图灵机"></a>确定型与非确定型图灵机</h2><p>定义中提及了确定型/非确定型图灵机，虽然对于理解P和NP问题没有太大影响，但还是有必要在这里做一个简要的阐述。</p>
<p>图灵机（Turing machine），又称<strong>确定型图灵机</strong>，是英国数学家艾伦·图灵于1936年提出的一种将人的计算行为抽象化的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。图灵机有以下几个组成部分：</p>
<ol>
<li>一个不限长度的<strong>纸带</strong>。纸带被划分成一个个的小格子，格子中标有符号或者空白。</li>
<li>一个<strong>读写头</strong>。可在纸带上移动，能够读写格子中的符号。</li>
<li>一套<strong>控制规则</strong>。根据当前机器所处状态以及当前读写头所指的格子上的符号，来决定读写头下一步的动作，并改变状态寄存器的值。</li>
<li>一个<strong>状态寄存器</strong>。保存图灵机当前状态。</li>
</ol>
<p>不难看出图灵机本质上就是状态机，我们可以将机器从开始运行到停机的运作过程记录为一串序列：</p>
<p>$$q_0 \rightarrow_{\omega_0} q_1 \rightarrow_{\omega_1} q_2 \rightarrow … \rightarrow_{\omega_{n-1}} q_n$$</p>
<p>开始时，机器处于$q_0$状态，读写头指向0号格子；开始运行后，读入格子中的符号$\omega_0$，根据控制规则，机器进入下一状态$q_1$；重复此过程，直至到达终止状态，机器停机。</p>
<p>终止状态包括两种状态，$q_{accept}$称为接受状态，即机器根据控制规则成功运行至终态；$q_{reject}$称为拒绝状态，如果在运行中遇到下一个操作没有定义的情况，机器将立刻停机并拒绝输入的字符串。由于整个过程只要初始状态、输入、控制规则确定，机器运行的过程就确定，所以我们将其称之为<strong>确定型</strong>图灵机。</p>
<p>如果不加特殊说明，通常所说的图灵机都是确定型图灵机。<strong>非确定型图灵机</strong>和确定型图灵机的不同之处在于，在计算的每一时刻，根据当前状态和读写头所读的符号，<strong>机器存在多种状态转移方案，机器将任意地选择其中一种方案继续运作</strong>，直到最后停机为止。</p>
<p>图灵机是一个计算机的理论模型，我们通常说，现代计算机是基于冯诺依曼体系的，实际是冯诺依曼机就是基于图灵机模型的实现，包括高度复杂化的运算、控制、存储、输入、输出五个部分。比如纸带（用内存/磁盘模拟）、内部状态寄存器（现代计算机有大量的标志位和大量的寄存器甚至寄存器组）、在纸带上移动（各种跳转指令、各种复杂的寻址操作）、控制规则（CPU指令集）等。到目前为止，依然没有能够超越图灵机的模型。关于人工智能、量子计算机是否超越了图灵机也有非常有趣的讨论，感兴趣的读者可以自行查阅资料。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.matrix67.com/blog/archives/105">什么是P问题、NP问题和NPC问题</a></li>
<li><a href="https://www.zhihu.com/question/27039635">怎么理解P问题和NP问题？- 知乎</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA">图灵机 - WiKi</a></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
  </entry>
  <entry>
    <title>从零部署 Spark 集群</title>
    <url>/2017/11/15/%E4%BB%8E%E9%9B%B6%E9%83%A8%E7%BD%B2%20Spark%20%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>服务器资源：三台服务器节点，配置均为4核8G，500G硬盘。</li>
<li>操作系统：Ubuntu 16.04 </li>
<li>Hadoop安装包：hadoop-2.6.0-cdh5.13.0.tar.gz    <a href="http://archive.cloudera.com/cdh5/cdh/5/">（hadoop-cdh5官方下载链接）</a></li>
<li>Spark安装包：spark-2.2.0-bin-hadoop2.6.tgz <a href="http://spark.apache.org/downloads.html">（Spark官网下载链接）</a></li>
<li>JDK安装包：jdk-8u144-linux-x64.tar.gz</li>
</ul>
<h2 id="服务器相关设置"><a href="#服务器相关设置" class="headerlink" title="服务器相关设置"></a>服务器相关设置</h2><p>三台服务器节点，采用一主二从的模式，需要修改主机名并建立服务器间的 ssh 通信便于各服务器间免密访问以及 scp 命令分发文件。</p>
<h3 id="host相关设置"><a href="#host相关设置" class="headerlink" title="host相关设置"></a>host相关设置</h3><p>执行<code>vi /etc/hostname</code>修改主机名，主节点命名为master，从节点命名为slave01和slave02，执行<code>reboot</code>重启服务器生效。</p>
<p>三台服务器都修改<code>/etc/hosts</code>文件，IP地址为内网IP。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.10.6 master</span><br><span class="line">192.168.10.7 slave01</span><br><span class="line">192.168.10.8 slave02</span><br></pre></td></tr></table></figure>

<h3 id="配置ssh免密通信"><a href="#配置ssh免密通信" class="headerlink" title="配置ssh免密通信"></a>配置ssh免密通信</h3><p>普通用户登录后，执行<code>sudo passwd root</code>修改root密码，<code>su root</code>切换为root用户。</p>
<p>修改 ssh 配置文件 <code>/etc/ssh/sshd_config</code>，允许root登录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br></pre></td></tr></table></figure>

<p>在<code>/root</code>目录下执行如下命令，生成<code>.ssh</code>文件夹和公钥私钥。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>将三台服务器以及客户端主机的公钥复制到三台服务器的<code>/root/.ssh/authorized_keys</code>文件中。并重启ssh服务。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>

<p>现在已完成了服务器间 ssh 免密通信的功能，可以通过 scp 命令将文件从客户端主机分发到各个服务器，以及从主节点服务器分发到从节点服务器。scp 命令使用格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scp ~/Downloads/jdk-8u144-linux-x64.tar.gz root@master:/opt</span><br></pre></td></tr></table></figure>

<p>接下来按照步骤依次安装 JDK、Hadoop和Spark。均安装在 <code>/opt</code> 目录下，并分别命名为 jdk8、hadoop、spark。</p>
<h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><p>将下载好的 JDK、Hadoop和Spark 的软件安装包分发到主节点的<code>/opt</code>路径下，解压并改名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xzvf jdk-8u144-linux-x64.tar.gz</span><br><span class="line">mv jdk1.8.0_144/ jdk8</span><br><span class="line">mv jdk-8u144-linux-x64.tar.gz /tmp</span><br></pre></td></tr></table></figure>

<p>同理，解压hadoop和spark压缩包至 <code>/opt</code> 路径下，改名为hadoop和spark，然后将整个 <code>/opt</code> 文件夹从主节点分发给从节点。</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>修改服务器环境变量配置文件 <code>/etc/profile</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk8</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/opt/hadoop</span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=/opt/spark</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$SPARK_HOME</span>/bin:<span class="variable">$SPARK_HOME</span>/sbin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>可以直接将修改后的配置文件分发给从节点。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scp /etc/profile root@slave01:/etc/profile</span><br><span class="line">scp /etc/profile root@slave02:/etc/profile</span><br></pre></td></tr></table></figure>

<p>三台服务器都需执行 <code>source /etc/profile</code> 命令，使配置文件生效。</p>
<h2 id="配置Hadoop"><a href="#配置Hadoop" class="headerlink" title="配置Hadoop"></a>配置Hadoop</h2><p>Hadoop支持为所有主从节点采用同一套配置文件，除非新机器的硬件规格与现有机器不同时，需要一套新的配置文件以充分利用新硬件的额外资源。<a href="http://hadoop.apache.org/docs/r2.6.5/hadoop-project-dist/hadoop-common/ClusterSetup.html">官网配置文档</a> </p>
<ul>
<li><strong>HDFS（Hadoop分布式文件系统）</strong>：启动HDFS时主节点启动NameNode，负责管理namespace、控制客户端访问。从节点启动DataNode，提供存储和客户端读写操作。</li>
<li><strong>Hadoop YARN（资源管理系统）</strong>：用于改善MapReduce的实现，启动Yarn时主节点启动ResourceManager，用于调度、分发资源。从节点启动NodeManager，用于启动、监控运行应用程序的容器。</li>
</ul>
<p><code>cd /opt/hadoop/etc/hadoop</code>，前往hadoop配置文件目录。</p>
<p><code>vi hadoop-env.sh</code>，修改运行hadoop时的环境变量。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk8</span><br><span class="line"><span class="built_in">export</span> HADOOP_HEAPSIZE=8000</span><br><span class="line"><span class="built_in">export</span> HADOOP_LOG_DIR=/var/<span class="built_in">log</span>/hadoop</span><br></pre></td></tr></table></figure>

<p><code>vi core-site.xml</code>，该属性描述了HDFS文件系统的URI，默认端口是8020。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>vi hdfs-site.xml</code>，Hadoop守护进程配置，包括Namenode、辅助NameNode和DataNode等。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/hdfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/hdfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.checkpoint.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/hdfs/namesecondary<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>分别配置了namenode存储永久性文件系统元数据的目录、datanode存储数据块目录、辅助namenode存储文件系统的检查点目录。均可冗余备份，逗号隔开。</p>
<p><code>vi yarn-site.xml</code>，Yarn守护进程的配置项，包括资源管理器、web应用代理服务器和节点管理器。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">&lt;!-Site specific YARN configuration properties --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:10000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.local-dirs<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/nm-local-dir<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.memory-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>8192<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.cpu-vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce.shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>vi slaves</code>，在该文件中列出所有从节点的主机名或IP。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave01</span><br><span class="line">slave02</span><br></pre></td></tr></table></figure>

<h2 id="配置Spark"><a href="#配置Spark" class="headerlink" title="配置Spark"></a>配置Spark</h2><p>Apache Spark是专为大规模数据处理而设计的快速通用的计算引擎。它并没有以MapReduce作为执行引擎，而是使用的自己的分布式运行环境在集群上执行工作。Spark与Hadoop紧密集成，可以在Yarn上运行并支持HDFS。</p>
<p><code>cd /opt/spark/conf</code>前往Spark配置文件目录。</p>
<p>拷贝模版文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp spark-env.sh.template spark-env.sh</span><br><span class="line">cp slaves.template slaves</span><br></pre></td></tr></table></figure>

<p><code>vi slaves</code>添加从节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave01</span><br><span class="line">slave02</span><br></pre></td></tr></table></figure>

<p><code>vi spark-env.sh</code>，配置spark启动环境脚本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk8</span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=/opt/hadoop/etc/hadoop</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_HOST=master</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_PORT=7077</span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_CORES=1</span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_MEMORY=1g</span><br></pre></td></tr></table></figure>

<p><code>vi spark-defaults.conf</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spark.master                     spark://master:7077</span><br><span class="line">spark.driver.memory              8g</span><br></pre></td></tr></table></figure>

<h2 id="启动和测试"><a href="#启动和测试" class="headerlink" title="启动和测试"></a>启动和测试</h2><blockquote>
<p>以下操作均在主节点下完成，主节点会启动从节点的相关程序。</p>
</blockquote>
<p>在<code>/root</code>目录下新建存储文件夹，目录结构如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── hdfs</span><br><span class="line">│   ├── data</span><br><span class="line">│   ├── name</span><br><span class="line">│   └── namesecondary</span><br><span class="line">└── nm-local-dir</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分发给从节点。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scp -r hdfs/ root@slave01:/root/</span><br><span class="line">scp -r hdfs/ root@slave02:/root/</span><br><span class="line">scp -r nm-local-dir/ root@slave01:/root/</span><br><span class="line">scp -r nm-local-dir/ root@slave02:/root/</span><br></pre></td></tr></table></figure>

<p>现在JDK、Hadoop和Spark均已安装配置完成，将<code>/opt</code>文件夹分发给从节点。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scp -r /opt root@slave01:/</span><br><span class="line">scp -r /opt root@slave02:/</span><br></pre></td></tr></table></figure>

<h3 id="启动hadoop"><a href="#启动hadoop" class="headerlink" title="启动hadoop"></a>启动hadoop</h3><p>执行<code>ufw disable</code>关闭防火墙。</p>
<p>初始化文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>

<p>启动Hadoop集群（该命令其实是包含了<code>start-dfs.sh</code>和<code>start-yarn.sh</code>两个命令）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure>

<p>在各节点上执行<code>jps</code>查看启动情况，日志文件在<code>/opt/hadoop/logs</code>目录下。</p>
<p>在本地浏览器上访问<code>&#123;IP&#125;:/50070</code>查看hdfs的WebUI（50070为默认端口）；访问<code>&#123;IP&#125;:/10000</code>查看ResourceManager的WebUI。</p>
<h3 id="启动Spark"><a href="#启动Spark" class="headerlink" title="启动Spark"></a>启动Spark</h3><p>启动Spark集群。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/spark/sbin/start-all.sh</span><br></pre></td></tr></table></figure>

<p>各节点执行<code>jps</code>可以看到主节点启动了Master程序，从节点启动了Worker程序。</p>
<p>可以在本地浏览器上访问<code>&#123;IP&#125;:8080</code>验证Spark已启动</p>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2019/02/25/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理模式（Proxy Pattern）是一种常见的设计模式，也是 GoF 提出的 23 种设计模式中的一种，属于结构型设计模式。<strong>它使用代理对象完成用户请求，屏蔽用户对真实对象的访问</strong>。代理模式用处很多，本文主要介绍如何使用代理模式实现<strong>延迟加载</strong>和<strong>面向切面编程</strong>，并着重介绍动态代理的几种实现方式。本文涉及到的示例代码以上传到 <a href="https://github.com/s1mplecc/proxy-pattern-demo">GitHub</a> 上。</p>
<h2 id="角色及职责"><a href="#角色及职责" class="headerlink" title="角色及职责"></a>角色及职责</h2><p>代理模式中的几个角色：</p>
<ul>
<li><strong>Subject</strong>，接口，定义了代理类和被代理类对外暴露的方法。代理类和被代理类都需要实现该接口。</li>
<li><strong>RealSubject</strong>，真实对象（被代理类），真正实现功能的对象。</li>
<li><strong>Proxy</strong>，代理类，用来<strong>封装</strong>真实对象。</li>
</ul>
<p><img src="/2019/02/25/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/0.png" alt="0d73af744af2fd7ecfd3326888c3d69b.png"></p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>代理模式通常用于解决以下几类问题：</p>
<ul>
<li><strong>需要控制对象的访问权限</strong></li>
<li><strong>需要扩展一个对象的功能</strong></li>
</ul>
<p>对此，代理模式使用 Proxy 封装真实对象，以达到控制真实对象的访问权限，并在此基础上提供额外功能。代理模式有以下几个典型的应用场景：</p>
<ul>
<li>远程代理，在分布式对象通信中，使用一个本地对象代表远程对象（分属不同地址空间）。本地对象是远程对象的代理，本地对象上的方法调用将导致远程对象上的方法调用。一个例子是 ATM 实现，其中 ATM 可以保存位于远程服务器上的银行信息的代理对象。</li>
<li>虚拟代理，如果一个对象很复杂或很重，可以使用虚拟代理。比如当图像很大时，可以按需的去加载用到的部分（亦即<strong>延迟加载</strong>）。</li>
<li>保护代理，可以控制资源的访问权限。</li>
</ul>
<h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>我们先来看看如何使用代理模式进行延迟加载。假设现在有一个数据库查询类 DBQuery，它执行查询返回一个字符串。由于数据查询需要连接数据库，所以在构造时会比较耗时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBQuery</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// create datebase connection</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;query result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，如果在程序启动的时候我们就去 new 这个对象，一旦存在大量类似的操作，系统的启动速度必定会受影响。而采用代理类替代 DBQuery，可以做到轻量级启动。</p>
<p>首先需要创建一个接口，对应着代理模式角色中的 Subject：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDBQuery</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实对象 DBQuery 和代理类 DBQueryProxy 都需要实现这个接口。<strong>在代理类内部封装了真实对象，实际调用时使用委派（Delegation）调用被代理类的方法</strong>。这也是代理模式的核心所在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBQueryProxy</span> <span class="keyword">implements</span> <span class="title">IDBQuery</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DBQuery dbQuery;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dbQuery == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dbQuery = <span class="keyword">new</span> DBQuery();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dbQuery.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在启动时初始化代理类，由于代理类 DBQueryProxy 的构造函数什么也没做，所以启动是相当迅速的（下述代码第 1 步）。而真正查询数据库（第 2 步）时才创建 DBQuery 对象执行耗时操作，从而实现了<strong>需要的时候才加载</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IDBQuery query = <span class="keyword">new</span> DBQueryProxy(); <span class="comment">// 1</span></span><br><span class="line">    query.query(); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>现在来考虑一件事，如果需要在查询语句的前后添加日志该怎么做？在没有代理类之前，我们可能只能在真实对象中添加两行日志。但严格来说，日志记录不属于 DBQuery 的职责，它破坏了类的纯粹性（违背了迪米特法则）。所以现在有了代理类 DBQueryProxy，我们理所因当的应该将日志记录放在代理类中。即如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBQueryProxy</span> <span class="keyword">implements</span> <span class="title">IDBQuery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dbQuery == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dbQuery = <span class="keyword">new</span> DBQuery();</span><br><span class="line">            log.info(<span class="string">&quot;Create database connection.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String result = dbQuery.query();</span><br><span class="line">        log.info(<span class="string">&quot;Query response is &#123;&#125;.&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以将日志功能与 DBQuery 解耦，我们做到了将业务功能与系统级功能解耦，但这还不够。我们实现解耦的方式是采用的<strong>静态代理</strong>，即代码在编译前就得写死了。虽然静态代理可以做到在不修改目标对象的功能前提下，对目标功能扩展，但它的缺点也显而易见，就是代码的冗余。一个 DBQuery，就需要一个代理类，那如果有一千个 DBQuery 难道要写一千个代理类吗？</p>
<p><strong>AOP（Aspect Oriented Programming）</strong>，面向切面编程的出现就是为了解决这类问题。它通过<strong>预编译</strong>方式和运行期<strong>动态代理</strong>实现程序功能的统一维护。最为人熟知的应该就是 Spring AOP 了。在 Spring 中提供了面向切面编程的丰富支持，允许<strong>通过分离应用的业务逻辑与系统级服务进行内聚性的开发</strong>。业务对象只做它应该做的 —— 完成业务逻辑 —— 仅此而已。它们并不负责其它的系统级关注点，诸如日志记录，性能统计，安全控制，事务处理，异常处理等。通过这种分离我们可以做到改变系统级服务代码时不影响业务代码的逻辑。</p>
<p>关于预编译的方式就不多说了，它的典型代表是 AspectJ，它需要专门的 Java 编译器将系统级代码织入业务代码中。除此之外，还可以通过运行时织入，也就是动态代理。<strong>Spring AOP 就构建在动态代理基础之上</strong>。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><strong>动态代理使用字节码动态生成加载技术，在运行时生成并加载类</strong>。与静态代理相比，动态代理有诸多好处。首先，不需要为真实主题创建一个形式上完全一样的封装类，假如主题接口中方法很多，为每个方法重写一个代理方法也是非常麻烦的事，一旦接口发生变更，意味着真实主题与代理类都要修改，不利于系统维护；其次，使用动态代理的生成方法可以指定代理类的执行逻辑，从而提升系统的灵活性。</p>
<p>生成动态代理的方式很多，包括 JDK 自带的动态代理、<strong>CGLIB</strong>、<strong>Javassist</strong> 等，本文只介绍前两种的使用方式。</p>
<h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>JDK 从 1.3 开始提供了对动态代理的支持，它可以动态的创建代理类并动态的处理对所代理方法的调用。在动态代理上所做的所有调用都会被重定向到单一的<strong>调用处理器</strong>上，它的工作是揭示调用的类型并确定相应的对策。</p>
<p>调用处理器需要实现 InvocationHandler 接口，重写 invoke 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DynamicProxyHandler.class);</span><br><span class="line">    <span class="keyword">private</span> Object proxied;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Dynamic proxy &#123;&#125; class &#123;&#125;() method.&quot;</span>, proxied.getClass().getSimpleName(), method.getName());</span><br><span class="line">        Object invoke = method.invoke(proxied, args);</span><br><span class="line">        log.info(<span class="string">&quot;result is &#123;&#125;.&quot;</span>,invoke);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面代码在 main 方法中生成了一个实现了 IDBQuery 接口的代理类，代理类的内部逻辑由 DynamicProxyHandler 决定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IDBQuery proxy = (IDBQuery) Proxy.newProxyInstance(</span><br><span class="line">            IDBQuery.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;IDBQuery.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> DynamicProxyHandler(<span class="keyword">new</span> DBQuery()));</span><br><span class="line">    proxy.query();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [main] INFO DynamicProxyHandler - Dynamic proxy DBQuery class query() method.</span></span><br><span class="line"><span class="comment">// [main] INFO DynamicProxyHandler - result is query result.</span></span><br></pre></td></tr></table></figure>

<p>通过调用静态方法 <code>Proxy.newProxyInstance()</code> 可以创建动态代理，该方法需要得到一个类加载器（通常可以从已经被加载的对象中获取其类加载器，然后传递给它），一个你希望该代理实现的接口列表（不是类或抽象类），以及 InvocationHandler 接口的一个实现。动态代理可以将所有调用重定向到调用处理器，因此通常会向调用处理器的构造器传入一个“实际”对象的引用，从而使得调用处理器在执行其中介任务时，可以将请求转发。</p>
<p>invoke 方法中传入了代理对象（即参数 proxy）以备你需要区分请求的来源，但在多数情况下你并不关心这一点。然而，在 invoke 内部，在代理上调用方法需要格外当心，因为对接口的调用将被重定向为对代理的调用。通常，你会执行被代理的操作，然后使用 <code>method.invoke()</code> 将请求转发给被代理对象，并传入必需的参数。</p>
<h3 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h3><p>Java 提供的动态代理使用简单，它内置在 JDK 中，因此不需要引入第三方 Jar 包，但相对功能较弱。除此之外，CGLIB 动态代理库为 JDK 的动态代理提供了很好的补充，并且性能更好。</p>
<p><strong>CGLIB 为没有实现接口的类提供代理</strong>，它针对代理的类，动态生成一个子类，然后子类覆盖代理类中的方法。如果是 private 或是 final 类修饰的方法，则不会被重写。通常可以使用 Java 的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB 是一个好的选择。</p>
<p>CGLIB 作为一个开源项目，其代码托管在 <a href="https://github.com/cglib/cglib">GitHub</a> 上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cglib proxy begin&quot;</span>);</span><br><span class="line">        Object result = method.invoke(target, objects);</span><br><span class="line">        System.out.println(result + <span class="string">&quot;\ncglib proxy end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> CglibProxy(target));</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DBQuery proxy = (DBQuery) CglibProxy.getProxy(<span class="keyword">new</span> DBQuery());</span><br><span class="line">        proxy.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cglib proxy begin</span></span><br><span class="line"><span class="comment">// query result</span></span><br><span class="line"><span class="comment">// cglib proxy end</span></span><br></pre></td></tr></table></figure>

<p>与 JDK 自带的代理类似，基于 CGLIB 的代理类需要实现 MethodInterceptor 接口，重写 intercept 方法。使用 Enhancer 生成需要被代理的类的子类的实例。</p>
<p>在 Spring 的 AOP 编程中，如果加入容器的目标对象有实现接口，使用 JDK 代理。如果目标对象没有实现接口，则使用 CGLIB 代理。</p>
<h3 id="Hibernate-对动态代理的应用"><a href="#Hibernate-对动态代理的应用" class="headerlink" title="Hibernate 对动态代理的应用"></a>Hibernate 对动态代理的应用</h3><p>动态代理的一个经典应用就是 Hibernate 框架。当 Hibernate 加载实体 Bean 时，并不会一次性将数据库所有的数据都装载，而是采用延迟加载的机制，以提高系统的性能。这里以属性的延迟加载为例，展示 Hibernate 是如何使用动态代理的。</p>
<p>从数据库载入 ID 为 1 的 User 用户，并且打印它的类名、父类名、实现的接口名。最后调用 getName 方法取得数据库数据。演示代码采用的 Hibernate 版本为 3.2.6，不同的 Hibernate 版本实现会有差异。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = (User)sessionFactory.getSession().load(User.class, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Class name: &quot;</span> + user.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">&quot;Superclass name: &quot;</span> + user.getClass().getSuperclass().getName());</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; anInterface : user.getClass().getInterfaces()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Interface name: &quot;</span> + anInterface.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;\n&quot;</span> + user.getName());</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class name: com.github.s1mplecc.gof.proxy.User$EnhancerByCGLIB$N8wfgVhe</span><br><span class="line">Superclass name: com.github.s1mplecc.gof.proxy.User</span><br><span class="line">Interface name: org.hibernate.proxy.HibernateProxy</span><br><span class="line"></span><br><span class="line">Hibernate: select user0_.id as id1_0_0_, user0_.name as name2_0_0_ from t_user user0_ where user0_.id=?</span><br><span class="line">Geym</span><br></pre></td></tr></table></figure>

<p>从输出来看，load 方法加载出的 User 类并不是我们定义的 User 类，而是名为 <code>com.github.s1mplecc.gof.proxy.User$EnhancerByCGLIB$N8wfgVhe</code> 的类。从名称上可以推测它是使用 CGLIB 的 Enhancer 生成的动态类。该类的父类才是我们自定义的 User 类，此外，它还实现了 HibernateProxy 接口。由此可见，<strong>Hibernate 使用一个动态代理生成的子类替代用户定义的类</strong>。只有在真正使用对象数据时，才去数据库加载实际的数据。从输出结果来看，在调用 getName 方法之前从未输出过一条 SQL 语句，这说明 User 对象被加载时根本没有访问数据库。Hibernate 正是用这种方式实现了延迟加载。</p>
<p>另外，由于 CGLIB 停止维护很长一段时间了，Hibernate 从 3.5.5 版本开始弃用 CGLIB 而使用 Javassist。感兴趣的同学可以自行下去研究。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Proxy_pattern">Proxy pattern —— Wiki</a></li>
<li>《Java 编程思想》</li>
<li>《Java 程序性能优化 —— 让你的 Java 程序更快、更稳定》</li>
</ul>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Certbot 配置 HTTPS</title>
    <url>/2017/11/06/%E4%BD%BF%E7%94%A8%20Certbot%20%E9%85%8D%E7%BD%AE%20HTTPS/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文介绍在搭建了服务器并且配置了域名后，如何通过 Certbot 将原先的 <code>http://</code> 域名配置为 <code>https://</code> 域名。文章的最后介绍了 HTTPS 基于的 SSL 协议，以及和 SSL 加密通信过程类似的 SSH 协议。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>Ubuntu 16.04</li>
<li>Nginx</li>
</ul>
<h2 id="安装配置-Certbot"><a href="#安装配置-Certbot" class="headerlink" title="安装配置 Certbot"></a>安装配置 Certbot</h2><p>添加软件源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:certbot/certbot</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>/etc/apt/sources.list.d</code> 目录下多了个 <code>certbot-ubuntu-certbot-xenial.list</code> 文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://ppa.launchpad.net/certbot/certbot/ubuntu xenial main</span><br><span class="line"># deb-src http://ppa.launchpad.net/certbot/certbot/ubuntu xenial main</span><br></pre></td></tr></table></figure>

<p>安装Certbot：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python-certbot-nginx </span><br></pre></td></tr></table></figure>

<p>使用如下命令自动配置Nginx服务，也可以加上 <code>certonly</code> 参数来手动配置nginx。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo certbot --nginx</span><br></pre></td></tr></table></figure>

<p>出现如下文字，说明Certbot读取了nginx配置文件。默认回车选择所有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Which names would you like to activate HTTPS for?</span><br><span class="line">-------------------------------------------------</span><br><span class="line">1: s1mple.info</span><br><span class="line">2: www.s1mple.info</span><br></pre></td></tr></table></figure>

<p>选择是否重定位到HTTPS：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">1: No redirect - Make no further changes to the webserver configuration.</span><br><span class="line">2: Redirect - Make all requests redirect to secure HTTPS access. Choose this for</span><br><span class="line">new sites, or if you&#x27;re confident your site works on HTTPS. You can undo this</span><br><span class="line">change by editing your web server&#x27;s configuration.</span><br></pre></td></tr></table></figure>

<p>配置成功，有效期为90天，过期需要使用 <code>certbot renew</code> 更新新的证书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMPORTANT NOTES:</span><br><span class="line">- Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">  /etc/letsencrypt/live/simple. info/fullchain.pem</span><br><span class="line">  Your key file has been saved at:</span><br><span class="line">  /etc/letsencrypt/live/simple. info/privkey.pem</span><br><span class="line">  Your cert will expire on 2018-02-04. To obtain a new or tweaked</span><br><span class="line">  version of this certificate in the future, simply run certbot again</span><br><span class="line">  with the “certonly&quot; option. To non-interactively renew xall* of</span><br><span class="line">  your certificates, run &quot;certbot renew&quot;</span><br></pre></td></tr></table></figure>

<p>现在你可以通过HTTPS访问你的网站了。</p>
<p>我们查看一下Nginx配置文件，文件名对应你的域名，以 <code>.conf</code> 结尾，发现新增了如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen 443 ssl; # managed by Certbot</span><br><span class="line">ssl_certificate /etc/letsencrypt/live/s1mple.info/fullchain.pem; # managed by Certbot</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/s1mple.info/privkey.pem; # managed by Certbot</span><br><span class="line">include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br><span class="line"></span><br><span class="line"># Redirect non-https traffic to https</span><br><span class="line">if ($scheme != &quot;https&quot;) &#123;</span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125; # managed by Certbot</span><br></pre></td></tr></table></figure>

<p>说明Nginx在监听443端口，并将不是HTTPS的请求重定位到HTTPS。</p>
<h2 id="协议原理"><a href="#协议原理" class="headerlink" title="协议原理"></a>协议原理</h2><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p><strong>HTTPS(Http over Secure Socket Layer)</strong> 是基于SSL加密的更安全的HTTP协议，默认端口443。SSL握手协议过程如下：</p>
<ol>
<li>客户端的浏览器向服务器传送客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他通讯所需要信息。</li>
<li>服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时<strong>服务器还将向客户端传送自己的证书</strong>。</li>
<li>客户端利用服务器传过来的信息<strong>验证服务器的合法性</strong>，服务器的合法性包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。</li>
<li>客户端随机产生一个用于后面通讯的“对话密钥”，然后用服务器的公钥（从步骤2中的服务器的证书中获得）对其加密，然后传给服务器。</li>
<li><strong>服务器用私钥解密</strong>“对话密钥”（此处的公钥和私钥是对应的，公钥加密的数据只能用私钥解密，服务器私钥只在服务器端保留），然后用其作为服务器和客户端的“通话密码”加解密通讯。具体的加密算法详见<a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA加密算法</a>。</li>
<li>SSL的握手部分结束，SSL安全通道的数据通讯开始，客户和服务器开始使用对话密钥进行数据通讯，同时进行通讯完整性的检验。</li>
</ol>
<p><img src="/2017/11/06/%E4%BD%BF%E7%94%A8%20Certbot%20%E9%85%8D%E7%BD%AE%20HTTPS/0.png" alt="78ab162bf20b438ca377faa87f4ea2a2_th"></p>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p><strong>SSH(Secure Shell)<strong>协议，专为远程登录会话提供安全性的协议，传输的数据都进行了加密。SSH提供两种级别的安全验证，第一种是</strong>基于口令</strong>的安全验证。第二种是<strong>基于密匙</strong>的安全验证，不需要传输口令，原理同 SSL 类似。下面介绍一下 SSH 基于密钥的安全验证。</p>
<p>客户端创建<strong>一对密钥</strong>（公钥和私钥），公钥存放在服务器上的 authorized_keys 文件中，当你想通过 ssh 远程连接服务器时会进行<strong>公钥比对</strong>。如果一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端。客户端收到“质询”之后就可以用你的<strong>私钥解密</strong>再把它发送给服务器。</p>
<p>SSH 通过密钥连接服务器步骤如下：</p>
<ol>
<li>在本地执行<code>ssh-keygen</code>生成配对密钥，在你的<code>~/.ssh</code>目录下会生成两个文件，<code>id_rsa</code>私钥，<code>id_rsa.pub</code>公钥。</li>
<li>将公钥拷贝到服务器的<code>~/.ssh/authorized_keys</code>文件中。</li>
<li>使用<code>chattr +i authorized_keys</code>命令给<code>authorized_keys</code>增加不可修改、删除的权限。</li>
<li>在本地使用<code>ssh &#123;username&#125;@&#123;ip&#125;</code>连接服务器。第一次连接会询问你是否继续，选择 yes 则将连接信息添加到<code>~/.ssh/known_hosts</code>文件中，此后连接不再询问。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://certbot.eff.org/#ubuntuxenial-nginx">Certbot官方文档</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">图解SSL/TLS协议 —— 阮一峰</a></li>
<li><a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA加密算法 —— WiKi</a></li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Docker 部署 Java Web 应用</title>
    <url>/2017/11/04/%E4%BD%BF%E7%94%A8%20Docker%20%E9%83%A8%E7%BD%B2%20Java%20Web%20%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JPress是基于JAVA的博客平台，作为一个Web程序，我将用它演示如何构建自己的Docker镜像，以及如何使用Docker部署Java Web应用。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>服务器 ubuntu 16.04</li>
<li>下载好的jpress.war包，<a href="http://jpress.cnitti.net/c/11.html">下载地址</a>，下载下来先在IDE里跑了测试一下，以免服务器上出问题</li>
<li>构建好的java-web开发环境Docker镜像，<a href="http://s1mple.info/deploy-with-docker/">如何构建</a></li>
<li>Nginx</li>
<li>Mysql</li>
</ul>
<h2 id="构建JPress镜像"><a href="#构建JPress镜像" class="headerlink" title="构建JPress镜像"></a>构建JPress镜像</h2><p>在部署JPress之前我们需要先构建JPress镜像，以便生成容器实例。首先修改Tomcat的配置文件，以适用于JPress。</p>
<h3 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h3><p>创建<code>java-web-env</code>容器实例，进入bash：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it s1mple1995/java-web-env bash</span><br></pre></td></tr></table></figure>

<p>修改Tomcat配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/lib/tomcat9/conf/server.xml</span><br></pre></td></tr></table></figure>

<p>修改8080端口为1110，并修改<code>&lt;Context&gt;</code>标签，意思是Web应用文件夹名为<code>jpress</code>，访问路径为根路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Context docBase=&quot;jpress&quot; path=&quot;&quot; reloadable=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>退出容器，并生成新的镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit $&#123;container ID&#125; s1mple1995/jpress</span><br></pre></td></tr></table></figure>
<p>现在你有了jpress的镜像，但是Tomcat的webapps目录下空空如也，我们需要通过<strong>Dockerfile</strong>来构建更完善的jpress镜像。</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>先在服务器上创建一个jpress文件夹，将<strong>jpress.war</strong><code>scp</code>到此目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/s1mple/jpress</span><br></pre></td></tr></table></figure>
<p>执行<code>vim Dockerfile</code>编写镜像构建文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Base image</span><br><span class="line">From s1mple1995/jpress</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line"># environment variables</span><br><span class="line">ENV APP /usr/local/lib/tomcat9/webapps</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at $APP</span><br><span class="line">ADD ./jpress.war $APP</span><br><span class="line"></span><br><span class="line"># Make port 1110 available to the world outside this container</span><br><span class="line">EXPOSE 1110</span><br><span class="line"></span><br><span class="line">WORKDIR $APP</span><br><span class="line"></span><br><span class="line">CMD [&quot;service&quot;, &quot;tomcat&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure>

<p>其中，<strong>From</strong>指依赖的基础镜像。<strong>USER</strong>默认就是root，在生产环境为了安全可以指定其他用户。<strong>ENV</strong>是环境变量。<strong>ADD</strong>或者<strong>COPY</strong>命令将我们的war包拷贝到webapps目录下。<strong>EXPOSE</strong>开放端口。<strong>WORKDIR</strong>表示你进入容器时的初始路径。<strong>CMD</strong>为容器启动时执行的命令。这里使用<code>service tomcat run</code>而不是<code>start</code>是因为容器会监控前台如果没有输出，在<code>start</code>命令执行完后就会自动退出。而<code>run</code>命令是前台运行。我之前一直用<code>start</code>命令发现容器总是刚启动就退出。<br>更多命令请参考<a href="https://docs.docker.com/engine/reference/builder/#from">官方文档</a>。</p>
<h3 id="构建Docker镜像"><a href="#构建Docker镜像" class="headerlink" title="构建Docker镜像"></a>构建Docker镜像</h3><p>现在所有准备工作都已完成，你可以构建自己的JPress镜像了。</p>
<p>在<code>/home/s1mple/jpress</code>目录下执行，<code>-t</code>给新镜像打上标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t s1mple1995/jpress .</span><br></pre></td></tr></table></figure>

<p>可以看到控制台输出了一些信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon 20.@6MB</span><br><span class="line">Step 1/6 : FROM simple1995/jpress</span><br><span class="line">---&gt; 6c7F7aa5716d</span><br><span class="line">Step 2/6 : USER root</span><br><span class="line">---&gt; Running in d29bd2d7cf4e</span><br><span class="line">---&gt; 616922ef516c</span><br><span class="line">Removing intermediate container d29bd2d7cf4e</span><br><span class="line">Step 3/6 : ENV APP /usr/local/lib/tomcat9/webapps</span><br><span class="line">---&gt; Running in 5667a207¢898</span><br><span class="line">---&gt; b6c061148616</span><br><span class="line">Removing intermediate container 5667a267¢898</span><br><span class="line">Step 4/6 : ADD ./jpress.war SAPP</span><br><span class="line">---&gt; a82c14e949e0</span><br><span class="line">Step 5/6 : EXPOSE 1110</span><br><span class="line">---&gt; Running in b31964ddfefo</span><br><span class="line">---&gt; cd9de2d7786F</span><br><span class="line">Removing intermediate container b31964ddfefo</span><br><span class="line">Step 6/6 : CMD service tomcat run</span><br><span class="line">---&gt; Running in @4a6a78fa77a</span><br><span class="line">---&gt; de9b3648553e</span><br><span class="line">Removing intermediate container @4a6a78fa77a</span><br><span class="line">Successfully built de9b3648553e</span><br><span class="line">Successfully tagged s1mple1995/jpress:latest</span><br></pre></td></tr></table></figure>

<p>Dockerfile里的每一句命令都会在一个新的容器中运行，并生成一个新的镜像，再将中间过渡的容器移除。</p>
<p>我们来验证一下，执行<code>docker images</code>看到我的两个镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPOSITORY                  TAG          IMAGE ID</span><br><span class="line">s1mple1995/jpress           latest       de9b3648553e</span><br><span class="line">simple1995/java-web-env     latest       292d98d8d6d4</span><br></pre></td></tr></table></figure>

<p>执行<code>docker image history de9</code>查看jpress镜像历史</p>
<p><img src="/2.png" alt="-----2017-11-04---7.01.30"></p>
<p>甚至可以看到我们通过<code>bash</code>修改tomcat配置文件后提交的镜像，你可以通过运行这些镜像来回退你的操作</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行，<code>-p</code>绑定端口，<code>-v</code>挂载宿主机与容器的共享文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -d -p 1110:1110 -v /home/s1mple/jpress/:/usr/local/lib/tomcat9/webapps s1mple1995/jpress</span><br></pre></td></tr></table></figure>

<p>不出意外，你现在就可以在浏览器上访问<code>http://&#123;domain&#125;:1110/install</code>进入JPress安装向导，按照步骤，填写数据库信息，需要提前建库。数据库主机填写你安装了mysql的服务器IP。</p>
<p>如果长时间未加载，可以执行<code>docker restart</code>命令重启容器</p>
<h2 id="Nginx重定位"><a href="#Nginx重定位" class="headerlink" title="Nginx重定位"></a>Nginx重定位</h2><p>通过nginx配置二级域名，你现在可以通过 <a href="http://jpress.s1mple.info/">http://jpress.s1mple.info</a> 访问我的jpress博客。</p>
<p>首先你要保证开放了二级域名。我的域名是在GoDaddy上买的，需要在他的DNS管理界面添加<code>*.s1mple.info</code>。</p>
<p>添加nginx配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/nginx/sites-enabled</span><br><span class="line">cp ghost_8080.conf jpress.conf</span><br></pre></td></tr></table></figure>

<p>修改jpress.conf文件，添加80、8080端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_name jpress.s1mple.info www.jpress.s1mple.info;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_pass http://127.0.0.1:1110;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>service nginx restart</code>即可。</p>
<p>效果图<br><img src="/3.png" alt="-----2017-11-20---9.42.47"></p>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Docker 快速部署 Spark + Hadoop 大数据集群</title>
    <url>/2021/10/12/%E4%BD%BF%E7%94%A8-Docker-%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2-Spark-Hadoop-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了免去繁杂的环境配置工作，提供开箱即用的 Spark + Hadoop 快捷部署方案。本教程基于 BitNami 项目的成熟镜像方案，搭建 Spark Docker 集群，并在原有镜像基础上，构建了安装有对应版本 Hadoop 的镜像。</p>
<p>镜像已提交至 Docker Hub 官方仓库中，可通过如下命令拉取：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull s1mplecc/spark-hadoop:3</span><br></pre></td></tr></table></figure>

<p>构建镜像的所需文件也已提交至 GitHub：<a href="https://github.com/s1mplecc/spark-hadoop-docker">s1mplecc/spark-hadoop-docker</a>。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>操作系统 MacOS Mojave，命令行工具：Terminal + Zsh</li>
<li>Docker Desktop for Mac，内置 Docker CLI client 与 Docker Compose</li>
<li>Spark Docker 镜像：<a href="https://github.com/bitnami/bitnami-docker-spark">bitnami-docker-spark</a>，Spark 版本：3.1.2</li>
<li>Hadoop 版本：<a href="https://hadoop.apache.org/release/3.2.0.html">hadoop-3.2.0</a></li>
</ul>
<h2 id="部署-Spark-集群"><a href="#部署-Spark-集群" class="headerlink" title="部署 Spark 集群"></a>部署 Spark 集群</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p><a href="https://github.com/bitnami">BitNami</a> 是一个开源项目，现已被 VMware 公司收购，其宗旨是简化在个人终端、Kubernetes 和云服务器等环境上的开源软件的部署。其已为 Docker Hub 社区提供了数百个容器镜像方案，其中的 Redis、MongoDB 等热门镜像更是超过了十亿次下载。</p>
<p>bitnami/spark 镜像也已超过百万次下载，这是一个成熟的 Spark Docker 方案。此外选择它的重要原因是它的文档齐全，且更新频率快，目前的最新版本基于 Spark 官方发行的最新版本 Spark 3.1.2。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ docker pull bitnami/spark:3</span><br><span class="line">➜ docker images       </span><br><span class="line">REPOSITORY               TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">bitnami/spark            3         67ed3ae333e0   4 days ago      1.29GB</span><br></pre></td></tr></table></figure>

<p>注：此镜像基于 bitnami/minideb 基础镜像，这是 BitNami 构建的极简 Debian 系统镜像。Debian 由于系统稳定且内核占用资源小的优势，非常适合作为服务器操作系统。</p>
<h3 id="以集群方式运行"><a href="#以集群方式运行" class="headerlink" title="以集群方式运行"></a>以集群方式运行</h3><p>为了模拟 Spark 集群，采取一主二从的部署方式，使用 Docker Compose 对容器集群进行统一编排管理。</p>
<p>首先，在本地新建一个工作目录，我的路径为 <code>~/docker/spark</code>，在该目录下编写 docker-compose.yml 配置文件。基于 bitnami/spark 提供的配置文件，我做了一些修改，包括：</p>
<ul>
<li><code>hostname</code>：容器实例主机名；</li>
<li><code>volumes</code>：挂载本地目录 <code>~/docker/spark/share</code> 到容器目录 <code>/opt/share</code>；</li>
<li><code>ports</code>：开放 4040 和从节点 Spark Web UI 端口。</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">spark:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/bitnami/spark:3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MODE=master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_AUTHENTICATION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_LOCAL_STORAGE_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_SSL_ENABLED=no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker/spark/share:/opt/share</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8080:8080&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;4040:4040&#x27;</span></span><br><span class="line">  <span class="attr">spark-worker-1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/bitnami/spark:3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">worker1</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MODE=worker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MASTER_URL=spark://master:7077</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_MEMORY=1G</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_CORES=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_AUTHENTICATION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_LOCAL_STORAGE_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_SSL_ENABLED=no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker/spark/share:/opt/share</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8081:8081&#x27;</span></span><br><span class="line">  <span class="attr">spark-worker-2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.io/bitnami/spark:3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">worker2</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MODE=worker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MASTER_URL=spark://master:7077</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_MEMORY=1G</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_CORES=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_AUTHENTICATION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_LOCAL_STORAGE_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_SSL_ENABLED=no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker/spark/share:/opt/share</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8082:8081&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在可以启动 Spark Docker 集群了。在工作目录下，执行如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ docker-compose up -d                        </span><br><span class="line">[+] Running 3/3</span><br><span class="line"> ⠿ Container spark-spark-1           Started                                         1.0s</span><br><span class="line"> ⠿ Container spark-spark-worker-2-1  Started                                         1.1s</span><br><span class="line"> ⠿ Container spark-spark-worker-1-1  Started                                         1.1s</span><br></pre></td></tr></table></figure>

<p>启动后的集群可以在 Docker Desktop 中进行查看：</p>
<p><img src="/2021/10/12/%E4%BD%BF%E7%94%A8-Docker-%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2-Spark-Hadoop-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4/1.png" alt="7262ff48300734f66dd1a10cce5a064e.png"></p>
<p>可通过映射的端口访问 Spark Web UI。集群以默认的 Standalone 独立集群模式启动，通过 <a href="http://localhost:8080/">http://localhost:8080/</a> 查看集群运行状态：</p>
<p><img src="/2021/10/12/%E4%BD%BF%E7%94%A8-Docker-%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2-Spark-Hadoop-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4/2.png" alt="556c8dffa7f55d32d78b52c11fe31701.png"></p>
<h4 id="集群网络"><a href="#集群网络" class="headerlink" title="集群网络"></a>集群网络</h4><p>默认情况下，通过 <code>docker-compose</code> 启动的容器集群，会创建并使用名为 <code>镜像名_default</code> 的桥接网络，如 <code>spark_default</code>。集群内的容器处于同一子网网段，因此可以相互通信。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ docker network ls         </span><br><span class="line">NETWORK ID     NAME            DRIVER    SCOPE</span><br><span class="line">331df1b4ff6d   bridge          bridge    local</span><br><span class="line">3a916c4f1299   host            host      local</span><br><span class="line">42b893852f97   none            null      local</span><br><span class="line">e425e615144b   spark_default   bridge    local</span><br></pre></td></tr></table></figure>

<p>通过 <code>inspect</code> 命令查看网络配置详情。以下是 <code>spark_default</code> 网络部分配置信息，其使用 <code>172.18.0.0/16</code> 子网网段，并为每个容器实例分配了 IPv4 地址。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">➜ docker network inspect e4</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;spark_default&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Id&quot;</span>: <span class="string">&quot;e425e615144b972265afa9c6e78d7bf22cab446bc5bdece3f188abf5879e8677&quot;</span>,   # NETWORK ID</span><br><span class="line">        <span class="attr">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;Subnet&quot;</span>: <span class="string">&quot;172.18.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;Gateway&quot;</span>: <span class="string">&quot;172.18.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;9b9d9c1bb6f873da6b3c72232afab3a451b12cdd4c19d51cc510de1854f95efd&quot;</span>: &#123;   # CONTAINER ID</span><br><span class="line">                <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;spark-spark-worker-1-1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.2/16&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;a162bd33dc1936c70259ed2146a1f4a30e52faf66a91624d794336b5357a5f7b&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;spark-spark-worker-2-1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.4/16&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;b6ad535e924221e30746722cd486dace692f0f42528eba57347ef4177b355855&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;spark-spark-1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.18.0.3/16&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>注：同 CONTAINER ID 一样，NETWORK ID 的前两位可以唯一标识一个网络，如 <code>e4</code>。</p>
<h3 id="使用-Spark-Shell-进行交互"><a href="#使用-Spark-Shell-进行交互" class="headerlink" title="使用 Spark Shell 进行交互"></a>使用 Spark Shell 进行交互</h3><p>查看正在运行的容器实例，找到 master 实例的容器 ID：a162bd33dc19。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  ~ docker ps                </span><br><span class="line">CONTAINER ID   IMAGE                     COMMAND                  CREATED        STATUS             PORTS                                                                                                                                              NAMES</span><br><span class="line">a162bd33dc19   s1mplecc/spark-hadoop:3   <span class="string">&quot;/opt/bitnami/script…&quot;</span>   42 hours ago   Up About an hour   0.0.0.0:4040-&gt;4040/tcp, 0.0.0.0:8080-&gt;8080/tcp   spark-spark-1</span><br><span class="line">9b9d9c1bb6f8   s1mplecc/spark-hadoop:3   <span class="string">&quot;/opt/bitnami/script…&quot;</span>   42 hours ago   Up About an hour   0.0.0.0:8081-&gt;8081/tcp                                                                                                                             spark-spark-worker-1-1</span><br><span class="line">b6ad535e9242   s1mplecc/spark-hadoop:3   <span class="string">&quot;/opt/bitnami/script…&quot;</span>   42 hours ago   Up About an hour   0.0.0.0:8082-&gt;8081/tcp                                                                                                                             spark-spark-worker-2-1</span><br></pre></td></tr></table></figure>

<p>执行如下命令进入到 master 容器内部。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ docker <span class="built_in">exec</span> -it a1 bash</span><br><span class="line">I have no name!@master:/opt/bitnami/spark$ </span><br></pre></td></tr></table></figure>

<p>注：实际上 <code>-it</code> 参数的作用是分配一个交互式虚拟终端；容器 ID 的前两位可以唯一标识该容器，如 a1。</p>
<p>现在，可以通过 <code>pyspark</code> 或 <code>spark-shell</code> 命令启动 Spark 交互式命令行，下面以 <code>pyspark</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyspark </span><br><span class="line">Python 3.6.15 (default, Sep 24 2021, 11:37:20) </span><br><span class="line">[GCC 8.3.0] on linux</span><br><span class="line">Setting default log level to &quot;WARN&quot;.</span><br><span class="line">To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).</span><br><span class="line">Welcome to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  &#x27;_/</span><br><span class="line">   /__ / .__/\_,_/_/ /_/\_\   version 3.1.2</span><br><span class="line">      /_/</span><br><span class="line"></span><br><span class="line">Using Python version 3.6.15 (default, Sep 24 2021 11:37:20)</span><br><span class="line">Spark context Web UI available at http://master:4040</span><br><span class="line">Spark context available as &#x27;sc&#x27; (master = local[*], app id = local-1633913993830).</span><br><span class="line">SparkSession available as &#x27;spark&#x27;.</span><br></pre></td></tr></table></figure>

<p>在启动交互式 Shell 时，<strong>Spark 驱动器程序（Driver Program）会创建一个名为 sc 的 SparkContext 对象，我们可以通过该对象来创建 RDD</strong>。例如，通过 <code>sc.textFile()</code> 方法读取本地或 HDFS 文件，或者通过 <code>sc.parallelize()</code> 方法直接由 Python 集合创建 RDD。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = sc.textFile(<span class="string">&#x27;README.md&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines.count()</span><br><span class="line"><span class="number">108</span>                                   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines.<span class="built_in">filter</span>(<span class="keyword">lambda</span> line: <span class="built_in">len</span>(line) &gt; <span class="number">10</span>)</span><br><span class="line">PythonRDD[<span class="number">3</span>] at RDD at PythonRDD.scala:<span class="number">53</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines.<span class="built_in">filter</span>(<span class="keyword">lambda</span> line: <span class="built_in">len</span>(line) &gt; <span class="number">10</span>).count()</span><br><span class="line"><span class="number">67</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strs = sc.parallelize([<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;i am spark&#x27;</span>, <span class="string">&#x27;hadoop&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strs.flatMap(<span class="keyword">lambda</span> s: s.split(<span class="string">&#x27; &#x27;</span>)).collect()</span><br><span class="line">[<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;am&#x27;</span>, <span class="string">&#x27;spark&#x27;</span>, <span class="string">&#x27;hadoop&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strs.flatMap(<span class="keyword">lambda</span> s: s.split(<span class="string">&#x27; &#x27;</span>)).reduce(<span class="keyword">lambda</span> x, y: x + <span class="string">&#x27;-&#x27;</span> + y)</span><br><span class="line"><span class="string">&#x27;hello-world-i-am-spark-hadoop&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注：由于 Spark 的<strong>惰性求值</strong>特性，只有当执行 Action 操作时，如 count、collect、reduce，才会真正执行计算并返回结果。</p>
<p>Spark Shell 默认以本地模式运行，但也支持以集群模式运行。可以通过指定 <code>--master</code> 参数，如 <code>pyspark --master spark://master:7077</code>，以 Standalone 模式运行 PySpark Shell。</p>
<h3 id="使用-spark-submit-提交独立应用"><a href="#使用-spark-submit-提交独立应用" class="headerlink" title="使用 spark-submit 提交独立应用"></a>使用 spark-submit 提交独立应用</h3><p>Spark Shell 支持与存储在硬盘或内存上的分布式数据进行交互，如 HDFS。因此 Spark Shell 适用于即时数据分析，比如数据探索阶段。但我们的最终目的是创建一个独立的 Java、Scala 或 Python 应用，将其提交到 Spark 集群上运行。</p>
<p>Spark 为各种集群管理器提供了统一的工具来提交作业，这个工具就是 <code>spark-submit</code>。</p>
<h4 id="提交-Python-应用"><a href="#提交-Python-应用" class="headerlink" title="提交 Python 应用"></a>提交 Python 应用</h4><p>下面以 Python 应用为例，编写 Python 脚本 my_script.py。Python 的 Spark 依赖库就叫做 pyspark，已经包含在 Spark 安装包内，位于 <code>$SPARK_HOME/python</code> 目录下。在独立应用中，我们需要导入该依赖，并且手动创建一个 SparkContext 实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkConf, SparkContext</span><br><span class="line"></span><br><span class="line">conf = SparkConf().setAppName(<span class="string">&#x27;My App&#x27;</span>)</span><br><span class="line">sc = SparkContext(conf=conf)</span><br><span class="line"></span><br><span class="line">count = sc.<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">100</span>).<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">100</span>).count()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;count: &#x27;</span>, count)</span><br></pre></td></tr></table></figure>

<p>注：SparkConf 用于声明应用配置信息，可以编码在代码中，也可以在命令行以参数形式指定。SparkConf 读取优先级为：代码 &gt; <code>spark-submit</code> 命令行参数 &gt; 以 <code>--properties-file</code> 参数指定的配置文件 &gt; 系统默认配置。</p>
<p>使用 <code>spark-submit</code> 命令提交 Python 脚本，指定 <code>--master</code> 参数提交到集群上。如果未指定该参数，则默认以本地模式运行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ spark-submit --master spark://master:7077 /opt/share/my_script.py</span><br><span class="line">count:  99999899</span><br></pre></td></tr></table></figure>

<p>当指定为 <code>spark://host:port</code> 时，应用提交到 Spark 自带的独立集群管理器（Standalone）上运行，默认端口 7077；如果使用 Apache Mesos 集群管理器，需指定为 <code>mesos://host:port</code>，默认端口 5050；使用 Hadoop YARN 则需指定为 <code>yarn</code>。</p>
<p>应用运行时，SparkContext 实例会启动应用的 Web UI，默认端口 4040。你可以在此网址查看应用的作业（Job）、组成作业的所有步骤（Stage）、持久化的 RDD 以及执行器状态等信息，这对于应用性能评估有巨大帮助。运行结束后，SparkContext 实例消亡，同时会关闭此 Web UI。</p>
<p><img src="/2021/10/12/%E4%BD%BF%E7%94%A8-Docker-%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2-Spark-Hadoop-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4/3.png" alt="2626b1a665dbf00b5641f10100befa4e.png"></p>
<h4 id="提交-Java-应用"><a href="#提交-Java-应用" class="headerlink" title="提交 Java 应用"></a>提交 Java 应用</h4><p>Spark 安装包内置了可以运行的示例 Jar 包，位于 <code>$SPARK_HOME/examples</code> 目录下。向 Spark 集群提交 Jar 包需额外指定程序入口类，即 main 函数所在类。可以通过 <code>jar tf</code> 命令查看 Jar 包所包含的类。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ jar tf /opt/bitnami/spark/examples/jars/spark-examples_2.12-3.1.2.jar | grep WordCount</span><br><span class="line">org/apache/spark/examples/JavaWordCount.class</span><br><span class="line">org/apache/spark/examples/sql/streaming/StructuredKerberizedKafkaWordCount.class</span><br><span class="line">org/apache/spark/examples/sql/streaming/StructuredNetworkWordCountWindowed.class</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>找到统计词频的入口类 <code>org.apache.spark.examples.JavaWordCount</code>，以此为例，向 Spark 集群提交 Java 应用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ spark-submit --master spark://master:7077 \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--name &quot;JavaWordCount&quot; \</span><br><span class="line">--executor-memory 1g \</span><br><span class="line">--class org.apache.spark.examples.JavaWordCount \</span><br><span class="line">/opt/bitnami/spark/examples/jars/spark-examples_2.12-3.1.2.jar /opt/share/words.txt</span><br></pre></td></tr></table></figure>

<p>注：<code>--deploy-mode</code> 参数决定了驱动器程序的运行位置。默认情况下，即客户端模式（client）下，<code>spark-submit</code> 会在本地（运行该命令的机器上）启动驱动器程序。如果指定为集群模式（cluster），驱动器程序将会运行在随机选取的一个工作节点上，此时即使 ctrl-c 中断 <code>spark-submit</code> 命令，也不会影响应用继续运行。因此，集群模式适用于需要长时间作业的应用。此外，Spark Standalone 目前不支持以集群模式运行 Python 应用（可以使用 YARN 集群来解决）。</p>
<blockquote>
<p><a href="https://spark.apache.org/docs/3.1.2/submitting-applications.html">Spark 3.1.2 官方文档</a>: Currently, the standalone mode does not support cluster mode for Python applications.</p>
</blockquote>
<p>当通过集群模式运行上述命令时，驱动器程序 Driver 并不是运行主节点上，而是运行在 IP 为 <code>172.18.0.2</code> 的工作节点上：</p>
<p><img src="/2021/10/12/%E4%BD%BF%E7%94%A8-Docker-%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2-Spark-Hadoop-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4/4.png" alt="9dbf3ac21791155581e6c3e71924002c.png"></p>
<h2 id="安装-Hadoop"><a href="#安装-Hadoop" class="headerlink" title="安装 Hadoop"></a>安装 Hadoop</h2><p>Hadoop 由分布式文件系统 HDFS、分布式计算框架 MapReduce 和资源管理框架 YARN 组成。MapReduce 是面向磁盘的，运行效率受到磁盘读写性能的约束，Spark 延续了 MapReduce 编程模型的设计思路，提出了面向内存的分布式计算框架，性能较之 MapReduce 有了 10～100 倍的提升。与此同时，Spark 框架还对 HDFS 做了很好的支持，并支持运行在 YARN 集群上。</p>
<blockquote>
<p>Spark uses Hadoop’s client libraries for HDFS and YARN. Downloads are pre-packaged for a handful of popular Hadoop versions.</p>
</blockquote>
<p>由于 Spark 使用了 Hadoop 的客户端依赖库，所以 Spark 安装包会指定依赖的 Hadoop 特定版本，如 spark-3.1.2-bin-hadoop3.2.tgz。而 bitnami/spark 镜像中只包含 Hadoop 客户端，并不包含服务器端。因此，如果需要使用 HDFS 和 YARN 功能，还需要部署 Hadoop 集群。</p>
<p>将 Hadoop 部署在 Spark 集群上，可以避免不必要的网络通信，并且面向磁盘的 HDFS 与面向内存的 Spark 天生互补。因此，考虑在 bitnami/spark 镜像基础上构建安装有 Hadoop 的新镜像。</p>
<h3 id="确定-Hadoop-版本"><a href="#确定-Hadoop-版本" class="headerlink" title="确定 Hadoop 版本"></a>确定 Hadoop 版本</h3><p>首先，需要确定 bitnami/spark 镜像所依赖的 Hadoop 版本。启动 pyspark 进行查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ pyspark</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc._gateway.jvm.org.apache.hadoop.util.VersionInfo.getVersion()</span><br><span class="line"><span class="string">&#x27;3.2.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 Hadoop 官网找到 Hadoop 3.2.0 安装包的<a href="https://hadoop.apache.org/release/3.2.0.html">下载地址</a>，稍后在构建镜像时通过 <code>curl -OL</code> 命令下载此安装包。</p>
<h3 id="准备配置文件及启动脚本"><a href="#准备配置文件及启动脚本" class="headerlink" title="准备配置文件及启动脚本"></a>准备配置文件及启动脚本</h3><p>在工作目录下创建 config 文件夹，编写需要覆盖的 Hadoop 配置文件。完整的配置文件已经上传至 GitHub：<a href="https://github.com/s1mplecc/spark-hadoop-docker">s1mplecc/spark-hadoop-docker</a>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ tree ~/docker/spark/config</span><br><span class="line">config</span><br><span class="line">├── core-site.xml</span><br><span class="line">├── hadoop-env.sh</span><br><span class="line">├── hdfs-site.xml</span><br><span class="line">├── mapred-site.xml</span><br><span class="line">├── workers</span><br><span class="line">└── yarn-site.xml</span><br></pre></td></tr></table></figure>

<p>注：其他详细配置请参考 Apache Hadoop 官方文档：<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/ClusterSetup.html">Hadoop Cluster Setup</a>。</p>
<p>除了配置文件外，还需要编写 Hadoop 启动脚本。由于设置了 ssh 免密通信，首先需要启动 ssh 服务，然后依次启动 HDFS 和 YARN 集群。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">service ssh start</span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/sbin/start-dfs.sh</span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/sbin/start-yarn.sh</span><br></pre></td></tr></table></figure>

<h3 id="基于-bitnami-spark-构建新镜像"><a href="#基于-bitnami-spark-构建新镜像" class="headerlink" title="基于 bitnami/spark 构建新镜像"></a>基于 bitnami/spark 构建新镜像</h3><p>在工作目录下，创建用于构建新镜像的 Dockerfile。新镜像基于 <code>docker.io/bitnami/spark:3</code>，依次执行如下指令：</p>
<ul>
<li>设置 Hadoop 环境变量；</li>
<li>配置集群间 ssh 免密通信。此处直接将 ssh-keygen 工具生成的公钥写入 authorized_keys 文件中，由于容器集群基于同一个镜像创建的，因此集群的公钥都相同且 authorized_keys 为自己本身；</li>
<li>下载 Hadoop 3.2.0 安装包并解压；</li>
<li>创建 HDFS NameNode 和 DataNode 工作目录；</li>
<li>覆盖 <code>$HADOOP_CONF_DIR</code> 目录下的 Hadoop 配置文件；</li>
<li>拷贝 Hadoop 启动脚本并设置为可执行文件；</li>
<li>格式化 HDFS 文件系统；</li>
<li>在入口脚本中启动 ssh 服务。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> docker.io/bitnami/spark:<span class="number">3</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">&quot;s1mplecc &lt;s1mple951205@gmail.com&gt;&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">&quot;Docker image with Spark (3.1.2) and Hadoop (3.2.0), based on bitnami/spark:3. \</span></span></span><br><span class="line"><span class="string"><span class="bash">For more information, please visit https://github.com/s1mplecc/spark-hadoop-docker.&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> HADOOP_HOME=<span class="string">&quot;/opt/hadoop&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> HADOOP_CONF_DIR=<span class="string">&quot;$HADOOP_HOME/etc/hadoop&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> HADOOP_LOG_DIR=<span class="string">&quot;/var/log/hadoop&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;$HADOOP_HOME/hadoop/sbin:$HADOOP_HOME/bin:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y openssh-server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ssh-keygen -t rsa -f /root/.ssh/id_rsa -P <span class="string">&#x27;&#x27;</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">    cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -OL https://archive.apache.org/dist/hadoop/common/hadoop-3.2.0/hadoop-3.2.0.tar.gz</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xzvf hadoop-3.2.0.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="bash">  mv hadoop-3.2.0 hadoop &amp;&amp; \</span></span><br><span class="line"><span class="bash">  rm -rf hadoop-3.2.0.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="bash">  mkdir /var/<span class="built_in">log</span>/hadoop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /root/hdfs/namenode &amp;&amp; \ </span></span><br><span class="line">    mkdir -p /root/hdfs/datanode </span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> config/* /tmp/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv /tmp/ssh_config /root/.ssh/config &amp;&amp; \</span></span><br><span class="line"><span class="bash">    mv /tmp/hadoop-env.sh <span class="variable">$HADOOP_CONF_DIR</span>/hadoop-env.sh &amp;&amp; \</span></span><br><span class="line"><span class="bash">    mv /tmp/hdfs-site.xml <span class="variable">$HADOOP_CONF_DIR</span>/hdfs-site.xml &amp;&amp; \ </span></span><br><span class="line">    mv /tmp/core-site.xml $HADOOP_CONF_DIR/core-site.xml &amp;&amp; \</span><br><span class="line">    mv /tmp/mapred-site.xml $HADOOP_CONF_DIR/mapred-site.xml &amp;&amp; \</span><br><span class="line">    mv /tmp/yarn-site.xml $HADOOP_CONF_DIR/yarn-site.xml &amp;&amp; \</span><br><span class="line">    mv /tmp/workers $HADOOP_CONF_DIR/workers</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> start-hadoop.sh /opt/start-hadoop.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /opt/start-hadoop.sh &amp;&amp; \</span></span><br><span class="line"><span class="bash">    chmod +x <span class="variable">$HADOOP_HOME</span>/sbin/start-dfs.sh &amp;&amp; \</span></span><br><span class="line"><span class="bash">    chmod +x <span class="variable">$HADOOP_HOME</span>/sbin/start-yarn.sh </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> hdfs namenode -format</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">&quot;1 a /etc/init.d/ssh start &gt; /dev/null &amp;&quot;</span> /opt/bitnami/scripts/spark/entrypoint.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">&quot;/opt/bitnami/scripts/spark/entrypoint.sh&quot;</span> ]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;/opt/bitnami/scripts/spark/run.sh&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>在工作目录下，执行如下命令构建镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ docker build -t s1mplecc/spark-hadoop:3 .</span><br></pre></td></tr></table></figure>

<p>构建过程将按照 Dockerfile 中的指令依次进行。</p>
<p><img src="/2021/10/12/%E4%BD%BF%E7%94%A8-Docker-%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2-Spark-Hadoop-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4/5.png" alt="fcf37dc09ce643cfbdda2b473ac6a194.png"></p>
<h3 id="启动-spark-hadoop-集群"><a href="#启动-spark-hadoop-集群" class="headerlink" title="启动 spark-hadoop 集群"></a>启动 spark-hadoop 集群</h3><p>构建镜像完成后，还需要修改 <code>docker-compose.yml</code> 文件，使其从新的镜像 <code>s1mplecc/spark-hadoop:3</code> 中启动容器集群，同时映射 Hadoop Web UI 端口。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">spark:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">s1mplecc/spark-hadoop:3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MODE=master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_AUTHENTICATION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_LOCAL_STORAGE_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_SSL_ENABLED=no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker/spark/share:/opt/share</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8080:8080&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;4040:4040&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8088:8088&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8042:8042&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;9870:9870&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;19888:19888&#x27;</span></span><br><span class="line">  <span class="attr">spark-worker-1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">s1mplecc/spark-hadoop:3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">worker1</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MODE=worker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MASTER_URL=spark://master:7077</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_MEMORY=1G</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_CORES=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_AUTHENTICATION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_LOCAL_STORAGE_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_SSL_ENABLED=no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker/spark/share:/opt/share</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8081:8081&#x27;</span></span><br><span class="line">  <span class="attr">spark-worker-2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">s1mplecc/spark-hadoop:3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">worker2</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MODE=worker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_MASTER_URL=spark://master:7077</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_MEMORY=1G</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_WORKER_CORES=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_AUTHENTICATION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_RPC_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_LOCAL_STORAGE_ENCRYPTION_ENABLED=no</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPARK_SSL_ENABLED=no</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker/spark/share:/opt/share</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8082:8081&#x27;</span></span><br></pre></td></tr></table></figure>

<p>运行 <code>docker-compose</code> 启动命令重建集群，不需要停止或删除旧集群。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ docker-compose up -d                     </span><br><span class="line">[+] Running 0/3</span><br><span class="line"> ⠼ Container spark-spark-1           Recreate                                        6.4s</span><br><span class="line"> ⠼ Container spark-spark-worker-2-1  Recreate                                        6.4s</span><br><span class="line"> ⠼ Container spark-spark-worker-1-1  Recreate                                        6.4s</span><br></pre></td></tr></table></figure>

<p>启动容器集群后，进入 master 容器执行启动脚本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜ docker <span class="built_in">exec</span> -it a1 bash</span><br><span class="line">$ ./start-hadoop.sh </span><br><span class="line">Starting OpenBSD Secure Shell server: sshd.</span><br><span class="line">Starting namenodes on [master]</span><br><span class="line">Starting secondary namenodes [master]</span><br><span class="line">Starting resourcemanager</span><br><span class="line">Starting nodemanagers</span><br></pre></td></tr></table></figure>

<h3 id="向-HDFS-写入文件"><a href="#向-HDFS-写入文件" class="headerlink" title="向 HDFS 写入文件"></a>向 HDFS 写入文件</h3><p>使用命令将共享文件中的 words.txt 写入 HDFS：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hadoop fs -put /opt/share/words.txt /</span><br><span class="line">$ hdfs dfs -ls /</span><br><span class="line">Found 1 items</span><br><span class="line">-rw-r--r--   2 root supergroup        440 2021-10-12 07:07 /words.txt</span><br></pre></td></tr></table></figure>

<p>写入的文件可以在 HDFS Web UI 上进行浏览：</p>
<p><img src="/2021/10/12/%E4%BD%BF%E7%94%A8-Docker-%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2-Spark-Hadoop-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4/6.png" alt="48ba5d8dbcb460ec421762e24565dd47.png"></p>
<h3 id="Spark-访问-HDFS"><a href="#Spark-访问-HDFS" class="headerlink" title="Spark 访问 HDFS"></a>Spark 访问 HDFS</h3><p>现在，可以通过 Spark 访问 HDFS 了，访问 URI 为 <code>hdfs://master:9000</code>，这是配置在 core-site.xml 文件中的默认文件系统 fs.defaultFS。下面通过 PySpark 演示如何读取和存储 HDFS 上的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ pyspark</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = sc.textFile(<span class="string">&#x27;hdfs://master:9000/words.txt&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines.collect()</span><br><span class="line">[<span class="string">&#x27;Apache Spark is a unified analytics engine for large-scale data processing. It provides high-level APIs in Java, Scala, Python and R, and an optimized engine that supports general execution graphs. It also supports a rich set of higher-level tools including Spark SQL for SQL and structured data processing, MLlib for machine learning, GraphX for graph processing, and Structured Streaming for incremental computation and stream processing.&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words = lines.flatMap(<span class="keyword">lambda</span> x: x.split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words.saveAsTextFile(<span class="string">&#x27;hdfs://master:9000/split-words.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>HDFS 上的文件被读取为 RDD，在内存上进行 Transformation 后写入 HDFS。写入的文件被存储到 HDFS 的 DataNode 块分区上。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hdfs dfs -ls /</span><br><span class="line">Found 2 items</span><br><span class="line">drwxr-xr-x   - root supergroup          0 2021-10-12 13:28 /split-words.txt</span><br><span class="line">-rw-r--r--   2 root supergroup        440 2021-10-12 13:24 /words.txt</span><br><span class="line">$ hdfs dfs -ls /split-words.txt</span><br><span class="line">Found 3 items</span><br><span class="line">-rw-r--r--   2 root supergroup          0 2021-10-12 13:28 /split-words.txt/_SUCCESS</span><br><span class="line">-rw-r--r--   2 root supergroup        441 2021-10-12 13:28 /split-words.txt/part-00000</span><br><span class="line">-rw-r--r--   2 root supergroup          0 2021-10-12 13:28 /split-words.txt/part-00001</span><br><span class="line">$ hdfs dfs -cat /split-words.txt/part-00000</span><br><span class="line">Apache</span><br><span class="line">Spark</span><br><span class="line">is</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="将-Spark-应用提交到-YARN-集群"><a href="#将-Spark-应用提交到-YARN-集群" class="headerlink" title="将 Spark 应用提交到 YARN 集群"></a>将 Spark 应用提交到 YARN 集群</h3><p>在运行 Hadoop 启动脚本时同时启动了 HDFS 和 YARN，现在可以将 Spark 应用提交到 YARN 集群上。默认使用 HDFS 文件系统，如需读取本地文件，还需要指定 <code>file://</code> 前缀。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ spark-submit --master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--name <span class="string">&quot;Word Count&quot;</span> \</span><br><span class="line">--executor-memory 1g \</span><br><span class="line">--class org.apache.spark.examples.JavaWordCount \</span><br><span class="line">/opt/bitnami/spark/examples/jars/spark-examples_2.12-3.1.2.jar /words.txt</span><br></pre></td></tr></table></figure>

<p>提交到 YARN 上的应用通过 ResourceManager Web UI 进行查看，默认端口 8088。</p>
<p><img src="/2021/10/12/%E4%BD%BF%E7%94%A8-Docker-%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2-Spark-Hadoop-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4/7.png" alt="21f342e77ffb7f24b02ffced7a931548.png"></p>
<h2 id="Web-UI-汇总"><a href="#Web-UI-汇总" class="headerlink" title="Web UI 汇总"></a>Web UI 汇总</h2><table>
<thead>
<tr>
<th align="center">Web UI</th>
<th align="center">默认网址</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">* <strong>Spark Application</strong></td>
<td align="center"><a href="http://localhost:4040/">http://localhost:4040</a></td>
<td align="center">由 SparkContext 启动，显示以本地或 Standalone 模式运行的 Spark 应用</td>
</tr>
<tr>
<td align="center">Spark Standalone Master</td>
<td align="center"><a href="http://localhost:8080/">http://localhost:8080</a></td>
<td align="center">显示集群状态，以及以 Standalone 模式提交的 Spark 应用</td>
</tr>
<tr>
<td align="center">* <strong>HDFS NameNode</strong></td>
<td align="center"><a href="http://localhost:9870/">http://localhost:9870</a></td>
<td align="center">可浏览 HDFS 文件系统</td>
</tr>
<tr>
<td align="center">* <strong>YARN ResourceManager</strong></td>
<td align="center"><a href="http://localhost:8088/">http://localhost:8088</a></td>
<td align="center">显示提交到 YARN 上的 Spark 应用</td>
</tr>
<tr>
<td align="center">YARN NodeManager</td>
<td align="center"><a href="http://localhost:8042/">http://localhost:8042</a></td>
<td align="center">显示工作节点配置信息和运行时日志</td>
</tr>
<tr>
<td align="center">MapReduce Job History</td>
<td align="center"><a href="http://localhost:19888/">http://localhost:19888</a></td>
<td align="center">MapReduce 历史任务</td>
</tr>
</tbody></table>
<p>注：星号标注的为较常用的 Web UI。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://sparkbyexamples.com/spark/spark-web-ui-understanding/">Spark Web UI – Understanding Spark Execution</a></li>
<li><a href="https://sparkbyexamples.com/spark/spark-deploy-modes-client-vs-cluster/">Spark Deploy Modes – Client vs Cluster Explained</a></li>
<li><a href="https://docs.docker.com/compose/networking/">Docker 官方文档：Networking in Compose</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/">Docker 官方文档：Dockerfile reference</a></li>
<li><a href="https://hadoop.apache.org/docs/r3.2.2/hadoop-project-dist/hadoop-common/ClusterSetup.html#Web_Interfaces">Apache Hadoop 官方文档：Hadoop Cluster Setup</a></li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>使用流畅接口编写 Kafka 集成测试框架</title>
    <url>/2020/01/03/%E4%BD%BF%E7%94%A8%E6%B5%81%E7%95%85%E6%8E%A5%E5%8F%A3%E7%BC%96%E5%86%99-Kafka-%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该文档是我在团队中负责集成测试模块时为团队成员编写的 API 接口文档，这次拿过来修改了一下，并已经将业务无关的代码剥离出来上传到 <a href="https://github.com/s1mplecc/kafka-integration-test">GitHub</a> 上。主要是向大家展示一种流畅接口设计框架代码的模式。</p>
<p>所谓流畅接口，可以参考我之前翻译的 Martin Flower 的<a href="https://s2mple.xyz/2019/01/23/Fluent-Interface-%E2%80%94%E2%80%94-Martin-Fowler-%E5%8D%9A%E5%AE%A2%E8%AF%91%E6%96%87/">博客译文</a>。简单来说，流畅接口被设计为<strong>可读的</strong>和<strong>流式的</strong>，使用起来几乎和自然语言一般流畅，并且配合 IDE 的智能提示，易于 API 使用者的理解和使用。譬如下面我编写的集成测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundToOutboundExampleJobTest</span> <span class="keyword">extends</span> <span class="title">JobIntegrationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_send_ACTT_and_receive_trigger_event_from_kafka</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        kafkaSuite.send(<span class="keyword">new</span> ResourceFile(<span class="string">&quot;sample/send/pek/ACTT.xml&quot;</span>))</span><br><span class="line">                .toTopic()</span><br><span class="line">                .ofConfig(<span class="string">&quot;inbound_imf&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SubjectEvent event = kafkaSuite</span><br><span class="line">                .await().latestOne()</span><br><span class="line">                .fromTopic()</span><br><span class="line">                .ofConfig(<span class="string">&quot;trigger&quot;</span>)</span><br><span class="line">                .toJavaObject(SubjectEvent.class);</span><br><span class="line"></span><br><span class="line">        assertThat(event.getEventName()).isEqualTo(<span class="string">&quot;FLOP_ACTT&quot;</span>);</span><br><span class="line">        assertThat(event.getGids().size()).isEqualTo(<span class="number">1</span>);</span><br><span class="line">        assertThat(event.getGids().get(<span class="number">0</span>)).isEqualTo(<span class="string">&quot;PEK_80664162170310656&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码读起来非常明了，<code>KafkaSuite</code> 是我编写的 Kafka 集成测试套件，负责将 xml 文件发送至 Kafka 的一个 Topic 中，该 Topic 配置在配置文件中，对应着 <code>inbound_imf</code> 项。同时 <code>KafkaSuite</code> 监听另一个 Topic <code>trigger</code> 的最新一条消息并转换成 Java 对象，对结果进行验证（其间过程 xml 文件会被其他模块解析并经过一系列的业务处理）。</p>
<p>上述代码中，<code>assertThat().isEqualTo()</code> 就是断言框架 <code>assertj</code> 的 API，它是一个非常优秀的流畅接口的框架，建议大家阅读其源代码。我在编写 Kafka 集成测试框架时就借鉴了这种编码模式。</p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>代码目前完成了 Kafka 集成测试的发送和监听功能。我们的流处理框架采用的是 Flink，将任务分解为一个个 Job 独立运行，所以集成测试首先得启动 Job，并且加载包括 Kafka IP地址等相关配置。为此我编写了 <code>JobIntegrationTest</code> 类，并规定所有集成测试用例必须继承该类。此外，<code>KafkaSuite</code> 是负责 Kafka 集成测试的套件，封装了各种流畅接口 API。</p>
<h3 id="JobIntegrationTest"><a href="#JobIntegrationTest" class="headerlink" title="JobIntegrationTest"></a>JobIntegrationTest</h3><p>所有的集成测试必需继承 JobIntegrationTest 类，该类提供 final 的 <code>setUp()</code> 方法和 <code>tearDown()</code> 方法。</p>
<p>集成测试运行的流程是 <code>SetUp -&gt; All Tests -&gt; TearDown</code>：</p>
<ol>
<li><p><code>setUp()</code> 方法中使用了单独的线程启动 Job，所以<strong>不会阻塞主线程（测试方法）的运行</strong>。</p>
</li>
<li><p>测试方法主体由集成测试使用者编写，如果用到 KafkaSuite 的 send 和 await 方法则会被阻塞，直到<strong>成功发送或者接收到消息</strong>，或者<strong>超时抛出异常</strong>退出。</p>
</li>
<li><p><code>tearDown()</code> 方法关闭 Job 和用到的资源。</p>
</li>
</ol>
<h3 id="KafkaSuite"><a href="#KafkaSuite" class="headerlink" title="KafkaSuite"></a>KafkaSuite</h3><p>目前集成测试实现了 Kafka 消息的<strong>阻塞发送</strong>和<strong>阻塞监听</strong>，抽象出来的 KafkaSuite 提供了流畅接口以支持集成测试。<code>kafkaSuite</code> 作为 JobIntegrationTest 的 protected 字段可以直接在集成测试类中使用。我将 KafkaSuite 的流畅接口分为三大阶段：配置阶段（PrepareStep）、发送阶段（SendStep）和接受阶段（AwaitStep）。具体的流畅接口使用可以查看 KafkaSuiteTest 或者直接阅读源码 JavaDoc。</p>
<h4 id="PrepareStep"><a href="#PrepareStep" class="headerlink" title="PrepareStep"></a>PrepareStep</h4><p>由于 JobIntegrationTest 会加载配置文件并由此创建 KafakSuite 实例，所以正常情况下不需要独立配置 IP、端口等。但为提供给特殊需求使用，仍设计相关接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaSuite.clusterIps(<span class="string">&quot;172.20.10.120:9092,172.20.10.152:9092,172.20.10.171:9092&quot;</span>)</span><br><span class="line">            .noSsl()</span><br><span class="line">            .send() <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<h4 id="SendStep"><a href="#SendStep" class="headerlink" title="SendStep"></a>SendStep</h4><p>KafkaSuite 发送消息是阻塞的，设置的超时时间是 10s，<strong>如果 10s 未发送成功则会抛出 SendTimeoutException 异常</strong>，这时候需要检查配置文件中的 IP 和 SSL 配置是否正确。</p>
<p>API 使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaSuite.send(<span class="keyword">new</span> ResourceFile(<span class="string">&quot;kafka/test-suite.json&quot;</span>))</span><br><span class="line">            .toTopic()</span><br><span class="line">            .ofConfig(<span class="string">&quot;INTEGRATION-TEST&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>send()</code> 方法提供发送字符串、文件或数据流的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DSLSendStep</span> </span>&#123;</span><br><span class="line">    <span class="function">DSLSendToStep <span class="title">send</span><span class="params">(String value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLSendToStep <span class="title">send</span><span class="params">(ResourceFile file)</span> <span class="keyword">throws</span> ResourceFileNotFoundException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLSendToStep <span class="title">send</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toTopic()</code> 方法可以直接 <code>toTopic(&quot;xxx&quot;)</code> 指定明确 Topic，但更加推荐从配置文件读取的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DSLSendToStep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toTopic</span><span class="params">(String topic)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLSentLoadConfigStep <span class="title">toTopic</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AwaitStep"><a href="#AwaitStep" class="headerlink" title="AwaitStep"></a>AwaitStep</h4><p>KafkaSuite 监听消息同样是阻塞的。设置的<strong>默认超时时间是 60s</strong>，也提供自定义超时时间的接口如 <code>await(300)</code>，单位为秒，<strong>超过这个时间未接收到消息则抛出 AwaitTimeoutException</strong>。理论上我们都是先发再收，所以如果发送成功则代表 Kafka 连接不存在问题（也就是配置没有问题），接收不到就应该是业务代码有问题，这时候就需要 Debug 排查问题。</p>
<p>监听结果提供<strong>监听一条</strong>和<strong>监听多条</strong>的 API，但不管是使用哪一个，<code>await()</code> 后会取到 Kafka 该 Topic 的上一个 offset 以来的所有新消息，然后变更 offset。可以根据 Index 获取多条消息里的某一条，Index 从 0 开始计算。大致用法是：使用 <code>await().latestOne()</code> 获取最新一条，<code>await().multi()</code> 或者直接 <code>await()</code> 获取多条。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DSLAwaitIndexStep</span> <span class="keyword">extends</span> <span class="title">DSLAwaitMultiFromStep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Kafka Consumer Fetch latest one record</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">latestOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">lastOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Kafka Consumer Fetch record by index in records</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">one</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">firstOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">secondOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitOneFromStep <span class="title">thirdOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Kafka Consumer Fetch all latest records</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitMultiFromStep <span class="title">all</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DSLAwaitMultiFromStep <span class="title">multi</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Kafka Consumer Fetch multi records directly from topic</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">DSLAwaitMultiLoadConfigStep <span class="title">fromTopic</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">DSLAwaitMultiRecordsStep <span class="title">fromTopic</span><span class="params">(String topic)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">DSLAwaitMultiRecordsStep <span class="title">fromTopic</span><span class="params">(String topic, String groupId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是<strong>监听一条并且验证消息是否正确</strong>的写法，这里使用了 <code>toJavaObject()</code> 转成了 Java 对象，这个是我提供的转换消息的 API，后面会有介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaSuite.send(<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;jack\&quot;,\&quot;age\&quot;:25&#125;&quot;</span>)</span><br><span class="line">                .toTopic()</span><br><span class="line">                .ofConfig(<span class="string">&quot;INTEGRATION-TEST&quot;</span>);</span><br><span class="line">                </span><br><span class="line">Person record = kafkaSuite</span><br><span class="line">                .await().latestOne()</span><br><span class="line">                .fromTopic()</span><br><span class="line">                .ofConfig(<span class="string">&quot;INTEGRATION-TEST&quot;</span>)</span><br><span class="line">                .toJavaObject(Person.class);</span><br><span class="line">                </span><br><span class="line">assertThat(record.getName()).isEqualTo(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">assertThat(record.getAge()).isEqualTo(<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<p><strong>由于有的业务场景会出口多条消息，所以接下来演示验证多条消息的正确写法</strong>。提供了 <code>fetchFirstOne()</code> 和 <code>fetchOne(int index)</code> 根据 Index 获取多条中的一条等 API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaSuite.send(<span class="string">&quot;&#123;\&quot;name\&quot;: \&quot;jack\&quot;, \&quot;age\&quot;: 25&#125;&quot;</span>)</span><br><span class="line">        .toTopic()</span><br><span class="line">        .ofConfig(<span class="string">&quot;INTEGRATION-TEST&quot;</span>);</span><br><span class="line"></span><br><span class="line">kafkaSuite.send(<span class="string">&quot;&#123;\&quot;name\&quot;: \&quot;tony\&quot;, \&quot;age\&quot;: 20&#125;&quot;</span>)</span><br><span class="line">        .toTopic()</span><br><span class="line">        .ofConfig(<span class="string">&quot;INTEGRATION-TEST&quot;</span>);</span><br><span class="line"></span><br><span class="line">DSLAwaitMultiRecordsStep records = kafkaSuite</span><br><span class="line">        .await().multi()</span><br><span class="line">        .fromTopic()</span><br><span class="line">        .ofConfig(<span class="string">&quot;INTEGRATION-TEST&quot;</span>);</span><br><span class="line"></span><br><span class="line">Person jack = records.fetchFirstOne().toJavaObject(Person.class);</span><br><span class="line">Person tony = records.fetchOne(<span class="number">1</span>).toJavaObject(Person.class);</span><br><span class="line"></span><br><span class="line">assertThat(jack.getName()).isEqualTo(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">assertThat(jack.getAge()).isEqualTo(<span class="number">25</span>);</span><br><span class="line">assertThat(tony.getName()).isEqualTo(<span class="string">&quot;tony&quot;</span>);</span><br><span class="line">assertThat(tony.getAge()).isEqualTo(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>最后结果的<strong>输出提供了转换和输出到文件的 API</strong>。需要注意，输出到文件只是方便调试 Bug 时使用，不应该出现在正式的代码中；输出的文件被写入到 <code>target/test-classes/resources</code> 下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DSLAwaitOneRecordStep</span> <span class="keyword">extends</span> <span class="title">DSLAwaitRecordStep</span>, <span class="title">DSLAwaitOneRecordOutputStep</span>, <span class="title">DSLAwaitOneRecordConvertStep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">JsonObject <span class="title">toJsonObject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">JSONArray <span class="title">toJsonArray</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toXml</span><span class="params">()</span></span>; <span class="comment">// 编码未完成</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">toJavaObject</span><span class="params">(Class&lt;T&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeAsTxt</span><span class="params">(String absolutePath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeAsTxt</span><span class="params">(ResourceFile resourceFile)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>流畅接口 API 的设计一个重中之重就是<strong>接口和抽象类的使用</strong>，为了契合流式接口，有时不能按照面向对象的模式设计接口继承关系。简言之，在编写流畅接口 API 框架时，大致思路是先编写接口（Interface），按照流式的原则设计接口之间的继承关系，然后再编写具体的实现类。以下是我的代码结构，与 <code>impl</code> 文件夹并列的都是接口。具体代码详见我的 <a href="https://github.com/s1mplecc/kafka-integration-test">GitHub</a> 项目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Assertions.java</span><br><span class="line">├── JobIntegrationTest.java</span><br><span class="line">├── KafkaSuite.java</span><br><span class="line">└── core</span><br><span class="line">    ├── dsl</span><br><span class="line">    │   ├── await</span><br><span class="line">    │   │   ├── DSLAwaitFromStep.java</span><br><span class="line">    │   │   ├── DSLAwaitIndexStep.java</span><br><span class="line">    │   │   ├── DSLAwaitLoadConfigStep.java</span><br><span class="line">    │   │   ├── DSLAwaitMultiFromStep.java</span><br><span class="line">    │   │   ├── DSLAwaitMultiLoadConfigStep.java</span><br><span class="line">    │   │   ├── DSLAwaitMultiRecordsConvertStep.java</span><br><span class="line">    │   │   ├── DSLAwaitMultiRecordsFetchOneStep.java</span><br><span class="line">    │   │   ├── DSLAwaitMultiRecordsStep.java</span><br><span class="line">    │   │   ├── DSLAwaitOneFromStep.java</span><br><span class="line">    │   │   ├── DSLAwaitOneLoadConfigStep.java</span><br><span class="line">    │   │   ├── DSLAwaitOneRecordConvertStep.java</span><br><span class="line">    │   │   ├── DSLAwaitOneRecordOutputStep.java</span><br><span class="line">    │   │   ├── DSLAwaitOneRecordStep.java</span><br><span class="line">    │   │   ├── DSLAwaitRecordStep.java</span><br><span class="line">    │   │   ├── DSLAwaitStep.java</span><br><span class="line">    │   │   └── impl</span><br><span class="line">    │   │       ├── AbstractDSLAwaitFromStep.java</span><br><span class="line">    │   │       ├── AbstractDSLAwaitLoadConfigStep.java</span><br><span class="line">    │   │       ├── DSLAwaitIndexStepImpl.java</span><br><span class="line">    │   │       ├── DSLAwaitMultiFromStepImpl.java</span><br><span class="line">    │   │       ├── DSLAwaitMultiLoadConfigStepImpl.java</span><br><span class="line">    │   │       ├── DSLAwaitMultiRecordsStepImpl.java</span><br><span class="line">    │   │       ├── DSLAwaitOneFromStepImpl.java</span><br><span class="line">    │   │       ├── DSLAwaitOneLoadConfigStepImpl.java</span><br><span class="line">    │   │       └── DSLAwaitOneRecordStepImpl.java</span><br><span class="line">    │   ├── send</span><br><span class="line">    │   │   ├── DSLSendStep.java</span><br><span class="line">    │   │   ├── DSLSendToStep.java</span><br><span class="line">    │   │   ├── DSLSentLoadConfigStep.java</span><br><span class="line">    │   │   └── impl</span><br><span class="line">    │   │       ├── DSLSendToStepImpl.java</span><br><span class="line">    │   │       └── DSLSentLoadConfigStepImpl.java</span><br><span class="line">    │   └── start</span><br><span class="line">    │       ├── DSLPrepareStep.java</span><br><span class="line">    │       └── DSLStartStep.java</span><br><span class="line">    └── exceptions</span><br><span class="line">        ├── AwaitTimeoutException.java</span><br><span class="line">        ├── InvalidIntegrationTestNameException.java</span><br><span class="line">        ├── SendNullValueException.java</span><br><span class="line">        └── SendTimeoutException.java</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>流畅接口</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2018/05/24/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>函数式编程是一种编程范式，我们常见的编程范式有<strong>命令式编程（Imperative programming）</strong>，<strong>函数式编程（Functional Programming）</strong>，常见的面向对象编程也是一种命令式编程。相比之下，函数式编程更关心<strong>数据的映射</strong>，命令式编程则关心解决问题的<strong>步骤</strong>。</p>
<p>命令式编程是面向计算机硬件的抽象，有变量（对应着存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令）。简单来说，命令式程序就是一个<strong>冯诺依曼机的指令序列</strong>。以下代码就是典型的命令式编程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sumOfPrices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; prices = Arrays.asList(<span class="number">10</span>, <span class="number">30</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">45</span>, <span class="number">12</span>);</span><br><span class="line">    Double total = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer price : prices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &gt; <span class="number">20</span>) &#123;</span><br><span class="line">            total = total + (price * <span class="number">0.9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而函数式编程是面向数学的抽象，将计算描述为一种表达式求值。函数式编程希望程序员用计算（函数）来表示程序，用<strong>计算（函数）的组合</strong>来表达程序的组合。而非函数式编程则习惯于用命令来表示程序，用命令的顺序执行来表达程序的组合。比如如下的 Scala 代码，通过<code>filter()、map()、reduce()</code>这些函数的组合，完成了从 prices 到 total 的<strong>映射关系</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object Prices &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val prices = Array(10, 30, 17, 20, 15, 18, 45, 12)</span><br><span class="line">    val total = prices.filter(x =&gt; x &gt; 20)</span><br><span class="line">      .map(x =&gt; x * 0.9)</span><br><span class="line">      .reduce((x, y) =&gt; x + y)</span><br><span class="line">    print(&quot;total is: &quot; + total)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>说到底，什么是函数式编程呢？这里借用廖雪峰老师在 <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317848428125ae6aa24068b4c50a7e71501ab275d52000">Python函数式编程</a> 中的定义。</p>
<p>我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计，函数就是面向过程的程序设计的基本单元。而函数式编程（请注意多了一个“式”字）—— Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。</p>
<p>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。在计算机的层次上，CPU 执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如 C 语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如 Lisp 语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要<strong>输入是确定的，输出就是确定的</strong>，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>在 FP 语言中，<strong>函数作为一等公民</strong>，指的是函数与其他数据类型一样，处于同等地位。函数可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，因此可以对函数进行组合。<strong>高阶函数 (Higher-order Function)</strong> 就是指<strong>接受入参或者返回值为函数</strong>的函数。</p>
<p>用 Python 定义一个简单的高阶函数，接受一个入参函数 f 对 x, y 做操作后相加，使用时我可以使用已经定义好的绝对值函数 <code>abs</code>，或者自定义的匿名函数 <code>lambda x : x * x</code> 取平方。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f_add</span>(<span class="params">x, y, f</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> f(x) + f(y)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_add(<span class="number">1</span>, -<span class="number">2</span>, <span class="built_in">abs</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_add(<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">lambda</span> x : x * x)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>有了高阶函数，就可以将复用的粒度降低到函数级别，相对于面向对象语言，复用的粒度更低。</p>
<h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p><strong>柯里化 (Currying)</strong> 是把多个参数的函数转变为只接受一个参数并返回接收剩余参数的函数的过程，这个过程持续多次直到收集到所有所需参数。在 FP 语言中函数（而不是类）被作为参数进行传递，Currying 常常用于转化一个函数的接口以便于其他代码调用。函数的接口就是它的参数，于是 Currying 通常用于减少函数参数的数量</p>
<p>在 JavaScript 中有一个实现函数式编程的库叫作 <strong>Ramda</strong> ，它有一个特性就是：所有方法都支持柯里化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> R = <span class="built_in">require</span>(<span class="string">&#x27;ramda&#x27;</span>)</span><br><span class="line"></span><br><span class="line">R.add(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// R.add(1, 2) =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increment = R.add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> addTen = R.add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">increment(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line">addTen(<span class="number">2</span>) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>这也归功于在 FP 语言中高阶函数的特性，我们来看看<code>add()</code>的实现，返回的是函数，所以不难理解如何实现 <code>increment()</code> 和 <code>addTen()</code> 对 <code>add()</code> 的复用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const add = function(x) &#123;</span><br><span class="line">  return function(y) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const increment = add(1)</span><br><span class="line">const addTen = add(10)</span><br></pre></td></tr></table></figure>
<p>熟悉 JavaScript 的同学可能使用过 Lodash 类库，Ramda 和 Lodash 最大的区别就是<strong>两者的参数位置不同</strong>，在 Ramda 中数据一律放在最后一个参数，理念是： <strong>Function first，Data last</strong> 。而不管是 Lodash 还是 Underscore 都将处理的数据作为第一个参数。事实证明，Ramda 设计更加合理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> R = <span class="built_in">require</span>(<span class="string">&#x27;ramda&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prices = [<span class="number">10</span>, <span class="number">30</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">45</span>, <span class="number">12</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = R.pipe(</span><br><span class="line">  R.filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">20</span>),</span><br><span class="line">  R.map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">0.9</span>),</span><br><span class="line">  R.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">total(prices) <span class="comment">// 67.5</span></span><br><span class="line">totalPrice = _.chain(prices)</span><br><span class="line">  .filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">20</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">0.9</span>)</span><br><span class="line">  .reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)</span><br><span class="line">  .value() <span class="comment">// 67.5</span></span><br></pre></td></tr></table></figure>
<p>显然，将数据放在最后，再利用 Currying 的特性，我们将对 prices 的一系列操作封装成<code>total()</code>函数，要比 Lodash 更具复用性。这种风格也叫做 <strong>Pointfree：不使用所要处理的值，只合成运算过程</strong>。</p>
<h2 id="λ演算"><a href="#λ演算" class="headerlink" title="λ演算"></a>λ演算</h2><p><strong>λ演算 (lambda calculus)<strong>是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。它由数学家阿隆佐·邱奇在20世纪30年代首次发表。Lambda 演算可比拟是最根本的编程语言，它包括了一条变换规则（变量替换）和一条将函数抽象化定义的方式。因此普遍公认是一种</strong>更接近软件而非硬件的方式</strong>。Lambda 演算对函数式编程语言造成很大影响，比如 Lisp、ML 语言和 Haskell 语言。Lambda 演算作为一种广泛用途的计算模型，可以清晰地定义什么是一个可计算函数，而任何可计算函数都能以这种形式表达和求值。Lambda 演算和图灵机已经被证明了是具有同样能力的系统，因此指令式编程能做到的函数式编程也同样可以做到。</p>
<p>编程中提到的 Lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指<strong>匿名函数</strong>，比如 Python 中的<code>lambda</code>关键字，JavaScript 和 Scala 中的箭头函数 <code>=&gt;</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices = [<span class="number">10</span>, <span class="number">30</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">45</span>, <span class="number">12</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(<span class="keyword">lambda</span> x, y : x + y, <span class="built_in">map</span>(<span class="keyword">lambda</span> x : x * <span class="number">0.9</span>, <span class="built_in">filter</span>(<span class="keyword">lambda</span> x : x &gt; <span class="number">20</span>, prices)))</span><br><span class="line"><span class="number">67.5</span></span><br></pre></td></tr></table></figure>

<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>纯函数式编程语言中的变量也不是命令式编程语言中的变量，即存储状态的单元，而是代数中的变量，即一个值的名称。变量的值是<strong>不可变的 (immutable)</strong> ，也就是说不允许像命令式编程语言中那样多次给一个变量赋值。比如说在命令式编程语言我们写<code>x = x + 1</code>，这依赖可变状态的事实，拿给程序员看说是对的，但拿给数学家看，却被认为这个等式为假。<strong>严格意义上的函数式编程意味着不使用可变的变量，赋值，循环和其他命令式控制结构进行编程</strong>。就好比 Java 中所有变量都是<code>final</code>的</p>
<p>事实上函数式程序是可以保存状态的，只不过它们用的不是变量，而是函数。状态保存在函数的参数中，也就是说在栈上。如果你需要保存一个状态一段时间并且时不时的修改它，那么你可以编写一个递归函数。举个例子，试着用 Java 写一个函数用来反转字符串。记住咯，这个程序里的变量都是默认为<code>final</code>的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">reverse</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverse(arg.substring(<span class="number">1</span>, arg.length())) + arg.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从理论上说，函数式语言也不是通过冯诺伊曼体系结构的机器上运行的，而是通过λ演算来运行的，就是通过变量替换的方式进行，变量替换为其值或表达式，函数也替换为其表达式，并根据运算符进行计算。λ演算是<strong>图灵完全 (Turing completeness)</strong> 的，但是大多数情况，函数式程序还是被编译成冯诺依曼机的机器语言的指令执行的。</p>
<p>函数式编程的最主要的好处主要是不可变性带来的。没有可变的状态，函数就是<strong>引用透明 (Referential Transparency)</strong> 的和**无副作用 (No Side Effect)**。</p>
<h3 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h3><p>引用透明指的是函数的运行不依赖于外部变量或状态，<strong>值只依赖输入的参数</strong>，任何时候<strong>只要参数相同，引用函数所得的返回值总是相同的</strong>。这样在并发编程中就避免了有外部变量被其它线程调用后导致返回的结果不是期望值，在函数式编程中，纯函数构成的程序是不需要加线程锁的。</p>
<h3 id="无副作用"><a href="#无副作用" class="headerlink" title="无副作用"></a>无副作用</h3><p>所谓<strong>副作用</strong>，指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。在其他类型的语言中，变量往往用来保存<strong>状态 (state)</strong> 。不修改变量，意味着状态不能保存在变量中。<strong>函数式编程使用参数保存状态</strong>，最好的例子就是递归。因为 FP 语言不包含任何赋值语句，变量值一旦被指派就永远不会改变。而且，调用函数只会计算出结果 ── 不会出现其他效果。因此，FP 语言没有副作用。</p>
<h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><p>由于函数是引用透明的，以及函数式编程不像命令式编程那样关注执行步骤，这个系统提供了优化函数式程序的空间，包括<strong>惰性求值 (Lazy evaluation)</strong> 和并性处理。惰性求值的目的是要最小化计算机要做的工作。在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。除可以得到性能的提升外，惰性求值还可以以简单的方式表示无限的概念，这种方式有利于程序的模块化。</p>
<p>比如我们用 Python 的生成器去生成无穷的一个自然数序列，控制台将会一直打印除非你手动中断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">natural_nums</span>():</span></span><br><span class="line"><span class="meta">... </span>     n = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>         <span class="keyword">yield</span> n</span><br><span class="line"><span class="meta">... </span>         n = n + <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>natural_nums()</span><br><span class="line">&lt;generator <span class="built_in">object</span> f1 at <span class="number">0x1033ed468</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> natural_nums():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="meta">... </span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>命令式编程主要关心的是 how to do，也就是怎么做，告诉机器每一步的实现过程。而函数式编程主要关心的是 what to do，也就是实体与实体之间的对应关系（<strong>映射</strong>）。函数式编程是给软件开发者提供的另一套工具箱，为我们提供了另外一种抽象和思考的方式。如果你对函数式编程的起源感兴趣，强烈推荐阅读 <a href="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn/blob/master/FunctionalProgrammingForTheRestOfUs.cn.md">Functional Programming For The Rest of Us</a> 这篇文章，写的很幽默风趣。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn/blob/master/FunctionalProgrammingForTheRestOfUs.cn.md">Functional Programming For The Rest of Us</a></li>
<li><a href="https://www.zhihu.com/question/28292740/answer/40336090">什么是函数式编程思维 - 知乎</a></li>
<li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">JS 函数式编程指南 - GitBook</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97">λ演算 - WiKi百科</a></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>前端编码规范</title>
    <url>/2018/01/22/%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>关于平时工作时前端的编码规范，多采用官方或者推荐的编码规范。包括 <strong>JavaScript</strong> 和 <strong>Vue.js</strong> 规范</p>
</blockquote>
<hr>
<h2 id="JavaScript规范"><a href="#JavaScript规范" class="headerlink" title="JavaScript规范"></a>JavaScript规范</h2><blockquote>
<p><strong>JavaScript</strong> 的规范采用 <strong>Airbnb</strong> 的 <strong>ESLint</strong> 规范。原则上能使用 <strong>ES6</strong>  语法的地方均使用 <strong>ES6</strong> 语法</p>
</blockquote>
<ul>
<li><p>因为我是用的 <strong>vue-cli</strong> 搭建的 <strong>Vue</strong> 项目的脚手架，所以可以很方便的应用 <strong>ESLint</strong> 来规范代码。生成的两个文件，<code>.eslintrc.js</code>中包含了 <strong>ESLint</strong> 配置和规则，<code>.eslintignore</code>包含忽略检测的文件，类似<code>.gitignore</code></p>
</li>
<li><p>在<code>.eslintrc.js</code>中自定义的规则，详细的规则请参考 <a href="https://eslint.org/docs/rules/">ESLint官网</a></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// allow debugger during development</span></span><br><span class="line">   <span class="string">&#x27;no-debugger&#x27;</span>: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;error&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">   <span class="comment">// allow console during development</span></span><br><span class="line">   <span class="string">&#x27;no-console&#x27;</span>: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;error&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">   <span class="comment">// allow unused variables during development</span></span><br><span class="line">   <span class="string">&#x27;no-unused-vars&#x27;</span>: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;error&#x27;</span> : <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">   <span class="comment">// disallow trailing commas</span></span><br><span class="line">   <span class="string">&#x27;comma-dangle&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">   <span class="comment">// disallow trailing semi</span></span><br><span class="line">   <span class="string">&#x27;semi&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">   <span class="comment">// allow the unary operators ++ and --</span></span><br><span class="line">   <span class="string">&#x27;no-plusplus&#x27;</span>: <span class="string">&#x27;off&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul>
<li><p>关于句尾是否该加<strong>分号</strong>，应该看个人习惯，我倒觉得两种风格都应该能适应，只要保证一个项目中<strong>统一风格</strong>即可。作为前端项目，个人为了简洁清爽所以没加分号</p>
</li>
<li><p><strong>ASI</strong>( or <strong>Automatic Semicolon Insertion</strong>，<strong>自动分号插入机制</strong>)，现在的 <strong>ECMAScript</strong> 实现，无论是浏览器还是 <strong>Node.js</strong> 都包含了 <strong>ASI</strong> 功能，可以动态识别 JS 语句并判断是否在句尾插入分号</p>
</li>
</ul>
<hr>
<h2 id="Vue-js规范"><a href="#Vue-js规范" class="headerlink" title="Vue.js规范"></a>Vue.js规范</h2><blockquote>
<p><strong>Vue.js</strong> 的官网上有非常详细的<a href="https://cn.vuejs.org/v2/style-guide/">风格指南</a>，所以说详细的官方文档真的很关键！</p>
</blockquote>
<h4 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a>组件命名</h4><ul>
<li><p>组件名始终为多个单词组成（为避免与 HTML 元素冲突），单词首字母大写拼接，组件的 name 属性不可省略（方便 <strong>DevTools</strong> 调试）</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">TodoItem.vue</span><br><span class="line"></span><br><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;TodoItem&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件名应该倾向于完整单词而不是缩写</p>
</li>
<li><p>HTML 中对应组件单词均小写，以<code>-</code>中划线连接多个单词</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">todo-item</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用组件名作为样式作用域空间，同时给<code>&lt;style&gt;</code>标签加上<code>scoped</code>属性</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app-button&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.app-button</span> &#123; <span class="comment">/* ... */</span> &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>通用组件</strong>或<strong>基础组件</strong>使用<code>App、Base、V</code>作为前缀</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AppHeader.vue</span><br><span class="line">AppTable.vue</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>组件的属性在 HTML 标签中一行一个，对齐显示</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">range-slider</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:values</span>=<span class="string">&quot;[10, 20]&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">min</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">max</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">step</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:on-slide</span>=<span class="string">&quot;updateInputs&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:on-end</span>=<span class="string">&quot;updateResults&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">range-slider</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><ul>
<li><p>总是用<code>key</code>配合<code>v-for</code></p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>永远不要把<code>v-if</code>和<code>v-for</code>同时用在同一个元素上，可以将<code>v-if</code>移至上一层</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//good</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://cn.vuejs.org/v2/style-guide/">Vue.js 官网风格指南</a></li>
<li> <a href="https://github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md">Vue.js 组件编码规范 - Github</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2018/11/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>单例模式为GOF设计模式中的一种，当我们创建的对象需要昂贵的资源，且该对象又被频繁使用，同时，这个对象的状态是共享的，为了避免资源的浪费以及加载资源的时间，我们往往会引入单例模式。因此，要实现单例模式，其核心就是要<strong>在已有该类的实例前提下，阻止其他开发人员再创建类的新实例</strong>。</p>
<p>在Java语言中，通常提供了如下几种单例模式的实现方式。</p>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过提供一个静态的对象 <code>instance</code>，利用 <code>private</code> 权限的构造方法和 <code>getInstance()</code> 方法来给予访问者一个单例。缺点是，没有考虑到线程安全，可能存在多个访问者同时访问，并同时构造了多个对象的问题。之所以叫做懒汉模式，主要是因为此种方法可以非常明显的 <strong>lazy loading</strong>。针对懒汉模式<strong>线程不安全</strong>的问题，我们自然想到了，在 <code>getInstance()</code> 方法前加锁，于是就有了第二种实现。</p>
<h4 id="线程安全的懒汉模式"><a href="#线程安全的懒汉模式" class="headerlink" title="线程安全的懒汉模式"></a>线程安全的懒汉模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而并发其实是一种特殊情况，大多时候这个锁占用的额外资源都浪费了，这种打补丁方式写出来的结构效率很低。</p>
<h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton has loaded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>instance</code> 成员变量使用 <code>static</code> 修饰，在 JVM 首次加载该类时单例对象 <code>instance</code> 会被创建并<strong>常驻内存</strong>，所以是线程安全的。但显然，这种方法没有起到 lazy loading 的效果。举个例子，也许你只想调用 <code>SingletonDemo.printHello()</code> 方法，但同时打印了 ”Singleton has loaded“，这可能是你不想见到的。</p>
<p>所以我们引入静态类内部加载的方式，也算是单例模式较为完善的解决方案。</p>
<h4 id="静态类内部加载"><a href="#静态类内部加载" class="headerlink" title="静态类内部加载"></a>静态类内部加载</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<strong>私有内部类</strong>的好处是，静态内部类不会在单例加载时就加载，而是在调用 <code>getInstance()</code> 方法时才进行加载。且单例的创建是在 SingletonHolder 被 JVM 加载时完成，故而也是线程安全的。因此该方法兼备了以上两种实现的优点。</p>
<h4 id="双重校验锁法"><a href="#双重校验锁法" class="headerlink" title="双重校验锁法"></a>双重校验锁法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singletonhasloaded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我解释一下在并发时，双重校验锁法会有怎样的情景：</p>
<ul>
<li>STEP 1. 线程A访问 <code>getInstance()</code> 方法，因为单例还没有实例化，所以进入了锁定块。</li>
<li>STEP 2. 线程B访问 <code>getInstance()</code> 方法，因为单例还没有实例化，得以访问接下来代码块，而接下来代码块已经被线程1锁定。</li>
<li>STEP 3. 线程A进入下一判断，因为单例还没有实例化，所以进行单例实例化，成功实例化后退出代码块，解除锁定。</li>
<li>STEP 4. 线程B进入接下来代码块，锁定线程，进入下一判断，因为已经实例化，退出代码块，解除锁定。</li>
<li>STEP 5. 线程A初始化并获取到了单例实例并返回，线程B获取了在线程A中初始化的单例。</li>
</ul>
<p>理论上双重校验锁法是线程安全的，并且，这种方法实现了lazy loading。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>图流算法之 Bipartiteness Check</title>
    <url>/2020/07/13/%E5%9B%BE%E6%B5%81%E7%AE%97%E6%B3%95%E4%B9%8B-Bipartiteness-Check/</url>
    <content><![CDATA[<h2 id="什么是二分图"><a href="#什么是二分图" class="headerlink" title="什么是二分图"></a>什么是二分图</h2><blockquote>
<p><strong>定义</strong>：设 G=(V, E) 是一个无向图，如果顶点 V 可分割为两个互不相交的子集｛U｝、｛V｝，并且图中的每条边 (i, j) 所关联的两个顶点 i 和 j 分别属于这两个不同的顶点集 i∈ U，j∈ V，则称图 G 为一个二分图。<strong>二分图的一个等价定义是：不含有「含奇数条边的环」的图</strong>。</p>
</blockquote>
<p>二分图（Bipartite Graph）是指<strong>图中的顶点可以划分到两个不相交的集合中，同一个集合中的顶点不相邻</strong>，即同一个集合中的两个顶点之间不存在边。如下图，我可以将左侧的蓝色和紫色构成的图转化为右图的二分图，集合 A 中全由紫色顶点构成，集合 B 中全由蓝色顶点构成，只存在<code>蓝-紫</code>（<code>紫-蓝</code>）边，同色顶点间不存在边。</p>
<p><img src="/2020/07/13/%E5%9B%BE%E6%B5%81%E7%AE%97%E6%B3%95%E4%B9%8B-Bipartiteness-Check/0.png" alt="bab01ea393c68a26dee629ce0d7e4de3.png"></p>
<p>所以二分图又可以等价于二色图（Two-colorable Graph），以下是一些二分图的常见示例，如星状图、网格图、齿轮图等。</p>
<p><img src="/2020/07/13/%E5%9B%BE%E6%B5%81%E7%AE%97%E6%B3%95%E4%B9%8B-Bipartiteness-Check/1.png" alt="14bf3a04408d7eacdf1b4dc323acf58c.png"></p>
<h2 id="Bipartiteness-Check"><a href="#Bipartiteness-Check" class="headerlink" title="Bipartiteness Check"></a>Bipartiteness Check</h2><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>那么如何检测一个图是否为二分图呢？在批处理情形下，即一个图的所有顶点和所有边的信息都已明确，我们借助于二色图的思想，可以通过<strong>染色法</strong>来判断一个图是否为二分图。算法可以通过 BFS 广度优先算法来实现，具体步骤如下：</p>
<ol>
<li>从任意一个顶点出发，将该顶点染成黑色。</li>
<li>遍历该顶点的所有相邻顶点，将其染成白色。</li>
<li>采用 BFS 依次遍历各个顶点的相邻顶点，将其染成与自身颜色相反的颜色。</li>
<li>当出现<strong>已访问过的相邻顶点颜色与自己相同，则该图不是二分图</strong>。否则，该图为二分图。</li>
</ol>
<h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h3><p>在流处理情形下，我们无法预知图的所有信息，取而代之的是，图的边（Edge）作为输入持续不断的流入我们的系统中。在这种情况下，考虑如何实时地判断当前所有边构成的图是否为二分图？</p>
<p>我们可以参考 GitHub 上的 <a href="https://github.com/vasia/gelly-streaming">Gelly Streaming 项目</a>，该项目是 Flink 的一个轻量级图流处理 API，提供了一些图流分析接口，并实现了部分图的流处理算法。</p>
<p>Gelly Streaming 的算法核心思想仍然是染色法，具体步骤如下：</p>
<ol>
<li>在一条边进入系统时，如果该边是已经存在的边，则丢弃；如果该边的两个顶点均不存在，则将其染成两个不同的颜色；如果该边有且仅有一个顶点已存在（已染色），则将另一个顶点染成相反的颜色。</li>
<li>如果该边的两个顶点均已存在，则可能出现三种情况：</li>
</ol>
<ul>
<li>新边的加入使原先的图构成了「含奇数条边的环」，如下图此时若到来一条 <code>2 - 4</code> 或 <code>7 - 8</code> 的边，均破坏了二分图的性质。此时的判断条件是：<strong>两个顶点同属于一个 Component 且两个顶点的颜色相同</strong>。</li>
<li>新边的加入使原先的图构成了「含偶数条边的环」，则图依然保持二分图的性质。此时的判断条件是：<strong>两个顶点同属于一个 Component 且两个顶点的颜色相异</strong>。</li>
<li>新边的两个顶点分属不同的 Componets，如下图此时若到来一条 <code>1 - 4</code> 边，图依然保持二分图的性质。我们可以做简单的证明：由于之前的两个单独的 Components 均是二分图，则我们可以分别将它们的顶点划分到两个不相交的集合中｛U1｝、｛V1｝和｛U2｝、｛V2｝中且令新边（i，j）的顶点i∈ U1，j∈ V2，由此可得出由｛U1｝、｛U2｝构成的集合｛U｝与｛V1｝、｛V2｝构成的集合｛V｝不相交，未破环二分图的性质。此时的判断条件：<strong>两个顶点分属于不同的 Components</strong>。在算法实现时，我们需要将两个 Components 合并为一个 Component，即 Gelly 算法中的 <code>merge</code> 操作。需要注意的是，此时若两个顶点（已染色）颜色不同，则直接合并，若两个顶点颜色相同，则需要将其中的一个 Component <strong>颜色反转</strong>。</li>
</ul>
<p><img src="/2020/07/13/%E5%9B%BE%E6%B5%81%E7%AE%97%E6%B3%95%E4%B9%8B-Bipartiteness-Check/2.png" alt="2bb51c94931f8c2b1ec93c3162d54501.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.educative.io/edpresso/what-is-a-bipartite-graph">What is a bipartite graph?</a></li>
<li><a href="https://github.com/vasia/gelly-streaming">Gelly Streaming：An experiemental API for single-pass graph streaming analytics on Apache Flink.</a></li>
</ul>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>流处理</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 DPDK 的模拟 (D)Dos 攻击实验</title>
    <url>/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>该实验是我暑期前往导师实验室，与一群东南大学网安三年级的本科生所做。我的工作是帮他们搭建了实验所需运行的服务器环境，实验数据的采集、制图以及结果分析均是他们所做。由于该实验可能在我研究生阶段进行进一步的研究，所以将它摘至我的博客，文档亦摘录了本科生们所做的实验报告，特此申明。</p>
</blockquote>
<p>东大网安本科组员：翟思宇、肖遥、宋昌霖、胡钺琳、赵泽瑞、赵钧陶<br>指导老师：肖卿俊</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本实验搭载高速以太网卡，通过持续的高速数据传输，达到逼近目标服务器链路的传输速率极限，以模拟 (D)Dos 攻击的效果。攻击主机系统采用 Ubuntu Server 版本，受 Linux 系统 I/O 的内核机制的影响，发包速率受到限制。本实验创新性的利用 DPDK 软件平台绕过系统内核，实现高数据吞吐率的效果。</p>
<p><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/0.png" alt="81db04d3b1658e9c254bfbfce6dedde2.png"></p>
<p>如上图，Linux 内核协议栈的实现决定了它内核网络协议的性能不佳，Linux 在内核收包处理时，将网卡收到的报文通过 DMA 放到内存，网卡出发中断通知系统有报文到达，系统分配 sk_buff，将报文拷贝到 sk_buff 中，交由协议栈处理，之后将其送用户态应用程序处理。</p>
<p>这种情况下，报文数量的增多将急剧增加资源的消耗。这包含报文产生 CPU 中断的上下文切换、为报文申请分配 sk_buff 消耗的资源、用户态程序收发包时产生系统调用和上下文切换带来的系统资源消耗。Kernel Bypass（内核旁路）技术应运而生，DPDK 正是采用的上图图由这种类 DMA 机制，直接将数据包从硬件（网卡端口）传输至用户态应用程序，以此来实现低延迟、低消耗的高吞吐网络传输。</p>
<p>TRex 是思科研发的一款成熟的基于 DPDK 的网络测试工具。它运行在标准的 Intel 处理芯片上，同时支持 stateful 和 stateless 两种模式，stateful 可以描述 L4~L7 层的应用场景，而 stateless 主要用于进行定制包的发包。本实验主要利用 TRex 的 DPDK 高线速发包能力，模拟对目标服务器进行 (D)Dos 打击。</p>
<p><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/1.png" alt="7a135e990f639b406cd1cc244d4943f3.png"></p>
<h2 id="实验物理环境"><a href="#实验物理环境" class="headerlink" title="实验物理环境"></a>实验物理环境</h2><p><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/2.JPG" alt="2ffa174d247d24ce9f16ea7332178308.jpeg"></p>
<ol>
<li>DELL Xeon Server，OS: Ubuntu Server 18.04 LTS。原装的系统为 CentOS 6，实验过程中遇到内核版本过低不支持 TRex 发包的问题，所以重装了 Ubuntu 系统。此外服务器还安装了实验室购入的兼容 DPDK 的 INTEL X710 网卡。</li>
<li>NetFPGA-SUME Virtex-7 FPGA Development Board，四个 10Gbps 的端口，实验过程中使用两根光缆连接到服务器构成回环。</li>
<li>DELL 工作站，用于将编译好的 P4 程序烧入 NetFPGA 智能网卡。</li>
</ol>
<h2 id="服务器环境准备"><a href="#服务器环境准备" class="headerlink" title="服务器环境准备"></a>服务器环境准备</h2><h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><ol>
<li>服务器操作系统选择兼容性、稳定性较好的 Ubuntu 18.04.5 LTS 版本，官网下载需要翻墙，也可以选择清华或阿里的开源软件镜像网。<a href="https://releases.ubuntu.com/bionic/">官网下载地址</a></li>
<li>制作启动 U 盘，使用 Rufus 镜像刻录工具将下载好的 iso 镜像刻录至 U 盘。<a href="https://ubuntu.com/tutorials/create-a-usb-stick-on-windows#1-overview">官网教程 - Create a bootable USB stick on Windows</a>。</li>
<li>启动服务器，按住 F2 进入 DELL 的 BIOS 界面，将 U 盘调整为启动的第一选项。</li>
<li>重启服务器，按照引导程序安装系统。<a href="https://ubuntu.com/tutorials/install-ubuntu-server#1-overview">官网教程 - Install Ubuntu Server</a></li>
</ol>
<h3 id="连接外网"><a href="#连接外网" class="headerlink" title="连接外网"></a>连接外网</h3><p><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/3.JPG" alt="8d45ed82634b33c68b4ddacfeef8a6a7.jpeg"></p>
<p>服务器共有四个网口 eno1～eno4，将网线插在左数第一个网口对应 eno1（图中①），并配置 interfaces 文件。图中②位置为 INTEL X710 网卡位置，从 NetFPGA 智能网卡的端口连接至服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vi etc/network/interfaces</span><br><span class="line"></span><br><span class="line">auto eno1</span><br><span class="line">iface eno1 inet dhcp</span><br></pre></td></tr></table></figure>

<p>在<code>/etc/resolv.conf</code>中加入 DNS 配置，此为阿里提供的公共 DNS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 223.6.6.6</span><br></pre></td></tr></table></figure>

<p>要先手动设置 IP 再使用 <code>dhclient</code> 命令启用 DHCP，<strong>每次重启服务器后如需连接外网，需输入这两行命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.102 netmask 255.255.255.0</span><br><span class="line">dhclient eno1</span><br></pre></td></tr></table></figure>

<p>执行完成就可以连通外网了</p>
<h3 id="设置网口"><a href="#设置网口" class="headerlink" title="设置网口"></a>设置网口</h3><p><code>ifconfig -a </code>查看网口信息，列出了 X710 网卡的两个网口信息，默认驱动是 Kernel Driver i40e，先设置 IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ifconfig enp59s0f0 192.168.200.2</span><br><span class="line">sudo ifconfig enp59s0f1 192.168.201.2</span><br></pre></td></tr></table></figure>

<p>在工作站的主机上 ping 一下服务器保证双向联通</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>使用 <code>apt-get</code> 命令安装 DPDK 依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt install -y dpdk dpdk-dev dpdk-doc</span><br></pre></td></tr></table></figure>

<p>安装其他依赖，可以先在本地保存为 <code>install.sh</code>，然后使用 <code>scp</code> 命令传到服务器上 <code>sh install.sh</code>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y cmake gcc g++ git automake llvm llvm-dev llvm-runtime libtool bison flex build-essential vim</span><br><span class="line"></span><br><span class="line"># Install pkg-config here, as it is required for p4lang/PI</span><br><span class="line"># installation to succeed.</span><br><span class="line">sudo apt-get install -y pkg-config</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y wget curl zip unzip rar unrar unar</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y libgc-dev libfl-dev libgmp-dev libevent-dev libssl-dev libjudy-dev libpcap-dev tcpdump</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y libboost-dev libboost-iostreams-dev libboost-graph-dev libboost-test-dev libboost-program-options-dev libboost-system-dev libboost-filesystem-dev libboost-thread-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y libreadline6 libreadline6-dev</span><br><span class="line"># 这里如果提示废弃就执行下面的安装</span><br><span class="line">sudo apt-get install -y libreadline-dev </span><br><span class="line"></span><br><span class="line"># Deps needed to build PI:</span><br><span class="line">sudo apt-get install -y libjudy-dev libreadline-dev valgrind libtool-bin libboost-dev libboost-system-dev libboost-thread-dev</span><br><span class="line"></span><br><span class="line"># Things needed for `cd tutorials/exercises/basic ; make run` to work:</span><br><span class="line">sudo apt-get install -y libgflags-dev net-tools</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y doxygen graphviz texlive-full</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y bridge-utils tcpreplay</span><br><span class="line">sudo apt-get install -y zlib1g-dev pciutils kmod strace  ## needed by cisco trex</span><br></pre></td></tr></table></figure>

<h3 id="安装TRex"><a href="#安装TRex" class="headerlink" title="安装TRex"></a>安装TRex</h3><p>联网下载 TRex</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-cache http://trex-tgn.cisco.com/trex/release/latest</span><br><span class="line">tar -zxvf latest</span><br></pre></td></tr></table></figure>

<p>我们下载的 TRex 最新版本为 v2.82，进入到该目录下并执行 DPDK 端口设置脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd v2.82</span><br><span class="line">./dpdk_setup_ports.py -i</span><br></pre></td></tr></table></figure>

<p>按照下图设置</p>
<p><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/4.jpeg" alt="0b9649d536fbab09908a9df0303c590a.jpeg"></p>
<p>此时可以注意到，X710 网卡的两个网口还是绑定的 i40e 内核驱动。但在运行 TRex 发包命令后会自动绑定到 DPDK 兼容驱动 igb_uio 上。</p>
<h2 id="发包测试"><a href="#发包测试" class="headerlink" title="发包测试"></a>发包测试</h2><p>实验环境准备就绪，进行发包测试。参考 TRex 官方手册 <a href="https://trex-tgn.cisco.com/trex/doc/trex_manual.html#_running_examples">Running examples
</a>，在 stateful 模式下使用 <code>t-rex-64</code> 命令发送数据包。<code>-f</code> 指定配置 yaml，<code>-m</code> 指定重放次数，<code>-l</code> 指定网络延迟检测速率。更多参数详见官方手册。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./t-rex-64 -f avl/sfr_delay_10_1g.yaml -m 5 -l 1000</span><br></pre></td></tr></table></figure>

<p>测试效果如下：</p>
<p><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/5.jpeg" alt="7402f2999111d19e378f8883aaf3ba34.jpeg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Per port stats table </span><br><span class="line"></span><br><span class="line">      ports |               0 |               1 </span><br><span class="line"> -----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   opackets |        27882688 |        35434728 </span><br><span class="line">     obytes |      8217921859 |     28586813888 </span><br><span class="line">   ipackets |         5007937 |             709 </span><br><span class="line">     ibytes |      4647534484 |           79608 </span><br><span class="line">    ierrors |               0 |               0 </span><br><span class="line">    oerrors |               0 |               0 </span><br><span class="line">      Tx Bw |       1.18 Gbps |       3.81 Gbps </span><br><span class="line"></span><br><span class="line">-Global stats enabled </span><br><span class="line"> Cpu Utilization : 31.6  %  31.6 Gb/core </span><br><span class="line"> Platform_factor : 1.0  </span><br><span class="line"> Total-Tx        :       5.00 Gbps  </span><br><span class="line"> Total-Rx        :       0.00  bps  </span><br><span class="line"> Total-PPS       :       1.07 Mpps  </span><br><span class="line"> Total-CPS       :      20.51 Kcps  </span><br><span class="line"></span><br><span class="line"> Expected-PPS    :       1.08 Mpps  </span><br><span class="line"> Expected-CPS    :      20.61 Kcps  </span><br><span class="line"> Expected-BPS    :       5.02 Gbps  </span><br><span class="line"></span><br><span class="line"> Active-flows    :    21328  Clients :      511   Socket-util : 0.0775 %    </span><br><span class="line"> Open-flows      :  1342791  Servers :     5621   Socket :    24927 Socket/Clients :  48.8 </span><br><span class="line"> drop-rate       :       5.00 Gbps   </span><br><span class="line"> current time    : 66.5 sec  </span><br><span class="line"> test duration   : 3533.5 sec  </span><br><span class="line"></span><br><span class="line">-Latency stats enabled </span><br><span class="line"> Cpu Utilization : 0.1 %  </span><br><span class="line"> if|   tx_ok , rx_ok  , rx check ,error,       latency (usec) ,    Jitter          max window </span><br><span class="line"></span><br><span class="line">   |         ,        ,          ,     ,   average   ,   max  ,    (usec)                     </span><br><span class="line"> ---------------------------------------------------------------------------------------------------------------- </span><br><span class="line"></span><br><span class="line"> 0 |    65254,   12858,         0,    0,          7  ,      23,       1      |  10  10  15  10  12  11  12  23  10  10  15  18  12 </span><br><span class="line"> 1 |    65254,     136,         0,    0,          3  ,       0,       0      |  0  0  0  0  0  0  0  0  0  0  0  0  0 </span><br><span class="line"></span><br><span class="line">## </span><br></pre></td></tr></table></figure>

<p>主要记录的数据包括：</p>
<ul>
<li><strong>Cpu Utilization</strong>，CPU利用率</li>
<li><strong>Total-Tx</strong>，总计发送速率（Transport）</li>
<li><strong>Total-Rx</strong>，总计接受速率（Receive）</li>
<li><strong>Total-PPS</strong>，总计每秒传输包数量（Packets per second）</li>
</ul>
<h2 id="发包实验"><a href="#发包实验" class="headerlink" title="发包实验"></a>发包实验</h2><p>接下来我们尝试在 stateful 模式下模拟 stateless 发包，使用的是 <code>cap2/</code> 目录下的 <code>imix.yaml</code> 配置文件，根据以太网协议，一个数据包的大小从最小 64Bytes 到最大 1518Bytes，imix 提供了 imix_64、imix_594 和 imix_1518 三类配置文件。</p>
<p><code>-c</code> 指定 CPU 核数，观察并绘制不同包大小、不同核数时 CPU 利用率以及吞吐率的 eps 矢量图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./t-rex-64 -f cap2/imix_1518.yaml -m 823451 -l 1000 -c 2</span><br></pre></td></tr></table></figure>

<p>实验结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Per port stats table </span><br><span class="line"></span><br><span class="line">      ports |               0 |               1 </span><br><span class="line"> -----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">   opackets |        34232892 |           42080 </span><br><span class="line">     obytes |     51904428378 |         2777280 </span><br><span class="line">   ipackets |               0 |               0 </span><br><span class="line">     ibytes |               0 |               0 </span><br><span class="line">    ierrors |               0 |               0 </span><br><span class="line">    oerrors |               0 |               0 </span><br><span class="line">      Tx Bw |       9.89 Gbps |     527.55 Kbps </span><br><span class="line"></span><br><span class="line">-Global stats enabled </span><br><span class="line"> Cpu Utilization : 100.0  %  9.9 Gb/core </span><br><span class="line"> Platform_factor : 1.0  </span><br><span class="line"> Total-Tx        :       9.89 Gbps  </span><br><span class="line"> Total-Rx        :       0.00  bps  </span><br><span class="line"> Total-PPS       :     816.02 Kpps  </span><br><span class="line"> Total-CPS       :       0.00  cps  </span><br><span class="line"></span><br><span class="line"> Expected-PPS    :       6.59 Gpps  </span><br><span class="line"> Expected-CPS    :       6.59 Gcps  </span><br><span class="line"> Expected-BPS    :      80.00 Tbps  </span><br><span class="line"></span><br><span class="line"> Active-flows    :     1600  Clients :      254   Socket-util : 0.0100 %    </span><br><span class="line"> Open-flows      :     1600  Servers :    65534   Socket :     1600 Socket/Clients :  6.3 </span><br><span class="line"> Total_queue_full : 72264932         </span><br><span class="line"> drop-rate       :       9.89 Gbps   </span><br><span class="line"> current time    : 43.3 sec  </span><br><span class="line"> test duration   : 3556.7 sec  </span><br><span class="line"></span><br><span class="line">-Latency stats enabled </span><br><span class="line"> Cpu Utilization : 0.1 %  </span><br><span class="line"> if|   tx_ok , rx_ok  , rx check ,error,       latency (usec) ,    Jitter          max window </span><br><span class="line"></span><br><span class="line">   |         ,        ,          ,     ,   average   ,   max  ,    (usec)                     </span><br><span class="line"> ---------------------------------------------------------------------------------------------------------------- </span><br><span class="line"></span><br><span class="line"> 0 |    42080,       0,         0,    0,          0  ,       0,       0      |  0  0  0  0  0  0  0  0  0  0  0  0  0 </span><br><span class="line"> 1 |    42081,       0,         0,    0,          0  ,       0,       0      |  0  0  0  0  0  0  0  0  0  0  0  0  0 </span><br><span class="line"></span><br><span class="line">## </span><br></pre></td></tr></table></figure>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h3><p>一个以太网帧的结构包括：</p>
<table>
<thead>
<tr>
<th>PA</th>
<th>SFD</th>
<th>DA</th>
<th>SA</th>
<th>Type</th>
<th>Payload</th>
<th>FCS</th>
<th>IFG</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>1</td>
<td>6</td>
<td>6</td>
<td>2</td>
<td>46 ~ 1500</td>
<td>4</td>
<td>12</td>
</tr>
</tbody></table>
<p>最小帧长：7+1+(6+6+2+46+4)+12 = 84B（最小有效帧长 64B）<br>最大帧长：7+1+(6+6+2+1500+4)+12 = 1538B（最大有效帧长 1518B）</p>
<p>对于最小帧长，最大包传输率 M 和吞吐率 T 为：</p>
<p>$$M = Speed/Size = 100 * 10^9 / (84 * 8) = 148809523 pps$$<br>$$T = M * 64 * 8 = 76.19Gbps$$</p>
<p>对于最大帧长，最大包传输率 M 和吞吐率 T 为：</p>
<p>$$M = Speed/Size = 100 * 10^9 / (1538 * 8) = 8127438 pps$$<br>$$T = M * 1518 * 8 = 98.69Gbps$$</p>
<p>以此类推，我们对于不同的帧长做了理论分析，得到下图：</p>
<p><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/6.png" alt="38021550bd20f375c0c872a80cea41af.png"></p>
<h3 id="吞吐率测试结果"><a href="#吞吐率测试结果" class="headerlink" title="吞吐率测试结果"></a>吞吐率测试结果</h3><p>以下是吞吐率的测试结果：</p>
<p><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/7.png" alt="037b37c99b1bc4c938f887dc1b876ba1.png"><br><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/8.png" alt="ec784c4bc84e984d27170739145d5bfe.png"><br><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/9.png" alt="d9c6568a7c11555a9290d452fbacafe2.png"></p>
<h3 id="包传输率测试结果"><a href="#包传输率测试结果" class="headerlink" title="包传输率测试结果"></a>包传输率测试结果</h3><p>以下是包传输率的测试结果：</p>
<p><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/10.png" alt="0f5b53c8b5544ae9572cebc9168f12cb.png"><br><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/11.png" alt="83c9995318589576075bf3140b4f46fd.png"><br><img src="/2020/09/17/%E5%9F%BA%E4%BA%8EDPDK%E7%9A%84%E6%A8%A1%E6%8B%9F-D-Dos%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/12.png" alt="79d66dcca878a695f31c01cf8e08e2d8.png"></p>
<h3 id="与内核机制发包的对比"><a href="#与内核机制发包的对比" class="headerlink" title="与内核机制发包的对比"></a>与内核机制发包的对比</h3><table>
<thead>
<tr>
<th align="center">包大小(B)</th>
<th align="center">内核机制发包<br>CPU利用率</th>
<th align="center">内核机制发包<br/>PPS(Kpps)</th>
<th align="center">DPDK机制发包<br/>PPS(Mpps)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">64</td>
<td align="center">100%</td>
<td align="center">593.5</td>
<td align="center">14.85</td>
</tr>
<tr>
<td align="center">549</td>
<td align="center">100%</td>
<td align="center">585.29</td>
<td align="center">2.04</td>
</tr>
<tr>
<td align="center">1518</td>
<td align="center">97.70%</td>
<td align="center">537.27</td>
<td align="center">0.82</td>
</tr>
</tbody></table>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>由上述实验结果可知：</p>
<ol>
<li>10Gbps 线速的网络，用 DPDK 跑 4 个核，基本可以实现 64B 最小包较好的发送吞吐率，但是仍达不到 10Gbps 的线速，只有 7.6Gbps 左右。</li>
<li>DPDK 由于采用了绕过内核驱动的技术，使得网络数据包的发送速度大大增加。</li>
<li>此外，随着数据包长度增加，其他条件一定时，吞吐率也随之增加，这与我们的理论分析基本吻合。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><em>Surasak Sanguanpong, Experiences in Building a 100 Gbps (D)DoS Traffic Generator, DIY with a Single  Commodity-off-the-shelf (COTS) Server.</em></li>
<li><a href="https://trex-tgn.cisco.com/trex/doc/trex_manual.html">TRex official manual</a></li>
<li><a href="https://trex-tgn.cisco.com/trex/doc/trex_stateless.html#_stateful_vs_stateless">TRex Stateless Support</a></li>
<li><a href="https://github.com/cisco-system-traffic-generator/trex-core">思科TRex Traffic Generator代码仓库</a></li>
</ul>
]]></content>
      <categories>
        <category>Projects</category>
      </categories>
  </entry>
  <entry>
    <title>如何阅读 Python 源码</title>
    <url>/2021/01/09/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB-Python-%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>阅读源码是每个程序员都应当具备的技能，阅读源码不仅能帮助你理解一个模块实现的细节，也能让你从优秀的源码中汲取经验，遵循更好的编码规范，编写出更 Pythonic 的代码。但不可否认的是，阅读源码需要一定的编码功底，盲目的阅读并不能取得应有的效果。在阅读源码之前我们要明白阅读的目的，如果是想了解一个模块的实现细节自不必多说，但如果是想提高自己的 Python 编码水平，那么就应该从 Python 标准库以及一些优秀的第三方开源代码下手。</p>
<p>在《Python编程之美：最佳实践指南》这本书中，作者 Kenneth Reitz 从简单的 HowDoI 项目，到大一点的 requests 库（他本身也是这个库的开发者），再到后面的 Web 框架 Flask，逐步递进地展示如何阅读高质量的代码。如果想阅读优秀的第三方库源码，可以从他在书中罗列出的经典项目开始。除此之外，GitHub 上也有人整理了比较详尽的目录：<a href="https://github.com/programthink/opensource/blob/master/libs/python.wiki">Python 开源库及示例代码</a>。项目很多，但不是每个都必读。还是强调的那一点：不要盲目的阅读源码，确定有必要的时候再去阅读。</p>
<p>抛开这些问题不谈，本篇我想结合我自己在阅读标准库源码（主要是 typing 模块和 re 模块）时的一点理解，介绍一些阅读源码前需要掌握的先验知识，以及如何结合开发工具在 PyCharm IDE 中高效地阅读源码。让我们先从 Python 代码的类型提示开始。</p>
<h2 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h2><blockquote>
<p><strong>PEP 3107 – Function Annotations</strong> : Python Version 3.0, Created Time 2-Dec-2006. This PEP introduces a syntax for adding arbitrary metadata annotations to Python functions.</p>
</blockquote>
<p>Python 3 添加了对类型提示（Type Hints）的支持，在此之前 Python 2.x 一直缺乏一种统一的方式去对函数参数和返回值进行标注，一些工具或三方库通过 docstring、注释或者函数装饰器等其他方法尝试去弥补这种缺陷。而自从 Python 3.0 开始，Python 通过 PEP 3107 提案引入了<strong>函数注解</strong>，也就是 Function Annotations，提供了一种标准的解决方案，用于<strong>为函数声明中的参数和返回值附加元数据</strong>。</p>
<p>函数注解的语法如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a: expression, b: expression = <span class="number">5</span></span>) -&gt; expression:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>函数声明中的各个参数可以在 <code>:</code> 之后添加注解表达式。如果参数有默认值，表达式后可以跟 <code>=</code> 指定默认值，且与常规函数声明一样，指定默认值参数要出现在无默认值参数之后。注解表达式最常使用的是类型（如 str 或 int），也可以是一个字符串（如 ‘int &gt; 0’）。如果想注解返回值，在 <code>)</code> 与 <code>:</code> 之间添加 <code>-&gt;</code> 和一个表达式，表达式可以是任意类型，如果函数无返回值则为 None。</p>
<p>本质上来说，PEP 3107 只是一种前导的语法规范，不对注解任何实质处理，你可以将其理解为官方规定的函数声明的注释。换句话说，<strong>注解只是元数据</strong>，Python 解释器对其不做检查、不做强制、不做验证。Python 对注解所做的唯一的事情，就是将它们存储在函数的 <code>__annotations__</code> 属性中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a: <span class="string">&#x27;x&#x27;</span>, b: <span class="number">5</span> + <span class="number">6</span>, c: <span class="built_in">list</span></span>) -&gt; <span class="built_in">max</span>(2, 9):</span> ...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__annotations__</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;c&#x27;</span>: &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt;, &#x27;<span class="title">return</span>&#x27;:</span> <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>

<p>其中 return 键保存的是返回值的注解，即函数声明里以 <code>-&gt;</code> 标记的部分。从这个例子我们可以看出，注解表达式的约束非常的宽泛，不管你是类型，还是字符串，或是个表达式。</p>
<p>注解可以供 IDE、框架和装饰器等工具使用，举个例子，框架可以对 <code>price: &#39;int &gt; 0&#39;</code> 这样的字符串注解转换为对参数的验证。注解最大的作用是为 IDE 和 lint 程序中的<strong>静态类型检查</strong>功能提供额外的类型信息，也就是我们接下来要讨论的类型提示。</p>
<p><strong>延伸</strong>：Java 中的注解也称为 Annotation，使用 <code>@</code> 符号标注，本质上也是元数据，本身 Java 解释器不会对其做任何处理，只有结合 Java 运行时的反射（getAnnotation 方法）才能获取注解内容从而针对性地制定处理逻辑，这在一些框架例如 Spring 中使用颇多。这与 Python 中的注解是否存在异曲同工之处呢？我们有理由相信，Python 中的静态类型检查工具也是获取了函数的 <code>__annotations__</code> 属性从而进行处理。</p>
<h2 id="类型提示"><a href="#类型提示" class="headerlink" title="类型提示"></a>类型提示</h2><blockquote>
<p><strong>PEP 484 – Type Hints</strong> : Python Version 3.5, Created Time 29-Sep-2014. This PEP aims to provide a standard syntax for type annotations, opening up Python code to easier static analysis and refactoring, potential runtime type checking, and (perhaps, in some contexts) code generation utilizing type information.</p>
</blockquote>
<p>在 PEP 3107 提案提出后，已经有一些第三方工具结合函数注解做了静态类型检查方面的工作，其中被采用较多的就是 Jukka Lehtosalo 开发的 mypy 项目。PEP 484 提案受 mypy 的强烈启发（Jukka 也参与了提案的制订），规定了如何给 Python 代码添加<strong>类型提示（Type Hints）</strong>，主要方式就是使用注解，以及引入了一个新模块：<strong>typing 模块</strong>。</p>
<h3 id="typing-模块"><a href="#typing-模块" class="headerlink" title="typing 模块"></a>typing 模块</h3><p>为了给 Python 静态类型检查提供统一的命名空间，标准库以渐进定型（gradual typing）的方式引入名为 <a href="https://docs.python.org/3/library/typing.html">typing</a> 的新模块，新模块不会影响现有程序的正常运行，只会对不规范的类型作出提示。</p>
<p>在 typing 模块中，定义了一些<strong>特殊类型</strong>（_SpecialForm），包括 Any, NoReturn, ClassVar, Union, Optional 等，从名称可以大概猜出这些类型的作用，比如：Any 代表任意类型；联合类型 <code>Union[X, Y]</code> 表示类型非 X 即 Y；Optional 作用则与 Java8 中的 Optional 类似，允许传入参数为空，可以避免空值引用的问题。</p>
<p>除此之外，还有一些常见的数据类型，比如 List、Tuple、Dict、Sequence，它们只是作为标准库类型的别名存在，如：<code>List = _alias(list, T, inst=False)</code>。typing 模块也提供了对于<strong>泛型</strong>（Generics）的支持，让我们得以像 <code>List[int]</code> 这样去定义特定类型集合。想了解更多 typing 模块的功能，建议阅读 PEP 484文档或者直接阅读源码，源码的文档注释介绍了该模块的结构，通过 <code>__all__</code> 属性也可以查明 typing 模块都提供了哪些功能。</p>
<p>PEP 484 旨在为类型注解提供一种标准语法，让 Python 代码更易于静态分析和重构，尽管 typing 模块也提供了一些潜在的用于运行时类型检查的功能模块，尤其是 <code>get_type_hints()</code> 函数，但它本身不对其做直接支持，仍然需要开发第三方库才能实现特定的运行时类型检查功能，比如使用装饰器或元类。<code>get_type_hints</code> 函数用于获取对象的类型提示，它的源码中包含这么一行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hints = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;__annotations__&#x27;</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>这验证了我们之前猜想的类型提示会去查询对象的 <code>__annotations__</code> 属性，此外该方法还会对注解字符串进行验证，我们将这个方法再应用到之前随意注解的 foo 函数时就会报错：找不到 “x” 类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> typing <span class="keyword">import</span> get_type_hints</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a: <span class="string">&#x27;x&#x27;</span>, b: <span class="number">5</span> + <span class="number">6</span>, c: <span class="built_in">list</span></span>) -&gt; <span class="built_in">max</span>(2, 9):</span> ...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__annotations__  <span class="comment"># No error</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;c&#x27;</span>: &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt;, &#x27;<span class="title">return</span>&#x27;:</span> <span class="number">9</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_type_hints(foo)  <span class="comment"># Error</span></span><br><span class="line">NameError: name <span class="string">&#x27;x&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">a: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span> ...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_type_hints(bar)</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;, &#x27;<span class="title">return</span>&#x27;:</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="变量注解"><a href="#变量注解" class="headerlink" title="变量注解"></a>变量注解</h3><blockquote>
<p><strong>PEP 526 – Syntax for Variable Annotations</strong> : Python Version 3.6, Created Time 09-Aug-2016. This PEP aims at adding syntax to Python for annotating the types of variables (including class variables and instance variables), instead of expressing them through comments.</p>
</blockquote>
<p>为了丰富类型提示的功能，Python 随即在 3.6 版本中引入了<strong>变量注解（Variable Annotations）</strong>，用于规定变量的类型。与函数注解相同，变量注解也只是元数据，Python 解释器不对其做任何处理，仅供框架和工具做类型检查。语法上变量注解与函数注解类似，使用 <code>:</code> 后接参数类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">primes: <span class="type">List</span>[<span class="built_in">int</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signal</span>(<span class="params">flag: <span class="built_in">bool</span></span>):</span></span><br><span class="line">    color: <span class="built_in">str</span>  <span class="comment"># Note: no initial value!</span></span><br><span class="line">    <span class="keyword">if</span> flag: color = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>: color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> color</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Starship</span>:</span></span><br><span class="line">    captain: <span class="built_in">str</span> = <span class="string">&#x27;Picard&#x27;</span>  <span class="comment"># instance variable with initial value</span></span><br><span class="line">    stats: ClassVar[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]] = &#123;&#125;  <span class="comment"># class variable</span></span><br></pre></td></tr></table></figure>

<p>变量注解适用于全局变量、局部变量、类属性以及实例属性。上述代码中的 ClassVar 是由 typing 模块定义的特殊类型，向静态类型检查程序标示在类实例中不允许对该变量进行赋值。注解的同时可以对变量进行初始化，如果省略初始化，也能很方面的在后续的条件分支中进行初始化。</p>
<p>全局变量的注解存储在当前模块的 <code>__annotations__</code> 字典中，如果在 Python 交互式命令行中就是 <code>__main__</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a: <span class="built_in">int</span> = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b: <span class="built_in">str</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__annotations__</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;, &#x27;<span class="title">b</span>&#x27;:</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;&#125;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; </span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">import</span> <span class="title">__main__</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">get_type_hints</span>(<span class="params">__main__</span>)</span></span><br><span class="line"><span class="class">&#123;&#x27;<span class="title">a</span>&#x27;:</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt;, &#x27;<span class="title">b</span>&#x27;:</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="何时使用类型提示"><a href="#何时使用类型提示" class="headerlink" title="何时使用类型提示"></a>何时使用类型提示</h3><p>PEP 484 中强调了 Python 将继续维持作为动态语言的特性，从来没有将类型提示强制化或是惯例化的想法。那么何时采用类型提示呢？一般而言，如果你开发的是供他人使用的第三方库（尤其是在  PyPI 上发布的库中），或是在一个多人协作的稍大项目中，推荐使用类型提示。一方面，这会帮助使用库的用户正确地调用接口。另一方面，类型提示也可以帮助理解类型是如何在代码中传播的。</p>
<p>Bernat Gabor 认为类型提示与单元测试重要性一致，本质上都是为了验证你的代码库的输入输出类型，只是表现形式不同。在他的文章 <a href="https://www.bernat.tech/the-state-of-type-hints-in-python/">the state of type hints in Python</a> 的最后总结中提到：<strong>只要值得编写单元测试，就应该添加类型提示</strong>，哪怕代码只有十行，只要你日后需要维护它。所以他给出的建议是，在编写单元测试的同时添加类型提示。虽然这会添加额外的代码量，但为了代码平稳工作值得付出这个代价，尤其是发生代码变更时。</p>
<p>我们可以在存根文件中使用类型注解来启用类型提示。并且如果参数声明带有默认值，则可以不指定实际的默认值而使用省略号 <code>...</code> 代替，这与冒号后的函数体使用省略号一样，将省略号用作占位符。对于变量，一般只声明类型不给出初值。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x: AnyStr, y: AnyStr = ...</span>) -&gt; AnyStr:</span> ...</span><br><span class="line"></span><br><span class="line">stream: IO[<span class="built_in">str</span>]</span><br></pre></td></tr></table></figure>

<h2 id="pyi-存根文件"><a href="#pyi-存根文件" class="headerlink" title=".pyi 存根文件"></a>.pyi 存根文件</h2><p>由于 Python 是动态语言，不对类型做强制约束，所以 IDE 在类型检查、类型推断、代码补全以及重构等方面必然不如 Java 等静态语言来的方便。<strong>存根文件是包含类型提示信息的文件</strong>，运行时不会用到，而是<strong>提供给第三方工具做静态类型检查和类型推断</strong>，这方面 PyCharm 做的很好。</p>
<p>在 PyCharm 中，如果某一行的左边有 * 号标识，则说明这一行（可以是类、属性或函数）在存根文件中有定义，你可以点击 * 号跳转到该文件对应的存根文件，通常是存放在 Python 库文件的 Typeshed Stubs 目录中，文件名以 <code>.pyi</code> 后缀结尾。同时，存根文件也是 GitHub 上一个单独的项目，项目地址：<a href="https://github.com/python/typeshed">https://github.com/python/typeshed</a> ，Python 的标准库以及内置 builtins 存根可以在该项目的 stdlib 目录下找到。</p>
<p>我们来看看 Python 正则库 re 的存根文件和源文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># re.pyi</span></span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span>(<span class="params">pattern: AnyStr, flags: _FlagsType = ...</span>) -&gt; Pattern[AnyStr]:</span> ...</span><br><span class="line"><span class="meta">@overload</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span>(<span class="params">pattern: Pattern[AnyStr], flags: _FlagsType = ...</span>) -&gt; Pattern[AnyStr]:</span> ...</span><br><span class="line">  </span><br><span class="line"><span class="comment"># re.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span>(<span class="params">pattern, flags=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;Compile a regular expression pattern, returning a Pattern object.&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">compile</span>(pattern, flags)</span><br></pre></td></tr></table></figure>

<p>这里只截取了源码中的一段 compile 函数。从形式上看，存根文件与 C 语言中的头文件有相似之处，将函数声明与函数定义分文件存放，但与其将存根文件理解为函数声明文件，不如理解为函数接口（Interface）文件，接口的意义就是让用户在调用时可以清晰地查看函数的参数和返回值类型。这也是为什么 PEP 484 的作者之一 Jukka Lehtosalo 说可以将 <code>.pyi</code> 中的 i 理解为 Interface。</p>
<p>上述源文件中的 compile 函数，调用了私有的 _compile 函数并返回一个 Pattern 对象，作用是将字符串处理（编译）成正则表达式模版。进一步 _compile 的源码会发现，如果传入的 pattern 参数本来就是 Pattern 类型的，为了避免重复处理，方法会直接返回 pattern，如下面的代码所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_compile</span>(<span class="params">pattern, flags</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(pattern, Pattern):</span><br><span class="line">        <span class="keyword">if</span> flags:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">&quot;cannot process flags argument with a compiled pattern&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> pattern</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这也解释了为什么存根文件中会存在两个 compile 函数声明，其中的第二个就是接收 Pattern 类型作为参数的。除了 compile 函数之外，re 存根文件中的大多数函数都有两个重载函数，原因就是它们实现时都调用了 _compile 函数。事实上，为了防止用户多次调用 _compile 引起不必要的开销，_compile 也设置了缓存优化，这点留给读者自行阅读源码分析。</p>
<p>在最新的 PyCharm 2020.3 版本中，支持直接创建 Python stub 类型的 Python File，只需要存根文件与源文件同名，PyCharm 就会自动按照存根文件中指定的类型进行静态类型检查。并且，你也可以像 Typeshed 项目为存根文件分配单独的文件夹，具体操作详见 JetBrains 官网的 PyCharm 手册：<a href="https://www.jetbrains.com/help/pycharm/stubs.html">Python Stubs</a>。</p>
<h2 id="PyCharm-高效阅读源码"><a href="#PyCharm-高效阅读源码" class="headerlink" title="PyCharm 高效阅读源码"></a>PyCharm 高效阅读源码</h2><p>除了标注存根文件，PyCharm 还对子类父类方法重载进行了标注，分别用 <code>O↑</code> 表示这一行重载了父类方法，点击可以跳转到父类实现；<code>O↓</code> 表示这一行有子类重载，点击可以跳转到子类实现。其中 O 代表的是 Override 的含义。</p>
<p>比如我们阅读 Python 内置的列表 list 的源码，append 方法这一行既是重载自父类也有子类重载（存根文件中标注的）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>(<span class="params">MutableSequence[_T], <span class="type">Generic</span>[_T]</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, __object: _T</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br></pre></td></tr></table></figure>

<p>可以看到 list 多重继承自 MutableSequence 和 Generic，如果点击 append 左侧 <code>O↑</code>，就会跳转到父类 MutableSequence 的 append 实现处。如果点击 <code>O↓</code>，可以选择某个子类并进行跳转（list 存在多个子类）。这在阅读一个具有继承结构的源码时会有所帮助。</p>
<p>当然，如果想在 PyCharm 中高效阅读源码，需要结合快捷键来使用。这里列出一些 Mac OS 下的快捷键，Windows 下一般是将 Cmd 替换为 Ctrl，你也可以打开 PyCharm 设置自行查阅 Keymap 快捷键：</p>
<table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">作用</th>
<th align="left">PyCharm Keymap</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cmd + U</td>
<td align="left">跳转到父类实现</td>
<td align="left">Go to Super Method</td>
</tr>
<tr>
<td align="left">Cmd + Alt + B/Left Click</td>
<td align="left">跳转到子类实现</td>
<td align="left">Go to Implementations</td>
</tr>
<tr>
<td align="left">Cmd + B/Left Click</td>
<td align="left">跳转到定义处或调用处</td>
<td align="left">Go to Declaration or Usages</td>
</tr>
<tr>
<td align="left">Cmd + [</td>
<td align="left">跳转到鼠标停留的上一个位置</td>
<td align="left">Back</td>
</tr>
<tr>
<td align="left">Cmd + ]</td>
<td align="left">跳转到鼠标停留的下一个位置</td>
<td align="left">Forward</td>
</tr>
<tr>
<td align="left">Cmd + E</td>
<td align="left">跳转到最近浏览的文件</td>
<td align="left">Iterate Recent Files</td>
</tr>
<tr>
<td align="left">Cmd + Shift + O</td>
<td align="left">以文件名查询并跳转</td>
<td align="left">Go to File</td>
</tr>
<tr>
<td align="left">Cmd + O</td>
<td align="left">以类名查询并跳转</td>
<td align="left">Go to Class</td>
</tr>
<tr>
<td align="left">Cmd + Alt + O</td>
<td align="left">以符号查询并跳转，可以查询函数和全局变量</td>
<td align="left">Go to Symbol</td>
</tr>
<tr>
<td align="left">双击 Shift</td>
<td align="left">整合了所有查询</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Cmd + F</td>
<td align="left">搜索当前文件下内容</td>
<td align="left">Find</td>
</tr>
<tr>
<td align="left">Cmd + Shift + F</td>
<td align="left">搜索项目文件中的内容</td>
<td align="left">Find in Files</td>
</tr>
</tbody></table>
<p>这些都是 PyCharm 中非常实用的快捷键，不管是阅读源码还是自己编码，熟悉这些快捷键有助于快速定位到某个文件，某个函数或是某个变量，从而提高我们的效率。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.python-guide.org/writing/reading/">Reading Great Code – Kenneth Reitz</a></li>
<li><a href="https://www.python.org/dev/peps/pep-3107/">PEP 3107 – Function Annotations</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0484/">PEP 484 – Type Hints</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0526/#abstract">PEP 526 – Syntax for Variable Annotations</a></li>
<li><a href="https://docs.python.org/3/library/typing.html">Python 官方文档：typing — Support for type hints</a></li>
<li><a href="https://realpython.com/python-type-checking/#function-annotations">Python Type Checking (Guide)</a></li>
<li><a href="https://sikasjc.github.io/2018/07/14/type-hint-in-python/#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA">译文：全面理解 Python 中的类型提示（Type Hints）</a></li>
</ul>
]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 JDK &amp; Tomcat</title>
    <url>/2017/11/02/%E5%AE%89%E8%A3%85%20JDK&amp;Tomcat/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>Tomcat是现在主流的应用服务器。可以直接将基于Spring框架的Java Web应用部署到Tomcat上。本文将介绍如何安装JDK和Tomcat</p>
</blockquote>
<h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><ul>
<li>服务器：Ubuntu 16.04</li>
<li>良好的网络环境</li>
</ul>
<h2 id="Install-JDK"><a href="#Install-JDK" class="headerlink" title="Install JDK"></a>Install JDK</h2><blockquote>
<p>官网安装jdk，相对较麻烦，但是官网毕竟权威</p>
</blockquote>
<ul>
<li><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">oracle官网</a>复制jdk下载链接，执行<code>wget</code>命令即可</p>
</li>
<li><p>解压<code>.tar.gz</code>压缩包，并改名</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv jdk-8u151-linux-x64.tar.gz /usr/local/lib/</span><br><span class="line">tar -xzvf jdk-8u151-linux-x64.tar.gz</span><br><span class="line">mv jdk-8u151-linux-x64 jdk8</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vim ~/.bashrc</code>配置环境变量，<a href="http://www.cnblogs.com/wangchenyang/archive/2011/08/17/2143620.html">为什么要设置Java环境变量</a></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/lib/jdk8</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  </span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH </span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>bashrc</strong>与<strong>profile</strong>都用于保存用户的环境信息，**/etc/profile** 中设定的变量(全局)的可以作用于任何用户。**~/.bashrc** 该文件包含专用于某个用户的bash shell的bash信息,当该用户登录时以及每次打开新的shell时,该文件被读取。需要注意的是我在docker容器中的 <strong>/etc/profile</strong> 配置java环境变量时，重启容器发现配置没生效，应该是操作系统在重启时加载 <strong>/etc/profile</strong> 文件，但是docker容器就没有这种操作了。</p>
</blockquote>
<ul>
<li><code>source ~/.bashrc</code>使文件生效</li>
</ul>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><strong>Tips</strong></h4><ol>
<li>当你执行一条命令，系统会去PATH路径下查找该命令，比如你现在可以执行<code>java -version</code>命令。<code>echo $PATH</code>查看PATH设置。   </li>
<li>全局环境变量，可以<code>$&#123;&#125;</code>或者<code>$</code>引用，你现在可以<code>echo $&#123;JAVA_HOME&#125;</code>打印该值。<code>env</code>查看环境变量设置。</li>
</ol>
<blockquote>
<p>如果你觉得官网太麻烦，可以安装openjdk，虽说是阉割版，但足够满足你的需求了</p>
</blockquote>
<ul>
<li>安装<strong>openjdk</strong>只需要下面一行命令  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a><strong>Tips</strong></h4><ol>
<li>你可以通过如下命令查看有关jdk版本和信息。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-cache search jdk</span><br><span class="line">apt-cache show openjdk-8-jdk</span><br></pre></td></tr></table></figure></li>
<li>java有关的可执行文件被安装在<code>/usr/bin</code>目录下，但是环境变量并没有设置。</li>
</ol>
<h2 id="Install-Tomcat"><a href="#Install-Tomcat" class="headerlink" title="Install Tomcat"></a>Install Tomcat</h2><ul>
<li><p>照例，<a href="https://tomcat.apache.org/download-90.cgi">官网</a>下载、解压。这里不再赘述</p>
</li>
<li><p>配置Tomcat为服务，<code>cd /usr/local/lib/tomcat9</code>目录下</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp ./bin/catalina.sh /etc/init.d/tomcat</span><br></pre></td></tr></table></figure></li>
<li><p><code>vim /etc/init.d/tomcat</code>加入如下内容</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/lib/jdk8</span><br><span class="line">JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">CATALINA_HOME=/usr/local/lib/tomcat9</span><br><span class="line">CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;CATALINA_HOME&#125;/lib</span><br></pre></td></tr></table></figure></li>
<li><p>添加<strong>restart</strong>命令，<code>&quot;$1&quot;</code>指输入的第一个参数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    elif [ &quot;$1&quot; = &quot;restart&quot; ] ; then</span><br><span class="line">        service tomcat stop</span><br><span class="line">        sleep 1</span><br><span class="line">        service tomcat start</span><br><span class="line">    ```    </span><br><span class="line">- 保存退出，现在可以通过`service tomcat [start|stop|restart]`来启动、停止Tomcat。查看是否正常启动</span><br></pre></td></tr></table></figure>
<p>  curl localhost:8080</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### **Tips**</span><br><span class="line"></span><br><span class="line">1. 你的应用程序安装路径在**webapps**下。在部署你自己的应用前执行`rm -r webapps/*`清空文件夹    </span><br><span class="line">2. Tomcat的配置文件在`conf/server.xml`中</span><br><span class="line"></span><br><span class="line">### **About server.xml**</span><br><span class="line"></span><br><span class="line">- [server.xml详解](http://www.cnblogs.com/gugnv/archive/2012/02/01/2334187.html)</span><br><span class="line"></span><br><span class="line">- 默认开启8080端口，可以修改端口号</span><br></pre></td></tr></table></figure>
<p>  &lt;Connector port=”8080” protocol=”HTTP/1.1”</p>
<pre><code>         connectionTimeout=&quot;20000&quot;
         redirectPort=&quot;8443&quot; /&gt;
</code></pre>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `&lt;Host&gt;`标签中，**appBase**解释了为什么将Java Web程序打包放在此目录下。**unpackWARs**为true自动解压war包，**autoDeploy**自动部署。所以在Tomcat启动后识别webapps目录下`.war`结尾的war包自动解压、部署。</span><br></pre></td></tr></table></figure>
<p>  &lt;Host name=”localhost”  appBase=”webapps”</p>
<pre><code>    unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
</code></pre>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 在`&lt;Host&gt;`标签中可设置`&lt;Context&gt;`上下文标签。**docBase**是应用程序包名，**path**是url前缀，**reloadable**为true时自动检测应用程序的`/WEB-INF/lib`和`/WEB-INF/classes`目录的变化，自动装载新的应用程序</span><br></pre></td></tr></table></figure>
  <Context docBase="app" path="/app" reloadable="true" />
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">- 如果不配置`&lt;Context&gt;`标签，将默认以应用程序文件夹名字作为url前缀，如**webapps**目录下应用程序文件夹名为**jpress**，则url为</span><br></pre></td></tr></table></figure>
  http://{IP}:{port}/jpress/
  ```</li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Elasticsearch 与 Kibana 搭建流量可视化平台</title>
    <url>/2021/12/14/%E5%9F%BA%E4%BA%8E-Elasticsearch-%E4%B8%8E-Kibana-%E6%90%AD%E5%BB%BA%E6%B5%81%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>前期工作</strong>：基于 Bind9 搭建内网 DNS 服务器，使得在 <code>/etc/resolv.conf</code> 中配置了该服务器 IP 的节点或终端的 DNS 流量都会流经该服务器，为集群 DNS 流量采集提供了先决基础。同时，初步使用日志记录 DNS 查询请求（配置在 <code>/etc/named.conf</code> 中），后续可采用 Packetbeat/TShark 等工具主动捕获。DNS 查询日志内容格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30-Nov-2021 08:57:25.192 client @0x7f74f800b650 192.168.101.145#61323 (apisix.apache.org): query: apisix.apache.org IN A + (168.168.168.47)</span><br><span class="line">30-Nov-2021 08:57:25.192 client @0x7f7514148d20 192.168.101.145#61325 (github.com): query: github.com IN A + (168.168.168.47)</span><br></pre></td></tr></table></figure>

<p>为了推进后续的 DNS 流量分类研究工作，本文介绍了如何基于现有的 DNS 流量日志，使用 Elasticsearch 和 Kibana 搭建流量监测可视化平台。本文包含以下内容：</p>
<ul>
<li>使用 <strong>Filebeat</strong> 将流量日志实时同步到 Elasticsearch；</li>
<li>使用 <strong>Grok</strong> 正则过滤器对采集到的日志消息二次处理；</li>
<li>使用网络数据包分析工具 <strong>Packetbeat</strong>。</li>
</ul>
<p>将日志文件转储到 Elasticsearch，一是作为历史归档考量，Bind9 日志存在存储时限，如果文件大小达到设置的上限，旧的日志文件会被循环覆盖。二是 JSON 格式易于拓展，支持嵌套和数组，且易于特征提取阶段 Python 进行处理。三是可视化支持好，在 Elasticsearch 数据集上，使用 Kibana 可以快速建立指标分析、图表分析以及时间序列分析等可视化。下图是基于 DNS 查询日志配置的 Kibana Dashboard 可视化界面。</p>
<p><img src="/2021/12/14/%E5%9F%BA%E4%BA%8E-Elasticsearch-%E4%B8%8E-Kibana-%E6%90%AD%E5%BB%BA%E6%B5%81%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/1.png" alt="93787acedd01f3ccf8ad7f2e4c62627d.png"></p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>操作系统 CentOS 7.9；</li>
<li>Docker，版本 19.03.13；</li>
<li>Elastic Stack 工具集，版本 7.15.2。包括 Elasticsearch、Kibana、Filebeat 和 Packetbeat。</li>
</ul>
<h2 id="部署-Elasticsearch-Kibana"><a href="#部署-Elasticsearch-Kibana" class="headerlink" title="部署 Elasticsearch + Kibana"></a>部署 Elasticsearch + Kibana</h2><p>使用 Docker 快速部署 Elasticsearch 与 Kibana 环境。首先，拉取 Docker 镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker pull docker.elastic.co/elasticsearch/elasticsearch:7.15.2</span><br><span class="line">$ docker pull docker.elastic.co/kibana/kibana:7.15.2</span><br></pre></td></tr></table></figure>

<p>需先以单点模式运行 Elasticsearch 容器，然后再启动 Kibana 容器。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run --name es01-test --net elastic -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> docker.elastic.co/elasticsearch/elasticsearch:7.15.2</span><br><span class="line">$ docker run -d --name kib01-test --net elastic -p 5601:5601 -e <span class="string">&quot;ELASTICSEARCH_HOSTS=http://es01-test:9200&quot;</span> docker.elastic.co/kibana/kibana:7.15.2</span><br></pre></td></tr></table></figure>

<p>成功启动容器后，可在 5601 端口访问 Kibana 首页。</p>
<p><img src="/2021/12/14/%E5%9F%BA%E4%BA%8E-Elasticsearch-%E4%B8%8E-Kibana-%E6%90%AD%E5%BB%BA%E6%B5%81%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/2.png" alt="d15ed7bec92f990449315ed49fa7bfeb.png"></p>
<h2 id="使用-Filebeat-监听日志文件变更"><a href="#使用-Filebeat-监听日志文件变更" class="headerlink" title="使用 Filebeat 监听日志文件变更"></a>使用 Filebeat 监听日志文件变更</h2><p>Filebeat 是 <a href="https://www.elastic.co/cn/beats/">Elastic/Beats</a> 数据采集器工具集中的一员，负责日志采集，相比于运行在 JVM 上的 Logstash，它更加轻量级。Filebeat 能够实时捕获文件的新增内容（类似 <code>tail -f</code> 命令），按行将新增内容转发到 Elasticsearch 或 Logstash 中存储，并记录文件当前偏移量，以便中断后下次启动从中断点继续开始。</p>
<p>下载、解压 Filebeat 安装包并重命名。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.15.2-linux-x86_64.tar.gz</span><br><span class="line">$ tar -xzvf filebeat-7.15.2-linux-x86_64.tar.gz </span><br><span class="line">$ mv filebeat-7.15.2-linux-x86_64 filebeat</span><br></pre></td></tr></table></figure>

<p>Filebeat 安装目录中，包含启动脚本以及默认配置文件 filebeat.yml。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> filebeat</span><br><span class="line">$ ./filebeat version</span><br><span class="line">filebeat version 7.15.2 (amd64), libbeat 7.15.2 [fd322dad6ceafec40c84df4d2a0694ea357d16cc built 2021-11-04 14:22:49 +0000 UTC]</span><br></pre></td></tr></table></figure>

<p>按照 filebeat.yml 文件格式，编写<strong>自定义配置文件</strong> named.yml。在配置文件中，设置日志输入源为 Bind9 生成的 query.log；去除了 Filebeat 生成的冗余字段（可选）；设置了写入的 Elasticsearch 的 URL 以及索引分片数。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/log/named/query.log</span></span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">drop_fields:</span></span><br><span class="line">      <span class="attr">fields:</span> [<span class="string">&quot;host&quot;</span>,<span class="string">&quot;agent&quot;</span>,<span class="string">&quot;ecs&quot;</span>,<span class="string">&quot;input&quot;</span>]</span><br><span class="line">      <span class="attr">ignore_missing:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;http://localhost:9200&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>默认情况下，Filebeat 写入 Elasticsearch 的索引名形如 <code>filebeat-%&#123;[beat.version]&#125;-%&#123;+yyyy.MM.dd&#125;</code>。此项配置在 <code>output.elasticsearch.index</code> 中，Filebeat 会自动创建索引别名，如 filebeat-7.15.2。</p>
<p>运行 Filebeat，参数 <code>-c</code> 指定配置文件 named.yml，<code>-e</code> 将错误日志输出到控制台。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./filebeat -e -c named.yml</span><br></pre></td></tr></table></figure>

<p>注：使用 <code>nohup</code> 和 <code>&amp;</code> 命令可以后台运行，并且输入 <code>exit</code> 退出命令行终端后依然不会停止（直接关闭命令行终端会停止）。</p>
<p>从 Filebeat 发往 Elasticsearch 的日志消息，包装在 message 字段中，除此之外，还有一些 Filebeat 生成的记录字段。一条日志信息转化后的格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;filebeat-7.15.2-2021.11.26-000001&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;5qjyan0BAsnp-ar_z6EP&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@timestamp&quot;</span>: <span class="string">&quot;2021-11-29T09:07:16.390Z&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;log&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;offset&quot;</span>: <span class="number">2892475</span>,</span><br><span class="line">      <span class="attr">&quot;file&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/var/log/named/query.log&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;29-Nov-2021 17:07:13.335 client @0x7fd6a0010f10 192.168.101.60#58832 (shcn2-06b.iplc188.com): query: shcn2-06b.iplc188.com IN A + (168.168.168.47)&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于原始的 message 字段，能够提供的信息有限，因此需要对消息字段加以处理。Logstash 的插件 Grok 正则过滤器提供对字符串的解析功能。如今，Elastic 提供了 Ingest Node 功能，允许在文档写入 Elasticsearch 索引之前经过<strong>预处理</strong>，并提供了对 Grok 的集成。</p>
<h2 id="使用-Grok-正则处理日志消息"><a href="#使用-Grok-正则处理日志消息" class="headerlink" title="使用 Grok 正则处理日志消息"></a>使用 Grok 正则处理日志消息</h2><p>在 Kibana 的 “Stack Management | Ingest Node Pipelines” 界面，可以指定一系列的处理器 （Processors）对消息进行流水线处理，包括定义异常处理分支。</p>
<p><img src="/2021/12/14/%E5%9F%BA%E4%BA%8E-Elasticsearch-%E4%B8%8E-Kibana-%E6%90%AD%E5%BB%BA%E6%B5%81%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/3.png" alt="dc741da57eca3e2b9bdc4bf70357cc3c.png"></p>
<p>对于 query.log 文件中的日志记录，由于日志格式固定，因此可以使用 Grok 对一条记录进行匹配。正则表达式格式如 <code>%&#123;IP:source.ip&#125;</code>，冒号左侧为 <a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/main/patterns/legacy/grok-patterns">Grok 默认 Pattern</a>，冒号右侧为存储的 JSON 字段名，支持嵌套结构。解析日志的 Grok 正则表达式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">23-Nov-2021 13:58:03.222 client @0x7f7034054680 168.168.168.47#56504 (baidu.com): query: baidu.com IN A + (168.168.168.47)</span><br><span class="line"></span><br><span class="line">%&#123;GREEDYDATA:timestamp&#125; %&#123;WORD&#125; %&#123;DATA:source.client&#125; %&#123;IP:source.ip&#125;#%&#123;NUMBER:source.port&#125; \(%&#123;HOSTNAME:domain.fullname&#125;\): query: %&#123;HOSTNAME&#125; %&#123;WORD:class&#125; %&#123;WORD:type&#125; </span><br></pre></td></tr></table></figure>

<p>此外，还可以<strong>自定义 Grok Pattern</strong>。例如，对于域名字段来说，其“二级域名 + 顶级域名”构成的域名后缀（即用户可以在域名注册网站购买的域名）可能具有重要分析意义。为此，定义了名为 SLD 的  Grok Pattern，将其解析成 <code>domain.eTLDplusOne</code> 字段（有效顶级域名 + 1，名称借鉴自 Packetbeat）。</p>
<p><img src="/2021/12/14/%E5%9F%BA%E4%BA%8E-Elasticsearch-%E4%B8%8E-Kibana-%E6%90%AD%E5%BB%BA%E6%B5%81%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/4-1.png" alt="fb23cc0fd30fb9e1e9c8d89ee52a22a6.png"></p>
<p>注：正则表达式中的反义字符由于要表示在 JSON 文档中，所以需要额外一个下划线，如 <code>\\.</code>。</p>
<p>可以在 “Stack Management | Ingest Node Pipelines” 界面添加测试文档测试流水线是否正常工作，这对于验证正则表达式正确性有巨大帮助。此外，还能够在 Dev Tools 的 Grok Debugger 控制台中调试正则表达式。</p>
<p>实际上，在 Kibana 界面添加 Pipeline 相当于在 Elasticsearch 的 <code>/_ingest/pipeline</code> 索引中添加了如下的一条文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dns_query_log_pipeline&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;description&quot;</span> : <span class="string">&quot;Extract fields from message.&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;processors&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;grok&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;message&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;patterns&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="string">&quot;%&#123;GREEDYDATA:timestamp&#125; %&#123;WORD&#125; %&#123;DATA:source.client&#125; %&#123;IP:source.ip&#125;#%&#123;NUMBER:source.port&#125; \(%&#123;HOSTNAME:domain.fullname&#125;\): query: %&#123;HOSTNAME&#125; %&#123;WORD:class&#125; %&#123;WORD:type&#125; &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;date&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;timestamp&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;formats&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;dd-MMM-yyyy HH:mm:ss.SSS&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">&quot;target_field&quot;</span> : <span class="string">&quot;timestamp&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;grok&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;domain.fullname&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;patterns&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="string">&quot;(%&#123;GREEDYDATA:domain.prefix&#125;\.)*(%&#123;SLD:domain.eTLDplusOne&#125;)&#123;1&#125;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">&quot;pattern_definitions&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;SLD&quot;</span> : <span class="string">&quot;&quot;</span><span class="string">&quot;((xn--)?[a-z0-9-]+\.[a-z|\-]&#123;2,63&#125;)&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;on_failure&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;set&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;domain.hostname&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;copy_from&quot;</span> : <span class="string">&quot;domain.fullname&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使该 Pipeline 生效，还需要在 Filebeat 的配置文件中添加此项配置，并重启 Filebeat 程序。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;http://localhost:9200&quot;</span>]</span><br><span class="line">  <span class="attr">pipeline:</span> <span class="string">&quot;dns_query_log_pipeline&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Kibana-可视化"><a href="#Kibana-可视化" class="headerlink" title="Kibana 可视化"></a>Kibana 可视化</h2><p>要在 Kibana 查看 Elasticsearch 中存储的数据，首先需要在 “Stack Management | Index patterns” 中配置索引模式（Index pattern）。</p>
<p><img src="/2021/12/14/%E5%9F%BA%E4%BA%8E-Elasticsearch-%E4%B8%8E-Kibana-%E6%90%AD%E5%BB%BA%E6%B5%81%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/4-2.png" alt="c1ddec742b59b52562067be4e9ed6231.png"></p>
<p>创建完成后，可以在 “Discover” 界面查看索引中存放的数据。</p>
<p><img src="/2021/12/14/%E5%9F%BA%E4%BA%8E-Elasticsearch-%E4%B8%8E-Kibana-%E6%90%AD%E5%BB%BA%E6%B5%81%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/5.png" alt="6625242b24495aaf1c3a084b4c17bb71.png"></p>
<p>还可以在 “Dashboard” 界面自定义可视化看板，效果图如前言中所示。</p>
<h2 id="使用-Packetbeat-监听数据包"><a href="#使用-Packetbeat-监听数据包" class="headerlink" title="使用 Packetbeat 监听数据包"></a>使用 Packetbeat 监听数据包</h2><p>除了使用 Filebeat + Grok 手动解析日志文件之外，Beats 工具集还提供了专用于<strong>网络数据包分析</strong>的轻量型工具 Packetbeat，它能够捕获由 ping 工具发起的 ICMP 报文（网络层），或者通过端口捕获应用层报文，如 HTTP 80 端口、MySQL 3306 端口等。捕获的报文可被解析成 JSON 格式存储到 Elasticsearch。</p>
<p>下载、解压 Packetbeat 安装包，并重命名。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl -L -O https://artifacts.elastic.co/downloads/beats/packetbeat/packetbeat-7.15.2-linux-x86_64.tar.gz</span><br><span class="line">$ tar xzvf packetbeat-7.15.2-linux-x86_64.tar.gz</span><br><span class="line">$ mv packetbeat-7.15.2-linux-x86_64 packetbeat</span><br></pre></td></tr></table></figure>

<p>Packetbeat 的配置文件模版位于 packetbeat.yml 中，我们需要自定义 DNS 配置文件 dns.yml。除了以 <code>packetbeat.</code> 开头的特定配置外，其他配置与 Filebeat 共用一套模版。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">packetbeat.interfaces.device:</span> <span class="string">eth0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">packetbeat.protocols:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">dns</span></span><br><span class="line">  <span class="attr">ports:</span> [<span class="number">53</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">drop_fields:</span></span><br><span class="line">      <span class="attr">fields:</span> [<span class="string">&quot;host&quot;</span>,<span class="string">&quot;agent&quot;</span>,<span class="string">&quot;ecs&quot;</span>]</span><br><span class="line">      <span class="attr">ignore_missing:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;http://localhost:9200&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>运行 Packetbeat，参数 <code>-c</code> 指定配置文件 named.yml，<code>-e</code> 将错误日志输出到控制台。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./packetbeat -e -c dns.yml</span><br></pre></td></tr></table></figure>

<p>启动 Packetbeat 后，捕获的数据被发送至 Elasticsearch，在 “Stack Management | Index patterns” 中配置索引模式后，就可以访问以 packetbeat-7.15.2 别名命名的索引中的数据。</p>
<p>此外，Packetbeat 还提供了一些可视化的 Kibana Dashboard 模版，通过如下命令初始化：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./packetbeat setup --dashboards</span><br></pre></td></tr></table></figure>

<p>Dashboard 效果图如下。</p>
<p><img src="/2021/12/14/%E5%9F%BA%E4%BA%8E-Elasticsearch-%E4%B8%8E-Kibana-%E6%90%AD%E5%BB%BA%E6%B5%81%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/6.png" alt="7a2a13ab1327c49fa654607b52f662e5.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>值得注意的是，Packetbeat 监听的是目的端口为 53 的数据包。不管是下面哪种 DNS 报文，Packetbeat 都能进行捕获。</p>
<ul>
<li>内网中访问内网 DNS 服务器的其他终端，如 192.168.101.215 -&gt; 168.168.168.47（内网 DNS 服务器）；</li>
<li>内网 DNS 服务器转发的 DNS 查询，如 168.168.168.47 -&gt; 8.8.8.8（谷歌 DNS 服务器，可在 Bind9 配置文件中定义转发规则）；</li>
<li>甚至是手动指定 DNS 服务器的查询报文，如 <code>dig @114.114.114.114 baidu.com</code>。</li>
</ul>
<p><img src="/2021/12/14/%E5%9F%BA%E4%BA%8E-Elasticsearch-%E4%B8%8E-Kibana-%E6%90%AD%E5%BB%BA%E6%B5%81%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/7.png" alt="08d3eb68410326d6b2798b8aa397eacc.png"></p>
<p>相比之下，使用日志记录 DNS 查询请求的方式就显得十分局限了。即使内网中的用户在 <code>/etc/resolv.conf</code> 中配置了内网 DNS 服务器，也不能保证恶意软件乖乖的使用该 DNS 服务器。因此理论上，只有在内网所有终端上部署类似 Packetbeat 的数据包探测器（类似的还有 Wireshark 的底层库工具 tshark），才能真正全量的监听 DNS 流量。此外，Packetbeat 解析出的 JSON 结构的数据所包含的信息要远大于通过正则分析的日志信息。</p>
<p>因此对于端口固定的数据包探测，Packetbeat 的实用性要优于 Filebeat + Grok 的方案。但 Filebeat 适用范围更广，任何有生成日志的程序，甚至是批/流处理产生的中间数据文件，理论上都能通过 Filebeat 采集特征存入 Elasticsearch 进行后续分析。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuring-ingest-node.html#configuring-ingest-node">Filebeat Reference | Parse data by using ingest node</a></li>
<li><a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/main/patterns/legacy/grok-patterns">logstash-plugins/grok-patterns</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/packetbeat/current/packetbeat-overview.html">Packetbeat Reference | Packetbeat overview</a></li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>探究 HTTP 协议</title>
    <url>/2017/12/25/%E6%8E%A2%E7%A9%B6HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>本文摘自油条的知乎文章 <a href="https://zhuanlan.zhihu.com/p/23957087">摸索HTTP</a>，自己结合实验一步一步探究HTTP协议</p>
</blockquote>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><ul>
<li>OS: MacOS或Linux各发行版</li>
<li><code>curl</code>、<code>nc</code>命令</li>
<li>多台电脑，最好是有自己的服务器</li>
</ul>
<h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><blockquote>
<p><strong>nc</strong>(or <strong>netcat</strong>)命令用于建立TCP和UDP监听和连接，它可以建立TCP连接、发送UDP包、监听任意TCP和UDP端口、端口扫描和处理IPv4和IPv6等。它比<strong>telnet</strong>命令更加实用，在网络工具中有“瑞士军刀”的美誉。</p>
</blockquote>
<ul>
<li><p>打开两个终端。一个充当客户端，一个充当服务端。</p>
</li>
<li><p>让服务端<code>nc</code>启动之后监听8000端口，等待TCP连接</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -l 8000 //server</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到客户端，如果是不同的机器则将<code>localhost</code>换成服务端主机的<strong>IP</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc localhost 8000 //client</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在在任意一个终端中输入些字符，敲击回车，另一个终端会显示相应字符，说明双方已经成功建立TCP连接进行通信，需要注意的是一定要服务端先建立监听</p>
</li>
</ul>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul>
<li><p>可以直接用<code>nc</code>命令来传输文件</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -l &#123;port&#125; &gt; filename // 接收端</span><br><span class="line">nc &#123;接受者IP&#125; &#123;port&#125; &lt; filename // 发送端</span><br></pre></td></tr></table></figure>
</li>
<li><p>亲测这条命令非常实用，适用于在你的本地和服务器未建立<strong>ssh认证</strong>时（不能使用<strong>scp</strong>），或内网网络传输文件，或你的两台电脑不能登陆同一微信传输文件时</p>
</li>
</ul>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><blockquote>
<p>浏览器在访问网站的时候，服务器到底给浏览器回复了一些什么玩意儿呢？有了上面的工具，接下来该探究一下HTTP了，到这里才正式开始切入正题了。首先，使用一下<strong>curl</strong>。<strong>curl</strong>能够向指定的URL发起一个http请求，并显示出请求回应中的内容。</p>
</blockquote>
<ul>
<li><p>先拿百度开刀，执行如下命令</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -i baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到如下输出内容</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 25 Dec 2017 03:19:21 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">ETag: &quot;51-47cf7e6ee8400&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 81</span><br><span class="line">Cache-Control: max-age=86400</span><br><span class="line">Expires: Tue, 26 Dec 2017 03:19:21 GMT</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>  这里，你所看到的这一大堆数据，便是一个完整的HTTP响应报文。也就是你在浏览器中输入网址 baidu.com 敲下回车之后，baidu服务器返回给浏览器的数据。</p>
</li>
<li><p><strong>响应报文</strong>包含如下部分：</p>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>响应正文（可能没有）</li>
</ul>
<p>  <img src="/0.png" alt="----"></p>
</li>
</ul>
<h3 id="解析响应报文"><a href="#解析响应报文" class="headerlink" title="解析响应报文"></a>解析响应报文</h3><blockquote>
<p>了解HTTP响应的格式，以及其中的各部分字段的含义，有助于我们理解一些Web应用的功能以及浏览器的行为。</p>
</blockquote>
<ul>
<li><p>这里对HTTP响应的数据稍作分析。上述报文中的第一行：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>  为HTTP响应的状态，这里的200代表OK，表示服务器已经成功地处理了请求</p>
</li>
<li><p>报文往后的内容直到空行部分：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date: Fri, 25 Nov 2016 10:58:59 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">ETag: &quot;51-47cf7e6ee8400&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 81</span><br><span class="line">Cache-Control: max-age=86400</span><br><span class="line">Expires: Sat, 26 Nov 2016 10:58:59 GMT</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>
<p>  这部分为HTTP响应的头部，其中大部分内容其实是可读性较强的，基本可以直接分析其中的含义。如<code>Content-Type: text/html</code>表示此次HTTP响应的结果为html文本。如果你访问的是一个图片，那么这里就可能是<code>Content-Type: image/png</code>了。头部中的<code>Content-Length: 81</code>表示整个响应的正文长度为81，这个也比较关键，告诉浏览器整个响应的正文部分数据有多少</p>
</li>
<li><p>HTTP响应的头部中有许多非常有用的信息，这些信息往往决定着浏览器收到报文后接下来需要做出什么样的行动。也有一些非必须的内容，比如<strong>Server、Accept-Ranges</strong></p>
</li>
<li><p>响应中的最后一部分内容，可以看到接下来页面刷新跳转到<code>http://www.baidu.com/</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>  为响应的正文部分，这部分内容的长度是和响应头部的<strong>Content-Length</strong>对应值一致。</p>
</li>
</ul>
<h4 id="Verify-Content-Length"><a href="#Verify-Content-Length" class="headerlink" title="Verify Content Length"></a>Verify Content Length</h4><blockquote>
<p>我们来验证正文长度是不是81。能用编程解决的就用编程解决，非常推荐平时用<strong>python</strong>或者<strong>JavaScript</strong>这种脚本语言去编程验证一些东西。只需要装个<strong>node</strong>或者<strong>python</strong>解释器就可以了，非常轻量级</p>
</blockquote>
<ul>
<li><p>这里用javascript，文件名a.js</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.length);</span><br></pre></td></tr></table></figure>
<p>  其中<code>`</code>反引号是ES6的新特性，可方便表示多行字符串。注意最后一行有回车</p>
</li>
<li><p>执行<code>node a.js</code>得到输出81</p>
</li>
</ul>
<h3 id="模拟HTTP响应"><a href="#模拟HTTP响应" class="headerlink" title="模拟HTTP响应"></a>模拟HTTP响应</h3><blockquote>
<p>上面大致了解了HTTP响应的大体结构，那么，我们来自己构造一个合法的HTTP响应，看看浏览器能不能做出正常的反应。</p>
</blockquote>
<ul>
<li><p><code>nc -l 8000</code>开启一个服务端，监听8000端口，粘贴如下内容</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 14</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Hello&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在浏览器端访问<code>http://localhost:8000/</code>，里面出现了一个大标题Hello</p>
</li>
<li><p>其实，浏览器在发起一个请求之后，只要服务器回应它一个符合HTTP标准的报文，它就能正常地解析并做出处理。而无论浏览器访问的对方是真的Web服务器还是假的nc，浏览器并不能知道它访问的目标到底是个什么东西，它只知道按照HTTP规范去解析收到的数据。这里可以看到，在网络中骗过浏览器是非常容易的，如传输的数据是未加密的，在这些传输的过程中很有可能会被拦截甚至篡改，浏览器被欺骗，进而用户被欺骗</p>
</li>
</ul>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><blockquote>
<p>在使用浏览器访问网站的时候，浏览器到底发送了一些什么东西过去呢？</p>
</blockquote>
<ul>
<li><p>其实我们就已经可以在终端里看到浏览器发送的请求报文</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: localhost:8000</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">Cookie: Webstorm-f269b48=ebcfcf96-de94-4438-acc1-f68e40c6b6f1; session=eyJ1aWQiOjJ9.DR6wAg.ktPekLF--XP9XrDZlpbeT8J0XDE</span><br></pre></td></tr></table></figure></li>
<li><p><strong>请求报文</strong>包含如下部分：</p>
<ul>
<li>请求行</li>
<li>请求头</li>
<li>请求体（可能没有）</li>
</ul>
<p>  <img src="/1.png" alt="-----2"></p>
</li>
</ul>
<ul>
<li><p>第一行为<strong>请求行</strong>，包含请求方法、请求路径和HTTP协议的版本三个信息。<strong>请求头</strong>通知服务器有关客户端请求的信息，比如上述头部中的<strong>User-Agent</strong>的值代表了浏览器信息，借助于此还可以做到根据不同的浏览器返回不同的页面（比如手机和PC的页面不一样）。最后多一行<strong>回车换行</strong>代表请求头的结束</p>
</li>
<li><p><strong>GET请求</strong>没有请求体，请求参数和对应的值附加在URL后面，利用问号<code>?</code>代表URL的结尾与请求参数的开始，与号<code>&amp;</code>连接多个参数。传递参数<strong>长度受限</strong>，并且可以在地址栏清楚的看到，不适合传输私密数据及大量数据</p>
</li>
<li><p>而在填写登陆表单点击确认后一般都是发送<strong>POST请求</strong>，请求数据在请求体中，不会显示的展示在地址栏，但是还是可能被黑客获取，所以通常密码等敏感信息需要加密而不是明文传输</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /user/login HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.98 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, sdch, br</span><br><span class="line">Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2</span><br><span class="line">Content-Length: 27</span><br><span class="line"></span><br><span class="line">username=test&amp;password=test</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="模拟HTTP请求"><a href="#模拟HTTP请求" class="headerlink" title="模拟HTTP请求"></a>模拟HTTP请求</h3><ul>
<li><p>同样可以使用<code>nc</code>构造一个HTTP请求，<code>nc baidu.com 80</code>与百度服务器建立连接</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造一个最精简的请求，敲击回车，终端上打印出响应报文</p>
</li>
</ul>
<h2 id="Postscripts"><a href="#Postscripts" class="headerlink" title="Postscripts"></a>Postscripts</h2><blockquote>
<p>实际上，按照前面的演示，在网络中，每一个应用都没法知道对面到底是个什么东西，只要双方相互收发的数据符合一定的格式和规则，它们之间就能够相互配合好工作。那么这些格式和规则，就时平时所谓的“协议”。</p>
</blockquote>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 SSR 科学上网</title>
    <url>/2019/04/10/%E6%90%AD%E5%BB%BA-SSR-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    <content><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本教程也是由于本人平时工作学习有 Google 的需求，所以就自己搭了一个梯子，并记录了搭建的过程方便以后重搭。大家搭建后小规模使用就好了，这样网速较快且不容易被封。<strong>特此申明：严禁用于商业用途！</strong></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li><strong>VPS 服务器</strong>，需要选择国外的，推荐 <a href="https://www.vultr.com/">Vultr</a>，速度不错、稳定且性价比高，按小时计费，能够随时开通和删除服务器。<strong>操作系统选择 CentOS 6</strong>，为了更换内核方便不宜选择版本过高的操作系统。</li>
<li>MacOS 自带的 Terminal，或者 Windows 的 XShell。用于 ssh 连接远程服务器并执行命令。</li>
<li><strong>ShadowsocksR 客户端</strong>，简称 SSR，是 Shadowsocks 的增强版，在其基础上增加了一些数据混淆方式。SSR 下载地址：<a href="https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases">Mac 版</a>，<a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases">Windows 版</a>。</li>
</ul>
<h2 id="部署SSR服务端"><a href="#部署SSR服务端" class="headerlink" title="部署SSR服务端"></a>部署SSR服务端</h2><p>执行 <code>ssh root@&#123;IP&#125;</code> 连接上 VPS 服务器，并安装 SSR 服务端一件部署脚本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure>

<p>等待下载完成后出现如下界面，按照提示一步步进行配置</p>
<p><img src="/2019/04/10/%E6%90%AD%E5%BB%BA-SSR-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/0.png" alt="6e65c95d5ad590eec8be684361594373.png"></p>
<p>依次会配置：</p>
<ol>
<li>端口和密码（端口建议设置 1000 ～ 65535 之间）</li>
<li>加密方式（随意）</li>
<li>协议插件（随意）</li>
<li>是否兼容原版 SS 客户端（即兼容没有协议和混淆的客户端，建议选 N）</li>
<li>每个端口的连接设备数限制、速度限制（auth_* 系列协议，并且不兼容原版时才有效）</li>
</ol>
<p>配置完成后等待部署完成，终端会打印配置信息，这些就是需要在 SSR 客户端填入的配置。现在可以直接进入下一个章节：配置SSR客户端。</p>
<p><img src="/2019/04/10/%E6%90%AD%E5%BB%BA-SSR-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.jpeg" alt="6a90ecf445798cb2c69a8bc05abd0a0a.png"></p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>默认情况下部署的是单端口模式，即多人共享一个端口。可以切换为多端口模式，一个用户一个端口，方便管理。直接执行 <code>bash ssr.sh</code> 键入 9 即可。</p>
<p>此外，键入 7 你可以随时修改 SSR 服务端的配置，以及在多端口模式下添加新用户，为他们分配新的端口号和密码。</p>
<p><img src="/2019/04/10/%E6%90%AD%E5%BB%BA-SSR-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.jpeg" alt="17f12e5ebc74a4105bacbeb69662a1f0.png"></p>
<h2 id="配置SSR客户端"><a href="#配置SSR客户端" class="headerlink" title="配置SSR客户端"></a>配置SSR客户端</h2><p>打开 SSR 客户端，按照服务端的配置填入对应配置。</p>
<p><img src="/2019/04/10/%E6%90%AD%E5%BB%BA-SSR-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/3.png" alt="7a34639c35446ec3808356b7eef07dc4.png"></p>
<p>至此就可以 Google 了，但网速较慢，可以使用锐速进行加速。锐速也有一键部署脚本，加速后对速度的提升很明显，所以推荐部署加速脚本。该加速方法是开机自动启动，部署一次就可以了。</p>
<h2 id="锐速加速"><a href="#锐速加速" class="headerlink" title="锐速加速"></a>锐速加速</h2><h3 id="更换操作系统内核"><a href="#更换操作系统内核" class="headerlink" title="更换操作系统内核"></a>更换操作系统内核</h3><p>安装锐速前需要先更换操作系统内核，下载更换内核脚本并执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://blog.asuhu.com/sh/ruisu.sh &amp;&amp; bash ruisu.sh</span><br></pre></td></tr></table></figure>

<p>成功替换内核后服务器会自动重启。等待重启完成后，重连服务器。</p>
<h3 id="一键安装锐速"><a href="#一键安装锐速" class="headerlink" title="一键安装锐速"></a>一键安装锐速</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh</span><br></pre></td></tr></table></figure>

<p>等待安装完成后即可体验飞一般的上网速度。</p>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>Vultr 提供方便快捷的快照 Snapshot 功能用于备份服务器。为防止服务器 IP 被封，我们可以备份服务器，方便将来重新部署。</p>
<p>在 Vultr 用户界面的 Servers 中添加快照，快照创建需要一点时间</p>
<p><img src="/2019/04/10/%E6%90%AD%E5%BB%BA-SSR-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/4.png" alt="1d8690c7a6d4d85711e11f2485996ba8.png"></p>
<p>将来在 Deploy new instance 新建实例时，服务器类型选择快照即可</p>
<p><img src="/2019/04/10/%E6%90%AD%E5%BB%BA-SSR-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/5.png" alt="1c652a6a3177df0e85958f81faa58043.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B">自建ss服务器教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
  </entry>
  <entry>
    <title>服务器安全设置</title>
    <url>/2017/11/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>在上个月月底的时候，阿里云通知我服务器在美国被异地登陆了，今天有时间整理了一些关于服务器安全的设置。</p>
</blockquote>
<h2 id="Locate-the-Matter"><a href="#Locate-the-Matter" class="headerlink" title="Locate the Matter"></a>Locate the Matter</h2><ul>
<li><p>当时我正好在用服务器，感觉异常的卡，用<code>htop</code>监控程序查看发现cpu正在被两个一样的进程100%占用，Command是<code>/usr/sbin/ApacheX</code>，去目录下找了下，没有该脚本，网上搜了也没该进程的信息。现在看来应该是黑客伪造的</p>
</li>
<li><p>查看日志，<code>vi /var/log/auth.log</code>，发现下面几行<br><img src="/0.png" alt="-----2017-10-31---11.24.57-1"></p>
</li>
<li><p>很奇怪，我平时都是用ssh连接服务器的，正常应该是这样的<br><img src="/1.png" alt="-----2017-11-08---11.12.08"></p>
</li>
<li><p>居然被人用密码登录了，一查IP，果然是美国的。当初测试切换用户时嫌麻烦修改了密码，直接用的root，被人试出来了。</p>
</li>
</ul>
<h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><ul>
<li><p>执行<code>passwd</code>修改密码，不加参数默认当前用户，加参数指定用户</p>
</li>
<li><p>修改ssh配置文件<strong>sshd_config</strong>，友情提示修改配置时开启多个窗口，以免登不上去还能用别的窗口修改回来</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>  <a href="http://blog.csdn.net/chenvast/article/details/72621086">SSHD配置文件详解</a></p>
</li>
<li><p>修改ssh端口，为防止黑客暴力破解22端口</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Port xxx</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ol>
<li>现在你需要使用<code>ssh &#123;user&#125;@&#123;IP&#125; -p &#123;port&#125;</code>来登录你的服务器。如果觉得麻烦，可以<code>!ssh</code>执行上一次的ssh命令，或者<code>history | grep ssh</code>粘贴命令。</li>
<li>传输文件时使用<code>scp -P &#123;port&#125;</code>来指定端口。<strong>scp</strong>(secure copy)通过ssh端口就行加密传输。</li>
<li><strong>ssh_config</strong>是针对客户端的配置文件，<strong>sshd_config</strong>是针对服务器端的配置文件，服务器后台运行的也是<strong>sshd</strong>守护进程(Daemon)。</li>
</ol>
<ul>
<li><p>启用ssh密钥认证，指定密钥存放路径</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSAAuthentication    yes</span><br><span class="line">PubkeyAuthentication    yes</span><br><span class="line">AuthorizedKeysFile    /root/.ssh/authorized_keys /home/s1mple/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li>
<li><p>禁用密码登录，只允许ssh登录</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PasswordAuthentication no</span><br><span class="line">UseLogin no</span><br><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure></li>
<li><p>另外，阿里云的服务器在你终端一段时间没有指令输入会断开，可以这样避免</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClientAliveInterval  30</span><br></pre></td></tr></table></figure>
<p>  每30s发送一个心跳包</p>
</li>
<li><p>修改完成后<code>service sshd restart</code>使配置生效</p>
</li>
</ul>
<h2 id="About-SSH"><a href="#About-SSH" class="headerlink" title="About SSH"></a>About SSH</h2><blockquote>
<p><strong>SSH</strong>(Secure Shell)协议，专为远程登录会话提供安全性的协议，传输的数据都进行了加密。SSH提供两种级别的安全验证，第一种是<strong>基于口令</strong>的安全验证。第二种是<strong>基于密匙</strong>的安全验证，较之第一种不需要传输口令，但速度稍慢一些。</p>
</blockquote>
<h4 id="基于密钥的安全验证"><a href="#基于密钥的安全验证" class="headerlink" title="基于密钥的安全验证"></a>基于密钥的安全验证</h4><blockquote>
<p>客户端创建<strong>一对密钥</strong>，公钥存放在服务器上，当你想通过ssh远程连接服务器时进行<strong>公钥比对</strong>。如果一致，服务器就用公用密匙加密“质询”(challenge)并把它发送给客户端。客户端收到“质询”之后就可以用你的<strong>私钥解密</strong>再把它发送给服务器。<br>这个配对密钥类似<strong>Https</strong>协议中的对称密钥。是基于<a href="https://zh.wikipedia.org/wiki/RSA%E7%AE%97%E6%B3%95">RSA算法</a>的。</p>
</blockquote>
<ul>
<li><p>在本地执行<code>ssh-keygen</code>生成配对密钥，在你的<code>~/.ssh</code>目录下会生成两个文件，<code>id_rsa</code>私钥，<code>id_rsa.pub</code>公钥。</p>
</li>
<li><p>将公钥拷贝到服务器的<code>~/.ssh/authorized_keys</code>文件中</p>
</li>
<li><p>给<code>authorized_keys</code>增加不可修改、删除的权限</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chattr +i authorized_keys</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 Git 和 Maven 私服</title>
    <url>/2017/11/21/%E6%90%AD%E5%BB%BAGit%E5%92%8CMaven%E7%A7%81%E6%9C%8D/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>应公司需求，搭建Git和Maven的企业私服，Maven私服使用Nexus搭建。</p>
</blockquote>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><ul>
<li>一台服务器，4核8G、1TB硬盘，Ubuntu 16.04</li>
<li>apache-maven-3.5.2-bin.tar.gz</li>
<li>nexus-3.6.1-02-unix.tar.gz，<a href="https://www.sonatype.com/download-oss-sonatype">官网下载</a></li>
<li>jdk-8u151-linux-x64.tar.gz</li>
</ul>
<h2 id="搭建Git"><a href="#搭建Git" class="headerlink" title="搭建Git"></a>搭建Git</h2><ul>
<li><p>安装Git，<code>git --version</code>查看版本</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></li>
<li><p>创建git用户，该命令会创建git组、git用户，并设置<code>/home/git</code>为用户目录</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adduser git</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了安全，禁止git用户bash登录，<code>vi /etc/passwd</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure>
<p>  修改为</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><blockquote>
<p><strong>git-shell :</strong> 提供了受限的git访问，只允许<strong>push/pull</strong>命令，官网解释：<br>This is a login shell for SSH accounts to provide restricted Git access. It permits execution only of server-side Git commands implementing the pull/push functionality, plus custom commands present in a subdirectory named git-shell-commands in the user’s home directory.</p>
</blockquote>
<h2 id="测试Git"><a href="#测试Git" class="headerlink" title="测试Git"></a>测试Git</h2><ul>
<li><p>在<code>/opt</code>创建文件夹，<code>mkdir git-repo</code>，并<code>cd</code>进去</p>
</li>
<li><p>初始化一个Git仓库，在当前目录下生成了一个空的Git仓库，包含了一些初始文件</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init --bare helloworld.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改权限</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R git:git helloworld.git </span><br></pre></td></tr></table></figure>
</li>
<li><p>将用户的ssh公钥加入到<code>/home/git/.ssh/authorized_keys</code>中，并重启sshd服务</p>
</li>
<li><p>在<strong>本地机器</strong>上将其<strong>clone</strong>下来</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@&#123;IP&#125;:/opt/git-repo/helloworld.git</span><br></pre></td></tr></table></figure>
<p>  会发现当前目录下多了个名为helloworld的文件夹</p>
</li>
<li><p>现在我们添加一个文件，测试将其push到服务器上</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch abc.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="搭建Maven私服"><a href="#搭建Maven私服" class="headerlink" title="搭建Maven私服"></a>搭建Maven私服</h2><blockquote>
<p>Nexus是目前Sonatype公司开发的搭建Maven企业级私服的工具，有付费版本<strong>Pro</strong>和开源版本<strong>OSS</strong> (Open Source Software)</p>
</blockquote>
<ul>
<li><p>上传jdk、maven和nexus的tar包并解压改名，如下</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@git-maven:/opt# ls</span><br><span class="line">git-repo  jdk  maven  nexus sonatype-work</span><br></pre></td></tr></table></figure>
<p>  其中<code>sonatype-work</code>文件夹用于存放私服的配置，日志文件和依赖包</p>
</li>
<li><p>修改环境变量，<code>vi /etc/profile</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># maven</span><br><span class="line">export M3_HOME=/opt/maven</span><br><span class="line">export PATH=$M3_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"># jdk</span><br><span class="line">export JAVA_HOME=/opt/jdk</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line"></span><br><span class="line"># nexus</span><br><span class="line">export PATH=/opt/nexus/bin:$PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>使环境变量生效，<code>source /etc/profile</code>，现在可以执行<code>nexus</code>命令查看它的一些操作，如下</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: nexus &#123; console | start | stop | restart | status | dump &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nexus不建议使用root用户启动，所以我们新建nexus用户，<code>adduser nexus</code>。<strong>注意</strong>，关于nexus的操作最好都在nexus用户下执行</p>
</li>
<li><p>切换到nexus用户，<code>su - nexus</code>，启动nexus</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nexus start</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果已正常启动，访问<code>&#123;IP&#125;:8081</code>即可前往控制台，8081为nexus默认端口，默认用户名admin，密码admin123，可在控制台中修改密码<br><img src="/0.png" alt="-----2017-11-22---4.40.57"></p>
</li>
</ul>
<h4 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h4><blockquote>
<p>其中<strong>maven-public</strong>是一个组，包含了<strong>maven-central</strong>(代理中央仓库，存放依赖构件)、<strong>maven-releases</strong>(存放发行版本)、<strong>maven-snapshots</strong>(存放快照版本)。</p>
</blockquote>
<h2 id="导入依赖包"><a href="#导入依赖包" class="headerlink" title="导入依赖包"></a>导入依赖包</h2><ul>
<li><a href="http://mvnrepository.com/">Maven中央仓库网址</a></li>
</ul>
<blockquote>
<p>现在已经成功部署了Nexus。可以通过配置你的项目，使其从你的私服上拉取依赖包，如果拉取不到，它会到Maven中央仓库拉取依赖并保存在服务器上</p>
</blockquote>
<ul>
<li><p>新建Maven项目，修改<code>pom.xml</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;nexus&lt;/id&gt;</span><br><span class="line">        &lt;name&gt;nexus&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;http://&#123;IP&#125;:8081/repository/maven-public/&lt;/url&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>&lt;dependencies&gt;</code>中添加你需要的依赖，执行<code>mvn package</code>打包项目即可</p>
</li>
<li><p>控制台上查看服务器上已经存储的依赖包<br><img src="/1.png" alt="-----2017-11-22---4.41.17"></p>
</li>
</ul>
<h2 id="搭建GitLab"><a href="#搭建GitLab" class="headerlink" title="搭建GitLab"></a>搭建GitLab</h2><ul>
<li><a href="https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/">清华大学开源软件镜像站</a></li>
</ul>
<blockquote>
<p>有空搭了个Gitlab，可以方便管理项目和成员公钥。但是运行GitLab对服务器内存的要求较高。官网明确要求内存至少4G</p>
</blockquote>
<ul>
<li><p>信任GitLab的GPG公钥</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加清华的镜像源，<code>touch /etc/apt/sources.list.d/gitlab-ce.list</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu xenial main</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装gitlab-ce</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gitlab-ce</span><br></pre></td></tr></table></figure></li>
<li><p>修改GitLab的Url，<code>vi /etc/gitlab/gitlab.rb</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">external_url &#x27;http://&#123;domain or IP&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>启动GitLab</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>访问你的Url进行注册登录即可，可以创建Groups、Projects，并添加你的SSH公钥。另外修改root用户密码参考文章：<a href="http://blog.csdn.net/yin138/article/details/51394868">http://blog.csdn.net/yin138/article/details/51394868</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习在网络安全中的应用 —— Chapter 1: Basics of Machine Learning in Cybersecurity</title>
    <url>/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文翻译并总结归纳自 <em><strong>Hands-On Machine Learning for Cybersecurity</strong></em> 书中的 Chapter 1: Basics of Machine Learning in Cybersecurity。该书主要着眼于机器学习在网络安全领域中的应用，介绍了多个方向的原理和解决方案，比如：包时间序列分析、垃圾邮件检测、使用 k-means 算法的网络异常检测等。总的来说，该书的动手操作很多，实战性很强。接下来我会用一个系列，整理归纳书中的各个章节。当然，除了第一章是介绍机器学习的概览之外，其他几个章节内容比较离散，所以顺序可能打乱。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自诞生以来，机器学习（Machine Learning）一直是一个非常热门的话题，它的出现实实在在地解决了很多问题，比如人脸识别、自动驾驶、购物推荐系统、聊天机器人等。</p>
<p>而在安全领域方面，老式的威胁检测系统通过使用启发式的和静态的签名（signature）来检测威胁和异常。例如：杀毒软件会根据病毒程序的特征，生成并维持一个病毒的签名库（保持持续更新），在查杀时通过与库中的签名比对来识别病毒程序。基于签名的威胁检测技术虽然容易理解，但并不健壮，它的最大的问题之一是：在数据规模、数据流速显著增大时，如何保证签名比对过程与数据流入速度匹配。每个包需要与数据库中的每个签名比对，如果不能保持同步，那意味着只能抛弃部分数据包，由此就会产生“漏网之鱼”。</p>
<p>如今，基于签名的系统逐渐被智能网络安全代理（Intelligent cybersecurity agent）所取代。机器学习在识别新型恶意软件、零日漏洞攻击（zero-day attack）、高级可持续威胁（advanced persistent threats，简称 APT）方面取得积极进展。</p>
<p>一般来说，由于攻击的复杂特性，要做到完全预防是很难的，机器学习能做到在攻击的初期识别攻击并防止其扩散到整个系统。许多网络安全公司使用诸如用户行为分析（user behavior analytics）和预测分析（predictive analytics）的高级分析方法，在威胁生命周期的早期阶段识别 APT 攻击，这种方式能够有效预防身份数据泄漏和内部威胁。规范分析（prescriptive analytics）则更具有响应性，能够在网络攻击发生以后分析该采取什么响应措施能将损失降到最小。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/1.png" alt="48e9cf0bd45e3630c4346d142839c8a1.png"></p>
<h2 id="机器学习中的数据"><a href="#机器学习中的数据" class="headerlink" title="机器学习中的数据"></a>机器学习中的数据</h2><p>数据是机器学习的核心。数据分为结构化数据和非结构化数据，<strong>结构化数据（structured data）</strong>可以被映射为二维表结构，包含表头（Header）和表内元素，传统的关系型数据库（RDBMS）如 MySQL、Oracle 等都是以这种方式存放结构化数据；而<strong>非结构化数据（unstructured data）</strong>数据结构不规则或不完整，没有预定义的数据模型，例如图片、音频/视频等；融合了结构化和非结构化的数据称为<strong>半结构化数据（semi-structured data）</strong>。</p>
<p>根据数据是否被打上标记，数据又被分为<strong>有标注数据（labelled data）</strong>和<strong>无标注数据（unlabelled data）</strong>。例如网络安全中的恶意流量检测，可以将样本中的善意流量（white）和恶意流量（black）手动打标（恶意流量可能是自己模拟生成的），构成训练集训练机器学习模型。</p>
<h3 id="机器学习阶段"><a href="#机器学习阶段" class="headerlink" title="机器学习阶段"></a>机器学习阶段</h3><p>机器学习分为以下四个阶段：</p>
<ul>
<li><strong>分析阶段（The analysis phase）</strong>：在这个阶段，采集到的数据需要被提取明确的<strong>特征（features）</strong>或者参数（parameters），来被用于训练模型。</li>
<li><strong>训练阶段（The training phase）</strong>： 前一阶段的数据将被用来在这个阶段训练机器学习模型（machine learning model），训练阶段是一个<strong>多次迭代</strong>的阶段，目的是为了训练一个更加可信的模型。</li>
<li><strong>测试阶段（The testing phase）</strong>： 在这一阶段，训练阶段产生的机器学习模型将结合更多的数据进行测试并<strong>评估模型</strong>的性能。测试的数据是前面阶段从未被使用的数据。模型的<strong>演化</strong>可能会需要参数训练（调参）。</li>
<li><strong>应用阶段（The application phase）</strong> ：模型被部署到<strong>生产环境</strong>，应用于真实数据。</li>
</ul>
<h3 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h3><p>在训练阶段，由于样本数据的不完备，训练出的机器学习模型可能并不理想（模型的泛化能力不佳），会产生两种现象：过拟合和欠拟合。</p>
<p><strong>过拟合（Overfitting）</strong>，是指系统太过适应于（fit）或者说太过依赖于训练集数据，导致新来的数据都视为不匹配，通常表现为：模型对于训练集表现很好，对于测试集表现很差（容纳度很低）。产生这种现象的常见原因之一是只使用了有标注的数据来训练模型。</p>
<blockquote>
<p>Overfitting: The production of an analysis that corresponds too closely or exactly to a particular set of data, and may therefore fail to fit additional data or predict future observations reliably. – Oxford Dictionary</p>
</blockquote>
<p><strong>欠拟合（Underfitting）</strong>，是模型表现差的另一种场景，通常是由于样本数量较少，模型训练依赖特征过少，学习能力低下造成的。</p>
<p>对于这两种情形，可以通过一些机器学习的常见步骤来消除，比如：数据的交叉验证（cross validation of the data），数据修剪（data pruning）和数据正则化（regularization of the data）。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/2.png" alt="0574cd5346226da66890df7956671e62.png"></p>
<p>由上图可以看到，当模型层级较低时（模型过于简单），表现为欠拟合，训练集和测试集效果都不好；当模型层级较高时（模型过于复杂），表现为过拟合，训练集效果很好，但由于学习能力过于强大，以至于把训练样本所包含的不太一般的特性都学到了，导致测试集中表现很差。所以我们需要摸索出合适的模型，既不能太简单也不能太复杂，使得在测试集上能有最优表现。</p>
<h2 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h2><p>传统上，基于所提供的学习类型，机器学习系统大体上可以分为两类：有监督学习和无监督学习。强化学习和深度学习是后面引入的新的研究分支。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/3.png" alt="49c0d215820883fdc0aa834405891742.png"></p>
<h3 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h3><p>有监督学习（Supervised learning）是指使用已标注的数据集推导出预测函数，对测试集进行分类和预测。有监督学习包含一些子分支，比如：</p>
<ul>
<li><strong>半监督学习（Semi-supervised learning）</strong>：训练阶段的数据集即含有有标注的，也含有未标注的。</li>
<li><strong>主动学习（Active learning）</strong>：主动学习是指，通过查询函数，从未标注数据集中查询出信息熵最大（可以简单理解为最复杂）的数据，交给督导者进行标注，循环迭代这个过程直至模型达到最佳。主动学习的“主动”，指的是<strong>主动提出标注请求</strong>，为此需要一个外在的能够对其请求进行标注的实体（通常是相关领域人员）。<br><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/4.png" alt="e834d2167c02ba1908f13760cec58005.png"></li>
</ul>
<p>有监督学习的常见应用包括：人脸识别，需要人为标注新面孔；垃圾邮件检测，需要对邮件内容文本进行分词处理，所以需要提前对一些敏感词汇做人为标注。</p>
<h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>无监督学习算法（Unsupervised learning）是指初始数据集是未标注的，数据视图是在处理过程中由系统自学习构建出来的，没有任何外部干涉。如果说有监督学习是：老师提供对错指示，要求学生能够“对于输入数据X能判断对错”，那么无监督学习就是：在没有老师的情况下，学生自学，要求学生能够“<strong>从数据X中归纳总结出知识点</strong>”。无监督学习算法的具体应用案例包括：用户行为分析（User behavior analysis）、购物篮分析（Market basket analysis）等。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/5.png" alt="942767e754efb165eb261f9f9692bbc4.png"></p>
<h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>强化学习（Reinforcement learning）是机器学习的又一分支，它强调如何基于<strong>环境</strong>而行动，以取得最大化的<strong>预期利益</strong>。</p>
<p>具有强化学习能力的程序或机器人被称为<strong>代理（Agent）</strong>。代理所解决的问题被抽象为<strong>环境（Environment）</strong>，比如迷宫或者棋盘。代理需要有一个基本的<strong>策略（Policy）</strong>，每次迭代根据这个策略选择一个<strong>动作（Action）</strong>作用于环境，环境接受该动作后<strong>状态（State）</strong>发生变化，同时产生一个<strong>信号（Reward）</strong>，正代表奖励，负代表惩罚。代理会根据这个信号评估之前的策略是否适合。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/6.png" alt="25df06c2835f3b3d1e7e198431865384.png"></p>
<p>强化学习有一些实际的用例，比如自动驾驶汽车，需要对周围复杂环境作出实施迅速的应对；又比如家喻户晓的 AlphaGo，只需要训练4个小时就可以击败世界知名的象棋AI Stockfish。</p>
<h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>深度学习（Deep learning）是机器学习领域的一个新的研究分支，是一种以人工神经网络为架构，对资料进行表征学习的算法。深度学习并不简单的囊括于传统的有监督/无监督分类中，它本身也会用到有监督和无监督的学习方法来训练深度神经网络。</p>
<p>深度学习的出现，引领了机器学习的又一波热潮，它摧枯拉朽地解决了之前未解决的诸多问题，使得似乎所有的机器辅助功能都变为可能。但它作为目前最热的机器学习方法之一，并不意味着是机器学习的终点，它也具有诸多问题，比如：深度学习需要巨大的数据集做支撑；复杂度较高；深度学习的构想来源于人脑的神经元结构，但人脑的复杂程度要远远超出它所能模拟的范畴。</p>
<h2 id="机器学习解决的问题"><a href="#机器学习解决的问题" class="headerlink" title="机器学习解决的问题"></a>机器学习解决的问题</h2><p>机器学习可以用于解决以下几类问题：分类问题，集群问题，回归问题，降维问题，密度估算问题等等。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/7.png" alt="53aaf02095bd399d6b16dec0b2332dd7.png"></p>
<h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><p>分类问题（Classification problems）是指基于特征将数据划分到多个类（class）中的问题。因为训练数据是有标注的，所以分类问题属于有监督学习。网络数据分类是一个经典的分类问题，互联网的内容可以根据它们的文本内容比如新闻、社交媒体、广告等划分到它们对应的类别。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/8.png" alt="d50de17881f0da10019d30b5e4266bef.png"></p>
<h3 id="聚类问题"><a href="#聚类问题" class="headerlink" title="聚类问题"></a>聚类问题</h3><p>聚类问题（Clustering problems）是指将数据分成若干组并将相似数据归为一组。聚类技术常用语信息检索、模式识别、人口统计分析领域。相比于分类问题，聚类问题并不关心某一类是什么，只需要将相似的数据归为一类。因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了，也就是说训练集无需作出预先标注。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/9.png" alt="c118f41b872bc162fd0f3858d25ec368.png"></p>
<h3 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h3><p>回归问题（Regression problems）指的是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。例如对于图中的二元组数据（x，y），我们可以求出能表示 x，y 关系的线性回归方程，再对接下来的测试数据集进行预测或分类。</p>
<p>回归包括多种类型，比如：线性回归（linear regression），逻辑回归（logistic regression），多项式回归（polynomial regression）等。回归可以用于欺诈检测系统，股票市场分析和预测。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/10.png" alt="985428a8e920d31726d314abe4af73d0.png"></p>
<h3 id="降维问题"><a href="#降维问题" class="headerlink" title="降维问题"></a>降维问题</h3><p>现实应用中属性维数经常成千上万，且许多学习方法都涉及距离计算，而高维空间会给距离计算带来很大的麻烦，当维数很高时甚至连计算内积都不再容易。事实上，在高维情形下出现的数据样本稀疏、距离计算困难等问题，是所有机器学习方法共同面临的严重障碍，被称为“维数灾难”（curse of dimensionality）。</p>
<p>缓解维数灾难的一个重要途径是<strong>降维（Dimension reduction）</strong>，亦称“维数约简”，即通过某种数学变换将原始高维属性空间转变为一个低维“子空间”（subspace），在这个子空间中样本密度大幅提高，距离计算也变得更为容易。降维将含有多个属性的高维数据，用它的主要属性去表示，并且不丢失重要特征。  降维技术经常用于<strong>特征提取</strong>，比如网络包流数据的处理，为了减少数据规模，通常只提取具有代表性的有用特征进行分析。</p>
<p>下图给出了一个直观的例子，将原始三维空间中的样本点，映射到二维嵌入子空间中。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/11.jpg" alt="d127776fa637378ffec32cc993ce3c49.png"></p>
<h3 id="密度估算问题"><a href="#密度估算问题" class="headerlink" title="密度估算问题"></a>密度估算问题</h3><p>密度估算问题（Density estimation problems）是用于对密集数据进行机器学习估算的统计学习方法。从技术上讲，它是一种<strong>计算概率密度函数</strong>的技术。在医学分析领域，通常使用这种技术来在庞大的人口中识别疾病相关症状。</p>
<h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><p>支持向量机（Support Vector Machines，SVM）属于有监督的算法，被用于解决线性或非线性的分类问题（linear/non linear classification）。由于优秀的性能，SVM 得到了广泛的应用。</p>
<p>若输入数据所在的特征空间存在作为决策边界（decision boundary）的超平面将样本按正类和负类分开，实际上构造了2个平行的超平面作为间隔边界以判别样本的分类，所有在上间隔边界上方的样本属于正类，在下间隔边界下方的样本属于负类。两个间隔边界的距离被定义为边距（margin），位于间隔边界上的正类和负类样本为支持向量（support vector）。SVM 旨在求解能够划分样本的<strong>最大边距超平面（maximum-margin hyperplane）</strong>。</p>
<p>对于二维平面，超平面可以理解为可以划分样本的一条「直线」，对于高维特征空间，SVM 可以通过<strong>核方法（kernel method）</strong>进行非线性分类。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/12.png" alt="e44a093db94c73420e3f30d4455b09f1.png"></p>
<h3 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a>贝叶斯网络</h3><p>贝叶斯网（Bayesian network，简称 BN）亦称“信念网”（belief network），它借助有向无环图（Direct Acyclic Graph，简称 DAG）来刻画属性之间的依赖关系，并使条件概率表（Conditional Probability Table，简称 CPT）来描述属性的联合概率分布。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/13.jpg" alt="fe9d8ceefb48edd4636364d7b7e00a2a.png"></p>
<p>上图给出了西瓜问题的一种贝叶斯网结构和属性“根蒂”的条件概率表。从图中网络结构可看出，“色泽”直接依赖于“好瓜”和“甜度”，而“根蒂”则直接依赖于“甜度”；进一步从条件概率表能得到“根蒂”对“甜度”量化依赖关系，如 $P(根蒂=硬挺|甜度=高)=0.1$ 等。</p>
<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>决策树（decision tree）是一类常见的机器学习方法。以二分类任务为例，我们希望从给定训练数据集学得一个模型用以对新示例进行分类，这个把样本分类的任务，可看作对“当前样本属于正类吗？“这个问题的“决策”或“判定”过程。</p>
<p>顾名思义，决策树是基于树结构来进行决策的，这恰是人类在面临决策问题时一种很自然的处理机制。树中非叶子节点表示需要作出分类判断的属性，每个分支代表可能的属性值。下图给出了西瓜问题的一颗决策树。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/14.jpg" alt="babb7185999143d2f546dc0d7fc76680.png"></p>
<h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>首先我们介绍一下 <strong>Bagging</strong>。给定包含 m 个样本的数据集，我们先随机取出一个样本放入采样集中，再把该样本放回初始数据集，使得下次采样时该样本仍有可能被选中，这样，经过m次随机采样操作，我们得到含 m 个样本的采样集，初始训练集中有的样本在采样集里多次出现，有的则从未出现。</p>
<p>照这样，我们可采样出 T 个含 m 个训练样本的采样集，然后基于每个采样集训练出一个基学习器，再将这些基学习器进行结合。这就是 Bagging 的基本流程。在对预测输出进行结合时，Bagging 通常对分类任务使用简单投票法，对回归任务使用简单平均法。若分类预测时出现两个类收到同样票数的情形，则最简单的做法是随机选择一个，也可进一步考察学习器投票的置信度来确定最终胜者。</p>
<p>随机森林（Random Forest，简称 RF）是 Bagging 的一个扩展变体。RF 在以决策树为基学习器构建 Bagging 集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。具体来说，传统决策树在选择划分属性时是在当前结点的属性集合（假定有 d 个属性）中选择一个最优属性；而在 RF 中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含 k 个属性的子集，然后再从这个子集中选择一个最优属性用于划分。这样使得随机森林中的决策树都能够彼此不同，提升系统的多样性，从而提升分类性能。</p>
<p>随机森林简单、容易实现、计算开销小，令人惊奇的是，它在很多现实任务中展现出强大的性能，被誉为“代表集成学习技术水平的方法”。</p>
<h3 id="kNN"><a href="#kNN" class="headerlink" title="kNN"></a>kNN</h3><p>k近邻（k-Nearest Neighbor，简称 kNN）学习是一种常用的监督学习方法，其工作机制非常简单：给定测试样本，基于某种距离度量找出训练集中与其最靠近的 k 个训练样本，然后基于这 k 个“邻居”的信息来进行预测。通常，在分类任务中可使用“投票法”，即选择这 k 个样本中出现最多的类别标记作为预测结果；在回归任务中可使用“平均法，即将这 k 个样本的实值输出标记的平均值作为预测结果；还可基于距离远近进行加权平均或加权投票，距离越近的样本权重越大。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/15.jpg" alt="a5e05733ac1f4912ecc1bd1828535f57.png"></p>
<p>上图是一个k近邻分类器示意图。虚线为等距线，测试样本在 k=1 或 k=5 时被判别为正例，k=3 时被判别为反例。显然，k 是一个重要参数，当 k 取不同值时，分类结果会有显著不同。</p>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。</p>
<p>神经网络中最基本的成分是神经元（neuron）模型，即上述定义中的“简单单元”。在生物神经网络中，每个神经元与其他神经元相连，当它“兴奋”时，就会向相连的神经元发送化学物质，从而改变这些神经元内的电位；如果某神经元的电位超过一个“阈值”（threshold），那么它就会被激活，即“兴奋”起来，向其他神经元发送化学物质。</p>
<p>1943年，McMulloch 和 Pitts 将上述情形抽象为下图所示的简单模型，这就是一直沿用至今的“<strong>M-P神经元模型</strong>”。把许多个这样的神经元按一定的层次结构连接起来，就得到了神经网络。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/16.jpg" alt="5ba11eb4ebb4f8dddb0b8806dace6347.png"></p>
<p>在这个模型中，神经元接收到来自 n 个其他神经元传递过来的输入信号，这些输入信号通过带权重的连接（connection）进行传递，神经元接收到总输入将与神经元的阈值进行比较，然后通过“激活函数”（activation function）处理以产生神经元的输出。</p>
<h2 id="机器学习架构"><a href="#机器学习架构" class="headerlink" title="机器学习架构"></a>机器学习架构</h2><p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/17.png" alt="8b49f81f455bb0bb519c3659accc8f7d.png"></p>
<p>注入机器学习系统的数据可能来自不同的源，可以是实时的流数据，也可以是批处理数据或者无交互的定时任务数据。常见的数据源有 Amazon Kinesis、Apache Flume、Apache Kafka 等。注入的数据经过清洗和预处理后被存入数据储存库中，例如 SQL/NoSQL 数据库、数据仓库（data warehouse）、HDFS 分布式系统等等。</p>
<h3 id="模型引擎"><a href="#模型引擎" class="headerlink" title="模型引擎"></a>模型引擎</h3><ul>
<li><strong>数据准备（Data preparation）</strong>：数据准备阶段需要进行数据清洗（data cleansing），检查数据一致性和完整性，对数据进行规范化，对拆分的或是聚合的数据进行转换和重组。</li>
<li><strong>特征生成（Feature generation）</strong>：找到待分析数据的关键特征。特征可以来自原始数据或者聚合后的数据，不同特征通常都是相互独立的。特征提取的首要目标是降低数据维度和提高模型性能。</li>
<li><strong>模型训练（Model training）</strong>：机器学习模型分析数据间的关联，将数据分类到不同的组。为了获得最佳性能，需要对数据特征进行合适的采样。通常 70～80% 的数据会被用于训练阶段。</li>
<li><strong>模型测试（Model testing）</strong>：在测试阶段我们验证模型，模型的性能能够被测试并做出调节。交叉验证能够确定模型的性能。通常 20% 的数据会被用于测试阶段。</li>
</ul>
<h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h3><p>性能调节（Performance tuning）和错误检测（error detection）是机器学习系统最重要的迭代过程，能够帮助提升系统的性能。如果系统的泛化功能能够以较高的概率给出较低的<strong>泛化误差（generalization error）</strong>，我们称这个系统拥有最优性能。事实上这属于 PAC 理论的范畴。</p>
<p>泛化误差与分类的准确度，回归模型预测的精确度直接相关。为了计算泛化误差，我们给出一些评估指标：</p>
<h4 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h4><p>假设现在有一条回归曲线，我们想测量每个点到回归线的距离，而均方误差（Mean squared error，MSE）就能够统计这些偏移量。$P_i$ 为预测值，$A_i$ 为真实值，MSE 对每个点偏移量的平方和求平均：</p>
<p>$$ MSE = \frac{1}{n}\sum_{i=1}^n{(P_i - A_i)^2} $$</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/18.png" alt="d8c5be836a6aff5b4e312f9b7a4a7a8a.png"></p>
<h4 id="平均绝对误差"><a href="#平均绝对误差" class="headerlink" title="平均绝对误差"></a>平均绝对误差</h4><p>平均绝对误差（Mean absolute error，MAE) 计算每个点绝对误差的均值。MAE 是时间序列分析中的预测误差的一个常见指标。相比于 MSE，由于 MSE 使用了平方会放大误差，所以 MSE 对于异常数据更加敏感，而 MAE 对异常点有更好的鲁棒性（抗干扰能力更强），更适合用来做预测分析。但对于学习效率来说，误差较大时 MSE 收敛更快精度更高。</p>
<p>$$ MAE = \frac{1}{n}\sum_{i=1}^n{|P_i - A_i|} $$</p>
<h4 id="精确率、召回率、准确率"><a href="#精确率、召回率、准确率" class="headerlink" title="精确率、召回率、准确率"></a>精确率、召回率、准确率</h4><p>精确率、召回率和准确率是机器学习分类问题（classification problem）模型评估中常见的性能度量指标：</p>
<ul>
<li><strong>精确率（Precision）</strong>，又叫查准率，定义为：$Precision \triangleq \frac{TP}{TP+FP}$</li>
<li><strong>召回率（Recall）</strong>，又叫查全率，定义为：$Recall \triangleq \frac{TP}{TP+FN}$</li>
<li><strong>准确率（Accuracy）</strong>，定义为：$Accuracy \triangleq \frac{TP+TN}{TP+TN+FP+FN}$</li>
</ul>
<p>上述定义式中 T 代表 True，F 代表 False，T/F 表示预测是否正确；P 代表 Positive，N 代表 Negative，P/N 代表本身是正例还是反例。例如：恶意流量检测系统中，P 代表是恶意流量，那么 TP 就代表正确检测出恶意流量，FN 代表本身不是恶意流量却被错误地识别为恶意流量。</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/19.png" alt="385e4f3b305ced036ed00c0098a74855.png"></p>
<p>Precision 从预测结果角度出发，描述了<strong>预测出来的正例结果中有多少是真实正例</strong>，关心的是查出来的准不准；Recall 从真实结果角度出发，描述了<strong>测试集中的真实正例有多少被检测出来</strong>，关心的是查的全不全。Accuracy 则代表所有预测中正确预测所占的比例。</p>
<p>当正负样本分布严重不均匀时，仅仅靠准确率 Accuracy 去评估模型性能是不合适的。就拿恶意流量检测来说，假设恶意流量占总流量的 0.1%，那么考虑一个全部流量都 pass 的检测系统，它的准确率依然能达到 99.9%，但是一条恶意流量都没有检测出来，这显然是不合要求的。所以通常需要结合这三个指标对模型进行整体评估。</p>
<h3 id="性能改善"><a href="#性能改善" class="headerlink" title="性能改善"></a>性能改善</h3><p>那么如何提高模型的性能呢？通常可以通过：</p>
<ul>
<li><strong>改善数据质量</strong>：数据需要清洗、重采样以及规范化，特征提取步骤也可能需要重新审视，缺乏独立性的特征也会导致性能不佳。</li>
<li><strong>更换算法</strong>：模型的性能不佳也可能是因为没有选对合适的算法，在这种情况下，不同算法的基准测试可以帮助我们做出合适的选择。基准测试包括但不限于：K倍交叉验证。</li>
<li>**使用集成学习（Ensemble Learning)**：同时使用多种学习算法来获得比单独使用任何学习算法具有更好的性能。一些最复杂的人工智能系统就是这类集成的副产物。</li>
</ul>
<h2 id="机器学习扩展库"><a href="#机器学习扩展库" class="headerlink" title="机器学习扩展库"></a>机器学习扩展库</h2><p>Python 作为机器学习最常用语言，虽然不是最快的，但因为它的灵活性而被数据科学家们广泛接受。Python 为机器学习专家提供了一系列的工具和扩展库，常用到的有：</p>
<ul>
<li><strong>NumPy</strong>：是统计分析和机器学习方面的重要扩展库，提供了支持线性代数、傅立叶变换和其他数值分析的复杂函数库。</li>
<li><strong>SciPy</strong>：基于 NumPy 的科学计算库，可以处理插值、积分、优化、图像处理、常微分方程数值解的求解、信号处理等问题。</li>
<li><strong>Scikit-learn</strong>：简单高效的机器学习库，提供了解决分类、集群、回归等问题的机器学习算法模型，Scikit-learn 依赖于 NumPy 和 SciPy。</li>
<li><strong>pandas</strong>：非常强力的数据统计分析工具。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。能够很好的读写和呈现表格数据。</li>
<li><strong>Matplotlib</strong>：绘图工具，常常与 NumPy、SciPy 配合使用。</li>
</ul>
<p>下图是 Scikit-learn 在解决不同规模，不同类型问题时推荐使用的算法模型：</p>
<p><img src="/2020/10/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-Chapter-1-Basics-of-Machine-Learning-in-Cybersecurity/20.png" alt="92b3401d754315d494e32f9bab97e755.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Halder, S. &amp; Ozdemir, S. <em>Hands-On Machine Learning for Cybersecurity: Safeguard your system by making your machines intelligent using the Python ecosystem[M].</em> Packt Publishing Ltd, 2018.</li>
<li>周志华. 机器学习[M]. 清华大学出版社, 2016.</li>
</ul>
]]></content>
      <categories>
        <category>Translations</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>流处理框架介绍: Storm、Spark &amp; Flink</title>
    <url>/2020/11/23/%E6%B5%81%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-Storm%E3%80%81Flink-Spark/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>与传统的批处理（Batch processing）相比，流处理（Streaming processing）处理的是实时的持续数据流，也被称为无界数据集（unbounded datasets），亦即能够持续增长的、不可预测的无限数据集。而批处理处理的是有界数据集（bounded datasets），有界数据集是有限的不变的，存在开始和结束，也被称之为历史数据集（historic datasets）。</p>
<p>通常，为了应对高速流动的无界数据流，流处理对于处理效率要求更高，内存占用要求更低，与之相对的，相较批处理对于错误的容忍度要更高。</p>
<p>本文介绍了 Apache Storm、Apache Flink 和 Spark Streaming 三种常用流处理框架，主要包含它们各自的拓扑结构和运行时架构，最后还对流处理框架的演进和流批一体化的趋势做了简要介绍。</p>
<h2 id="Apache-Storm"><a href="#Apache-Storm" class="headerlink" title="Apache Storm"></a>Apache Storm</h2><p><a href="https://storm.apache.org/index.html">Apache Storm</a> 是一个分布式实时计算框架，主要使用 Clojure 和 Java 语言编写，目前最新版本 2.2.0。在 Storm 中，数据流被抽象为 tuples，由数据和 ID 标识符组成。Storm 的拓扑结构（Topology）是一个有向无环图，由<strong>输入节点Spouts</strong>、<strong>处理节点Bolts</strong>和<strong>代表数据流的边</strong>三部分组成，如下图所示：</p>
<p><img src="/2020/11/23/%E6%B5%81%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-Storm%E3%80%81Flink-Spark/1.png" alt="7f120eb6c1e92b4775e84d196100e3f5.png"></p>
<p>Spouts 是整个拓扑结构的入口点，负责将输入数据流转换为 tuples，送至 Bolts 进行处理；Bolts 负责处理输入流并转换为输出流，它维护了处理逻辑，能够对 tuples 执行过滤、映射、聚合等函数式操作，还能与数据库进行交互。</p>
<p>Storm 的运行时架构与 Hadoop 类似，也是经典的主从模式（master-slave）。Storm 中的主节点（master node）运行一个叫做 <strong>Nimbus</strong> 的程序，由其负责资源分配和任务调度，用户定义的 Topology 会被提交到 Nimbus 上；从节点（worker node）运行 <strong>Supervisor</strong> 程序，负责执行 Nimbus 分配的任务，其上可以运行一个或多个工作进程（worker process），每个工作进程执行 Topology 的一个子集。Nimbus 不能直接与 Supervisor 进行交互，两者需要通过 <strong>ZooKeeper</strong> 进行协作，ZooKeeper 保存调度信息、心跳信息、集群状态和配置信息。</p>
<p><img src="/2020/11/23/%E6%B5%81%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-Storm%E3%80%81Flink-Spark/2.png" alt="aa1882c89b70544081866ade75563064.png"></p>
<p>类似于 Hadoop 中的 MapReduce 架构，每个 Spouts 和 Bolts 也可以设置<strong>并行度</strong>（parallelism）。通过设置并行度可指定一个 Worker 运行多个 Executor，所以实际上 Executor 才是运行 Spouts 或者 Bolts 组件的最小单元。</p>
<p><strong>数据一致性</strong>方面，Storm 基于 ACK 确认机制，可以确保每个 Tuple 至少被执行一次（<strong>at-least-once</strong>）。但现如今 Storm 官方提供了一个在 Storm 之上的更高层级的抽象：<a href="http://storm.apache.org/releases/current/Trident-tutorial.html">Trident</a>，可以确保每个 Tuple 有且只有一次被执行（exactly-once），代价是增大了数据处理的延迟。Trident 的示例 API 如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TridentTopology topology = <span class="keyword">new</span> TridentTopology();        </span><br><span class="line">TridentState wordCounts =</span><br><span class="line">     topology.newStream(<span class="string">&quot;spout1&quot;</span>, spout)</span><br><span class="line">       .each(<span class="keyword">new</span> Fields(<span class="string">&quot;sentence&quot;</span>), <span class="keyword">new</span> Split(), <span class="keyword">new</span> Fields(<span class="string">&quot;word&quot;</span>))</span><br><span class="line">       .groupBy(<span class="keyword">new</span> Fields(<span class="string">&quot;word&quot;</span>))</span><br><span class="line">       .persistentAggregate(<span class="keyword">new</span> MemoryMapState.Factory(), <span class="keyword">new</span> Count(), <span class="keyword">new</span> Fields(<span class="string">&quot;count&quot;</span>))                </span><br><span class="line">       .parallelismHint(<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h2><p><a href="https://spark.apache.org/">Apache Spark</a> 于 2009 年诞生于加州大学伯克利分校，2013 年被捐献给 Apache 基金会。Spark 的初衷是改良 Hadoop 的 MapReduce 编程模型和执行速度，它提供了更加方便易用的接口，提供 Java、Scala、Python 和 R 四种语言的 API，支持 SQL、机器学习和图计算，覆盖了绝大多数大数据计算的场景。Spark 由 Java 和 Scala 编写，目前最新版本 3.0.1。</p>
<p>Spark Streaming 是 Spark 框架中的核心组件之一，提供流处理功能。但 Spark Streaming 并不支持严格意义的实时流处理，它按照预设的时间间隔将流数据累积，对这个时间间隔上的数据做批处理。所以实际上 Spark Streaming 是一种<strong>微批处理（micro-batch）</strong>框架。</p>
<p>Spark 提出了弹性分布式数据集 <strong>RDD</strong>（resilient distributed dataset）的概念，它是 Spark 中最基本的数据抽象，它代表一个不可变、只读的，被分区的数据集，你可以像操作本地集合一样操作 RDD。而在 RDD 之上，Spark Streaming 包装了称为离散流 <strong>DStream</strong>（discretized stream）的高级抽象，底层由一系列连续的 RDD 组成。</p>
<p><img src="/2020/11/23/%E6%B5%81%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-Storm%E3%80%81Flink-Spark/3.png" alt="557ca0d5fa2c990b57e8d1a8a625df02.png"></p>
<p>Spark 架构也是经典的 master-slave 架构。主节点上运行着 Driver，用户从客户端提交应用 Jar 包，首先会构建一个 Spark Application，并初始化程序入口 <strong>SparkContext</strong>（要运行 Spark Streaming 程序则是 StreamingContext），由 SparkContext 负责和资源管理器 Cluster Manager（可以是 Standalone，Mesos，YARN）进行通信以及资源的申请、任务的分配和监控等。</p>
<p>SparkContext 根据 RDD 之间的依赖关系构建 DAG 图，提交给 DAG 调度器 DAGScheduler 进行解析，DAGScheduler 将 DAG 图分解成多个阶段（stage），也就是任务子集（Taskset），再提交给底层的任务调度器 TaskScheduler ，最后由 Task Scheduler 将 Task 发送给 Executor 运行。</p>
<p><img src="/2020/11/23/%E6%B5%81%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-Storm%E3%80%81Flink-Spark/4.png" alt="f987224f95342713f69ee1a0bd428474.png"></p>
<p>数据一致性方面，Spark 采用了 Checkpoint 机制保证了数据处理的 <strong>exactly-once</strong> 语义。</p>
<p>另外值得一提的是，Spark 提供了 MLlib 机器学习库，并且支持<strong>流式机器学习算法</strong>（streaming machine learning algorithms），包括 Streaming Linear Regression，Streaming KMeans 等等。这意味着可以一边使用流数据训练模型，一边将模型应用于流数据。此外，你也可以通过历史数据离线训练模型，再将模型在线地应用于实时流数据。</p>
<h2 id="Apache-Flink"><a href="#Apache-Flink" class="headerlink" title="Apache Flink"></a>Apache Flink</h2><p><a href="https://flink.apache.org/">Apache Flink</a> 是由德国几所大学发起的的学术项目，后来不断发展壮大，并于 2014 年末成为 Apache 顶级项目。Flink 主要面向流处理，如果说 Spark 是批处理界的王者，那么 Flink 就是流处理领域的冉冉升起的新星。Flink 由 Java 和 Scala 编写，目前最新版本 1.11。</p>
<p>Flink 提供了负责流处理的  <strong>DataStream API</strong> 和负责批处理的 <strong>DataSet API</strong>，在其之上，又封装了 <strong>Table API</strong> 和 <strong>SQL</strong> 两种关系型 API。这两个 API 都是批处理和流处理统一的 API，这意味着在无边界的实时数据流和有边界的历史记录数据集上，关系型 API 会以相同的语义执行查询，并产生相同的结果。它们可以与 DataStream 和 DataSet API 无缝集成，并支持用户自定义的标量函数，聚合函数以及表值函数。</p>
<p>在 DataStream API 设计中，一个 Streaming Dataflow 被定义为由一系列 <strong>Operator</strong>（算子）组成，Operator 分为三类：Source Operator 定义入口；Sink Operator 定义出口；Transformation Operator 定义数据的中间转换操作。下图是一个使用 DataStream API 的示例：</p>
<p><img src="/2020/11/23/%E6%B5%81%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-Storm%E3%80%81Flink-Spark/5.png" alt="7489b8c785545f3d80c397cfc32bdca3.png"></p>
<p>在一个完整的 Dataflow DAG 中，可能包含多个 Source 和 Sink，一个 Transformation 也可以包含多个算子。在执行过程中，一个流会有一个或多个流分片（stream partitions），一个算子包含一个或多个算子子任务（operator subtasks），算子子任务的个数就是该算子的并行度（parallelism）。</p>
<p>Flink 运行时架构如下图所示，主要由一个 JobManager 进程和若干个 TaskManager 进程组成。其中，客户端 Client 并不是程序运行的组成部分，而是负责将用户的 Jar 包构建成 Dataflow Graph，提交到 JobManager 上。JobManager 和 TaskManager 既可以直接以 standalone 模式启动，也可以通过 YARN 或者 Mesos 等资源管理框架进行协调工作。</p>
<p><img src="/2020/11/23/%E6%B5%81%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-Storm%E3%80%81Flink-Spark/6.png" alt="e870b01bdb5da98f44fbc6729f928b14.png"></p>
<p><strong>JobManager</strong> 类似于 Storm 中的 Nimbus，是协调 Flink 应用分布式执行的主进程。一个 Flink 应用中至少有一个 JobManager，在高可用（High Availability）模式下可能会存在多个 JobManager，它们中的一个作为 leader，其余作为 standby。JobManager 由三个组件组成：</p>
<ul>
<li><strong>ResourceManager</strong>，负责 Flink 集群资源的分配。它管理着资源调度的最小单元 Task Slots，同时支持 YARN，Mesos，Kubernetes 等多种部署管理方式；</li>
<li><strong>Dispatcher</strong>，为用户提供了一个可以提交 Flink 应用的 REST 接口。同时  Dispatcher 也会启动一个Web UI，方便展示和监控作业执行的信息；</li>
<li><strong>JobMaster</strong>，负责管理作业图（JobGraph）的执行。多个 Job 可以同时在 Flink 集群上运行，每个 Job 会有自己独立的 JobMaster。</li>
</ul>
<p><strong>TaskManager</strong>，又称作 Worker，负责执行 Task，以及数据流的缓存和交换。Flink 很形象的将任务执行资源称为 Task Slot（插槽），每个插槽是 TaskManager 资源的一个固定子集，比如拥有 3 个插槽的 TaskManager 每个插槽能够使用 1/3 的内存。TaskManager 携有资源，而调度则是通过 JobManager。</p>
<p>数据一致性方面，Flink 通过 Checkpoint（检查点）机制，保证了数据处理的“精确一次”（<strong>exactly-once</strong>）语义。在应用程序运行期间，Flink 会定期检查状态的一致检查点。如果发生故障，Flink 会将程序状态置为最近的检查点时的状态，并重新启动处理流程，消费并处理检查点和发生故障之间的所有数据。尽管这意味着 Flink 会对一些数据处理两次（在故障之前和之后），我们仍然可以说这个机制实现了精确一次的一致性语义，因为所有算子的状态都已被重置，而重置后的状态下还不曾看到这些数据。</p>
<h2 id="流处理框架演进"><a href="#流处理框架演进" class="headerlink" title="流处理框架演进"></a>流处理框架演进</h2><p>流处理框架的演进，要从 MapReduce 编程模型开始讲起。为了解决分布式计算学习和使用成本高的问题，Google 在 2004 年提出一种编程范式，它要求程序员将分布式数据操作拆分为两大步：<code>map</code> 和 <code>reduce</code>，也就是所谓的 MapReduce 编程模型。</p>
<p>在同一年，Hadoop 的创始人受 MapReduce 编程模型等一系列论文的启发，对论文中提出的模型进行了编程实现。时至今日，Hadoop 不仅仅是整个大数据领域的先行者和领导者，更形成了一套围绕 Hadoop 的生态系统，成为企业首选的大数据解决方案。不论是 Storm、Spark 还是 Flink 都是敞开怀抱拥抱 Hadoop 生态并融入成为了生态圈的一部分。</p>
<p><img src="/2020/11/23/%E6%B5%81%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-Storm%E3%80%81Flink-Spark/7.png" alt="e2dc809939ef9af086d3197d3e648b0e.png"></p>
<p>Hadoop 虽然已被公认为大数据分析领域无可争辩的王者，但它更加专注于批处理，并不适合做实时计算。随着 Hadoop 生态的繁荣发展，诞生了一批流处理框架，本质上它们的核心处理流程也不偏离 MapReduce 思想：</p>
<ul>
<li><strong>第一代</strong>被广泛采用的流处理框架是 Storm，但由于 Storm 只支持 “at least once” 语义，对于很多对数据准确性要求较高的应用，Storm 有一定劣势。</li>
<li><strong>第二代</strong>非常流行的流处理框架是 Spark Streaming。Spark Streaming 使用微批处理的思想，每次处理一小批数据，以接近实时处理的效果。也正是由于时间间隔的存在，导致 Spark Streaming 的“实时处理”延迟较大，一般适用于延迟是秒级别的实时计算应用。但 Spark Streaming 的优势是拥有 Spark 这个靠山，用户从 Spark 迁移到 Spark Streaming 的成本较低，因此能给用户提供一个批量和流式于一体的计算框架。</li>
<li><strong>第三代</strong>流处理框架 Flink 是一个支持在有界和无界数据流上做有状态计算的大数据引擎。它以事件为单位，并且支持 SQL、State、WaterMark 等特性。比起 Storm，它的吞吐量更高，延迟更低，准确性能得到保障；比起 Spark Streaming，它以事件为单位，达到真正意义上的实时计算，且所需计算资源相对更少。</li>
</ul>
<p><img src="/2020/11/23/%E6%B5%81%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-Storm%E3%80%81Flink-Spark/8.jpg" alt="67fc13f9d829042f7b800522e416d280.jpeg"></p>
<p>Spark 和 Flink 各有所长，也在相互竞争、相互借鉴。可以说 Spark 是以批处理起家的，通过使用内存计算比传统 Hadoop MapReduce 具有显著性能优势，Spark 已经成为行业内大数据批处理的首选处理引擎。但在处理稍微复杂点的实时流处理场景 (比如各种窗口、状态等) ，Flink 要比 Spark Streaming 更具有显著优势。事实证明，阿里最终在流处理框架选型中选择了 Flink，并在其之上开发了自己的流处理框架 Blink，并对 Flink 社区提供了贡献，包括促进 Flink 流处理、批处理一体化等。</p>
<h2 id="流批一体"><a href="#流批一体" class="headerlink" title="流批一体"></a>流批一体</h2><p>现如今，流批一体已经越来越成为一种趋势，它旨在将流处理和批处理通过一套相同的处理逻辑来实现。流批一体意味着计算引擎同时具备流计算的低延迟和批计算的高吞吐高稳定性，提供统一编程接口开发两种场景的应用并保证它们的底层执行逻辑是一致的。</p>
<p>2015 年，Google 提出了 <a href="https://www.vldb.org/pvldb/vol8/p1792-Akidau.pdf">Dataflow</a> 模型，旨在提供一种统一批处理和流处理的解决方案。作为 Dataflow 模型的最早采用者之一，Apache Flink 在流批一体特性的完成度上在开源项目中是十分领先的。Flink 遵循 Dataflow 模型的理念: <strong>批处理是流处理的特例</strong>，亦即批处理处理的是无界数据流上的一小段有界数据流。Flink 设计之初流处理应用和批处理应用底层都是流处理，但在编程 API 上是分开的。</p>
<p><img src="/2020/11/23/%E6%B5%81%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-Storm%E3%80%81Flink-Spark/9.png" alt="dbcd10468cea3d61ff1f88d9c640643a.png"></p>
<p>在 Flink 架构上，负责物理执行环境的 Runtime 层是统一的流处理，上面分别有独立的 DataStream 和 DataSet 两个 API，两者基于不同的任务类型（Stream Task/Batch Task）和 UDF 接口（Transformation/Operator）。而更上层基于关系代数的 Table API 和 SQL API 表面上是统一的，但实际上编程入口（Environment）是分开的，且内部将流批作业分别翻译到 DataStream API 和 DataSet API 的逻辑也是不一致的。</p>
<p>基于批处理是流处理的特例的理念，用流处理表达批处理在语义上是完全可行的，而流批一体的难点在于批处理场景作为特殊场景的优化。对 Flink 而言，难点主要体现批处理作业在 Task 线程模型、调度策略和计算模型及算法的差异性上。因此，要实现真正的流批一体，Flink 需完成 Table/SQL API 的和 DataStream/DataSet API 两层的改造，将批处理完全移植到流处理之上，并且需要兼顾作为批处理立身之本的效率和稳定性。目前流批一体也是 Flink 长期目标中很重要一点，流批一体的完成将标志着 Flink 进入 2.0 新版本的时代。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.tutorialandexample.com/apache-storm-tutorial/">Apache Storm Tutorial</a></li>
<li><a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html">Spark Streaming Programming Guide 官方文档</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/">Apache Flink 1.11 官方文档</a></li>
<li><a href="https://confucianzuoyuan.github.io/flink-tutorial/book/chapter03-05-02-%E4%BB%8E%E4%B8%80%E8%87%B4%E6%A3%80%E6%9F%A5%E7%82%B9%E4%B8%AD%E6%81%A2%E5%A4%8D%E7%8A%B6%E6%80%81.html">尚硅谷Flink教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/94302767">从Hadoop到Spark、Flink，大数据处理框架十年激荡发展史</a></li>
<li><a href="https://developer.aliyun.com/article/754468">Flink 流批一体的实践与探索 —— 阿里云开发者社区</a></li>
<li><a href="https://www.vldb.org/pvldb/vol8/p1792-Akidau.pdf">The Dataflow Model: A Practical Approach to Balancing Correctness, Latency, and Cost in Massive-Scale, Unbounded, Out-of-Order Data Processing</a></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>流处理</tag>
      </tags>
  </entry>
  <entry>
    <title>构建你的 Docker 镜像</title>
    <url>/2017/11/02/%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84Docker%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>Docker实现了宿主系统和Docker容器(container)的隔离，使用Docker可以将构建开发所需环境的镜像(images)，再根据镜像生成容器实例。实现不依赖宿主机环境的高效部署、测试。</p>
</blockquote>
<p>油条有一篇很好的文章介绍了Docker的工作原理。<a href="https://0x233.com/shen-qi-de-dockerdao-di-zuo-liao-shi-yao/">链接</a></p>
<h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>安装Docker,<a href="https://docs.docker.com/engine/installation/">官网文档</a></p>
<blockquote>
<p>1.官方镜像仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a><br>2.官网下载速度较慢，推荐DaoCloud仓库，和官网同步更新的 <a href="https://hub.daocloud.io/">https://hub.daocloud.io/</a></p>
</blockquote>
<p>下载ubuntu基础镜像，冒号后是标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull daocloud.io/library/ubuntu:16.04</span><br></pre></td></tr></table></figure>
<p>执行<code>docker images</code>查看已下载的镜像</p>
<p>创建容器实例，返回容器ID。<code>-d</code>后台运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -it daocloud.io/library/ubuntu:16.04</span><br></pre></td></tr></table></figure>
<p>执行<code>docker ps</code>查看正在运行的容器</p>
<h2 id="Build-Your-Image"><a href="#Build-Your-Image" class="headerlink" title="Build Your Image"></a>Build Your Image</h2><p>进入容器，ID输入可区分的几位就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 4e bash</span><br></pre></td></tr></table></figure>
<p>可以看到在容器中有一套全新的目录结构，与宿主机是隔离的。</p>
<p>更改软件源为阿里云源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/apt/</span><br><span class="line">cp sources.list sources.list_backup </span><br><span class="line">cat /dev/null &gt; sources.list </span><br></pre></td></tr></table></figure>

<p><code>vim sources.list</code>将如下内容加入文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.cloud.aliyuncs.com/ubuntu/ xenial main</span><br><span class="line">deb-src http://mirrors.cloud.aliyuncs.com/ubuntu/ xenial main</span><br><span class="line">deb http://mirrors.cloud.aliyuncs.com/ubuntu/ xenial-updates main</span><br><span class="line">deb-src http://mirrors.cloud.aliyuncs.com/ubuntu/ xenial-updates main</span><br><span class="line">deb http://mirrors.cloud.aliyuncs.com/ubuntu/ xenial universe</span><br><span class="line">deb-src http://mirrors.cloud.aliyuncs.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.cloud.aliyuncs.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb-src http://mirrors.cloud.aliyuncs.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.cloud.aliyuncs.com/ubuntu/ xenial-security main</span><br><span class="line">deb-src http://mirrors.cloud.aliyuncs.com/ubuntu/ xenial-security main</span><br><span class="line">deb http://mirrors.cloud.aliyuncs.com/ubuntu/ xenial-security universe</span><br><span class="line">deb-src http://mirrors.cloud.aliyuncs.com/ubuntu/ xenial-security universe</span><br></pre></td></tr></table></figure>

<p>日常<code>apt-get update|upgrade</code>之后着手安装jdk和Tomcat了</p>
<p>我的另一篇博客详细介绍了如何<a href="http://s1mple.info/install-java-tomcat/">安装 JDK&amp;Tomcat</a></p>
<blockquote>
<p>如果你成功到了这里，那恭喜你，你自己的开发环境镜像已经构建完了。还需要一些步骤来将你的镜像推上云端！</p>
</blockquote>
<h2 id="Push-It"><a href="#Push-It" class="headerlink" title="Push It !"></a>Push It !</h2><p><code>exit</code>或者<code>ctrl+d</code>退出当前容器，<code>docker ps</code>查看容器ID</p>
<p>根据容器创建一个新的镜像，不加标签默认<strong>latest</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit 4e s1mple1995/java-web-env</span><br></pre></td></tr></table></figure>

<p>在<code>push</code>前需要在<a href="https://cloud.docker.com/">docker官网</a>注册账户，用于存放自己的镜像</p>
<p>在<strong>Docker Cloud</strong>中<strong>create repository</strong>，镜像名要和服务器中的镜像名一致，不一致可以使用如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag local-image:tagname new-repo:tagname</span><br></pre></td></tr></table></figure>

<p>在服务器端登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure>

<p>执行push命令，等待上传完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker push s1mple1995/java-web-env</span><br></pre></td></tr></table></figure>

<p>现在你的镜像已经存放在Docker Cloud云端了，搜索你的镜像，随时随地可以pull下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search s1mple1995</span><br></pre></td></tr></table></figure>

<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ol>
<li>Docker的镜像管理很像git的版本控制。</li>
<li>你也可以使用阿里云的容器镜像服务。如果你的服务器是阿里云的ECS，可以使用内网传输，速度非常快。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker login registry-vpc.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​    </p>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>离线安装 Nginx</title>
    <url>/2018/01/22/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Nginx/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>工作中难免有不能使用外网的环境，虽然说不能连外网安装软件真的是很费劲，但是为了安全着想也没得办法嘛</p>
</blockquote>
<hr>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><ul>
<li><strong>nginx-1.12.2.tar.gz</strong> <a href="http://nginx.org/en/download.html">官网</a>下载tar包，下载链接：<a href="http://nginx.org/download/nginx-1.12.2.tar.gz">http://nginx.org/download/nginx-1.12.2.tar.gz</a></li>
<li><strong>pcre-8.41.tar.gz</strong></li>
<li><strong>zlib-1.2.11.tar.gz</strong></li>
<li><strong>openssl-1.0.2n.tar.gz</strong></li>
<li>配置好 <strong>ssh</strong> 免密钥登录服务器</li>
</ul>
<hr>
<h2 id="Installing"><a href="#Installing" class="headerlink" title="Installing"></a>Installing</h2><ul>
<li><p>上传各个 tar 包至服务器的<code>/opt</code>目录，然后使用<code>tar -xzvf</code>解压</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp /Users/s1mple/Downloads/nginx-1.12.2.tar.gz root@10.0.1.16:/opt</span><br><span class="line">scp /Users/s1mple/Downloads/pcre-8.41.tar.gz root@10.0.1.16:/opt</span><br><span class="line">scp /Users/s1mple/Downloads/zlib-1.2.11.tar.gz root@10.0.1.16:/opt</span><br><span class="line">scp /Users/s1mple/Downloads/openssl-1.0.2n.tar.gz root@10.0.1.16:/opt</span><br></pre></td></tr></table></figure></li>
<li><p>前往解压出来的<code>/opt/nginx-1.12.2</code>文件夹，其中包含了 <strong>Nginx</strong> 的配置脚本<code>configure</code>，运行这个脚本并指导刚才解压的各依赖的路径</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure --with-pcre=/opt/pcre-8.41 --with-zlib=/opt/zlib-1.2.11 --with-openssl=/opt/openssl-1.0.2n</span><br></pre></td></tr></table></figure></li>
<li><p>执行后的结果，生成了 <strong>Makefile</strong> 文件，并输出了一些配置的摘要。简单看一下，默认的 <strong>Nginx</strong> 安装在<code>/usr/local/nginx</code>下，以及启动脚本、配置、日志的路径</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">creating objs/Makefile</span><br><span class="line"></span><br><span class="line">Configuration summary</span><br><span class="line">  + using PCRE library: /opt/pcre-8.41</span><br><span class="line">  + using OpenSSL library: /opt/openssl-1.0.2n</span><br><span class="line">  + using zlib library: /opt/zlib-1.2.11</span><br><span class="line"></span><br><span class="line">  nginx path prefix: &quot;/usr/local/nginx&quot;</span><br><span class="line">  nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot;</span><br><span class="line">  nginx modules path: &quot;/usr/local/nginx/modules&quot;</span><br><span class="line">  nginx configuration prefix: &quot;/usr/local/nginx/conf&quot;</span><br><span class="line">  nginx configuration file: &quot;/usr/local/nginx/conf/nginx.conf&quot;</span><br><span class="line">  nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot;</span><br><span class="line">  nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot;</span><br><span class="line">  nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot;</span><br><span class="line">  nginx http client request body temporary files: &quot;client_body_temp&quot;</span><br><span class="line">  nginx http proxy temporary files: &quot;proxy_temp&quot;</span><br><span class="line">  nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;</span><br><span class="line">  nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;</span><br><span class="line">  nginx http scgi temporary files: &quot;scgi_temp&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><code>make</code>是 <strong>Linux</strong> 下常用的构建工具，主要用于 C 语言，它会根据 <strong>Makefile</strong> 中的构建规则生成文件。在<code>/opt/nginx-1.12.2</code>目录下执行这俩个命令</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>/opt/nginx-1.12.2</code>目录下的 <strong>Makefile</strong> 文件包含了实际执行的命令。<code>-f</code>指定了刚刚生成的<code>/objs/Makefile</code>文件</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default:    build</span><br><span class="line">build:      $(MAKE) -f objs/Makefile</span><br><span class="line">install:    $(MAKE) -f objs/Makefile install</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建完成后前往<code>/usr/local/nginx</code>查看生成的文件</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls /usr/local/nginx</span><br><span class="line">client_body_temp  fastcgi_temp  logs        sbin       uwsgi_temp</span><br><span class="line">conf              html          proxy_temp  scgi_temp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h2><ul>
<li><p>运行<code>sbin/nginx</code>启动脚本并验证是否已启动</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./sbin/nginx</span><br><span class="line">$ ps -ef | grep nginx</span><br><span class="line">root     31402     1  0 11:48 ?        00:00:00 nginx: master process ./nginx</span><br><span class="line">nobody   31403 31402  0 11:48 ?        00:00:00 nginx: worker process</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器访问 10.0.1.16 也已显示 <strong>Nginx</strong> 启动成功<br><img src="/0.png" alt="Screen-Shot-2018-01-22-at-11.50.30-AM"></p>
</li>
</ul>
<hr>
<h2 id="Configuring"><a href="#Configuring" class="headerlink" title="Configuring"></a>Configuring</h2><ul>
<li><p>在<code>/usr/local/nginx/conf</code>中包含了 <strong>Nginx</strong> 配置文件，我们先做个备份</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp nginx.conf nginx.conf.bk</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>nginx.conf</code>文件，在<code>http&#123;&#125;</code>中加入这一行表示引入外部配置文件</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include /usr/local/nginx/conf/conf.d/*.conf;</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>/usr/local/nginx/conf</code>中创建<code>conf.d</code>文件夹，并创建自己的配置文件，注意要以<code>.conf</code>结尾，添加<code>server&#123;&#125;</code>后重启 <strong>Nginx</strong> 即可</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;                                                                                </span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line"></span><br><span class="line">    server_name 10.0.1.16;</span><br><span class="line">    root /var/www/dist;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="Postscripts"><a href="#Postscripts" class="headerlink" title="Postscripts"></a>Postscripts</h2><blockquote>
<p>安装下来感觉就是，本来一条命令就解决的事，你比如说 <strong>sudo apt-get install nginx</strong> 结果强行搞这么复杂，网络带来的便利无疑是巨大的，所以说安全方面的意识和技能非常关键</p>
</blockquote>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://www.nginx.cn/doc/">Nginx中文文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>结合案例使用 Java 注解和反射</title>
    <url>/2018/11/29/%E7%BB%93%E5%90%88%E6%A1%88%E4%BE%8B%E4%BD%BF%E7%94%A8%20Java%20%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在项目开发时遇到这样一个场景：从上游传过来一个实体类对象 <code>newEntity</code>，但它只有部分字段，需要去库中查出对应的旧对象 <code>oldEntity</code> 做一次补全（相当于一次部分更新）。</p>
<p>一开始我们这样编码的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FlightBasic <span class="title">merge</span><span class="params">(FlightBasic newEntity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newEntity.getAirportCode() != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setAirportCode(newEntity.getAirportCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newEntity.getCraftNo() != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setCraftNo(newEntity.getCraftNo());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newEntity.getCraftType() != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setCraftType(newEntity.getCraftType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// too long ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很快我们发现了问题：不仅类的字段很多，这样的 Entity 也有很多，所以到处都是又臭又长的 <code>merge</code> 方法。</p>
<p>其实不难总结这些代码的共性：</p>
<ul>
<li>一个 Entity 只能和本身的类型 Merge</li>
<li>代码都是判空后对属性的 <code>getter/setter</code> 方法的重复调用</li>
</ul>
<p>为了简化代码（偷懒），就在想能不能通过统一的处理完成这些 Merge 逻辑。首先想到的是代码生成，类似 MyBatis Generator，重复的工作交给脚本或者工具多好。但是很快就否定了这种方案，配置这些类的工作量也不小，而且很多类中有自己的业务逻辑，一不小心覆盖了也不行。那注解行不行呢？Spring Boot 就大量使用注解替换了之前配置繁杂的 XML 文件。实际编码后验证是可行的！本文将介绍如何<strong>配合使用 Java 的注解和反射</strong>实现上述问题中的 Merge 操作。示例代码已上传到 <a href="https://github.com/s1mplecc/merging">GitHub</a> 上。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>每当你创建描述符性质的类或者接口时，一旦其中包含重复性的工作，就可以考虑使用注解来简化与自动化该过程。一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有<strong>解析</strong>它的代码，它可能连注释都不如。而解析注解往往有两种方式，一种是<strong>编译期扫描</strong>，典型的例如 <code>@Override</code>，这种只适用于编译器已经认识的注解，一般都是 JDK 内置注解；另一种则是通过<strong>运行期反射</strong>，也是在我们自定义注解后需要自己编码的。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>Java提供了四种元注解，专门负责<strong>修饰其他注解</strong>：</p>
<ul>
<li><code>@Target</code>：注解的作用目标</li>
<li><code>@Retention</code>：注解的生命周期</li>
<li><code>@Documented</code>：注解是否要包含在 JavaDoc 文档中</li>
<li><code>@Inherited</code>：子类是否继承该注解</li>
</ul>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p><code>@Target</code> 用于定义注解的<strong>作用域</strong>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>ElementType</code> 是一个枚举类型，包含以下值：</p>
<ul>
<li><code>ElementType.TYPE</code>：允许注解作用在类、接口和枚举上</li>
<li><code>ElementType.FIELD</code>：允许作用在属性字段上</li>
<li><code>ElementType.METHOD</code>：允许作用在方法上</li>
<li><code>ElementType.PARAMETER</code>：允许作用在方法参数上</li>
<li><code>ElementType.CONSTRUCTOR</code>：允许作用在构造器上</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：允许作用在本地局部变量上</li>
<li><code>ElementType.ANNOTATION_TYPE</code>：允许作用在注解上</li>
<li><code>ElementType.PACKAGE</code>：允许作用在包上</li>
</ul>
<p>当允许有多个作用域时使用花括号 <code>&#123;&#125;</code> 包裹，比如这样：<code>@Target(&#123; ElementType.TYPE, ElementType.FIELD &#125;)</code></p>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p><code>@Retention</code> 用于标明注解存在的<strong>生命周期</strong>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RetentionPolicy</code> 也是一个枚举类型，包含以下值：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>：在源文件中保留，编译为 .class 文件时会被丢弃，比如 <code>@Override</code>、<code>@SuppressWarnings</code></li>
<li><code>RetentionPolicy.CLASS</code>：.class 文件中会保留，但运行时丢弃</li>
<li><code>RetentionPolicy.RUNTIME</code>：运行时保留，可以通过<strong>反射获取</strong></li>
</ul>
<p>剩下两种类型的注解用的不多，也比较简单，这里不再详细的介绍了，只需要知道他们各自的作用即可。<code>@Documented</code> 修饰的注解，当执行 JavaDoc 文档打包时会被保存进文档，否则将被丢弃。<code>@Inherited</code> 注解修饰的注解是有<strong>继承性</strong>的，也就说我们的注解修饰了一个类，而该类的子类将自动继承父类的该注解。该注解只作用于类，对属性或方法无效。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Java 反射机制是指在<strong>程序运行时（Runtime）识别和使用对象的类型信息</strong>。以下内容摘自《Thinking in Java》，是我认为的有利于理解反射的核心概念。</p>
<blockquote>
<p>要理解反射的工作原理，首先必须知道<strong>类型信息</strong>在运行时是如何表示的。这项工作是由称为 <strong>Class</strong> 对象的特殊对象完成的，它包含了与类有关的信息。事实上，Class 对象就是用来创建类的所有“常规”对象的。</p>
<p>类是程序的一部分，每个类都有一个 Class 对象。换言之，每当编写并且编译了一个新类，就会产生一个 Class 对象（更恰当地说，是被保存在一个同名的 <code>.class</code> 文中）。为了生成这个类的对象，运行这个程序的 Java 虚拟机（JVM）将使用被称为<strong>类加载器</strong>的子系统。类加载器首先检查这个类的 Class 对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找 <code>.class</code> 文件。<strong>一旦某个类的 Class 对象被载入内存，它就被用来创建这个类的所有对象</strong>。</p>
<p><code>Class</code> 类和 <code>java.lang.reflect</code> 类库一起对反射的概念提供了支持，该类库包含 <code>Field</code>、<code>Method</code> 以及 <code>Constructor</code> 类。这些类型的对象是由 JVM 在运行时创建的，用以<strong>表示未知类里对应的成员</strong>。这样你就可以使用 <code>Constructor</code> 创建新的对象，用 <code>get()</code> 和 <code>set()</code> 方法读取和修改与 <code>Field</code> 对象关联的字段，用 <code>invoke()</code> 方法调用与 <code>Method</code> 对象关联的方法等等。另外，还可以调用 <code>getFields()</code>、<code>getMethods()</code> 和 <code>getConstructors()</code> 等方法以返回表示字段、方法以及构造器的对象的数组（可以查看 Class 类源码了解更多资料）。</p>
<p>重要的是，要认识到反射机制并没有什么神奇之处。当通过反射与一个未知类型的对象打交道时，JVM 只是简单地检查这个对象，看它属于哪个特定的类。在用它做其他事情之前必须先加在那个类的 Class 对象。对于反射机制来说，<code>.class</code> 文件在编译时是不可获取的，所以是在运行时打开和检查 <code>.class</code> 文件。</p>
</blockquote>
<p>这里简单的介绍一下我们编码时用到的与反射有关的方法：</p>
<ul>
<li><code>obj.getClass();</code> Java 提供了三种方式获取类的 Class 对象的引用：<code>Class.forName()</code> 通过类名获取；<code>obj.getClass();</code> 通过对象获取和 <code>Object.class</code> 通过类字面常量获取。</li>
<li><code>getDeclaredFields();</code> 获取类中声明的所有字段，不包括父类和接口中的字段。它与 <code>getFields()</code> 的区别在于，<code>getFields()</code> 是获取所在类以及父类和接口中的所有访问修饰符为 <code>public</code> 的字段。</li>
<li><code>getAnnotation();</code> 获取标注的注解实例对象。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Merge-粒度与等级"><a href="#Merge-粒度与等级" class="headerlink" title="Merge 粒度与等级"></a>Merge 粒度与等级</h3><p>回到我们的问题上来，首先考虑一个问题：Merge 的粒度应该位于什么层次？如果是类级别的，意味着整个类的所有属性将一视同仁，要么都合并要么都不，显然这样是不行的。Merge 的<strong>粒度应该在属性字段上</strong>，为此，我们专门定义了字段的 Merge 等级 <code>Level</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Level</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 无论新值为何值，都会覆盖旧值 */</span></span><br><span class="line">    Mandatory,</span><br><span class="line">    <span class="comment">/* 如果新值不为null，覆盖旧值，否则不覆盖 */</span></span><br><span class="line">    Required,</span><br><span class="line">    <span class="comment">/* 忽略，不做合并处理 */</span></span><br><span class="line">    Ignored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义注解-MergeOn"><a href="#自定义注解-MergeOn" class="headerlink" title="自定义注解 @MergeOn"></a>自定义注解 @MergeOn</h3><p>接下来就需要自定义我们的注解：<code>@MergeOn</code>，作用在字段上，在运行时有效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MergeOn &#123;</span><br><span class="line">    <span class="function">Level <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> Level.Required</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>default</code> 关键字可以设置缺省等级为 <code>Required</code>。</p>
<h3 id="通过反射将字段设值"><a href="#通过反射将字段设值" class="headerlink" title="通过反射将字段设值"></a>通过反射将字段设值</h3><p>现在，还差最后一步，就是如何通过反射将字段设值。要想让实体类实现 Merge，首先需要定义一个接口 <code>Merging</code> 让实体类去继承它，然后接口中得有一个默认方法 <code>mergeWith(T newEntity)</code>，它将做下面这几件事：</p>
<ul>
<li>通过反射获取 Entity 声明的所有字段</li>
<li>通过反射获取字段上 <code>@MergeOn</code> 注解的 Level</li>
<li>通过 Level 走不同的分支去给字段设值，是强制或是忽略亦或是只有非空情况下才设值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Merging</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Merging</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">mergeWith</span><span class="params">(T newEntity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getClass() != newEntity.getClass()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MergeWithDifferentClassTypeException(</span><br><span class="line">                    String.format(<span class="string">&quot;&lt;%s&gt; can not merge with other class type &lt;%s&gt;&quot;</span>, <span class="keyword">this</span>.getClass().getName(), newEntity.getClass().getName()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field[] fields = <span class="keyword">this</span>.getClass().getDeclaredFields(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            MergeOn mergeOn = field.getAnnotation(MergeOn.class); <span class="comment">// 2</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mergeOn == <span class="keyword">null</span> || mergeOn.level().isRequired()) &#123; <span class="comment">// 4...</span></span><br><span class="line">                    Object newFieldValue = field.get(newEntity);</span><br><span class="line">                    <span class="keyword">if</span> (newFieldValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        field.set(<span class="keyword">this</span>, newFieldValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mergeOn.level().isMandatory()) &#123; <span class="comment">// 4...</span></span><br><span class="line">                    field.set(<span class="keyword">this</span>, field.get(newEntity)); <span class="comment">// 5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MergeOnFieldIllegalAccessException(field.getName(), ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看代码具体的实现步骤（注释中标明了顺序）：</p>
<ol>
<li><code>this.getClass().getDeclaredFields();</code> 获取类中声明的所有字段，不包含父类和接口中的字段。<code>this</code> 指向的是实现接口的实体类。</li>
<li><code>field.getAnnotation(MergeOn.class);</code> 获取字段上的 <code>@MergeOn</code> 注解实例。</li>
<li><code>field.setAccessible(true);</code> 由于字段通常是 <code>private</code> 修饰的，就需要<strong>获取访问权</strong>（并不是修改实际权限），否则将抛出 <code>IllegalAccessException</code> 异常。由此可见，反射有可能破环封装性。</li>
<li>根据 Level 做相应设值。如果无注解或 Level 为 Required，则新值非空时覆盖旧值；如果是强制（Mandatory）则始终覆盖；否则（Ignored），忽略不做处理。</li>
<li><code>field.set(this, field.get(newEntity));</code> 字段设值的实际操作，接口设计看上去有点反人类。第一个参数为需要设置字段的对象，此处为 oldEntity，第二个参数为要设置的值，此处为新对象的字段值。</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>接下来我将演示如何使用这个接口，并编写单元测试验证其正确性。</p>
<p>首先定义实体类 Entity。</p>
<ul>
<li>为了测试全面性，加入了各种类型的属性字段，包括基础类型、集合、数组和类；同时，<code>@MergeOn</code> 注解覆盖了所有 Level，还包括缺省和无注解的情况。</li>
<li>为了简单，直接在字段声明时赋初值。即 <code>new Entity()</code> 出来的可以看成旧的模型对象（oldEntity）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entity</span> <span class="keyword">implements</span> <span class="title">Merging</span>&lt;<span class="title">Entity</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@MergeOn(level = Level.Ignored)</span></span><br><span class="line">    <span class="keyword">private</span> String string = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    <span class="meta">@MergeOn</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> anInt = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@MergeOn(level = Level.Mandatory)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; stringList = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="meta">@MergeOn(level = Level.Required)</span></span><br><span class="line">    <span class="keyword">private</span> String[] strings = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;sArr1&quot;</span>, <span class="string">&quot;sArr2&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Email email = <span class="keyword">new</span> Email(<span class="string">&quot;zz@163.com&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Email&gt; emails = Sets.newLinkedHashSet(<span class="keyword">new</span> Email(<span class="string">&quot;zz@163.com&quot;</span>), <span class="keyword">new</span> Email(<span class="string">&quot;zz@gmail.com&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Email</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理想情况下，<code>string</code> 字段新值应当被忽略；<code>stringList</code> 在新值为 null 时也会被强制覆盖；其他缺省和无注解的应当行为与 <code>@MergeOn(level = Level.Required)</code> 一致，即非空时才会覆盖旧值。以下为测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_merge_new_entity_with_different_merge_level</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity newEntity = <span class="keyword">new</span> Entity();</span><br><span class="line">    newEntity.setString(<span class="string">&quot;newString&quot;</span>);  <span class="comment">// Ignored</span></span><br><span class="line">    newEntity.setAnInt(<span class="number">2</span>);</span><br><span class="line">    newEntity.setStringList(<span class="keyword">null</span>);  <span class="comment">// Mandatory</span></span><br><span class="line">    newEntity.setStrings(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;newS1&quot;</span>, <span class="string">&quot;newS2&quot;</span>, <span class="string">&quot;newS3&quot;</span>&#125;);</span><br><span class="line">    newEntity.setEmail(<span class="keyword">new</span> Entity.Email(<span class="string">&quot;newEmail@163.com&quot;</span>));</span><br><span class="line">    newEntity.setEmails(<span class="keyword">null</span>); <span class="comment">// Required, wished not be overwrited</span></span><br><span class="line"></span><br><span class="line">    Entity entity = <span class="keyword">new</span> Entity(); <span class="comment">// oldEntity</span></span><br><span class="line">    entity.mergeWith(newEntity);</span><br><span class="line"></span><br><span class="line">    assertThat(entity.getString()).isEqualTo(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">    assertThat(entity.getAnInt()).isEqualTo(<span class="number">2</span>);</span><br><span class="line">    assertThat(entity.getStringList()).isNull();</span><br><span class="line">    assertThat(entity.getStrings()).containsSequence(<span class="string">&quot;newS1&quot;</span>, <span class="string">&quot;newS2&quot;</span>, <span class="string">&quot;newS3&quot;</span>);</span><br><span class="line">    assertThat(entity.getEmail().getValue()).isEqualTo(<span class="string">&quot;newEmail@163.com&quot;</span>);</span><br><span class="line">    assertThat(entity.getEmails()).hasSize(<span class="number">2</span>);</span><br><span class="line">    assertThat(entity.getEmails()).contains(<span class="keyword">new</span> Entity.Email(<span class="string">&quot;zz@163.com&quot;</span>));</span><br><span class="line">    assertThat(entity.getEmails()).contains(<span class="keyword">new</span> Entity.Email(<span class="string">&quot;zz@gmail.com&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://juejin.im/post/5b45bd715188251b3a1db54f">JAVA 注解的基本原理 —— 掘金</a></li>
<li>Thinking in Java 第14章：类型信息</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>结合源码深入理解 MapReduce 工作原理</title>
    <url>/2021/10/22/%E7%BB%93%E5%90%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MapReduce-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="MapReduce-架构"><a href="#MapReduce-架构" class="headerlink" title="MapReduce 架构"></a>MapReduce 架构</h2><blockquote>
<p>本文讨论的 MapReduce 架构是 Hadoop 1.0 版本时的架构，从 Hadoop 2.0 开始，Hadoop 推出了资源管理框架 YARN。在 YARN 中，使用 ResourceManager 来负责容器的调度（任务运行在容器中），以及作业的管理。使用 NodeManager 来向 ResourceManager 汇报节点资源以及容器运行状态，NodeManager 负责创建并管理执行任务的容器。从职责方面，ResourceManager 等同于 JobTracker，NodeManager 等同于 TaskTracker。大多数的分布式框架都符合这种主从设计，如 HDFS 的 NameNode 和 DataNode、Spark 的 Driver 和 Executor 等。</p>
</blockquote>
<p>以下是 MapReduce 架构和工作流程中的常用术语：</p>
<ul>
<li>Job（作业）：是客户端需要执行的一个工作单元，包括输入数据、MapReduce 程序和配置信息；</li>
<li>Task（任务）：Hadoop 将作业分成若干个任务来执行，任务分为两类，即 Map 任务和 Reduce 任务；</li>
<li>Map/Reduce：从执行阶段来看，Map 和 Reduce 代表两个大类阶段。从计算模型角度看，它们代表两个计算步骤。从代码层面看，它们是定义在 Mapper 和 Reducer 类中的函数；</li>
<li>Mapper/Reducer：从执行阶段的详细划分来看，Mapper 和 Reducer 代表执行 map 与 reduce 函数的步骤。从代码层面看，这是定义在代码中的两个 Java 类。某些语境下，Mapper 可以指代 Map 任务，Reducer 同理。</li>
</ul>
<p>与多数的大数据分布式框架相同，MapReduce 的架构也遵循主从结构：</p>
<ul>
<li>运行在 HDFS NameNode 主节点上的 <strong>JobTracker</strong> 程序，负责接收从客户端提交的 Job，将其划分成 Map 任务和 Reduce 任务，分发给从节点 TaskTracker 执行。JobTracker 负责任务之间的协作，并通过 TaskTracker 发送来的心跳包维护集群的运行状态，以及作业进度信息。</li>
<li>多个运行在 HDFS DataNode 节点上的 <strong>TaskTracker</strong> 程序，负责执行 Map 任务和 Reduce 任务，直接与 HDFS 交互。每隔一段时间，TaskTracker 向 JobTracker 发送心跳包，汇报节点运行状态，以及任务完成进度。</li>
</ul>
<p><img src="/2021/10/22/%E7%BB%93%E5%90%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MapReduce-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/1.png" alt="66b01a299a89595ca02de7b5b9f02b85.png"></p>
<p>为了减少网络传输带来的性能影响，JobTracker 在分发 Map 任务时基于<strong>数据本地化优化</strong>（Data locality optimization）策略，将 Map 任务分发给包含此 Map 处理数据的从节点，并将程序 Jar 包发送给该 TaskTracker，遵循“运算移动，数据不移动”的原则。</p>
<h2 id="新旧版本-API-说明"><a href="#新旧版本-API-说明" class="headerlink" title="新旧版本 API 说明"></a>新旧版本 API 说明</h2><p>本文中的源码是 Hadoop 3.2.0 版本的源码，使用的是 Hadoop 新版 API。新版 API 位于 <code>org.apache.hadoop.mapreduce</code> 包下，旧版 API 位于 <code>org.apache.hadoop.mapred</code> 包下，两版 API 并不兼容，你可以在 <a href="https://www.slideshare.net/sh1mmer/upgrading-to-the-new-map-reduce-api">这里</a> 查看两者的区别。为保证向后兼容，Hadoop 并没有移除旧版 API，因此依赖库中两个版本并存，使用时要注意。</p>
<p>设计新版 API 的主要目的是给用户提供更加简洁优雅的接口，框架的核心代码并没有调整包，比如执行 Map 与 Reduce 任务的 MapTask 和 ReduceTask 类仍位于 <code>org.apache.hadoop.mapred</code> 包下。但由于使用了两套 API，在该类中你会经常看到以 Old/New 命名的类或方法，如 <code>runNewMapper()</code> 和 <code>runOldMapper()</code>。</p>
<p>在旧版本中，Mapper 与 Reducer 被定义为接口，而在新版本中被定义为具体类，并提供默认的 map 和 reduce 实现：仅是通过 <code>context.write()</code> 重新写回数据。旧版本的 Mapper 接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span>&lt;<span class="title">K1</span>, <span class="title">V1</span>, <span class="title">K2</span>, <span class="title">V2</span>&gt; <span class="keyword">extends</span> <span class="title">JobConfigurable</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">map</span><span class="params">(K1 key, V1 value, OutputCollector&lt;K2, V2&gt; output, Reporter reporter)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版本中广泛使用上下文 Context 对象，整合了 OutputCollector、Reporter  和部分 JobConf 的功能，来实现与 MapReduce 系统的通信，如使用 <code>context.write()</code> 代替旧版的 <code>output.collect()</code> 功能。</p>
<p>新版本使用 Job 类替换旧版的 JobClient 类，实现作业控制，并使用统一的配置类 Configuration 来替换旧版的 JobConf 类，用于作业配置。因此，现在的一个 MapReduce 程序的入口函数可能如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    Job job = Job.getInstance(conf, <span class="string">&quot;word count&quot;</span>);</span><br><span class="line">    job.setJarByClass(WordCount.class);</span><br><span class="line">    </span><br><span class="line">    FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">    FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">    job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">    job.setReducerClass(IntSumReducer.class);</span><br><span class="line">    </span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(IntWritable.class);</span><br><span class="line">    </span><br><span class="line">    System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MapReduce-中的数据格式"><a href="#MapReduce-中的数据格式" class="headerlink" title="MapReduce 中的数据格式"></a>MapReduce 中的数据格式</h2><p>MapReduce 工作过程中每个阶段的输入和输出数据都是以<strong>键值对</strong>的形式出现，如下表所示，表中的 k 与 v 代表了数据类型，不同下标代表不同的数据类型。</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">输入</th>
<th align="center">输出</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>map()</code></td>
<td align="center">&lt;$k_1$, $v_1$&gt;</td>
<td align="center">[&lt;$k_2$, $v_2$&gt;, …]</td>
<td align="center">一个输入分片被 Map 处理成一系列的键值对</td>
</tr>
<tr>
<td align="center"><code>reduce()</code></td>
<td align="center">&lt;$k_2$, [$v_2$, …]&gt;</td>
<td align="center">&lt;$k_3$, $v_3$&gt;</td>
<td align="center">Reduce 的输入键类型为 Map 后的输出键类型，输入值是键对应的值的集合</td>
</tr>
</tbody></table>
<p>下面以统计词频程序 WordCount 为例，来说明 MapReduce 过程中的数据类型转换。</p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><p>在 Mapper 工作之前，框架从文件系统中读取文件并切分为分片，将数据转换为 <code>&lt;KEYIN, VALUEIN&gt;</code> 格式的键值对传给 map 函数。在 WordCount 程序中可以理解为形如 <code>&lt;行号, &quot;a b c&quot;&gt;</code> 的输入数据。实际上，输入键“行号”在实际代码中可能如下的 LongWritable 类型，一个可序列化的长整型偏移量（offset）。这是由 Hadoop 框架定义的数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        String line = value.toString();</span><br><span class="line">        String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            Text outputKey = <span class="keyword">new</span> Text(word.toUpperCase().trim());</span><br><span class="line">            IntWritable outputValue = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">            context.write(outputKey, outputValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：Hadoop 提供了一套可优化网络序列化传输的基本类型，而不直接使用 Java 内置类型，这些类型位于 <code>org.apache.hadoop.io</code> 包中。上述代码中的 LongWritable 相当于 Java 的 Long 类型，Text 相当于 String 类型，IntWritable 相当于 Integer 类型。</p>
<p>map 函数将输入的文本串切分为一个个单词，输入的键值对被转换为 <code>&lt;KEYOUT, VALUEOUT&gt;</code> 格式的<strong>中间键值对</strong>输出。此时的输出键为单词，输出值为单词计数，默认为 1。即经由 Mapper 处理后，原本的“一行”数据被转换为了形如 <code>[&lt;&quot;a&quot;, 1&gt;, &lt;&quot;b&quot;, 1&gt;, &lt;&quot;c&quot;, 1&gt;]</code> 的中间数据。</p>
<p>中间数据是暂时数据，不会存入 HDFS，但是会存入运行 Map 任务节点的本地磁盘，经过数据混洗后被 Reducer 端消费。</p>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>由于 Reduce 任务与 Map 任务与不一定处于同一节点上，Reduce 任务会通过网络通信拉取多个 Map 任务产生的中间数据。数据从 Map 任务端传输给 Reduce 任务端的过程被称为<strong>数据混洗</strong>。</p>
<p>混洗之后传入给 Reducer 的输入键值对的值，是该键对应的值的集合（可迭代对象），如 <code>&lt;&quot;a&quot;, [1, 2, 1]&gt;</code>。值可能为 2 是因为，为了减少磁盘写入和网络传输的数据量，Map 任务可能会在本地节点上预先聚合，这也就是 Combiner 所做的工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text word, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            sum += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(word, <span class="keyword">new</span> IntWritable(sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过 reduce 函数处理后，单词的所有计数值被累加，输出形如 <code>&lt;&quot;a&quot;, 4&gt;</code> 的键值对。</p>
<h2 id="MapReduce-工作流程详解"><a href="#MapReduce-工作流程详解" class="headerlink" title="MapReduce 工作流程详解"></a>MapReduce 工作流程详解</h2><p>MapReduce 将处理过程分成两个大类阶段：Map 阶段和 Reduce 阶段。在 Map 阶段，由于任务分发基于数据本地化原则，Map 任务运行在包含有该任务处理数据的节点上，数据存储在当前节点的 HDFS DataNode 中。因此，Map 阶段处理的都是本地数据，不需要进行网络传输。Map 阶段产生的中间数据将会暂存在当前节点上，Reduce 阶段需要从相关节点上拉取数据进行聚合运算，再将结果写入 HDFS。因此，Reduce 阶段既需要磁盘读写，也需要网络传输。</p>
<p>当然，MapReduce 在工作时还要细分为许多小阶段，下面这张图很好的展示了 MapReduce 的整个工作流程，具体包括：数据读入阶段、Mapper 处理阶段、优化性阶段 Combiner、中间数据分区 Partitioner 阶段、被称为 MapReduce “心脏”的数据混洗 Shuffle 阶段、Reducer 处理阶段以及数据写入阶段。</p>
<p><img src="/2021/10/22/%E7%BB%93%E5%90%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MapReduce-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2.jpg" alt="9b17e681d1c5745840c517209dd2808f.jpeg"></p>
<p>从大类阶段上划分，数据混洗之前的阶段都可以划分到 Map 阶段，因为这些步骤都是在本地节点上完成的，不涉及网络传输。而在数据混洗阶段，程序从本地或是集群上的其他节点拉取并拷贝 Mapper 产生的中间数据，提供给 Reducer 作为输入。因此，可以将包括数据混洗及其之后的步骤划分为 Reduce 阶段。事实上，数据混洗的相关类也被定义在 <code>org.apache.hadoop.mapreduce.task.reduce</code> 包下。</p>
<p>下面将结合源码详细介绍各个阶段的工作。</p>
<h3 id="数据读入阶段"><a href="#数据读入阶段" class="headerlink" title="数据读入阶段"></a>数据读入阶段</h3><p>数据被 Mapper 处理前，需要先转换为 Mapper 支持的键值对类型，这个过程由 InputFormat 和 RecordReader 类完成。首先，由 InputFormat 类从 HDFS 读入文件并创建<strong>输入分片</strong>（Input Split），分片为等长的逻辑数据块，比如可能是形如 <code>(input-file-path, start, offset)</code> 的元组。</p>
<p>一个合理的分片大小应该与 HDFS 块大小保持一致，默认为 128 MB。<strong>Hadoop 会在分片数据所在的物理节点寻找一个空闲的 Map 槽，运行 Map 任务</strong>，由该任务运行用户自定义的 map 函数从而处理分片中的每条记录。此时，符合之前所说的数据本地化原则。一旦一个分片跨越两个物理块，由于 HDFS 的分布式存储特性，这两个块极可能位于不同的 DataNode 上，此时分片中的部分数据就需要通过网络传输到 Map 任务运行的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputFormat</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;InputSplit&gt; <span class="title">getSplits</span><span class="params">(JobContext context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> RecordReader&lt;K, V&gt; <span class="title">createRecordReader</span><span class="params">(InputSplit split, TaskAttemptContext context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InputFormat 会为一个分片创建一个 RecordReader 对象，负责将输入分片转换为 Mapper 可处理的键值对。从数据视图角度看，输入数据字节流被转换为了面向记录的视图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordReader</span>&lt;<span class="title">KEYIN</span>, <span class="title">VALUEIN</span>&gt; <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">nextKeyValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KEYIN <span class="title">getCurrentKey</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> VALUEIN <span class="title">getCurrentValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mapper-阶段"><a href="#Mapper-阶段" class="headerlink" title="Mapper 阶段"></a>Mapper 阶段</h3><p>在这个阶段，Mapper 会执行用户定义的 map 函数，并将输入的键值对转换为中间键值对序列。在 MapTask 类中，使用新版本的 Mapper 会直接调用 <code>mapper.run()</code> 方法运行，旧版本还需要由包装有 Mapper 的 MapRunner 来运行。新版的 API 中，允许用户覆盖 <code>run()</code> 方法，以及 Context 对象的生命周期方法，来做到对 Mapper 执行的完全控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mapper</span>&lt;<span class="title">KEYIN</span>, <span class="title">VALUEIN</span>, <span class="title">KEYOUT</span>, <span class="title">VALUEOUT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(KEYIN key, VALUEIN value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        context.write((KEYOUT) key, (VALUEOUT) value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        setup(context);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (context.nextKeyValue()) &#123;</span><br><span class="line">                map(context.getCurrentKey(), context.getCurrentValue(), context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cleanup(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：Map 阶段的整个工作流程，可以在 MapTask 类的 <code>run()</code> 和 <code>runNewMapper()</code> 或 <code>runOldMapper()</code> 方法中清晰的一览。</p>
<h3 id="Partitioner-阶段"><a href="#Partitioner-阶段" class="headerlink" title="Partitioner 阶段"></a>Partitioner 阶段</h3><p>与 Map 任务不同，Reduce 任务并不具备数据本地化的优势，单个 Reduce 任务的输入通常来自于所有 Mapper 的输出。因此，即使 Reduce 任务与某些个 Map 任务处于同一节点上，也不可避免的需要通过网络传输从其他节点上获取 Mapper 输出。</p>
<p>当只有一个 Reduce 任务时，这个 Reduce 任务会读取所有 Mapper 输出，此时对中间数据分区意义不大，因为所有 Mapper 输出都被写入同一文件。但当有多个 Reduce 任务时，为提高数据吞吐量，<strong>每个 Map 任务会针对输出进行分区（Partition），即为每个 Reduce 任务创建一个分区</strong>。同一个键对应的键值对记录都被划分在同一分区中，每个分区中可以包含许多键（及其对应的值）。并且，一个分区中的记录是<strong>按键排序</strong>的，这样，磁盘读取一个键的所有记录时能保证读取连续数据，而不是从零散的文件中再过滤数据。</p>
<h4 id="数据溢写"><a href="#数据溢写" class="headerlink" title="数据溢写"></a>数据溢写</h4><p><img src="/2021/10/22/%E7%BB%93%E5%90%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MapReduce-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/3.png" alt="20cbf28f315007e05a1c762915a25ca2.png"></p>
<p>每个 Map 任务有一个环形内存缓冲区，缓冲区大小由 <code>io.sort.mb</code> 指定，默认 100MB。Mapper 产生的中间键值对记录将被先写入缓冲区，当达到缓冲区设定阈值时（<code>io.sort.spill.percent</code>，默认 80%），会开启一个线程将内容<strong>溢写</strong>（spill）到磁盘，由 <code>mapred.local.dir</code> 属性指定的目录。线程工作的同时，Mapper 的输出继续被写到缓冲区，如果在此期间缓冲区被写满，Mapper 将会阻塞直到溢写过程结束。</p>
<p><strong>每次缓冲区达到溢出阈值，就会新建一个溢出文件，键值对会在内存中先按键排序然后写入文件</strong>。在任务完成前，溢出文件会不断合并并保证文件中数据是有序的。</p>
<p>数据溢写会写入运行 Map 任务节点的本地磁盘，并不会写入 HDFS（但 Reducer 的输出并不是这样）。这是因为，Map 任务运行的输入分片来自本地节点，输出也应写入本地节点，这样保证了整个 Map 任务的数据本地化。而写入 HDFS 则会为数据创建分布式副本，带来额外网络开销。更何况，Map 任务产生的输出只是暂时数据，任务执行完毕后会被删除。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>下面我们通过阅读 <code>org.apache.hadoop.mapred.MapTask</code> 类的相关源码，来加深对 Map 任务将中间键值对分区、排序存入磁盘过程的理解。Hadoop 使用 OutputCollector 将 Mapper 数据写入磁盘，由于继承/实现的类不同，MapTask 类中存在 Old/NewOutputCollector 两套新旧收集器。以新版 NewOutputCollector 为例，它的实现逻辑如下：</p>
<ul>
<li>首先，创建一个排序收集器 collector，具体的排序逻辑在 MapOutputBuffer 类中，其实现了 IndexedSortable 接口的 <code>compare()</code> 方法，按键进行排序；</li>
<li>从作业上下文（配置）中获取 Reduce 任务总数；</li>
<li>当 Reduce 任务数大于一时，通过反射创建 Partitioner 类的实例，这个类可以是用户自定义的类，并在配置阶段注入；</li>
<li>如果 Reduce 任务数等于零（纯 Map 作业）或等于一，创建匿名内部类，返回的分区号为固定值，所有输出写到同一分区；</li>
<li>写入阶段通过收集器的 <code>collect()</code> 方法，将键值对按照分区号写入对应分区。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NewOutputCollector</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">RecordWriter</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MapOutputCollector&lt;K,V&gt; collector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Partitioner&lt;K,V&gt; partitioner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partitions;</span><br><span class="line"></span><br><span class="line">    NewOutputCollector(JobContext jobContext, JobConf job, TaskUmbilicalProtocol umbilical, TaskReporter reporter) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        collector = createSortingCollector(job, reporter);</span><br><span class="line">        partitions = jobContext.getNumReduceTasks();</span><br><span class="line">        <span class="keyword">if</span> (partitions &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            partitioner = (Partitioner&lt;K,V&gt;) ReflectionUtils.newInstance(jobContext.getPartitionerClass(), job);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            partitioner = <span class="keyword">new</span> Partitioner&lt;K,V&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(K key, V value, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> partitions - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(K key, V value)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        collector.collect(key, value, partitioner.getPartition(key, value, partitions));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Partitioner 类位于 <code>org.apache.hadoop.mapreduce</code> 包下，其作用是返回一个整型分区号，Map 任务将这个分区号作为写入哪个分区的标识。用户可以自定义分区函数，需要继承 Partitioner 类。通常，默认的分区函数 HashPartitioner 足够用了，它使用哈希函数，将键进行哈希后取非负（前置位补零）然后对 Reduce 任务总数取模。这样，能保证键相同的记录被分配至同一分区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashPartitioner</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/** Use &#123;<span class="doctag">@link</span> Object#hashCode()&#125; to partition. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(K key, V value, <span class="keyword">int</span> numReduceTasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashPartitioner 足够高效，但如果你执行的 MapReduce 作业发生数据倾斜的问题（如存在大部分相同键），可以考虑自定义分区函数，比如加入随机值。</p>
<h4 id="Reduce-任务数设置"><a href="#Reduce-任务数设置" class="headerlink" title="Reduce 任务数设置"></a>Reduce 任务数设置</h4><p>Hadoop MapReduce 的<strong>并行度</strong>取决于 Map 任务数量和 Reduce 任务数量。Map 任务数量不需要手动设置，原因是该数量等于输入文件被划分成的分片数，框架会为一个输入分片分配一个 Map 任务。Map 任务数据取决于输入文件的大小以及 HDFS 文件块的大小。默认情况下，输入分片大小与块大小保持一致，均为 128 MB。</p>
<p>Reduce 任务数量可以在作业配置时通过 <code>job.setNumReduceTasks()</code> 手动设置。默认情况下，只有一个 Reduce 任务，这对于本地小规模数据已经足够了。但在真实应用中，几乎所有作业都将它设置为一个较大的数字，否则，所有的中间数据都被传输给一个 Reduce 任务，作业处理极其低效。</p>
<p>为一个作业设置多少个 Reduce 任务数，与其说是一门技术，不如说更多是一门艺术。由于并行化程度提高，增加 Reducer 能缩短 Reduce 阶段整体耗时。并且，增加的 Reducer 对于解决数据倾斜问题通常能有很好的帮助。然而，如果配置了过多 Reducer，文件将被切分为更多小文件，磁盘 I/O 次数将显著增加，这又不够优化。相对于大批量的小文件，Hadoop 更适合处理少量的大文件。一条经验法则是，目标 Reducer 保持在每个运行 5 分钟左右，且产生至少一个 HDFS 块的输出比较合适。</p>
<h3 id="Combiner-阶段"><a href="#Combiner-阶段" class="headerlink" title="Combiner 阶段"></a>Combiner 阶段</h3><p>为了减少 Map 和 Reduce 任务之间的数据传输量，Hadoop 允许用户针对 Map 任务指定一个 Combiner 类。以统计词频程序为例，Mapper 输出的键值对 <code>&lt;单词，计数值&gt;</code> 的计数值初始均为一，此时可通过 Combiner 将相同键的值进行聚合，即计数值累加。这样，同一个 Mapper （来自同一输入分片）的处理数据将被提前聚合，既减少了磁盘写入数据量，也减少了需要通过网络传输给 Reducer 的数据量。因此 Combiner 也被称为 “Mini-reducer” 或 “Local-reducer”，意指在本地节点完成的。</p>
<p><img src="/2021/10/22/%E7%BB%93%E5%90%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MapReduce-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/4.png" alt="e58767ee9dfc6d8bf818f639a0508b7f.png"></p>
<p>Combiner 工作在文件溢写的前后，具体是在 MapTask 的内部类的 <code>sortAndSpill() </code> 和 <code>mergeParts()</code> 方法中，由 <code>combinerRunner.combine()</code> 运行。在 Mapper 输出的键值对被溢写到磁盘之前，会在内存中按键排序，如果定义了 Combiner，它将在排序后的输出上运行，经过 Combiner 紧凑后的数据再写入磁盘。在溢出文件合并阶段，如果至少存在 3 个溢出文件（由 <code>mapreduce.map.combine.minspills</code> 属性指定），那么 Combiner 将会在文件合并时再次运行。因此，Combiner 可能会在 Mapper 输出上反复运行。如果只有 1 或 2 个溢出文件，此时说明 Mapper 输出吞吐量降低，因而不值得调用 Combiner 带来额外开销。</p>
<p>由于 Combiner 与 Reducer 聚合逻辑相同，Hadoop 没有提供额外的 Combiner 类，而是通过 Reducer 类复用。新版的 CombinerRunner 代码如下，它通过反射获取了一个 Reducer 实例，直接运行 Reducer 的 <code>run()</code> 方法进行数据聚合，聚合结果由上下文对象传入 OutputCollector 中，最后写入磁盘。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NewCombinerRunner</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">CombinerRunner</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(RawKeyValueIterator iterator, OutputCollector&lt;K, V&gt; collector)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// make a reducer</span></span><br><span class="line">        Reducer&lt;K, V, K, V&gt; reducer = (Reducer&lt;K, V, K, V&gt;) ReflectionUtils.newInstance(reducerClass, job);</span><br><span class="line">        Context reducerContext = createReduceContext(reducer, job, taskId,</span><br><span class="line">                iterator, <span class="keyword">null</span>, inputCounter,</span><br><span class="line">                <span class="keyword">new</span> OutputConverter(collector),</span><br><span class="line">                committer,</span><br><span class="line">                reporter, comparator, keyClass,</span><br><span class="line">                valueClass);</span><br><span class="line">        reducer.run(reducerContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户在声明作业配置时可以直接复用定义好的 Reducer 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">job.setReducerClass(IntSumReducer.class);</span><br></pre></td></tr></table></figure>

<h3 id="Shuffler-阶段"><a href="#Shuffler-阶段" class="headerlink" title="Shuffler 阶段"></a>Shuffler 阶段</h3><p>数据混洗（Shuffle）被称为是 MapReduce 的“心脏”，是奇迹发生的地方。从宏观上，它体现为从 Map 任务端到 Reduce 任务端的数据流处理过程，具体说即是 <strong>Mapper 产生的中间键值对被重新组织（排序、分区），写入到本地磁盘中（溢写），Reducer 从多个 Mapper 工作节点上拷贝、合并数据</strong>的过程。最终目的是将数据从 Mapper 端发送到 Reducer 端，中间过程则是 MapReduce 框架基于性能考量的优化过程。从下图你可以清晰的体会到为什么这个过程被称为“数据混洗”。</p>
<p><img src="/2021/10/22/%E7%BB%93%E5%90%88%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MapReduce-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/5.png" alt="2abd2dc93aa589f4b1d42b451b2b873c.png"></p>
<p>在微观上，Shuffle 被划分为了 Reduce 任务阶段的工作，定义在 <code>org.apache.hadoop.mapreduce.task.reduce</code> 包内。它是一个具体类，是框架定义的 <code>ShuffleConsumerPlugin&lt;K, V&gt;</code> 接口的内置实现类。从接口命名上可以体现出它作为 Mapper 端输出数据“消费者”的身份，“插件”则体现了它的可插拔特性，框架允许用户使用除了内置实现以外的三方插件。</p>
<p>在 ReduceTask 类的 <code>run()</code> 方法中通过反射获取了一个 Shuffle 类实例。<code>job.getClass()</code> 的第一个参数是三方插件的配置地址，第二个值 <code>Shuffle.class</code> 即为默认的内置实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReduceTask</span> <span class="keyword">extends</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(JobConf job, <span class="keyword">final</span> TaskUmbilicalProtocol umbilical)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ShuffleConsumerPlugin shuffleConsumerPlugin = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;? extends ShuffleConsumerPlugin&gt; clazz = job.getClass(MRConfig.SHUFFLE_CONSUMER_PLUGIN, Shuffle.class, ShuffleConsumerPlugin.class);</span><br><span class="line">        shuffleConsumerPlugin = ReflectionUtils.newInstance(clazz, job);</span><br><span class="line"></span><br><span class="line">        shuffleConsumerPlugin.init(shuffleContext);</span><br><span class="line">        rIter = shuffleConsumerPlugin.run();</span><br><span class="line">        <span class="keyword">if</span> (useNewApi) &#123;</span><br><span class="line">            runNewReducer(job, umbilical, reporter, rIter, comparator, keyClass, valueClass);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            runOldReducer(job, umbilical, reporter, rIter, comparator, keyClass, valueClass);</span><br><span class="line">        &#125;</span><br><span class="line">        shuffleConsumerPlugin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shuffle 类的 <code>run()</code> 方法，是数据混洗步骤真正的具体实现。</p>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p>在一个 Map 任务完成后，会通过心跳包通知 JobTracker，这样，JobTracker 就能获取 Map 输出与主机位置之间的映射关系，Reduce 任务中的一个线程定期询问 JobTracker 以获取 Map 输出位置，直到获取所有输出位置。当一个 Map 任务完成后，Reduce 任务就可以开始复制了，这就是 <strong>Reduce 任务的复制（copy）阶段</strong>。此过程由并发线程完成，默认是 5 个线程，由 <code>mapreduce.reduce.shuffle.parallelcopies</code> 属性指定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shuffle</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ShuffleConsumerPlugin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">ExceptionReporter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RawKeyValueIterator <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// Start the map-completion events fetcher thread</span></span><br><span class="line">        <span class="keyword">final</span> EventFetcher&lt;K, V&gt; eventFetcher = <span class="keyword">new</span> EventFetcher&lt;K, V&gt;(reduceId, umbilical, scheduler, <span class="keyword">this</span>, maxEventsToFetch);</span><br><span class="line">        eventFetcher.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the map-output fetcher threads</span></span><br><span class="line">        <span class="keyword">boolean</span> isLocal = localMapFiles != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numFetchers = isLocal ? <span class="number">1</span> : jobConf.getInt(MRJobConfig.SHUFFLE_PARALLEL_COPIES, <span class="number">5</span>);</span><br><span class="line">        Fetcher&lt;K, V&gt;[] fetchers = <span class="keyword">new</span> Fetcher[numFetchers];</span><br><span class="line">        <span class="keyword">if</span> (isLocal) &#123;</span><br><span class="line">            fetchers[<span class="number">0</span>] = <span class="keyword">new</span> LocalFetcher&lt;K, V&gt;(jobConf, reduceId, scheduler, merger, reporter, metrics, <span class="keyword">this</span>, reduceTask.getShuffleSecret(), localMapFiles);</span><br><span class="line">            fetchers[<span class="number">0</span>].start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numFetchers; ++i) &#123;</span><br><span class="line">                fetchers[i] = <span class="keyword">new</span> Fetcher&lt;K, V&gt;(jobConf, reduceId, scheduler, merger, reporter, metrics, <span class="keyword">this</span>, reduceTask.getShuffleSecret());</span><br><span class="line">                fetchers[i].start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shuffle 使用名为 Fetcher 的线程类进行数据复制，如果 Reduce 任务恰好就处于运行 Map 任务的节点上，此时不需要网络通信，直接通过 LocalFetcher 获取本地数据。否则，使用 Fetcher 通过 HTTP 通信拉取相关节点上的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If merge is on, block</span></span><br><span class="line">        merger.waitForResource();</span><br><span class="line">        <span class="comment">// Get a host to shuffle from</span></span><br><span class="line">        host = scheduler.getHost();</span><br><span class="line">        metrics.threadBusy();</span><br><span class="line">        <span class="comment">// Shuffle</span></span><br><span class="line">        copyFromHost(host);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：拉取后的数据是写入内存还是写入磁盘，是由 MapOutput 类的 <code>shuffle()</code> 方法完成的，该类拥有两个具体子类：InMemoryMapOutput 和 OnDiskMapOutput。</p>
<p>如果 Map 任务输出相当小，会被复制到 Reduce 任务的 JVM 内存缓冲区中，一旦内存缓冲区达到阈值，Map 输出会被复制到磁盘。随着磁盘上副本增多，后台线程会将它们合并为更大的、按键排好序的文件，这就是 Reduce 任务的<strong>合并阶段</strong>（merge）。这个阶段将合并 Map 输出，并维持其按键排序。合并的数据可能来自于内存缓冲区和磁盘文件。</p>
<p>合并阶段按照预先设定的合并因子（默认为 10），每趟合并 10 个文件，所以合并过程是循环进行的。为减少磁盘读写次数，最后一轮的文件合并（包含所有数据）不再写入磁盘，而是直接传送给 Reducer 处理。</p>
<h3 id="Reducer-阶段"><a href="#Reducer-阶段" class="headerlink" title="Reducer 阶段"></a>Reducer 阶段</h3><p>在 Reducer 阶段，对已排序的输出中的每个键调用 reduce 函数。此阶段的输出直接写到输出文件系统，一般为 HDFS，还可以是数据库。如果采用 HDFS，由于 Reduce 任务运行所在的节点也运行 DataNode，所以第一个块副本将被写到本地磁盘中。</p>
<p>用户需要继承 Reducer 并重写 reduce 函数，函数的输入值入参是值的可迭代对象，框架会从文件系统中读取输入键对应的值集合，传入给 reduce 函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reducer</span>&lt;<span class="title">KEYIN</span>, <span class="title">VALUEIN</span>, <span class="title">KEYOUT</span>, <span class="title">VALUEOUT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(KEYIN key, Iterable&lt;VALUEIN&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (VALUEIN value : values) &#123;</span><br><span class="line">            context.write((KEYOUT) key, (VALUEOUT) value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 Mapper 类似，框架也允许用户覆盖 <code>run()</code> 方法，以及 Context 对象的生命周期方法。</p>
<h3 id="数据写入阶段"><a href="#数据写入阶段" class="headerlink" title="数据写入阶段"></a>数据写入阶段</h3><p>数据写入阶段，由 OutputFormat 负责检验作业的输出规范，如输出目录是否已存在。如果写入到文件系统，则由实现子类 FileOutputformat 的 <code>setOutputPath()</code> 方法负责从作业配置中读取输出目录。由 OutputFormat 创建的 RecordWriter 对象负责将 Reducer 产生的键值对数据写到输出文件，每个 Reducer 对应一个文件。此过程无需创建分片。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputFormat</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> RecordWriter&lt;K, V&gt; <span class="title">getRecordWriter</span><span class="params">(TaskAttemptContext context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">checkOutputSpecs</span><span class="params">(JobContext context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> OutputCommitter <span class="title">getOutputCommitter</span><span class="params">(TaskAttemptContext context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MapReduce-的局限"><a href="#MapReduce-的局限" class="headerlink" title="MapReduce 的局限"></a>MapReduce 的局限</h2><p>在 MapReduce 的工作过程中，框架需要频繁地读写文件系统，MapReduce 作业往往又都是数据密集型的，因此大量的中间数据会被往复地写入、读取、合并排序后又写入磁盘。大量的磁盘 I/O 导致 MapReduce 的耗时往往是分钟级、甚至是小时级的。受到 MapReduce 诞生年代的约束，昂贵的内存迫使用户将 Hadoop 集群部署在廉价的商用机器集群上，使用磁盘来进行数据的缓存。大规模的分布式部署使得 MapReduce 程序具有高容错性和良好的横向扩展性优势。</p>
<p>时至今日，用户对数据处理延迟的忍耐性越来越低，在大规模数据批处理之上又诞生了实时性要求极高的流处理系统。不管是 Spark Streaming 还是 Flink 都能做到秒级甚至是毫秒级的响应，MapReduce 因为其性能局限已经跟不上时代的需求。</p>
<p>MapReduce 的函数本身是无状态的，这意味着并不是所有工作 MapReduce 都能胜任，比如需要状态共享和参数依赖的机器学习模型训练算法。尽管 MapReduce 可以通过文件存储状态，但这样带来的性能开销是巨大的。相反，Spark 作为一个基于内存迭代式的大数据计算引擎很适合这样的场景，其提供了有状态的流来应对需要状态共享的作业，通过 <code>updateStateByKey()</code> 和 <code>mapWithState()</code> 状态管理函数共享状态。状态被保存在内存中，后续访问直接从内存中读取。据 Spark 官方统计的 Spark 运行逻辑回归机器学习算法的运行时间要优于 hadoop 一百倍。这也让 Spark 提供机器学习库 Spark MLlib 成为可能。</p>
<p>MapReduce 框架要求用户编写底层的 map 和 reduce 函数，这对于数据分析师是一个考验，Spark SQL 允许数据分析师使用 SQL 语言处理数据，由框架负责将其翻译成底层执行步骤。而且，编写底层函数这样的控制粒度不够灵活，对于一个复杂的作业来说，可能要由多个 MapReduce 作业组合而成，这样又会引入额外的中间数据读写开销。相比之下，Spark 编程模型更灵活，提供了丰富的 Transformation 和 Action 算子。性能方面，Spark 会为作业构建逻辑执行计划图（DAG），并针对其步骤进行优化，减少数据混洗阶段的 I/O 次数。</p>
<p>不管怎么说，MapReduce 作为第一代分布式计算引擎，其后诞生的分布式框架都是在其基础上的演进，因此有必要对 MapReduce 工作原理做个详细了解。Spark 由批处理起家，延续了 MapReduce 编程模型的设计思路。下一节我们将介绍 Spark 的运行原理。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Hadoop 权威指南（第四版）</li>
<li><a href="https://hadoop.apache.org/docs/stable/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html#Mapper">Apache Hadoop 官方文档：MapReduce Tutorial</a></li>
<li><a href="https://techvidvan.com/tutorials/how-mapreduce-works/">Phases of MapReduce – How Hadoop MapReduce Works</a></li>
<li><a href="http://hadoopbeforestarting.blogspot.com/2012/12/difference-between-hadoop-old-api-and.html">Difference  between Hadoop OLD API and NEW API</a></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>网站外链爬虫</title>
    <url>/2021/12/17/%E7%BD%91%E7%AB%99%E5%A4%96%E9%93%BE%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>网站外链爬虫，使用轻量级 Web 应用框架 Flask，以 Restful 接口提供服务，支持容器化部署。项目地址：<a href="https://github.com/s1mplecc/external-link-crawler">https://github.com/s1mplecc/external-link-crawler</a> ，需要 Python 版本 3.x。</p>
<p>对于传入的网站 URL，获取其 HTML 网页，提取外部链接的域名。包含如下几类外链：</p>
<ul>
<li>超链接，标签 <code>a</code> 下的 <code>href</code> 属性；</li>
<li>图片，标签 <code>img</code> 下的 <code>src</code> 属性；</li>
<li>外部样式文件，标签 <code>link</code> 下  <code>href</code> 属性；</li>
<li>外部 JavaScript 脚本文件，标签 <code>script</code> 下  <code>src</code> 属性。</li>
</ul>
<h2 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h2><p>Step 1：克隆项目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/s1mplecc/external-link-crawler.git</span></span><br></pre></td></tr></table></figure>

<p>Step 2：安装依赖，包括 Flask 和 BeautifulSoup4。建议使用 Virtualenv 局部安装依赖。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip3 install -r requirements.txt</span> </span><br></pre></td></tr></table></figure>

<p>Step 3：在 IDE 中运行或通过 Flask 命令行工具启动应用，端口号默认为 5000。生产环境可使用 Gunicorn 部署。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FLASK_ENV=<span class="string">&quot;development&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> flask run</span></span><br><span class="line"> * Environment: development</span><br><span class="line"> * Debug mode: on</span><br><span class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>

<h2 id="容器化部署"><a href="#容器化部署" class="headerlink" title="容器化部署"></a>容器化部署</h2><p>除本地运行之外，也支持在生产环境中使用容器化方式部署，镜像入口脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">gunicorn --worker-class=gevent --worker-connections=1000 -w 4 -b 0.0.0.0:8000 app:app</span><br></pre></td></tr></table></figure>

<p>使用 Gunicorn 启动 Flask 应用。由于爬虫运行效率主要受网络延迟影响，因此为提高并发吞吐量，使用多进程 + 协程方式部署。协程由 Gevent 库支持。参数 <code>-w</code> 指定进程数，每个进程默认最大并发连接数 1000。Gunicorn 应用端口号默认为 8000。</p>
<p>Step 1：拉取镜像。镜像已提交至 Docker Hub 仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull s1mplecc/external-link-crawler</span></span><br></pre></td></tr></table></figure>

<p>也可以在本地手动构建镜像。克隆下项目后，在 Dockerfile 所在目录执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t s1mplecc/external-link-crawler .</span></span><br></pre></td></tr></table></figure>

<p>Step 2：启动容器，映射端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 5000:8000 --name external-link-crawler s1mplecc/external-link-crawler</span></span><br></pre></td></tr></table></figure>

<h2 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h2><ul>
<li>请求类型 GET；</li>
<li>请求前缀 <code>/external-link-domains</code> ；</li>
<li>参数 <code>url</code>，需传入合法 URL，否则返回参数异常状态码。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -XGET <span class="string">&quot;http://127.0.0.1:5000/external-link-domains?url=https://www.zhihu.com/&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="响应格式"><a href="#响应格式" class="headerlink" title="响应格式"></a>响应格式</h2><p>响应体为 JSON 格式，包含如下字段：</p>
<ul>
<li><code>data</code> 字段，数据本体；</li>
<li><code>code</code> 字段，状态码。成功 - 200，参数异常 - 400，服务器内部错误 - 500；</li>
<li><code>messages</code> 字段，附加消息。出错时提示异常信息。</li>
</ul>
<p>响应样例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;css_scripts_domains&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;https://hm.baidu.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://static.zhihu.com&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;css_scripts_domains_size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;href_domains&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;http://www.12377.cn&quot;</span>,</span><br><span class="line">            <span class="string">&quot;http://www.beian.gov.cn&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://app.mokahr.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://beian.miit.gov.cn&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://tsm.miit.gov.cn&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://www.zhihu.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://zhstatic.zhihu.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://zhuanlan.zhihu.com&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;href_domains_size&quot;</span>: <span class="number">8</span>,</span><br><span class="line">        <span class="attr">&quot;img_domains&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;https://pic2.zhimg.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://pic3.zhimg.com&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;img_domains_size&quot;</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;messages&quot;</span>: <span class="string">&quot;[SUCCESS] ok&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数异常响应样例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;messages&quot;</span>: <span class="string">&quot;[BAD_REQUEST] invalid param url value: xyz&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="镜像构建过程"><a href="#镜像构建过程" class="headerlink" title="镜像构建过程"></a>镜像构建过程</h2><p>Step 1：编写 Dockerfile。镜像基于 Python 官方镜像 3.8-slim 精简版本。将整个项目文件拷贝到镜像的工作目录内，在 <code>.dockerignore</code> 中指定忽略拷贝文件。入口文件为 Gunicorn 启动脚本。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> FLASK_WORK_DIR=<span class="string">&quot;/root/flask&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$FLASK_WORK_DIR</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install -r requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install gunicorn gevent</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x gunicorn_starter.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;./gunicorn_starter.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>Step 2：构建镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t s1mplecc/external-link-crawler .</span></span><br></pre></td></tr></table></figure>

<p>Step 3：推送到远端仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker tag s1mplecc/external-link-crawler docker.io/s1mplecc/external-link-crawler</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker push docker.io/s1mplecc/external-link-crawler</span> </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Projects</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移 Ghost 博客并使用 Docker  部署</title>
    <url>/2018/06/24/%E8%BF%81%E7%A7%BB%20Ghost%20%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%BD%BF%E7%94%A8%20Docker%20%20%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>因为阿里云服务器在七月初即将过期，以及生活上的一些琐事，博客已经近一个月没有更新了。考虑到十月份域名也将过期，以及阿里云非学生用户太贵，遂考虑国外的云服务器 <a href="https://www.vultr.com/">Vultr</a>，优点是绑定域名不需要备案，以及按时计费也很方便，缺点是国内访问网速确实比不上阿里云，但同时也跟同学了解到可以使用<strong>锐速</strong>进行优化，这个以后再研究。此外，为将来迁移方便，使用 <strong>Docker</strong> 重新部署 Ghost 博客并制作成镜像上传到云端。这也算我迁移博客后的第一篇文章了。</p>
</blockquote>
<h2 id="Prefaring"><a href="#Prefaring" class="headerlink" title="Prefaring"></a>Prefaring</h2><ul>
<li><p>在 Vultr 的 Servers 界面先新增一个实例，如果能抢到每月 $2.5 的服务器是最好的，然而我没有抢到，所以选择了每月 $5 的服务器，系统为 Ubuntu 16.04，机房在新加坡</p>
</li>
<li><p>在添加实例成功后第一件事是<code>ping</code>一下公网 IP 是否是通的，有些时候分配的 IP 是被大陆给墙了的。<code>ping</code>通后我习惯的首件要事就是添加我的 ssh 公钥以及修改 ssh 的一些策略，比如修改默认端口号、禁用密码登陆之类的，一切都是为安全考虑（吃了第一次的亏，一夜之间异常登陆三十次）</p>
</li>
<li><p>迁移 Ghost 博客之前需要先将原先服务器上的相关文件下载到本地，再上传到新的服务器上。主要包含文章内容，图片以及主题。所幸 Ghost 博客提供了 Export/Import 功能，而且是所有文件导出到一个大 Json 文件中，很方便迁移<br><img src="/0.png" alt="14070DA1-C3CD-4A9F-AE52-D4D2DE4A2CDB">主题也很方便，我之前就将代码上传至 <a href="https://github.com/s1mplecc/ghost-theme-kaldorei">GitHub</a>，克隆下来压缩上传就行。图片稍微麻烦点，需要将 Ghost 目录下的整个<code>content/images</code>文件夹<code>scp</code>到本地，再<code>scp</code>到 Vultr 服务器上，可能要花些时间</p>
</li>
<li><p>接下来去修改你的域名设置，我是在 <a href="https://sg.godaddy.com/zh">GoDaddy</a> 上购买的域名，所以去狗爹网修改配置如下<br><img src="/1.png" alt="64F8A358-E544-4FA3-819C-7F38F5327A5A"></p>
</li>
<li><p>准备工作已经做好，剩下的就是在新服务器上搭建环境和部署博客了。必要的东西也就三个，Nginx 用于做端口映射，Docker 用于运行 Ghost 容器，Certbot 用来配置 Https。Nginx 在 Ubuntu 上安装很简单，使用<code>apt-get</code>命令即可。Certbot 安装在我的另一篇博客<a href="https://s2mple.xyz/configure-https-with-certbot/">Certbot配置Https</a>中有详细介绍。我们着重介绍一下如何安装 Docker</p>
</li>
</ul>
<h2 id="Installing-Docker"><a href="#Installing-Docker" class="headerlink" title="Installing Docker"></a>Installing Docker</h2><blockquote>
<p>参考 <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Docker官方网站</a>，选择自己的操作系统，我的是 Ubuntu 16.04</p>
</blockquote>
<ul>
<li><p>Update the apt package index, Install packages to allow apt to use a repository over HTTPS</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>
</li>
<li><p>Add Docker’s official GPG key</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
</li>
<li><p>Set up the stable repository</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Install the latest version of Docker CE</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Deploying-Ghost"><a href="#Deploying-Ghost" class="headerlink" title="Deploying Ghost"></a>Deploying Ghost</h2><ul>
<li><p>拉取 Ghost 最新的 Docker 镜像</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker pull ghost</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行一个容器实例，<code>-d</code>后台运行，<code>-p 2368:2368</code>绑定宿主机 2368 端口至容器内 2368 端口（必须显式的绑定，不然不会自动映射），这也是 Ghost 默认占用的端口号</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -d -p 2368:2368 ghost</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行后访问<code>&#123;IP&#125;:2368</code>可以成功进入 Ghost 主页，但是现在还有一些问题，就是点击 Home 键跳转的地址为 localhost:2368，我们需要进入到容器内部修改 Ghost 配置文件</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker exec -it 16 bash</span><br></pre></td></tr></table></figure>
<p>  上述命令表示以交互式终端执行容器的<code>bash</code>命令，其中 16 是刚才启动的容器 ID 前两位，可以使用<code>docker ps</code>查看，通常使用可以唯一标识的前几位即可</p>
</li>
<li><p>进入容器后默认在<code>/var/lib/ghost</code>即 Ghost 安装路径下，修改其下的<code>config.production.json</code>配置文件，其实该文件链接到<code>config.development.json</code>，所以修改哪一个都一样，只需要修改 url 和 server 即可</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://s2mple.xyz/&quot;</span>,</span><br><span class="line"><span class="string">&quot;server&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;port&quot;</span>: <span class="number">2368</span>,</span><br><span class="line">    <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>  退出容器后使用<code>docker restart 16</code>重启容器</p>
</li>
<li><p>主题可以在网页上直接上传。图片还需要我们拷贝到容器中，使用如下命令</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker cp images/ 16:/var/lib/ghost/content</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Nginx-amp-Https"><a href="#Nginx-amp-Https" class="headerlink" title="Nginx &amp; Https"></a>Nginx &amp; Https</h2><blockquote>
<p>至此，我们的博客已经算迁移完毕，接下来还剩下两个步骤：1. 配置 Nginx 80 端口转发到 2368 端口；2. 使用 Certbot 配置 Https。</p>
</blockquote>
<h4 id="Configuring-Nginx"><a href="#Configuring-Nginx" class="headerlink" title="Configuring Nginx"></a>Configuring Nginx</h4><ul>
<li><p>前往 <code>/etc/nginx/conf.d/</code> 目录中创建 ghost.conf 配置文件，配置如下</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;                                                                                  </span><br><span class="line">    server_name s1mple.info www.s1mple.info;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_pass http://127.0.0.1:2368;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ /.well-known &#123;</span><br><span class="line">        allow all;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    client_max_body_size 50m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  保存退出后，<code>service nginx restart</code> 重启 Nginx 服务</p>
</li>
</ul>
<h4 id="Configuring-Https"><a href="#Configuring-Https" class="headerlink" title="Configuring Https"></a>Configuring Https</h4><ul>
<li><p>使用 Certbot 工具配置 Https，如何安装运行可以参考我的另一篇博客<a href="https://s2mple.xyz/configure-https-with-certbot/"><br>Certbot配置Https</a>。实际上它会读取 Nginx 配置文件并修改它们，可以发现，配置完成后的 ghost.conf 多了如下一些内容，其中就包括重定位到 Https 端口 443</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    # 省略...</span><br><span class="line"></span><br><span class="line">    listen [::]:443 ssl ipv6only=on; # managed by Certbot</span><br><span class="line">    listen 443 ssl; # managed by Certbot</span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/s2mple.xyz/fullchain.pem; # managed by Certbot</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/s2mple.xyz/privkey.pem; # managed by Certbot</span><br><span class="line">    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    if ($host = www.s1mple.info) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ($host = s1mple.info) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line">    listen 80; </span><br><span class="line">    listen [::]:80;</span><br><span class="line"></span><br><span class="line">    server_name s1mple.info www.s1mple.info;</span><br><span class="line">    return 404; # managed by Certbot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  大功告成！现在就可以通过 <a href="https://s2mple.xyz/">https://s2mple.xyz/</a> 访问我的博客网站了！</p>
</li>
</ul>
<h2 id="Docker-image"><a href="#Docker-image" class="headerlink" title="Docker image"></a>Docker image</h2><blockquote>
<p>接下来我们将经过修改的容器（包含文章、图片、Kaldorei 主题、修改后的配置文件）提交为一个镜像，上传到云端。以后迁移直接<code>pull</code>下来即可。可以参考我之前的博客 <a href="https://s2mple.xyz/build-docker-images/">构建你的Docker镜像</a></p>
</blockquote>
<ul>
<li><p>首先需要在 <a href="https://cloud.docker.com/">Docker Cloud官网</a> 注册自己的账号，然后在服务器使用命令登陆</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker login</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">// username</span><br><span class="line">// password</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Docker Cloud 中创建一个新的仓库，命名为 myghost 。将当前容器提交为一个镜像，不加标签默认 latest</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker commit 16 s1mple1995/myghost</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看本地的 Docker 镜像，有两个，一个是原始的 ghost 镜像，一个是刚刚提交的镜像</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">s1mple1995/myghost   latest              e11def1af177        15 seconds ago      613MB</span><br><span class="line">ghost                latest              a375d6b66f06        4 weeks ago         574MB</span><br></pre></td></tr></table></figure>
</li>
<li><p>将镜像<code>push</code>到云端，等待上传完成</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker push s1mple1995/myghost</span><br></pre></td></tr></table></figure></li>
<li><p>现在镜像已经存放在 Docker Cloud 云端了，搜索你的镜像，随时随地可以<code>pull</code>下来</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker search s1mple1995</span><br><span class="line">NAME                      DESCRIPTION                    STARS               OFFICIAL            AUTOMATED</span><br><span class="line">s1mple1995/get-started    学习初步使用                         1                                       </span><br><span class="line">s1mple1995/java-web-env   Java Web程序的运行环境                0                                       </span><br><span class="line">s1mple1995/jpress         jpress blog                    0                                       </span><br><span class="line">s1mple1995/ubuntu         基于官方ubuntu镜像，更改为阿里云软件源，并安…     0                                       </span><br><span class="line">s1mple1995/myghost        我的 Ghost 镜像，包含了文章、图片和主题（ Ka…   0 </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><blockquote>
<p>总的来说，使用 Docker 部署 Ghost 的话可以方便许多。而且制作成镜像上传到云端的话，以后可以直接<code>pull</code>下来，图片、文章、主题都在镜像中了，顶多是更换域名要修改 Ghost 的配置文件。除此之外，更换域名后文章中的域名也需要全量替换，这个我打算以后要换域名的时候写个 Python 脚本来完成。</p>
</blockquote>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移 Ghost 博客至 Hexo 并使用 GitHub Pages 部署</title>
    <url>/2018/12/27/%E8%BF%81%E7%A7%BB-Ghost-%E5%8D%9A%E5%AE%A2%E8%87%B3-Hexo-%E5%B9%B6%E4%BD%BF%E7%94%A8-GitHub-Pages-%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="为什么迁移"><a href="#为什么迁移" class="headerlink" title="为什么迁移"></a>为什么迁移</h2><h3 id="Ghost"><a href="#Ghost" class="headerlink" title="Ghost"></a>Ghost</h3><p>优点：</p>
<ol>
<li>提供后台管理界面，支持在线编辑文章，随时更新随时发布。</li>
<li>图片上传方便，直接拷贝到正文即可，会自动上传到服务器并生成 Markdown 链接。</li>
<li>支持多人同时使用，可用作团队博客。</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要在服务器上部署 Ghost。</li>
<li>本地和服务器端文章同步麻烦（这也是我换用 Hexo 的主要原因）。</li>
<li>不支持离线编辑文章。虽说这个可以本地写完了再一次性拷贝到服务器上，但这又回到了第 2 点。</li>
<li>Themes 配置麻烦，不够统一。Kaldorei 主题是我废了很大劲才搜罗到的，还得每次修改完源码后压缩上传（调样式的时候调的我头疼）。</li>
</ol>
<p><img src="/2018/12/27/%E8%BF%81%E7%A7%BB-Ghost-%E5%8D%9A%E5%AE%A2%E8%87%B3-Hexo-%E5%B9%B6%E4%BD%BF%E7%94%A8-GitHub-Pages-%E9%83%A8%E7%BD%B2/0.png" alt="dbdd8ad99f065192aa340cf474709b2d.png"><br><img src="/2018/12/27/%E8%BF%81%E7%A7%BB-Ghost-%E5%8D%9A%E5%AE%A2%E8%87%B3-Hexo-%E5%B9%B6%E4%BD%BF%E7%94%A8-GitHub-Pages-%E9%83%A8%E7%BD%B2/1.png" alt="fa0a3c8ae59030f8e5ef80a9b04d8c7d.png"></p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>优点：</p>
<ol>
<li>文档本地化。在本地编写博客，一条指令即可生成静态网页（具体体现就是你在 <code>source/_posts</code> 下编写 Markdown，写完了执行 <code>hexo g</code> 就可以生成样式美观的 <code>index.html</code>）。</li>
<li>一条指令即可部署到 GitHub Pages，不需要额外的服务器（配合第 1 条超级好用好嘛！）。</li>
<li>丰富的插件和主题，配置也统一化了。比如图中我使用的 Next 主题，主题的配置修改 <code>theme/next/_config.yml</code>；Hexo 的配置修改主目录的 <code>_config.yml</code> 即可。</li>
<li>图片上传还算方便。在与文章同名的文件夹下保存图片即可。这个下面会细说。</li>
</ol>
<p><img src="/2018/12/27/%E8%BF%81%E7%A7%BB-Ghost-%E5%8D%9A%E5%AE%A2%E8%87%B3-Hexo-%E5%B9%B6%E4%BD%BF%E7%94%A8-GitHub-Pages-%E9%83%A8%E7%BD%B2/2.png" alt="6bc65c0ff0fb6d62ea90ce4c35c04ac9.png"><br><img src="/2018/12/27/%E8%BF%81%E7%A7%BB-Ghost-%E5%8D%9A%E5%AE%A2%E8%87%B3-Hexo-%E5%B9%B6%E4%BD%BF%E7%94%A8-GitHub-Pages-%E9%83%A8%E7%BD%B2/3.png" alt="8b1c5aa127adbfef220cfb30a6d55e1d.png"></p>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="创建-GitHub-Pages-仓库"><a href="#创建-GitHub-Pages-仓库" class="headerlink" title="创建 GitHub Pages 仓库"></a>创建 GitHub Pages 仓库</h3><p>GitHub Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 GitHub 上，你可以选择使用 GitHub Pages 默认提供的域名 <code>github.io</code> 或者自定义域名来发布站点。</p>
<p>GitHub Pages 分为两类，用户主页和项目主页。我们需要部署的是用户主页。需要在 GitHub 上新建一个仓库，<strong>仓库名必须为</strong> <code>$&#123;github-username&#125;.github.io</code>，这样才会被识别为用户主页。用户主页是唯一的，填其他名称只会被当成普通项目。通过 <code>https://$&#123;github-username&#125;.github.io</code> 进行访问。</p>
<p>创建完成后将仓库 clone 至本地。</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>GitHub Pages 会自动部署静态网页文件，并<strong>将 master 分支作为部署的默认分支</strong>。为将静态网页和源文件（包含文章、主题等）分离开，强烈建议创建新分支。<code>git checkout -b hexo</code> 创建 hexo 分支。<strong>应当只将 master 分支当作静态网页的发布分支，而文档编辑和 Hexo 命令操作等都在 hexo 分支上完成</strong>。这样在执行 <code>hexo generate -deploy</code> 时就会将生成的静态文件（整个 <code>public</code> 文件夹）发布到 GitHub 的 master 分支上。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  github.io git:(hexo) ✗ git branch -v    </span><br><span class="line"></span><br><span class="line">* hexo                  0d03653 dump ghost markdown files to hexo</span><br><span class="line">  master                673d037 initial commit</span><br></pre></td></tr></table></figure>

<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>Hexo 和 Ghost 一样，都是使用 Node.js 编写的，所以使用 npm 安装。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>完成后执行 <code>hexo -v</code> 验证是否正确安装。</p>
<h3 id="生成-Hexo-项目"><a href="#生成-Hexo-项目" class="headerlink" title="生成 Hexo 项目"></a>生成 Hexo 项目</h3><p>现在你可以使用 <code>hexo</code> 命令了，在生成 Hexo 项目前需要确保一件事：你已将 Git 仓库 clone 至本地，并且处于 hexo 分支上。由于只能在<strong>空文件夹</strong>下生成 Hexo 项目，所以我们先将 <code>.git</code> 文件夹整个移出去，然后执行 <code>hexo init</code> 命令。最后别忘了将 <code>.git</code> 文件夹移回来。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  github.io git:(hexo) ✗ mv .git ../</span><br><span class="line">➜  github.io ✗ hexo init </span><br><span class="line">➜  github.io ✗ mv ../.git ./</span><br></pre></td></tr></table></figure>

<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  github.io git:(hexo) ✗ ls -F         </span><br><span class="line">_admin-config.yml  node_modules/      public/            themes/</span><br><span class="line">_config.yml        package-lock.json  scaffolds/         yarn.lock</span><br><span class="line">db.json            package.json       <span class="built_in">source</span>/</span><br></pre></td></tr></table></figure>

<p>主要打交道的是下面这几个文件：</p>
<ul>
<li><code>_config.yml</code> Hexo 的配置文件，你的自定义配置会在该文件中修改</li>
<li><code>scaffolds/</code> 保存了 hexo 生成新文章所用的模版文件</li>
<li><code>source/</code> 主要保存文章的 Markdown 源文件</li>
<li><code>themes/</code> 保存主题的源代码</li>
<li><code>public/</code> 生成的静态文件，包括图片、Tags、Categories 等都保存在这里。执行 <code>hexo g</code> 生成；<code>hexo clean</code> 则会清空该文件夹。部署到 GitHub Pages 上的亦即该文件夹下的内容。</li>
</ul>
<h3 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h3><p>最开始 <code>source</code> 文件夹中会自带一篇介绍 Hexo 的文章，我们可以直接拿它来测试部署是否成功。</p>
<p>Hexo 支持本地启动，命令为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo serve</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>启动后访问 <code>http://localhost:4000</code>，就应该能看到自带的那篇文章。但为了能部署到 GitHub Pages 上，我们还需要做两件事：<strong>安装插件</strong>和<strong>修改配置</strong>。</p>
<p>在项目所在目录下执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>修改 <code>_config.yml</code> 将 repo 指定为自己的仓库地址，发布到的分支默认为 master：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>现在，执行如下命令即可将发布文章：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo generate -deploy</span></span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>访问你的网址 <code>https://$&#123;github-username&#125;.github.io</code> 去见证成果吧！</p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>Hexo 自带的默认主题是 landscape，不过我们可以从 <a href="https://hexo.io/themes/">Hexo主题库</a> 或 GitHub 上找到自己喜欢的主题。Next 是 Hexo 最受欢迎的主题之一，下面我将用它向大家演示如何更换主题。</p>
<p>Ps: 目前 Next 主题已经升级到 v6.0 版本以上，GitHub 上的仓库从原先的旧版本（v5.1.4 及以下）：<code>https://github.com/iissnan/hexo-theme-next</code> 迁移到了新仓库中：<code>https://github.com/theme-next/hexo-theme-next</code>，目前版本是 v6.6.0。如果安装的是 v5 版本，在启动时会提示升级。</p>
<p><strong>下载源码</strong>，直接将 Next 项目克隆到 Hexo 目录的 <code>themes</code> 文件夹下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p><strong>启用 Next 主题</strong>，修改 Hexo 的 <code>_config.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># theme: landscape</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>v6.0 版本以上的 <a href="https://theme-next.org/docs/getting-started/">Next官方文档</a> 也做了迁移，描述的很详细，包含了主题设置、三方服务和插件的配置等。所有要找的 <code>themes/next/_config.yml</code> 中的配置项在官方文档中都能找到。</p>
<h2 id="更换域名"><a href="#更换域名" class="headerlink" title="更换域名"></a>更换域名</h2><p>部署到 GitHub Pages 上会提供 <code>https://$&#123;github-username&#125;.github.io</code> 默认的域名以供访问。除此之外，GitHub Pages 也提供绑定自定义域名的功能。</p>
<p>首先，你需要在阿里云万网、腾讯云或者 GoDaddy 上购买域名（我选择 GoDaddy 是因为它不需要备案），然后<strong>配置域名解析</strong>。下表是我的个性域名 <code>s1mple.online</code> 的配置项。其中：</p>
<ul>
<li>CNAME 项用于将所有 <code>*.s1mple.online</code> 包含三级域名（不包括 <code>s1mple.online</code>）的访问路由到 <code>s1mplecc.github.io</code>。</li>
<li>A 项将二级域名 <code>s1mple.online</code> 路由到 <code>192.30.252.153</code>。此值可通过 <code>ping s1mplecc.github.io</code> 获得。</li>
</ul>
<table>
<thead>
<tr>
<th>记录类型</th>
<th>记录类型</th>
<th>记录值</th>
</tr>
</thead>
<tbody><tr>
<td>记录类型</td>
<td>主机记录</td>
<td>记录值</td>
</tr>
<tr>
<td>CNAME</td>
<td>*</td>
<td>s1mplecc.github.io</td>
</tr>
<tr>
<td>A</td>
<td>@</td>
<td>192.30.252.153</td>
</tr>
</tbody></table>
<p>第二步，在本地 Hexo 的 <code>source</code> 文件夹下添加<strong>名为 CNAME 的文件</strong>，内容为个人域名地址，比如我的 <code>s1mple.online</code>。并执行 <code>hexo g -d</code> 部署到服务器。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;s1mple.online&#x27;</span> &gt; ./<span class="built_in">source</span>/CNAME</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>第三步，在 GitHub Pages 项目的配置中<strong>绑定个人域名</strong>，记得将 Enforce HTTPS 选项勾选上（GitHub 提供免费的 HTTPS 服务）。保存成功后如下图提示即可通过 <code>https://s1mple.online</code> 访问。</p>
<p><img src="/2018/12/27/%E8%BF%81%E7%A7%BB-Ghost-%E5%8D%9A%E5%AE%A2%E8%87%B3-Hexo-%E5%B9%B6%E4%BD%BF%E7%94%A8-GitHub-Pages-%E9%83%A8%E7%BD%B2/5.png" alt="5"></p>
<h2 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h2><p>当项目中只用到少量图片时，可以将图片统一放在 <code>source/images</code> 文件夹中，通过绝对路径访问。比如头像。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Markdown</span></span><br><span class="line"><span class="type">![avatar](/images/avatar.jpeg)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># themes/next/_config.yml</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpeg</span></span><br></pre></td></tr></table></figure>

<p>除此之外，图片还可以放在 <code>source/_posts</code> 下与文章同名的目录中。需要先将 Hexo 配置文件中的开关打开。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo _config.yml</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>这样在执行 <code>hexo new xxx</code> 后会在 <code>source/_posts</code> 中会生成文章 <code>xxx.md</code> 和同名文件夹 <code>xxx</code>。将图片资源放在 <code>xxx</code> 中，然后在 <code>xxx.md</code> 中使用图片的文件名引用它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure>

<h2 id="ghost-to-hexo-migrater"><a href="#ghost-to-hexo-migrater" class="headerlink" title="ghost-to-hexo-migrater"></a>ghost-to-hexo-migrater</h2><p>我自己用 Python 写了一个迁移 Ghost 博客至 Hexo 的程序，项目已经提交到 <a href="https://github.com/s1mplecc/ghost-to-hexo-migrater">GitHub</a>。</p>
<p>主要做了如下事情：</p>
<ul>
<li>通过 Ghost API 将 Ghost 博客上的所有文章和图片下载到本地。</li>
<li>给每篇文章加上 Hexo 规定的 header，包括 Title、创建日期、Tags；由于 Ghost 博客不支持分类，所以保留 categories 默认为空。</li>
<li>按照 Hexo 的规定，创建与文章标题一致的文件夹用于存放文章中的图片，并更换文章中图片的 Markdown 链接。</li>
</ul>
<p>这样可以将整个 <code>downloads</code> 文件夹拷贝到 Hexo 的 <code>source/_posts</code> 目录下发布即可！</p>
<p><img src="/2018/12/27/%E8%BF%81%E7%A7%BB-Ghost-%E5%8D%9A%E5%AE%A2%E8%87%B3-Hexo-%E5%B9%B6%E4%BD%BF%E7%94%A8-GitHub-Pages-%E9%83%A8%E7%BD%B2/4.png" alt="7292889b7bb90233a1ac2dd1ac2cd97a.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://pages.github.com/">GitHub Pages官网</a></li>
<li><a href="https://hexo.io/zh-cn/index.html">Hexo官网</a></li>
<li><a href="https://theme-next.org/docs/getting-started/">Next官方文档</a> </li>
<li><a href="https://juejin.im/post/5acf02086fb9a028b92d8652#heading-17">GitHub Pages部署个人博客（Hexo篇）—— 掘金</a></li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
  </entry>
  <entry>
    <title>部署 Ghost Blog</title>
    <url>/2017/11/01/%E9%83%A8%E7%BD%B2Ghost%20Blog/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>Ghost是比较简约、轻量级的博客平台，而且文档编写使用markdown完成的。所以本片博客将介绍如何在服务器上搭建了Ghost。</p>
</blockquote>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><ul>
<li>Ubuntu 16.04</li>
<li>MySQL</li>
<li>NGINX (minimum of 1.9.5 for SSL)</li>
<li>Systemd</li>
<li>Node v6 installed via NodeSource</li>
<li>At least 1GB memory (swap can be used)</li>
<li>A non-root user for running ghost commands</li>
</ul>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p><a href="https://docs.ghost.org/v1.0.0/docs/install">官网安装文档</a>   </p>
<blockquote>
<p>如果你的数据库在其他服务器上，可以不安装mysql</p>
</blockquote>
<ul>
<li>更新软件包源以及更新通过包源安装的软件  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li>
<li>mysql、ngnix、systemd都可以通过<code>sudo apt-get install</code>命令安装</li>
<li>由于ghost是基于nodejs开发的，所以要安装nodejs，执行下面这俩条命令  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash </span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure></li>
<li>安装ghost-cli命令行程序  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm i -g ghost-cli</span><br></pre></td></tr></table></figure></li>
<li>安装完成后可以使用<code>ghost</code>命令，<code>ghost help</code>查看帮助，ghost安装需要一个空的文件夹  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /home/s1mple/ghost</span><br></pre></td></tr></table></figure></li>
<li><code>cd</code>到这个目录下，执行<code>ghost install</code>命令即可</li>
</ul>
<blockquote>
<p>1.安装过程中会配置数据库，需要提前建个空的database。如果mysql装在本机，就输入localhost，装在别的服务器上就需要输入服务器IP<br>2.询问是否使用nginx可以选no，可以自己手动配置nginx。实际上他帮你配置将80端口的请求转发到ghost的2368端口<br>3.询问是否新建”ghost”用户可以选no，若选yes他会在数据库中新建此用户，并且在ghost后台管理可以看到此用户和一些默认文章。</p>
</blockquote>
<h3 id="After-Installation"><a href="#After-Installation" class="headerlink" title="After Installation"></a>After Installation</h3><ul>
<li>安装后当前文件下会生成<strong>config.production.json</strong>文件，配置信息在这里。<code>ghost ls</code>查看当前ghost运行实例信息，<code>ghost restart</code>重启ghost。</li>
<li>安装完成后，访问<code>／ghost</code>进入后台管理系统，根据引导创建用户。</li>
<li>在后台Design模块中可以导入主题zip压缩包，<code>/ghost/#/settings/design</code>。在Ghost Marketplace下找了个时间轴的主题，并修改了部分视觉效果。<a href="https://github.com/s1mplecc/ghost-theme">时间轴主题下载链接</a></li>
</ul>
<h3 id="Redirect-Port-With-Nginx"><a href="#Redirect-Port-With-Nginx" class="headerlink" title="Redirect Port With Nginx"></a>Redirect Port With Nginx</h3><blockquote>
<p>很尴尬，因为Aliyun的服务器需要备案，80端口有时候会出现抽风的情况。所以有必要先配置个其他端口（2368端口太难记了），比如8080。</p>
</blockquote>
<ul>
<li><code>cat /etc/nginx/nginx.conf </code>发现nginx配置文件包括如下两行  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include /etc/nginx/conf.d/*.conf;</span><br><span class="line">include /etc/nginx/sites-enabled/*;</span><br></pre></td></tr></table></figure>
  意思就是配置文件会导入上述两个目录中的文件。所以我们可以<code>cd /etc/nginx/sites-enabled/</code>中。</li>
<li>发现目录下有个<strong>s1mple.info.conf</strong>文件，这其实就是ghost配置nginx的文件。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp s1mple.info.conf ghost_8080.conf</span><br></pre></td></tr></table></figure></li>
<li>修改<code>ghost_8080.conf</code>中的监听端口80为8080,<code>service nginx restart</code>重启nginx</li>
<li>修改ghost安装目录下的<strong>config.production.json</strong>,重启ghost  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;url&quot;: &quot;http://s1mple.info:8080&quot;,</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>有个端口号看着很丑，等备案完成，删掉<code>ghost_8080.conf</code>就行了。（你看，国外主机就不用备案）</p>
</blockquote>
<h2 id="Postscript"><a href="#Postscript" class="headerlink" title="Postscript"></a>Postscript</h2><ul>
<li>本来想在docker容器中部署Ghost,但是可能由于docker和宿主系统隔离的原因，systemd命令不能正常运行<code>Failed to connect to bus: No such file or directory</code>。暂时没找到解决方法。不过我在docker里部署了另一个博客平台jPress。<a href="https://jpress.s2mple.xyz/">跳转链接</a></li>
<li>jPress是基于java的轻量级博客平台，前身是WordPress。也许下个博客我会介绍如何用docker部署jPress，谁知道呢。</li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
  </entry>
  <entry>
    <title>配置 Nginx 目录</title>
    <url>/2017/11/19/%E9%85%8D%E7%BD%AENginx%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>配置Nginx目录，可以很方便的下载镜像，查看文件等等</p>
</blockquote>
<ul>
<li>效果图<br><img src="/0.png" alt="-----2017-11-19---10.54.27"></li>
</ul>
<h2 id="Configure-Nginx"><a href="#Configure-Nginx" class="headerlink" title="Configure Nginx"></a>Configure Nginx</h2><ul>
<li><p>前往nginx配置目录</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/nginx/sites-enabled</span><br></pre></td></tr></table></figure></li>
<li><p><code>vi dir_80.conf</code>添加配置文件</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line"></span><br><span class="line">    server_name dir.s1mple.info www.dir.s1mple.info;</span><br><span class="line">    root /var/www/html;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        autoindex on;</span><br><span class="line">        autoindex_exact_size off;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listen 443 ssl; # managed by Certbot</span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/s1mple.info/fullchain.pem; # managed by Certbot</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/s1mple.info/privkey.pem; # managed by Certbot</span><br><span class="line">    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br><span class="line"></span><br><span class="line">    # Redirect non-https traffic to https</span><br><span class="line">    if ($scheme != &quot;https&quot;) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>service nginx restart</code>重启nginx服务</p>
</li>
</ul>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ol>
<li>监听80端口，域名为dir.s1mple.info和<a href="http://www.dir.s1mple.info/">www.dir.s1mple.info</a></li>
<li>根目录为/var/www/html</li>
<li><strong>autoindex on</strong>打开目录浏览功能</li>
<li><strong>autoindex_exact_size</strong>默认为on，显示文件确切大小，单位bytes，改为off后显示大概大小，单位kB或者MB或者GB</li>
<li>剩下的是<strong>Certbot</strong>重定位https的配置</li>
</ol>
<h2 id="Configure-Certbot"><a href="#Configure-Certbot" class="headerlink" title="Configure Certbot"></a>Configure Certbot</h2><ul>
<li><p>重新配置Certbot</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certbot run</span><br></pre></td></tr></table></figure>
</li>
<li><p>它会自动检测nginx的配置文件<br><img src="/1.png" alt="-----2017-11-19---10.31.17"></p>
</li>
<li><p>提示已经存在证书，并且已经配置了一些域名，询问是否扩充，选择E<br><img src="/2.png" alt="-----2017-11-19---10.32.45"></p>
</li>
<li><p>询问是否将HTTP重定位到HTTPS，选择2是所有请求均重定位到HTTPS<br><img src="/3.png" alt="-----2017-11-19---10.38.24"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Ops</category>
      </categories>
  </entry>
  <entry>
    <title>随机数生成与熵池策略</title>
    <url>/2017/12/05/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E4%B8%8E%E7%86%B5%E6%B1%A0%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>最近同事在将jar包上传到服务器执行<strong>spark-submit</strong>时，运行的时间总是不确定的，有时甚至等待数十分钟。遂想到当初自己在服务器上运行<strong>Tomcat</strong>时也遇到这种问题，往往第一次运行很快，后面要等很长时间。最近查阅相关资料，终于发现问题所在。</p>
</blockquote>
<h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><blockquote>
<p>首先要明白操作系统如何产生随机数以及内核熵池的一些概念</p>
</blockquote>
<ul>
<li><p>随机数在许多领域都有重要应用，如密码学、网络安全等。Linux内核从1.3.30版本开始实现了一个<strong>高强度的随机数产生器</strong></p>
</li>
<li><p>Linux 内核采用<strong>熵</strong>来描述<strong>数据的随机性</strong>。熵是描述<strong>系统混乱无序程度</strong>的物理量，一个系统的熵越大则说明该系统的有序性越差，即不确定性越大。在信息学中，熵被用来表征一个符号或系统的不确定性，熵越大，表明系统所含有用信息量越少，不确定度越大</p>
</li>
<li><p>计算机本身是可预测的系统，因此，用计算机算法不可能产生真正的随机数。要生成高强度的随机数需要许多<strong>不确定的外界参数</strong>。你比如说编程中的随机数种子就是一个外界参数，如果你的种子数确定，那么生成的随机序列是可以预测的</p>
</li>
<li><p>恰好机器的环境中充满了各种各样的噪声，如硬件设备发生中断的时间，用户点击鼠标的时间间隔等是完全随机的，事先无法预测。Linux内核实现的随机数产生器正是利用系统中的这些随机噪声来产生高质量随机数序列</p>
</li>
<li><p>内核维护了一个<strong>熵池</strong>用来收集来自设备驱动程序和其它来源的环境噪音。为跟踪熵池中数据的随机性，内核在将数据加入池的时候将估算数据的随机性，这个过程称作熵估算。<strong>熵估算值</strong>描述池中包含的随机数位数，其值越大表示池中数据的随机性越好</p>
</li>
<li><p>内核提供了两个字符设备<code>/dev/random</code>和<code>/dev/urandom</code>以让用户调用获得随机数序列，<code>/dev/random</code>输出的随机数序列质量更高，适合于<strong>高强度的加密算法</strong>，但它只返回熵估算值所允许的最长的随机数序列，否则请求将被<strong>阻塞</strong>直到熵估算值增大到一定域值。<code>/dev/urandom</code>总是立即返回所请求的随机数序列，”u”代表<strong>unlocked</strong>非阻塞</p>
</li>
<li><p>当熵池为空时，来自<code>/dev/random</code>的读操作将被<strong>阻塞</strong>，直到熵池收集到足够的环境噪声数据。这么做的目的是生成尽可能随机的数据。对于生成高质量的加密密钥或者是需要长期保护的场景，一定要这么做。</p>
</li>
</ul>
<blockquote>
<p>Ok，其实到这里，原因就已经明了了，在启动<strong>Tomcat</strong>生成<strong>SessionID</strong>时和<strong>spark-submit</strong>连接数据库时，用到了 <strong>/dev/random</strong>生成的随机数，却因为熵池用空而进入阻塞，这也解释了为什么第一次的执行很快，后面却很慢。</p>
</blockquote>
<h2 id="Solving"><a href="#Solving" class="headerlink" title="Solving"></a>Solving</h2><blockquote>
<p>Apache官网上也有描述如何优化Tomcat的运行效率，有两种方法解决这个问题</p>
</blockquote>
<ul>
<li>修改<code>$&#123;java_home&#125;/jre/lib/security/java.security</code>中的这一行  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">securerandom.source=file:/dev/random</span><br></pre></td></tr></table></figure>
  替换为  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">securerandom.source=file:/dev/./urandom</span><br></pre></td></tr></table></figure>
</li>
<li>或者在Tomcat的<code>catalina.sh</code>中加入如下行  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Djava.security.egd=file:/dev/./urandom</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul>
<li>关于为什么加<code>/./</code>有人说是Bug，也有人说是故意这么设计的，oracle的官方文档 <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6521844">Java Bug Database</a></li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://hongjiang.info/jvm-random-and-entropy-source/">JVM上的随机数与熵池策略</a></li>
<li><a href="https://wiki.apache.org/tomcat/HowTo/FasterStartUp">How do I make Tomcat startup faster?</a></li>
</ul>
]]></content>
      <categories>
        <category>Concepts</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
