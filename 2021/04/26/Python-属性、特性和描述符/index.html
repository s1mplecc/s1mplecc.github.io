<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"s1mplecc.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="类的属性在 Python 中，数据属性和处理数据的方法统称为属性（attribute），方法也可称为方法属性，本质上是可调用的（callable）属性。Python 提供了丰富的 API 用于控制访问属性，以及实现动态属性。即使访问不存在的属性，也可以通过特殊方法实现“虚拟属性”，从而即时计算属性的值。 处理属性的特殊属性为了方便处理属性，Python 定义了一些特殊属性，包括：  __class">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 属性、特性和描述符">
<meta property="og:url" content="https://s1mplecc.github.io/2021/04/26/Python-%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6/index.html">
<meta property="og:site_name" content="芥子屋">
<meta property="og:description" content="类的属性在 Python 中，数据属性和处理数据的方法统称为属性（attribute），方法也可称为方法属性，本质上是可调用的（callable）属性。Python 提供了丰富的 API 用于控制访问属性，以及实现动态属性。即使访问不存在的属性，也可以通过特殊方法实现“虚拟属性”，从而即时计算属性的值。 处理属性的特殊属性为了方便处理属性，Python 定义了一些特殊属性，包括：  __class">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-26T03:18:39.000Z">
<meta property="article:modified_time" content="2021-12-17T05:47:55.538Z">
<meta property="article:author" content="s1mple">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://s1mplecc.github.io/2021/04/26/Python-%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Python 属性、特性和描述符 | 芥子屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">芥子屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/s1mplecc" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s1mplecc.github.io/2021/04/26/Python-%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="s1mple">
      <meta itemprop="description" content="春光恰与少年同，十里清风慕天青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芥子屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python 属性、特性和描述符
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-26 11:18:39" itemprop="dateCreated datePublished" datetime="2021-04-26T11:18:39+08:00">2021-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 13:47:55" itemprop="dateModified" datetime="2021-12-17T13:47:55+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Languages/" itemprop="url" rel="index"><span itemprop="name">Languages</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/04/26/Python-%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/26/Python-%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><p>在 Python 中，数据属性和处理数据的方法统称为属性（attribute），方法也可称为方法属性，本质上是可调用的（callable）属性。Python 提供了丰富的 API 用于控制访问属性，以及实现动态属性。即使访问不存在的属性，也可以通过特殊方法实现“虚拟属性”，从而即时计算属性的值。</p>
<h3 id="处理属性的特殊属性"><a href="#处理属性的特殊属性" class="headerlink" title="处理属性的特殊属性"></a>处理属性的特殊属性</h3><p>为了方便处理属性，Python 定义了一些特殊属性，包括：</p>
<ul>
<li><code>__class__</code>：对象所属类的引用。<code>obj.__class__</code> 与 <code>type(obj)</code> 效果一致。类和类的实例都具有属性，有些属性只能在类中查询，比如特殊方法；</li>
<li><code>__dict__</code>：存储类或实例的可写属性的字典。如果设置了 <code>__slots__</code> 属性，实例可能没有 <code>__dict__</code> 属性；</li>
<li><code>__slots__</code>：类可以定义这个属性，限制实例能拥有哪些属性。该属性的值可以是个可迭代对象，但通常会使用元组。如果类设置了 <code>__slots__</code> 属性且 <code>__slots__</code> 中不包含 <code>&#39;__dict__&#39;</code>，那么该类的实例没有 <code>__dict__</code> 属性。</li>
</ul>
<h4 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a><code>__dict__</code></h4><p>默认情况下，Python 会使用名为 <code>__dict__</code> 的字典存储类和实例中的可写属性。其中，<strong>类属性字典</strong>由名为 <code>mappingproxy</code> 的代理对象包装，<code>mappingproxy</code> 定义在 <code>collections.abc</code> 模块中，特别指代类属性字典的类型：<code>mappingproxy = type(type.__dict__)</code>。类属性字典包含显式定义在类中的字段和方法，以及一些可写的特殊属性，包括模块、字典、弱引用和文档字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.b = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, </span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function Foo.__init__ at <span class="number">0x1051fe8b0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;Foo&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;Foo&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>类属性不仅限于类字典中所展示的，还包含一些不可变的类属性，比如所属类的引用 <code>__class__</code>，直接父类组成的元组 <code>__bases__</code> 等。</p>
<p><strong>实例属性字典</strong>则是普通的字典类型，为实例属性赋值，会动态的修改实例字典。如果属性不存在，则将其添加到字典中，包括在初始化方法 <code>__init__</code> 中赋值的实例属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.c = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h4><p>Python 解释器会默认在类的构造方法 <code>__new__</code> 中创建 <code>__dict__</code> 存放实例属性，在访问时通过访问实例字典读取属性值。由于字典底层使用了散列表结构，对属性的存取会相当迅速。但同时，为了减少散列冲突，散列表的大小通常要远大于键的数量，这种基于空间换时间的考量会导致字典会消耗大量内存。为此，Python 提供了 <code>__slots__</code> 属性，该属性会覆盖 <code>__dict__</code> 属性，<strong>使用类似元组的结构存储实例变量</strong>，从而达到节省内存的目的。</p>
<p>我沿用之前定义的 Person 类做了测试，它包含 name 和 age 两个实例属性。使用列表推导生成一百万个 Person 对象，分别对默认使用 <code>__dict__</code> 和添加了 <code>__slots__</code> 属性的内存占用情况进行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ time python3 slots.py --use-dict </span><br><span class="line">Initial RAM Usage:    5,472,256</span><br><span class="line">  Final RAM Usage:  186,380,288</span><br><span class="line">python3 slots.py --use-dict  1.11s user 0.07s system 99% cpu 1.187 total</span><br><span class="line">➜ time python3 slots.py --use-slots</span><br><span class="line">Initial RAM Usage:    5,476,352</span><br><span class="line">  Final RAM Usage:   76,369,920</span><br><span class="line">python3 slots.py --use-slots  0.74s user 0.04s system 99% cpu 0.788 total</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>__slots__</code> 后内存占用得到显著优化，只占了使用 <code>__dict__</code> 的一半不到，运行速度也更快。</p>
<p><strong>定义 <code>__slots__</code> 的方式</strong>是，创建一个名为 <code>__slots__</code> 的类属性，把它的值设为一个字符串构成的可迭代对象（通常使用元组），其中的元素名称代表实例属性，比如<code>__slots__ = (&#39;name&#39;, &#39;age&#39;)</code>。定义 <code>__slots__</code> 属性相当于告诉解释器：这个类的所有实例属性都在这儿了。<strong>实例不能再有 <code>__slots__</code> 所列之外的其他属性</strong>。但应该明白，<code>__slots__</code> 并不是用来禁止类的用户新增实例属性的手段，而只是一种内存优化方案。</p>
<p>如果你阅读 <code>collections.abc</code> 模块的源码，会发现其中的类都存在一行 <code>__slots__ = ()</code> 代码。即使这些类没有实例属性，使用空元组定义的 <code>__slots__</code> 属性可以避免类的构造方法创建 <code>__dict__</code> 空字典，空字典也会在堆上分配内存空间。对于集合这种基本数据类型，有必要为其声明空元组形式的 <code>__slots__</code> 属性。此外，对于模式固定的数据库记录，以及特大型数据集，也有必要声明 <code>__slots__</code> 属性。</p>
<p>上面介绍的这些特殊属性，在一些访问和处理属性的内置函数和特殊方法中会被使用。下面列出这些函数和方法。</p>
<h3 id="处理属性的内置函数"><a href="#处理属性的内置函数" class="headerlink" title="处理属性的内置函数"></a>处理属性的内置函数</h3><p><code>dir([object])</code>：列出对象的大多数属性。object 参数是可选的，缺省时会列出当前模块的属性。dir 函数能够审查对象有没有 <code>__dict__</code> 和 <code>__slots__</code> 属性，并列出其中的键。</p>
<p><code>getattr(object, name[, default])</code>：从对象中读取属性值。获取的属性可能来自对象所属的类或超类。如果没有找到指定属性，则抛出 AttributeError 异常，或返回预设默认值。</p>
<p><code>hasattr(object, name)</code>：会调用 getattr 函数查看能否获取指定的属性，当抛出 AttributeError 异常时返回 False。</p>
<p><code>setattr(object, name, value)</code>：为对象指定的属性设值。这个函数可能会创建一个新属性，或者覆盖现有的属性。前提是对象能够接受这个值，比如设定了 <code>__slots__</code> 的对象不能添加新属性。</p>
<p><code>vars([object])</code>：返回对象的 <code>__dict__</code> 属性，参数缺省时返回当前模块的 <code>__dict__</code> 属性。vars 函数不能处理设定了 <code>__slots__</code> 属性的对象。</p>
<h3 id="处理属性的特殊方法"><a href="#处理属性的特殊方法" class="headerlink" title="处理属性的特殊方法"></a>处理属性的特殊方法</h3><p><code>__getattribute__(self, name)</code>：除了访问特殊属性和特殊方法，尝试获取指定的属性时总会调用这个方法。dot 运算符、<code>getattr</code> 和 <code>hasattr</code> 会调用这个方法。该方法内部定义了属性访问规则，当未找到指定属性时抛出 AttributeError 异常，<code>__getattr__</code> 方法会被调用。</p>
<p><code>__getattr__(self, name)</code>：仅当获取指定属性失败时，即处理不存在的属性时被调用。用户自定义的类可以实现 <code>__getattr__</code> 方法从而动态计算属性的值。</p>
<p><code>__setattr__(self, name, value)</code>：尝试为指定属性设值时总会调用该方法。dot 运算符和 <code>setattr</code> 会调用这个方法。该方法内部定义了属性设值规则。</p>
<p><code>__delattr__(self, name)</code>：使用 del 关键字删除属性时会调用这个方法。</p>
<p><code>__dir__(self)</code>：内置函数 <code>dir()</code> 会调用这个方法。</p>
<h3 id="属性访问规则"><a href="#属性访问规则" class="headerlink" title="属性访问规则"></a>属性访问规则</h3><p>Python 解释器在访问属性时会按照一定的规则，从入口方法 <code>__getattribute__</code> 开始，按照顺序依次查找，如果找到则返回，未找到则抛出异常，调用 <code>__getattr__</code> 动态计算虚拟属性。属性访问规则如下：</p>
<ol>
<li><code>__getattribute__</code> 方法</li>
<li>数据描述符</li>
<li>实例对象的字典</li>
<li>类的字典</li>
<li>非数据描述符</li>
<li>父类的字典</li>
<li><code>__getattr__</code> 方法</li>
</ol>
<p>注：其中，数据描述符是实现了 <code>__get__</code> 和 <code>__set__</code> 描述符协议的类。描述符的内容，会在后面做详细介绍。</p>
<p>查询属性的入口方法 <code>__getattribute__</code> 实现逻辑的伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">name</span>)：</span></span><br><span class="line"><span class="function">    # 先在类(<span class="params">包括父类、祖先类</span>)字典中查找数据描述符</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">find</span> <span class="title">data</span> <span class="title">descriptor</span> <span class="title">in</span> <span class="title">class</span> <span class="title">and</span> <span class="title">base</span> <span class="title">class</span> <span class="title">__dict__</span>:</span></span><br><span class="line">        <span class="comment"># 如果是数据描述符，则调用该数据描述符的 __get__ 方法并将结果返回</span></span><br><span class="line">        <span class="keyword">return</span> descriptor.__get__(instance, instance.__class__)</span><br><span class="line">    <span class="comment"># 如果不是数据描述符，继续查询实例字典</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> instance.__dict__:</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[name]</span><br><span class="line">    <span class="comment"># 实例字典中没有，则继续查询类字典</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> instance.__class__.__dict__:</span><br><span class="line">        <span class="keyword">return</span> instance.__class__.__dict__[name]</span><br><span class="line">    <span class="comment"># 在类和父类字典中查询非数据描述符</span></span><br><span class="line">    <span class="keyword">if</span> find non-data descriptor <span class="keyword">in</span> <span class="class"><span class="keyword">class</span> <span class="title">and</span> <span class="title">base</span> <span class="title">class</span> <span class="title">__dict__</span>:</span></span><br><span class="line">        <span class="comment"># 如果找到，返回描述符实例</span></span><br><span class="line">        <span class="keyword">return</span> descriptor.instance</span><br><span class="line">    <span class="comment"># 如果不是描述符，继续在父类字典中查找</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> baseclass __dict__:</span><br><span class="line">        <span class="keyword">return</span> baseclass.__dict__[name]</span><br><span class="line">    <span class="comment"># 如果依然没有找到，抛出异常，__getattr__ 函数会被调用</span></span><br><span class="line">    <span class="keyword">raise</span> AttributeError</span><br></pre></td></tr></table></figure>

<p>为实例属性赋值则没有这么麻烦，<code>__setattr__</code> 作为入口方法，只需要判断属性是否是数据描述符，如果是则调用其 <code>__set__</code> 方法，如果不是则为实例字典添加新的属性。<code>__setattr__</code> 实现逻辑的伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__setattr__(name, value):</span><br><span class="line">    <span class="comment"># 先在类(包括父类、祖先类)字典中查找描述符</span></span><br><span class="line">    <span class="keyword">if</span> find data descriptor <span class="keyword">in</span> <span class="class"><span class="keyword">class</span> <span class="title">and</span> <span class="title">base</span> <span class="title">class</span> <span class="title">__dict__</span>:</span></span><br><span class="line">        <span class="comment"># 如果是数据描述符，则调用描述符的 __set__ 方法进行设值</span></span><br><span class="line">        descriptor.__set__(instance, value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 否则，为实例属性字典添加新值</span></span><br><span class="line">        instance.__dict__[name] = value</span><br></pre></td></tr></table></figure>

<p>由此也可以发现，Python 存取属性的方式特别不对等。通过实例访问属性时，如果实例中没有指定属性，那么会尝试获取类属性。而为实例中的属性赋值时，如果属性不存在会在实例中创建该属性，根本不影响类。</p>
<p>下面介绍如何使用 <code>__getattr__</code> 方法动态计算虚拟属性。</p>
<h3 id="自定义-getattr-即时计算属性"><a href="#自定义-getattr-即时计算属性" class="headerlink" title="自定义 __getattr__ 即时计算属性"></a>自定义 <code>__getattr__</code> 即时计算属性</h3><p>处理 JSON 是非常常见的需求，JavaScript 对 JSON 具有天生的支持，可以使用 dot 运算符链式获取属性的值，如 <code>res.cities[0].ext.province</code>。而 Python 原生的字典不支持使用 dot 运算符直接获取属性，只能使用 <code>res[&#39;cities&#39;][0][&#39;ext&#39;][&#39;province&#39;]</code> 的形式，会显得格外冗长。但可以通过实现一个近似字典的类，达到同样的效果。如下是 Python 中的效果演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> json_parser <span class="keyword">import</span> JsonParser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json = &#123;</span><br><span class="line"><span class="meta">... </span>  <span class="string">&quot;code&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line"><span class="meta">... </span>  <span class="string">&quot;cities&quot;</span>: [</span><br><span class="line"><span class="meta">... </span>    &#123;</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;lat&quot;</span>: <span class="string">&quot;41.2334465&quot;</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;lng&quot;</span>: <span class="string">&quot;116.9772857&quot;</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;citycode&quot;</span>: <span class="number">207</span>,</span><br><span class="line"><span class="meta">... </span>      <span class="string">&quot;ext&quot;</span>: &#123;</span><br><span class="line"><span class="meta">... </span>        <span class="string">&quot;province&quot;</span>: <span class="string">&quot;河北省&quot;</span>,</span><br><span class="line"><span class="meta">... </span>        <span class="string">&quot;city&quot;</span>: <span class="string">&quot;承德市&quot;</span></span><br><span class="line"><span class="meta">... </span>      &#125;</span><br><span class="line"><span class="meta">... </span>    &#125; </span><br><span class="line"><span class="meta">... </span>  ]</span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = JsonParser(json)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.code</span><br><span class="line"><span class="string">&#x27;200&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.cities[<span class="number">0</span>].citycode</span><br><span class="line"><span class="number">207</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.cities[<span class="number">0</span>].ext.province</span><br><span class="line"><span class="string">&#x27;河北省&#x27;</span></span><br></pre></td></tr></table></figure>

<p>能够使用 dot 运算符链式获取属性的关键在于定义在 JsonParser 中的 <code>__getattr__</code> 方法。前面已经说过，Python 解释器在查询对象属性失败时会调用 <code>__getattr__</code> 方法动态计算属性。下面代码定义了动态计算的逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonParser</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, arg</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(arg, Mapping):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(arg, MutableSequence):</span><br><span class="line">            <span class="keyword">return</span> [cls(i) <span class="keyword">for</span> i <span class="keyword">in</span> arg]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self._data = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> JsonParser(self._data[name])</span><br></pre></td></tr></table></figure>

<p>通过 <code>__getattr__</code> 方法递归地创建 JsonParser 类，并将下级的 JSON 结构  <code>_data[name]</code> 作为构造参数传入。构造方法 <code>__new__</code> 会判断传入参数的类型，如果是映射类型直接创建 JsonParser 对象，如果是可变序列，则通过列表推导式返回 JsonParser 列表。之所以要这么处理是因为 JSON 结构可能是数组，除了映射结构还需要对数组类型进行解析，以支持 <code>cities[0]</code> 式的访问。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>在 Java 中，为了控制属性的访问权限，一般会将属性设置为私有属性，并为可以公开的属性设置公有的 getter 和 setter 方法。这样做还有一个好处，可以在方法内添加对属性的验证，比如保证商品的数量不会是负数。如果想更进一步，可以按照领域驱动设计的理念，可以将属性设置为实体类 Entity，在类中对属性进行校验。这两种思想在 Python 中也都有对应的实现，前一种对应于特性，后一种对应于描述符。</p>
<p>特性经常用于把公开的属性变成使用读值方法和设置方法管理的属性，且在不影响客户端代码的前提下实施业务规则。使用 <code>get/set + 属性名</code> 的命名方式不符合 Python 一贯的简约作风，为此 Python 提供了特性，即 property。property 是一个类形式的函数装饰器，本质上它是一个<strong>描述符类</strong>（实现了描述符协议）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">property</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        fget: <span class="type">Optional</span>[<span class="type">Callable</span>[[<span class="type">Any</span>], <span class="type">Any</span>]] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">        fset: <span class="type">Optional</span>[<span class="type">Callable</span>[[<span class="type">Any</span>, <span class="type">Any</span>], <span class="literal">None</span>]] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">        fdel: <span class="type">Optional</span>[<span class="type">Callable</span>[[<span class="type">Any</span>], <span class="literal">None</span>]] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">        doc: <span class="type">Optional</span>[<span class="built_in">str</span>] = ...,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span>(<span class="params">self, fget: <span class="type">Callable</span>[[<span class="type">Any</span>], <span class="type">Any</span>]</span>) -&gt; <span class="built_in">property</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span>(<span class="params">self, fset: <span class="type">Callable</span>[[<span class="type">Any</span>, <span class="type">Any</span>], <span class="literal">None</span>]</span>) -&gt; <span class="built_in">property</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleter</span>(<span class="params">self, fdel: <span class="type">Callable</span>[[<span class="type">Any</span>], <span class="literal">None</span>]</span>) -&gt; <span class="built_in">property</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj: <span class="type">Any</span>, <span class="built_in">type</span>: <span class="type">Optional</span>[<span class="built_in">type</span>] = ...</span>) -&gt; <span class="type">Any</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, obj: <span class="type">Any</span>, value: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, obj: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fget</span>(<span class="params">self</span>) -&gt; <span class="type">Any</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fset</span>(<span class="params">self, value: <span class="type">Any</span></span>) -&gt; <span class="literal">None</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fdel</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span> ...</span><br></pre></td></tr></table></figure>

<p>使用函数形式的装饰器会返回一个嵌套的高阶函数，类形式的装饰器也类似，使用 <code>@property</code> 装饰的方法会被包装成特性类。特性类具有 getter、setter 和 deleter 方法属性，这三个属性也都返回 property 对象。</p>
<p>因此，用 <code>@property</code> 装饰的读值方法，如下的 <code>amount(self)</code> 方法，相当于返回一个 <code>property(amount)</code> 特性对象，将读值方法作为初始化参数 fget 传入。而后可以使用 <code>@amount.setter</code> 装饰设值方法，此时设值方法 amount 返回的是特性对象，setter 是它的方法属性。相当于 <code>property(amount).setter(amount)</code>，第二个 amount 是设值方法，将设值方法作为 fset 参数传入 setter 方法。也因此，<code>@amount.setter</code> 必须要定义在被 <code>@property</code> 装饰的设置方法之后。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, price, amount</span>):</span></span><br><span class="line">        self.price = price</span><br><span class="line">        self.amount = amount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.amount</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">amount</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._amount</span><br><span class="line"></span><br><span class="line"><span class="meta">    @amount.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">amount</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> value &gt;= <span class="number">0</span>:</span><br><span class="line">            self._amount = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;item amount must &gt;= 0&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>读值方法可以不与实例属性名一致，但要保证，读值方法名称、设值方法名称和 <code>@amount.setter</code> 装饰器中的名称三者保持一致，即都为 amount。这样，在访问属性时可以通过 <code>item.amount</code> 的形式对真正的实例属性 <code>self._amount</code> 进行读值和赋值。其实，初始化函数中的 <code>self.amount = amount</code> 语句就已经在使用特性的设置方法了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;_amount&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.total_price()</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.total_price()</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount = -<span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: item amount must &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到，真正被操作的实例属性 <code>_amount</code> 被保存在实例字典中。</p>
<p>任何对 <code>item.amount</code> 的读值和设值操作，都会经过由特性包装的读值和设值方法进行处理。由于在设值方法中对属性值做了非负验证，所以将其设置为负值会抛出 ValueError 异常。</p>
<p>需要注意的是，特性是类属性，被保存于类的 <code>__dict__</code> 字典中。在使用 <code>obj.attr</code> 这样的表达式时，不会从 obj 开始查询 attr 属性，而是从实例所属的类，即 <code>obj.__class__</code> 开始，仅当类中没有名为 attr 的特性时，才会去查询实例字典。也就是说，<strong>特性的读值和设值方法要优先于实例字典</strong>，只有直接存取 <code>__dict__</code> 属性才能跳过特性的处理逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;attribute&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function LineItem.__init__ at <span class="number">0x105459a60</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;total_price&#x27;</span>: &lt;function LineItem.total_price at <span class="number">0x105459af0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;amount&#x27;</span>: &lt;<span class="built_in">property</span> <span class="built_in">object</span> at <span class="number">0x105487680</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;_amount&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__[<span class="string">&#x27;_amount&#x27;</span>] = -<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这条规则不仅适用于特性，还适用于数据描述符，其实，特性也是数据描述符。或者换句话说，正是由于数据描述符的访问优先级要高于实例字典，特性的读值和设值方法访问才优先于实例字典。下面我们介绍描述符。</p>
<h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><p>描述符是 Python 的独有特征，不仅在应用层，内置库和标准库中也有使用。除了特性之外，使用描述符的还有方法、classmethod 和 staticmethod 装饰器，以及 functools 模块中的诸多类。理解描述符是精通 Python 的关键，本章的话题就是描述符。</p>
<p><strong>描述符是实现了特定协议的类</strong>，这个协议包括 <code>__get__</code>、<code>__set__</code> 和 <code>__delete__</code> 方法。特性类 property 实现了完整的描述符协议。通常，可以只实现部分协议。其实，我们在真实代码中见到的大多数描述符只实现了 <code>__get__</code> 和 <code>__set__</code> 方法，还有很多只实现了其中的一个。</p>
<h3 id="定制描述符实现属性验证"><a href="#定制描述符实现属性验证" class="headerlink" title="定制描述符实现属性验证"></a>定制描述符实现属性验证</h3><p><strong>描述符是对多个属性运用相同存取逻辑的一种方式</strong>。假设我们想为之前定义的 LineItem 类中的 price 和 amount 属性都设置非负验证，一种方式是为它们都编写读值和设值方法，但这会造成代码重复。为了避免这个问题，Python 提出了一种面向对象的解决方式，那就是定制描述符类。</p>
<p>在下面的代码中，定义了一个名为 Quantity 的描述符类，用于管理 LineItem 的属性。我们将 LineItem 类称为托管类，被管理的属性称为托管属性。Quantity 类的实例属性 attribute 指代托管属性的名称，由初始化方法传入。通过在托管类中声明类属性的形式，如 <code>price = Quantity(&#39;price&#39;)</code> 将描述符实例绑定给 price 属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, attribute</span>):</span></span><br><span class="line">        self.attribute = attribute</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> value &gt;= <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.attribute] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;<span class="subst">&#123;self.attribute&#125;</span> must &gt;= 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    price = Quantity(<span class="string">&#x27;price&#x27;</span>)</span><br><span class="line">    amount = Quantity(<span class="string">&#x27;amount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, price, amount</span>):</span></span><br><span class="line">        self.price = price</span><br><span class="line">        self.amount = amount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.amount</span><br></pre></td></tr></table></figure>

<p>描述符类中定义了 <code>__set__</code> 方法，当尝试为托管属性赋值时，会调用这个方法并对值做验证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;price&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;amount&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount = -<span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: amount must &gt;= <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.price = -<span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: price must &gt;= <span class="number">0</span>                            </span><br></pre></td></tr></table></figure>

<p><strong><code>__set__</code> 方法的签名</strong>：<code>def __set__(self, instance, value) -&gt; None: ...</code>。第一个参数 self 是<strong>描述符实例</strong>，即 <code>LineItem.price</code> 或 <code>LineItem.amount</code>；第二个参数 instance 是<strong>托管类实例</strong>，即 LineItem 实例；第三个参数 value 是要设置的值。在为属性赋值时，必须直接操作托管实例的 <code>__dict__</code>，如果使用内置的 setattr 函数，将会重复调用 <code>__set__</code> 导致无限递归。</p>
<p>由于读值方法不需要特殊的逻辑，所以这个描述符类没有定义 <code>__get__</code> 方法。一般情况下，如果没有 <code>__get__</code> 方法，为了给用户提供内省和其他元编程技术支持，通过托管类访问属性会返回描述符实例。通过实例访问则会去实例字典中查询对应属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.attribute]</span><br></pre></td></tr></table></figure>

<p><strong><code>__get__</code> 方法的签名</strong>：<code>def __get__(self, instance, owner) -&gt; Any: ...</code>。与 <code>__set__</code> 方法相同，<code>__get__</code> 方法的第一个参数代表描述符实例，第二个参数代表托管类实例。而第三个参数 owner 是<strong>托管类的引用</strong>，当通过托管类访问属性时会被使用，返回类字典中的描述符实例，可以理解为 <code>instance.__class__</code>。</p>
<p>此时通过托管类访问属性会得到描述符实例，通过实例访问属性会得到托管属性的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.amount</span><br><span class="line">&lt;lineitem_with_descriptor.Quantity <span class="built_in">object</span> at <span class="number">0x108c52760</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = LineItem(<span class="number">1.0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item.amount</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;lineitem_with_descriptor&#x27;</span>, </span><br><span class="line">              <span class="string">&#x27;price&#x27;</span>: &lt;lineitem_with_descriptor.Quantity <span class="built_in">object</span> at <span class="number">0x10abd1910</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;amount&#x27;</span>: &lt;lineitem_with_descriptor.Quantity <span class="built_in">object</span> at <span class="number">0x10ac037f0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function LineItem.__init__ at <span class="number">0x10abd8af0</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;total_price&#x27;</span>: &lt;function LineItem.total_price at <span class="number">0x10abd8b80</span>&gt;, </span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;LineItem&#x27;</span> objects&gt;, </span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>同一时刻，内存中可能存在许多 LineItem 实例，但只会存在两个描述符实例：<code>LineItem.price</code> 和 <code>LineItem.amount</code>。这是因为描述符实例被定义为 LineItem 的类属性，会出现在 LineItem 的类字典中，由全部实例共享。</p>
<h3 id="描述符分类"><a href="#描述符分类" class="headerlink" title="描述符分类"></a>描述符分类</h3><p>我们将同时实现了 <code>__get__</code> 和 <code>__set__</code> 方法的描述符类称为<strong>数据描述符</strong>，将只实现了 <code>__get__</code> 的描述符类称为<strong>非数据描述符</strong>。在 CPython 的描述符对象 <a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/master/Objects/descrobject.c">descrobject</a> 的源码中，会检查描述符是否有 <code>__set__</code> 方法来返回描述符是否是数据描述符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyDescr_IsData</span><span class="params">(PyObject *ob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Py_TYPE(ob)-&gt;tp_descr_set != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python 社区在讨论这些概念时会用不同的术语，数据描述符也被称为<strong>覆盖型描述符</strong>或强制描述符，非数据描述符也被称为<strong>非覆盖型描述符</strong>或遮盖型描述符。总之，这两者的区别在于是否实现了 <code>__set__</code> 方法。之所以这么分类，是由于 Python 中<strong>存取属性方式的不对等性</strong>，我们在属性访问规则一节中提到了这点。这种不对等的处理方式也对描述符产生影响。</p>
<p>描述符的覆盖体现在，如果实现了 <code>__set__</code> 方法，即使描述符是类属性，也会覆盖对实例属性的赋值操作。比如 <code>item.amount = -1</code> 不会直接修改实例字典，而是强制执行描述符的 <code>__set__</code> 方法对数值进行非负验证。</p>
<p>如果没有实现 <code>__set__</code> 方法，比如 Python 中的方法就是以非覆盖型描述符实现的，只定义了 <code>__get__</code> 方法。如果类中定义了名为 method 的方法，使用 <code>obj.method = 1</code> 会直接修改实例字典，即<strong>实例属性会遮盖同名描述符属性</strong>，但类中的描述符属性依然存在。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span>():</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.method = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;method&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.method</span><br><span class="line">&lt;function C.method at <span class="number">0x10f7ff940</span>&gt;</span><br></pre></td></tr></table></figure>

<p>综上所述，数据描述符的表现形式更像可以被随意赋值的数据，提供了完备的取值方法 <code>__get__</code> 和设值方法 <code>__set__</code>。而非数据描述符表现形式不像数据，比如 Python 中的方法，为非数据描述符赋值会遮盖掉实例的同名描述符属性。</p>
<p>以上讨论的都是是否存在 <code>__set__</code> 方法的情形，其实，也可以没有读值方法 <code>__get__</code>，比如我们定义的 Quantity 描述符。一般情况下，没有读值方法时访问属性会返回描述符对象本身。然而访问 LineItem 实例属性 <code>item.amount</code> 会得到对应数值。这是因为在它的初始化方法 <code>__init__</code> 中已经调用了描述符的 <code>__set__</code> 方法，该方法为实例字典 <code>__dict__</code> 创建了同名实例属性，由于实例属性会遮盖同名描述符属性，读取属性会返回实例字典中的值而不是描述符对象。这也是为什么将实现了 <code>__set__</code> 的描述符称为遮盖型描述符的原因。</p>
<p>总之，<strong>按照属性访问规则，数据描述符在实例字典之前被访问（调用 <code>__get__</code> 和<code>__set__</code> 方法），非数据描述符在实例字典之后被访问（可能会被遮盖）</strong>。</p>
<h3 id="方法是描述符"><a href="#方法是描述符" class="headerlink" title="方法是描述符"></a>方法是描述符</h3><p>定义在类中的方法会变成绑定方法（bound method），这是 Python 语言底层使用描述符的最好例证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span>():</span> ...</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.method</span><br><span class="line">&lt;bound method C.method of &lt;__main__.C <span class="built_in">object</span> at <span class="number">0x10f837580</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.method</span><br><span class="line">&lt;function C.method at <span class="number">0x10fff6b80</span>&gt;</span><br></pre></td></tr></table></figure>

<p>通过类和实例访问函数返回的是不同的对象。CPython 中定义的函数对象 <a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/master/Objects/funcobject.c">funcobject</a> 实现了描述符协议的 <code>__get__</code> 方法，即如下的 <code>func_descr_get</code> 方法。与描述符一样，通过托管类访问函数时，传入的 obj 参数为空，函数的 <code>__get__</code> 方法会返回自身的引用。通过实例访问函数时，返回的是绑定方法对象，并把托管实例绑定给函数的第一个参数（即 self），这与 functool.partial 函数的行为一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bind a function to an object */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject *</span></span><br><span class="line"><span class="function"><span class="title">func_descr_get</span><span class="params">(PyObject *func, PyObject *obj, PyObject *type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == Py_None || obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(func);</span><br><span class="line">        <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyMethod_New(func, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Method objects are used for bound instance methods returned by instancename.methodname.</span></span><br><span class="line"><span class="comment">   ClassName.methodname returns an ordinary function. */</span></span><br><span class="line"><span class="function">PyObject * <span class="title">PyMethod_New</span><span class="params">(PyObject *func, PyObject *self)</span></span></span><br></pre></td></tr></table></figure>

<p>绑定方法对象还有个 <code>__call__</code> 方法，用于处理真正的调用过程。这个方法会调用 <code>__func__</code> 属性引用的原始函数，把函数的第一个参数设为绑定方法的 <code>__self__</code> 属性。这就是<strong>形参 self 的隐式绑定过程</strong>。</p>
<h3 id="使用描述符的最佳实践"><a href="#使用描述符的最佳实践" class="headerlink" title="使用描述符的最佳实践"></a>使用描述符的最佳实践</h3><p><strong>使用特性以保持简单</strong>：内置的 property 类创建的是数据描述符，<code>__get__</code> 和 <code>__set__</code> 方法都实现了。特性的 <code>__set__</code> 方法默认抛出 AttributeError: can’t set attribute，因此创建只读属性最简单的方式是使用特性。且由于特性存在 <code>__set__</code> 方法，不会被同名实例属性遮盖。</p>
<p><strong>只读描述符也要实现 <code>__set__</code> 方法</strong>：如果使用描述符类实现只读数据属性，要记住，<code>__get__</code> 和 <code>__set__</code> 方法必须都定义。否则，实例的同名属性会遮盖描述符。只读属性的 <code>__set__</code> 方法只需抛出 AttributeError 异常，并提供合适的错误消息。</p>
<p><strong>非特殊的方法可以被实例属性遮盖</strong>：Python 的方法只实现了 <code>__get__</code> 方法，所以对与方法名同名的属性将会遮盖描述符，也就是说 <code>obj.method = 1</code> 负值后通过实例访问 method 将会得到数字 1，但不影响类或其他实例。然而，特殊方法不受这个问题影响。因为解释器只会在类中查询特殊方法。也就是说 <code>repr(x)</code> 执行的其实是 <code>x.__class__.__repr__(x)</code>，因此 x 的 <code>__repr__</code> 属性对 <code>repr(x)</code> 方法调用没有影响。出于同样的原因，实例的 <code>__getattr__</code> 属性不会破坏常规的属性访问规则。</p>
<p><strong>用于验证的描述符可以只实现 <code>__set__</code> 方法</strong>：对仅用于验证的描述符来说，<code>__set__</code> 方法应该检查 value 参数是否有效，如果有效，使用与描述符实例同名的名称作为键，直接在实例字典中设值，如 Quantity 中的 <code>instance.__dict__[self.attribute] = value</code> 语句。这样，从实例字典中读取同名属性就不需要经过 <code>__get__</code> 方法处理。</p>
<p><strong>仅有 <code>__get__</code> 方法的描述符可以实现高效缓存</strong>：如果仅实现了 <code>__get__</code> 方法，那么创建的是非数据描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例字典中获取值，而不会再出发描述符的 <code>__get__</code> 方法。</p>
<h3 id="描述符应用场景"><a href="#描述符应用场景" class="headerlink" title="描述符应用场景"></a>描述符应用场景</h3><p>当将描述符逻辑抽象到单独的代码单元中，如 Quantity 类中，就可以在整个应用中进行重用。在一些框架中，会将描述符定义在单独的工具模块中，比如 Django 框架中与数据库交互的模型字段类，就是描述符类。你会发现下面这段 Django 的测试用例的代码与我们定义的 LineItem 非常类似。只不过我们的描述符类 Quantity 换成了他们的 models.CharFiled 等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    books = models.ManyToManyField(Book)</span><br><span class="line">    person = models.OneToOneField(<span class="string">&#x27;Person&#x27;</span>, models.CASCADE, null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>当然，目前定义的描述符类还有提升的空间，比如 <code>price = Quantity(&#39;price&#39;)</code> 使用字符串对属性名进行初始化可能并不那么可靠。又比如想为字段设置更多限定，比如 Django 中设置的字段 max_length 等。其实，Django 框架使用到了 Python 更高阶的类元编程的特性 —— 元类。除了开放框架，一般用不到这个特性。后面我们会对元类加以介绍。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpeg" alt="s1mple 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/12/Python-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" rel="prev" title="Python 函数详解">
      <i class="fa fa-chevron-left"></i> Python 函数详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/12/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="next" title="Python 面向对象">
      Python 面向对象 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">类的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">处理属性的特殊属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dict"><span class="nav-number">1.1.1.</span> <span class="nav-text">__dict__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slots"><span class="nav-number">1.1.2.</span> <span class="nav-text">__slots__</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">处理属性的内置函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">处理属性的特殊方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99"><span class="nav-number">1.4.</span> <span class="nav-text">属性访问规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-getattr-%E5%8D%B3%E6%97%B6%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">自定义 __getattr__ 即时计算属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">3.</span> <span class="nav-text">描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%B1%9E%E6%80%A7%E9%AA%8C%E8%AF%81"><span class="nav-number">3.1.</span> <span class="nav-text">定制描述符实现属性验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%88%86%E7%B1%BB"><span class="nav-number">3.2.</span> <span class="nav-text">描述符分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E6%98%AF%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">3.3.</span> <span class="nav-text">方法是描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.4.</span> <span class="nav-text">使用描述符的最佳实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.5.</span> <span class="nav-text">描述符应用场景</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="s1mple"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">s1mple</p>
  <div class="site-description" itemprop="description">春光恰与少年同，十里清风慕天青</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/s1mplecc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;s1mplecc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:s1mple951205@gmail.com" title="E-Mail → mailto:s1mple951205@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">s1mple</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 33231,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













  

  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://s1mplecc.github.io/2021/04/26/Python-%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'LL5WuMzDNh0Y7j17go8YWYQ8-gzGzoHsz',
      appKey     : 'eGkSV4kghSvWKeQvrDPjf6ig',
      placeholder: "说点什么吧。",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
